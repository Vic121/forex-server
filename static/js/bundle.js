/*! jQuery v1.8.3 jquery.com | jquery.org/license */
(function (e, t) {
    function _(e) {
        var t = M[e] = {};
        return v.each(e.split(y), function (e, n) {
            t[n] = !0
        }), t
    }

    function H(e, n, r) {
        if (r === t && e.nodeType === 1) {
            var i = "data-" + n.replace(P, "-$1").toLowerCase();
            r = e.getAttribute(i);
            if (typeof r == "string") {
                try {
                    r = r === "true" ? !0 : r === "false" ? !1 : r === "null" ? null : +r + "" === r ? +r : D.test(r) ? v.parseJSON(r) : r
                } catch (s) {
                }
                v.data(e, n, r)
            } else r = t
        }
        return r
    }

    function B(e) {
        var t;
        for (t in e) {
            if (t === "data" && v.isEmptyObject(e[t]))continue;
            if (t !== "toJSON")return !1
        }
        return !0
    }

    function et() {
        return !1
    }

    function tt() {
        return !0
    }

    function ut(e) {
        return !e || !e.parentNode || e.parentNode.nodeType === 11
    }

    function at(e, t) {
        do e = e[t]; while (e && e.nodeType !== 1);
        return e
    }

    function ft(e, t, n) {
        t = t || 0;
        if (v.isFunction(t))return v.grep(e, function (e, r) {
            var i = !!t.call(e, r, e);
            return i === n
        });
        if (t.nodeType)return v.grep(e, function (e, r) {
            return e === t === n
        });
        if (typeof t == "string") {
            var r = v.grep(e, function (e) {
                return e.nodeType === 1
            });
            if (it.test(t))return v.filter(t, r, !n);
            t = v.filter(t, r)
        }
        return v.grep(e, function (e, r) {
            return v.inArray(e, t) >= 0 === n
        })
    }

    function lt(e) {
        var t = ct.split("|"), n = e.createDocumentFragment();
        if (n.createElement)while (t.length)n.createElement(t.pop());
        return n
    }

    function Lt(e, t) {
        return e.getElementsByTagName(t)[0] || e.appendChild(e.ownerDocument.createElement(t))
    }

    function At(e, t) {
        if (t.nodeType !== 1 || !v.hasData(e))return;
        var n, r, i, s = v._data(e), o = v._data(t, s), u = s.events;
        if (u) {
            delete o.handle, o.events = {};
            for (n in u)for (r = 0, i = u[n].length; r < i; r++)v.event.add(t, n, u[n][r])
        }
        o.data && (o.data = v.extend({}, o.data))
    }

    function Ot(e, t) {
        var n;
        if (t.nodeType !== 1)return;
        t.clearAttributes && t.clearAttributes(), t.mergeAttributes && t.mergeAttributes(e), n = t.nodeName.toLowerCase(), n === "object" ? (t.parentNode && (t.outerHTML = e.outerHTML), v.support.html5Clone && e.innerHTML && !v.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : n === "input" && Et.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : n === "option" ? t.selected = e.defaultSelected : n === "input" || n === "textarea" ? t.defaultValue = e.defaultValue : n === "script" && t.text !== e.text && (t.text = e.text), t.removeAttribute(v.expando)
    }

    function Mt(e) {
        return typeof e.getElementsByTagName != "undefined" ? e.getElementsByTagName("*") : typeof e.querySelectorAll != "undefined" ? e.querySelectorAll("*") : []
    }

    function _t(e) {
        Et.test(e.type) && (e.defaultChecked = e.checked)
    }

    function Qt(e, t) {
        if (t in e)return t;
        var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = Jt.length;
        while (i--) {
            t = Jt[i] + n;
            if (t in e)return t
        }
        return r
    }

    function Gt(e, t) {
        return e = t || e, v.css(e, "display") === "none" || !v.contains(e.ownerDocument, e)
    }

    function Yt(e, t) {
        var n, r, i = [], s = 0, o = e.length;
        for (; s < o; s++) {
            n = e[s];
            if (!n.style)continue;
            i[s] = v._data(n, "olddisplay"), t ? (!i[s] && n.style.display === "none" && (n.style.display = ""), n.style.display === "" && Gt(n) && (i[s] = v._data(n, "olddisplay", nn(n.nodeName)))) : (r = Dt(n, "display"), !i[s] && r !== "none" && v._data(n, "olddisplay", r))
        }
        for (s = 0; s < o; s++) {
            n = e[s];
            if (!n.style)continue;
            if (!t || n.style.display === "none" || n.style.display === "")n.style.display = t ? i[s] || "" : "none"
        }
        return e
    }

    function Zt(e, t, n) {
        var r = Rt.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
    }

    function en(e, t, n, r) {
        var i = n === (r ? "border" : "content") ? 4 : t === "width" ? 1 : 0, s = 0;
        for (; i < 4; i += 2)n === "margin" && (s += v.css(e, n + $t[i], !0)), r ? (n === "content" && (s -= parseFloat(Dt(e, "padding" + $t[i])) || 0), n !== "margin" && (s -= parseFloat(Dt(e, "border" + $t[i] + "Width")) || 0)) : (s += parseFloat(Dt(e, "padding" + $t[i])) || 0, n !== "padding" && (s += parseFloat(Dt(e, "border" + $t[i] + "Width")) || 0));
        return s
    }

    function tn(e, t, n) {
        var r = t === "width" ? e.offsetWidth : e.offsetHeight, i = !0, s = v.support.boxSizing && v.css(e, "boxSizing") === "border-box";
        if (r <= 0 || r == null) {
            r = Dt(e, t);
            if (r < 0 || r == null)r = e.style[t];
            if (Ut.test(r))return r;
            i = s && (v.support.boxSizingReliable || r === e.style[t]), r = parseFloat(r) || 0
        }
        return r + en(e, t, n || (s ? "border" : "content"), i) + "px"
    }

    function nn(e) {
        if (Wt[e])return Wt[e];
        var t = v("<" + e + ">").appendTo(i.body), n = t.css("display");
        t.remove();
        if (n === "none" || n === "") {
            Pt = i.body.appendChild(Pt || v.extend(i.createElement("iframe"), {frameBorder: 0, width: 0, height: 0}));
            if (!Ht || !Pt.createElement)Ht = (Pt.contentWindow || Pt.contentDocument).document, Ht.write("<!doctype html><html><body>"), Ht.close();
            t = Ht.body.appendChild(Ht.createElement(e)), n = Dt(t, "display"), i.body.removeChild(Pt)
        }
        return Wt[e] = n, n
    }

    function fn(e, t, n, r) {
        var i;
        if (v.isArray(t))v.each(t, function (t, i) {
            n || sn.test(e) ? r(e, i) : fn(e + "[" + (typeof i == "object" ? t : "") + "]", i, n, r)
        }); else if (!n && v.type(t) === "object")for (i in t)fn(e + "[" + i + "]", t[i], n, r); else r(e, t)
    }

    function Cn(e) {
        return function (t, n) {
            typeof t != "string" && (n = t, t = "*");
            var r, i, s, o = t.toLowerCase().split(y), u = 0, a = o.length;
            if (v.isFunction(n))for (; u < a; u++)r = o[u], s = /^\+/.test(r), s && (r = r.substr(1) || "*"), i = e[r] = e[r] || [], i[s ? "unshift" : "push"](n)
        }
    }

    function kn(e, n, r, i, s, o) {
        s = s || n.dataTypes[0], o = o || {}, o[s] = !0;
        var u, a = e[s], f = 0, l = a ? a.length : 0, c = e === Sn;
        for (; f < l && (c || !u); f++)u = a[f](n, r, i), typeof u == "string" && (!c || o[u] ? u = t : (n.dataTypes.unshift(u), u = kn(e, n, r, i, u, o)));
        return (c || !u) && !o["*"] && (u = kn(e, n, r, i, "*", o)), u
    }

    function Ln(e, n) {
        var r, i, s = v.ajaxSettings.flatOptions || {};
        for (r in n)n[r] !== t && ((s[r] ? e : i || (i = {}))[r] = n[r]);
        i && v.extend(!0, e, i)
    }

    function An(e, n, r) {
        var i, s, o, u, a = e.contents, f = e.dataTypes, l = e.responseFields;
        for (s in l)s in r && (n[l[s]] = r[s]);
        while (f[0] === "*")f.shift(), i === t && (i = e.mimeType || n.getResponseHeader("content-type"));
        if (i)for (s in a)if (a[s] && a[s].test(i)) {
            f.unshift(s);
            break
        }
        if (f[0]in r)o = f[0]; else {
            for (s in r) {
                if (!f[0] || e.converters[s + " " + f[0]]) {
                    o = s;
                    break
                }
                u || (u = s)
            }
            o = o || u
        }
        if (o)return o !== f[0] && f.unshift(o), r[o]
    }

    function On(e, t) {
        var n, r, i, s, o = e.dataTypes.slice(), u = o[0], a = {}, f = 0;
        e.dataFilter && (t = e.dataFilter(t, e.dataType));
        if (o[1])for (n in e.converters)a[n.toLowerCase()] = e.converters[n];
        for (; i = o[++f];)if (i !== "*") {
            if (u !== "*" && u !== i) {
                n = a[u + " " + i] || a["* " + i];
                if (!n)for (r in a) {
                    s = r.split(" ");
                    if (s[1] === i) {
                        n = a[u + " " + s[0]] || a["* " + s[0]];
                        if (n) {
                            n === !0 ? n = a[r] : a[r] !== !0 && (i = s[0], o.splice(f--, 0, i));
                            break
                        }
                    }
                }
                if (n !== !0)if (n && e["throws"])t = n(t); else try {
                    t = n(t)
                } catch (l) {
                    return {state: "parsererror", error: n ? l : "No conversion from " + u + " to " + i}
                }
            }
            u = i
        }
        return {state: "success", data: t}
    }

    function Fn() {
        try {
            return new e.XMLHttpRequest
        } catch (t) {
        }
    }

    function In() {
        try {
            return new e.ActiveXObject("Microsoft.XMLHTTP")
        } catch (t) {
        }
    }

    function $n() {
        return setTimeout(function () {
            qn = t
        }, 0), qn = v.now()
    }

    function Jn(e, t) {
        v.each(t, function (t, n) {
            var r = (Vn[t] || []).concat(Vn["*"]), i = 0, s = r.length;
            for (; i < s; i++)if (r[i].call(e, t, n))return
        })
    }

    function Kn(e, t, n) {
        var r, i = 0, s = 0, o = Xn.length, u = v.Deferred().always(function () {
            delete a.elem
        }), a = function () {
            var t = qn || $n(), n = Math.max(0, f.startTime + f.duration - t), r = n / f.duration || 0, i = 1 - r, s = 0, o = f.tweens.length;
            for (; s < o; s++)f.tweens[s].run(i);
            return u.notifyWith(e, [f, i, n]), i < 1 && o ? n : (u.resolveWith(e, [f]), !1)
        }, f = u.promise({
            elem: e,
            props: v.extend({}, t),
            opts: v.extend(!0, {specialEasing: {}}, n),
            originalProperties: t,
            originalOptions: n,
            startTime: qn || $n(),
            duration: n.duration,
            tweens: [],
            createTween: function (t, n, r) {
                var i = v.Tween(e, f.opts, t, n, f.opts.specialEasing[t] || f.opts.easing);
                return f.tweens.push(i), i
            },
            stop: function (t) {
                var n = 0, r = t ? f.tweens.length : 0;
                for (; n < r; n++)f.tweens[n].run(1);
                return t ? u.resolveWith(e, [f, t]) : u.rejectWith(e, [f, t]), this
            }
        }), l = f.props;
        Qn(l, f.opts.specialEasing);
        for (; i < o; i++) {
            r = Xn[i].call(f, e, l, f.opts);
            if (r)return r
        }
        return Jn(f, l), v.isFunction(f.opts.start) && f.opts.start.call(e, f), v.fx.timer(v.extend(a, {
            anim: f,
            queue: f.opts.queue,
            elem: e
        })), f.progress(f.opts.progress).done(f.opts.done, f.opts.complete).fail(f.opts.fail).always(f.opts.always)
    }

    function Qn(e, t) {
        var n, r, i, s, o;
        for (n in e) {
            r = v.camelCase(n), i = t[r], s = e[n], v.isArray(s) && (i = s[1], s = e[n] = s[0]), n !== r && (e[r] = s, delete e[n]), o = v.cssHooks[r];
            if (o && "expand"in o) {
                s = o.expand(s), delete e[r];
                for (n in s)n in e || (e[n] = s[n], t[n] = i)
            } else t[r] = i
        }
    }

    function Gn(e, t, n) {
        var r, i, s, o, u, a, f, l, c, h = this, p = e.style, d = {}, m = [], g = e.nodeType && Gt(e);
        n.queue || (l = v._queueHooks(e, "fx"), l.unqueued == null && (l.unqueued = 0, c = l.empty.fire, l.empty.fire = function () {
            l.unqueued || c()
        }), l.unqueued++, h.always(function () {
            h.always(function () {
                l.unqueued--, v.queue(e, "fx").length || l.empty.fire()
            })
        })), e.nodeType === 1 && ("height"in t || "width"in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], v.css(e, "display") === "inline" && v.css(e, "float") === "none" && (!v.support.inlineBlockNeedsLayout || nn(e.nodeName) === "inline" ? p.display = "inline-block" : p.zoom = 1)), n.overflow && (p.overflow = "hidden", v.support.shrinkWrapBlocks || h.done(function () {
            p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]
        }));
        for (r in t) {
            s = t[r];
            if (Un.exec(s)) {
                delete t[r], a = a || s === "toggle";
                if (s === (g ? "hide" : "show"))continue;
                m.push(r)
            }
        }
        o = m.length;
        if (o) {
            u = v._data(e, "fxshow") || v._data(e, "fxshow", {}), "hidden"in u && (g = u.hidden), a && (u.hidden = !g), g ? v(e).show() : h.done(function () {
                v(e).hide()
            }), h.done(function () {
                var t;
                v.removeData(e, "fxshow", !0);
                for (t in d)v.style(e, t, d[t])
            });
            for (r = 0; r < o; r++)i = m[r], f = h.createTween(i, g ? u[i] : 0), d[i] = u[i] || v.style(e, i), i in u || (u[i] = f.start, g && (f.end = f.start, f.start = i === "width" || i === "height" ? 1 : 0))
        }
    }

    function Yn(e, t, n, r, i) {
        return new Yn.prototype.init(e, t, n, r, i)
    }

    function Zn(e, t) {
        var n, r = {height: e}, i = 0;
        t = t ? 1 : 0;
        for (; i < 4; i += 2 - t)n = $t[i], r["margin" + n] = r["padding" + n] = e;
        return t && (r.opacity = r.width = e), r
    }

    function tr(e) {
        return v.isWindow(e) ? e : e.nodeType === 9 ? e.defaultView || e.parentWindow : !1
    }

    var n, r, i = e.document, s = e.location, o = e.navigator, u = e.jQuery, a = e.$, f = Array.prototype.push, l = Array.prototype.slice, c = Array.prototype.indexOf, h = Object.prototype.toString, p = Object.prototype.hasOwnProperty, d = String.prototype.trim, v = function (e, t) {
        return new v.fn.init(e, t, n)
    }, m = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, g = /\S/, y = /\s+/, b = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, w = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/, E = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, S = /^[\],:{}\s]*$/, x = /(?:^|:|,)(?:\s*\[)+/g, T = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, N = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g, C = /^-ms-/, k = /-([\da-z])/gi, L = function (e, t) {
        return (t + "").toUpperCase()
    }, A = function () {
        i.addEventListener ? (i.removeEventListener("DOMContentLoaded", A, !1), v.ready()) : i.readyState === "complete" && (i.detachEvent("onreadystatechange", A), v.ready())
    }, O = {};
    v.fn = v.prototype = {
        constructor: v, init: function (e, n, r) {
            var s, o, u, a;
            if (!e)return this;
            if (e.nodeType)return this.context = this[0] = e, this.length = 1, this;
            if (typeof e == "string") {
                e.charAt(0) === "<" && e.charAt(e.length - 1) === ">" && e.length >= 3 ? s = [null, e, null] : s = w.exec(e);
                if (s && (s[1] || !n)) {
                    if (s[1])return n = n instanceof v ? n[0] : n, a = n && n.nodeType ? n.ownerDocument || n : i, e = v.parseHTML(s[1], a, !0), E.test(s[1]) && v.isPlainObject(n) && this.attr.call(e, n, !0), v.merge(this, e);
                    o = i.getElementById(s[2]);
                    if (o && o.parentNode) {
                        if (o.id !== s[2])return r.find(e);
                        this.length = 1, this[0] = o
                    }
                    return this.context = i, this.selector = e, this
                }
                return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e)
            }
            return v.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), v.makeArray(e, this))
        }, selector: "", jquery: "1.8.3", length: 0, size: function () {
            return this.length
        }, toArray: function () {
            return l.call(this)
        }, get: function (e) {
            return e == null ? this.toArray() : e < 0 ? this[this.length + e] : this[e]
        }, pushStack: function (e, t, n) {
            var r = v.merge(this.constructor(), e);
            return r.prevObject = this, r.context = this.context, t === "find" ? r.selector = this.selector + (this.selector ? " " : "") + n : t && (r.selector = this.selector + "." + t + "(" + n + ")"), r
        }, each: function (e, t) {
            return v.each(this, e, t)
        }, ready: function (e) {
            return v.ready.promise().done(e), this
        }, eq: function (e) {
            return e = +e, e === -1 ? this.slice(e) : this.slice(e, e + 1)
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, slice: function () {
            return this.pushStack(l.apply(this, arguments), "slice", l.call(arguments).join(","))
        }, map: function (e) {
            return this.pushStack(v.map(this, function (t, n) {
                return e.call(t, n, t)
            }))
        }, end: function () {
            return this.prevObject || this.constructor(null)
        }, push: f, sort: [].sort, splice: [].splice
    }, v.fn.init.prototype = v.fn, v.extend = v.fn.extend = function () {
        var e, n, r, i, s, o, u = arguments[0] || {}, a = 1, f = arguments.length, l = !1;
        typeof u == "boolean" && (l = u, u = arguments[1] || {}, a = 2), typeof u != "object" && !v.isFunction(u) && (u = {}), f === a && (u = this, --a);
        for (; a < f; a++)if ((e = arguments[a]) != null)for (n in e) {
            r = u[n], i = e[n];
            if (u === i)continue;
            l && i && (v.isPlainObject(i) || (s = v.isArray(i))) ? (s ? (s = !1, o = r && v.isArray(r) ? r : []) : o = r && v.isPlainObject(r) ? r : {}, u[n] = v.extend(l, o, i)) : i !== t && (u[n] = i)
        }
        return u
    }, v.extend({
        noConflict: function (t) {
            return e.$ === v && (e.$ = a), t && e.jQuery === v && (e.jQuery = u), v
        }, isReady: !1, readyWait: 1, holdReady: function (e) {
            e ? v.readyWait++ : v.ready(!0)
        }, ready: function (e) {
            if (e === !0 ? --v.readyWait : v.isReady)return;
            if (!i.body)return setTimeout(v.ready, 1);
            v.isReady = !0;
            if (e !== !0 && --v.readyWait > 0)return;
            r.resolveWith(i, [v]), v.fn.trigger && v(i).trigger("ready").off("ready")
        }, isFunction: function (e) {
            return v.type(e) === "function"
        }, isArray: Array.isArray || function (e) {
            return v.type(e) === "array"
        }, isWindow: function (e) {
            return e != null && e == e.window
        }, isNumeric: function (e) {
            return !isNaN(parseFloat(e)) && isFinite(e)
        }, type: function (e) {
            return e == null ? String(e) : O[h.call(e)] || "object"
        }, isPlainObject: function (e) {
            if (!e || v.type(e) !== "object" || e.nodeType || v.isWindow(e))return !1;
            try {
                if (e.constructor && !p.call(e, "constructor") && !p.call(e.constructor.prototype, "isPrototypeOf"))return !1
            } catch (n) {
                return !1
            }
            var r;
            for (r in e);
            return r === t || p.call(e, r)
        }, isEmptyObject: function (e) {
            var t;
            for (t in e)return !1;
            return !0
        }, error: function (e) {
            throw new Error(e)
        }, parseHTML: function (e, t, n) {
            var r;
            return !e || typeof e != "string" ? null : (typeof t == "boolean" && (n = t, t = 0), t = t || i, (r = E.exec(e)) ? [t.createElement(r[1])] : (r = v.buildFragment([e], t, n ? null : []), v.merge([], (r.cacheable ? v.clone(r.fragment) : r.fragment).childNodes)))
        }, parseJSON: function (t) {
            if (!t || typeof t != "string")return null;
            t = v.trim(t);
            if (e.JSON && e.JSON.parse)return e.JSON.parse(t);
            if (S.test(t.replace(T, "@").replace(N, "]").replace(x, "")))return (new Function("return " + t))();
            v.error("Invalid JSON: " + t)
        }, parseXML: function (n) {
            var r, i;
            if (!n || typeof n != "string")return null;
            try {
                e.DOMParser ? (i = new DOMParser, r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), r.async = "false", r.loadXML(n))
            } catch (s) {
                r = t
            }
            return (!r || !r.documentElement || r.getElementsByTagName("parsererror").length) && v.error("Invalid XML: " + n), r
        }, noop: function () {
        }, globalEval: function (t) {
            t && g.test(t) && (e.execScript || function (t) {
                e.eval.call(e, t)
            })(t)
        }, camelCase: function (e) {
            return e.replace(C, "ms-").replace(k, L)
        }, nodeName: function (e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        }, each: function (e, n, r) {
            var i, s = 0, o = e.length, u = o === t || v.isFunction(e);
            if (r) {
                if (u) {
                    for (i in e)if (n.apply(e[i], r) === !1)break
                } else for (; s < o;)if (n.apply(e[s++], r) === !1)break
            } else if (u) {
                for (i in e)if (n.call(e[i], i, e[i]) === !1)break
            } else for (; s < o;)if (n.call(e[s], s, e[s++]) === !1)break;
            return e
        }, trim: d && !d.call("\ufeff\u00a0") ? function (e) {
            return e == null ? "" : d.call(e)
        } : function (e) {
            return e == null ? "" : (e + "").replace(b, "")
        }, makeArray: function (e, t) {
            var n, r = t || [];
            return e != null && (n = v.type(e), e.length == null || n === "string" || n === "function" || n === "regexp" || v.isWindow(e) ? f.call(r, e) : v.merge(r, e)), r
        }, inArray: function (e, t, n) {
            var r;
            if (t) {
                if (c)return c.call(t, e, n);
                r = t.length, n = n ? n < 0 ? Math.max(0, r + n) : n : 0;
                for (; n < r; n++)if (n in t && t[n] === e)return n
            }
            return -1
        }, merge: function (e, n) {
            var r = n.length, i = e.length, s = 0;
            if (typeof r == "number")for (; s < r; s++)e[i++] = n[s]; else while (n[s] !== t)e[i++] = n[s++];
            return e.length = i, e
        }, grep: function (e, t, n) {
            var r, i = [], s = 0, o = e.length;
            n = !!n;
            for (; s < o; s++)r = !!t(e[s], s), n !== r && i.push(e[s]);
            return i
        }, map: function (e, n, r) {
            var i, s, o = [], u = 0, a = e.length, f = e instanceof v || a !== t && typeof a == "number" && (a > 0 && e[0] && e[a - 1] || a === 0 || v.isArray(e));
            if (f)for (; u < a; u++)i = n(e[u], u, r), i != null && (o[o.length] = i); else for (s in e)i = n(e[s], s, r), i != null && (o[o.length] = i);
            return o.concat.apply([], o)
        }, guid: 1, proxy: function (e, n) {
            var r, i, s;
            return typeof n == "string" && (r = e[n], n = e, e = r), v.isFunction(e) ? (i = l.call(arguments, 2), s = function () {
                return e.apply(n, i.concat(l.call(arguments)))
            }, s.guid = e.guid = e.guid || v.guid++, s) : t
        }, access: function (e, n, r, i, s, o, u) {
            var a, f = r == null, l = 0, c = e.length;
            if (r && typeof r == "object") {
                for (l in r)v.access(e, n, l, r[l], 1, o, i);
                s = 1
            } else if (i !== t) {
                a = u === t && v.isFunction(i), f && (a ? (a = n, n = function (e, t, n) {
                    return a.call(v(e), n)
                }) : (n.call(e, i), n = null));
                if (n)for (; l < c; l++)n(e[l], r, a ? i.call(e[l], l, n(e[l], r)) : i, u);
                s = 1
            }
            return s ? e : f ? n.call(e) : c ? n(e[0], r) : o
        }, now: function () {
            return (new Date).getTime()
        }
    }), v.ready.promise = function (t) {
        if (!r) {
            r = v.Deferred();
            if (i.readyState === "complete")setTimeout(v.ready, 1); else if (i.addEventListener)i.addEventListener("DOMContentLoaded", A, !1), e.addEventListener("load", v.ready, !1); else {
                i.attachEvent("onreadystatechange", A), e.attachEvent("onload", v.ready);
                var n = !1;
                try {
                    n = e.frameElement == null && i.documentElement
                } catch (s) {
                }
                n && n.doScroll && function o() {
                    if (!v.isReady) {
                        try {
                            n.doScroll("left")
                        } catch (e) {
                            return setTimeout(o, 50)
                        }
                        v.ready()
                    }
                }()
            }
        }
        return r.promise(t)
    }, v.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (e, t) {
        O["[object " + t + "]"] = t.toLowerCase()
    }), n = v(i);
    var M = {};
    v.Callbacks = function (e) {
        e = typeof e == "string" ? M[e] || _(e) : v.extend({}, e);
        var n, r, i, s, o, u, a = [], f = !e.once && [], l = function (t) {
            n = e.memory && t, r = !0, u = s || 0, s = 0, o = a.length, i = !0;
            for (; a && u < o; u++)if (a[u].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
                n = !1;
                break
            }
            i = !1, a && (f ? f.length && l(f.shift()) : n ? a = [] : c.disable())
        }, c = {
            add: function () {
                if (a) {
                    var t = a.length;
                    (function r(t) {
                        v.each(t, function (t, n) {
                            var i = v.type(n);
                            i === "function" ? (!e.unique || !c.has(n)) && a.push(n) : n && n.length && i !== "string" && r(n)
                        })
                    })(arguments), i ? o = a.length : n && (s = t, l(n))
                }
                return this
            }, remove: function () {
                return a && v.each(arguments, function (e, t) {
                    var n;
                    while ((n = v.inArray(t, a, n)) > -1)a.splice(n, 1), i && (n <= o && o--, n <= u && u--)
                }), this
            }, has: function (e) {
                return v.inArray(e, a) > -1
            }, empty: function () {
                return a = [], this
            }, disable: function () {
                return a = f = n = t, this
            }, disabled: function () {
                return !a
            }, lock: function () {
                return f = t, n || c.disable(), this
            }, locked: function () {
                return !f
            }, fireWith: function (e, t) {
                return t = t || [], t = [e, t.slice ? t.slice() : t], a && (!r || f) && (i ? f.push(t) : l(t)), this
            }, fire: function () {
                return c.fireWith(this, arguments), this
            }, fired: function () {
                return !!r
            }
        };
        return c
    }, v.extend({
        Deferred: function (e) {
            var t = [["resolve", "done", v.Callbacks("once memory"), "resolved"], ["reject", "fail", v.Callbacks("once memory"), "rejected"], ["notify", "progress", v.Callbacks("memory")]], n = "pending", r = {
                state: function () {
                    return n
                }, always: function () {
                    return i.done(arguments).fail(arguments), this
                }, then: function () {
                    var e = arguments;
                    return v.Deferred(function (n) {
                        v.each(t, function (t, r) {
                            var s = r[0], o = e[t];
                            i[r[1]](v.isFunction(o) ? function () {
                                var e = o.apply(this, arguments);
                                e && v.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[s + "With"](this === i ? n : this, [e])
                            } : n[s])
                        }), e = null
                    }).promise()
                }, promise: function (e) {
                    return e != null ? v.extend(e, r) : r
                }
            }, i = {};
            return r.pipe = r.then, v.each(t, function (e, s) {
                var o = s[2], u = s[3];
                r[s[1]] = o.add, u && o.add(function () {
                    n = u
                }, t[e ^ 1][2].disable, t[2][2].lock), i[s[0]] = o.fire, i[s[0] + "With"] = o.fireWith
            }), r.promise(i), e && e.call(i, i), i
        }, when: function (e) {
            var t = 0, n = l.call(arguments), r = n.length, i = r !== 1 || e && v.isFunction(e.promise) ? r : 0, s = i === 1 ? e : v.Deferred(), o = function (e, t, n) {
                return function (r) {
                    t[e] = this, n[e] = arguments.length > 1 ? l.call(arguments) : r, n === u ? s.notifyWith(t, n) : --i || s.resolveWith(t, n)
                }
            }, u, a, f;
            if (r > 1) {
                u = new Array(r), a = new Array(r), f = new Array(r);
                for (; t < r; t++)n[t] && v.isFunction(n[t].promise) ? n[t].promise().done(o(t, f, n)).fail(s.reject).progress(o(t, a, u)) : --i
            }
            return i || s.resolveWith(f, n), s.promise()
        }
    }), v.support = function () {
        var t, n, r, s, o, u, a, f, l, c, h, p = i.createElement("div");
        p.setAttribute("className", "t"), p.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", n = p.getElementsByTagName("*"), r = p.getElementsByTagName("a")[0];
        if (!n || !r || !n.length)return {};
        s = i.createElement("select"), o = s.appendChild(i.createElement("option")), u = p.getElementsByTagName("input")[0], r.style.cssText = "top:1px;float:left;opacity:.5", t = {
            leadingWhitespace: p.firstChild.nodeType === 3,
            tbody: !p.getElementsByTagName("tbody").length,
            htmlSerialize: !!p.getElementsByTagName("link").length,
            style: /top/.test(r.getAttribute("style")),
            hrefNormalized: r.getAttribute("href") === "/a",
            opacity: /^0.5/.test(r.style.opacity),
            cssFloat: !!r.style.cssFloat,
            checkOn: u.value === "on",
            optSelected: o.selected,
            getSetAttribute: p.className !== "t",
            enctype: !!i.createElement("form").enctype,
            html5Clone: i.createElement("nav").cloneNode(!0).outerHTML !== "<:nav></:nav>",
            boxModel: i.compatMode === "CSS1Compat",
            submitBubbles: !0,
            changeBubbles: !0,
            focusinBubbles: !1,
            deleteExpando: !0,
            noCloneEvent: !0,
            inlineBlockNeedsLayout: !1,
            shrinkWrapBlocks: !1,
            reliableMarginRight: !0,
            boxSizingReliable: !0,
            pixelPosition: !1
        }, u.checked = !0, t.noCloneChecked = u.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !o.disabled;
        try {
            delete p.test
        } catch (d) {
            t.deleteExpando = !1
        }
        !p.addEventListener && p.attachEvent && p.fireEvent && (p.attachEvent("onclick", h = function () {
            t.noCloneEvent = !1
        }), p.cloneNode(!0).fireEvent("onclick"), p.detachEvent("onclick", h)), u = i.createElement("input"), u.value = "t", u.setAttribute("type", "radio"), t.radioValue = u.value === "t", u.setAttribute("checked", "checked"), u.setAttribute("name", "t"), p.appendChild(u), a = i.createDocumentFragment(), a.appendChild(p.lastChild), t.checkClone = a.cloneNode(!0).cloneNode(!0).lastChild.checked, t.appendChecked = u.checked, a.removeChild(u), a.appendChild(p);
        if (p.attachEvent)for (l in{
            submit: !0,
            change: !0,
            focusin: !0
        })f = "on" + l, c = f in p, c || (p.setAttribute(f, "return;"), c = typeof p[f] == "function"), t[l + "Bubbles"] = c;
        return v(function () {
            var n, r, s, o, u = "padding:0;margin:0;border:0;display:block;overflow:hidden;", a = i.getElementsByTagName("body")[0];
            if (!a)return;
            n = i.createElement("div"), n.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px", a.insertBefore(n, a.firstChild), r = i.createElement("div"), n.appendChild(r), r.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", s = r.getElementsByTagName("td"), s[0].style.cssText = "padding:0;margin:0;border:0;display:none", c = s[0].offsetHeight === 0, s[0].style.display = "", s[1].style.display = "none", t.reliableHiddenOffsets = c && s[0].offsetHeight === 0, r.innerHTML = "", r.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", t.boxSizing = r.offsetWidth === 4, t.doesNotIncludeMarginInBodyOffset = a.offsetTop !== 1, e.getComputedStyle && (t.pixelPosition = (e.getComputedStyle(r, null) || {}).top !== "1%", t.boxSizingReliable = (e.getComputedStyle(r, null) || {width: "4px"}).width === "4px", o = i.createElement("div"), o.style.cssText = r.style.cssText = u, o.style.marginRight = o.style.width = "0", r.style.width = "1px", r.appendChild(o), t.reliableMarginRight = !parseFloat((e.getComputedStyle(o, null) || {}).marginRight)), typeof r.style.zoom != "undefined" && (r.innerHTML = "", r.style.cssText = u + "width:1px;padding:1px;display:inline;zoom:1", t.inlineBlockNeedsLayout = r.offsetWidth === 3, r.style.display = "block", r.style.overflow = "visible", r.innerHTML = "<div></div>", r.firstChild.style.width = "5px", t.shrinkWrapBlocks = r.offsetWidth !== 3, n.style.zoom = 1), a.removeChild(n), n = r = s = o = null
        }), a.removeChild(p), n = r = s = o = u = a = p = null, t
    }();
    var D = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, P = /([A-Z])/g;
    v.extend({
        cache: {},
        deletedIds: [],
        uuid: 0,
        expando: "jQuery" + (v.fn.jquery + Math.random()).replace(/\D/g, ""),
        noData: {embed: !0, object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", applet: !0},
        hasData: function (e) {
            return e = e.nodeType ? v.cache[e[v.expando]] : e[v.expando], !!e && !B(e)
        },
        data: function (e, n, r, i) {
            if (!v.acceptData(e))return;
            var s, o, u = v.expando, a = typeof n == "string", f = e.nodeType, l = f ? v.cache : e, c = f ? e[u] : e[u] && u;
            if ((!c || !l[c] || !i && !l[c].data) && a && r === t)return;
            c || (f ? e[u] = c = v.deletedIds.pop() || v.guid++ : c = u), l[c] || (l[c] = {}, f || (l[c].toJSON = v.noop));
            if (typeof n == "object" || typeof n == "function")i ? l[c] = v.extend(l[c], n) : l[c].data = v.extend(l[c].data, n);
            return s = l[c], i || (s.data || (s.data = {}), s = s.data), r !== t && (s[v.camelCase(n)] = r), a ? (o = s[n], o == null && (o = s[v.camelCase(n)])) : o = s, o
        },
        removeData: function (e, t, n) {
            if (!v.acceptData(e))return;
            var r, i, s, o = e.nodeType, u = o ? v.cache : e, a = o ? e[v.expando] : v.expando;
            if (!u[a])return;
            if (t) {
                r = n ? u[a] : u[a].data;
                if (r) {
                    v.isArray(t) || (t in r ? t = [t] : (t = v.camelCase(t), t in r ? t = [t] : t = t.split(" ")));
                    for (i = 0, s = t.length; i < s; i++)delete r[t[i]];
                    if (!(n ? B : v.isEmptyObject)(r))return
                }
            }
            if (!n) {
                delete u[a].data;
                if (!B(u[a]))return
            }
            o ? v.cleanData([e], !0) : v.support.deleteExpando || u != u.window ? delete u[a] : u[a] = null
        },
        _data: function (e, t, n) {
            return v.data(e, t, n, !0)
        },
        acceptData: function (e) {
            var t = e.nodeName && v.noData[e.nodeName.toLowerCase()];
            return !t || t !== !0 && e.getAttribute("classid") === t
        }
    }), v.fn.extend({
        data: function (e, n) {
            var r, i, s, o, u, a = this[0], f = 0, l = null;
            if (e === t) {
                if (this.length) {
                    l = v.data(a);
                    if (a.nodeType === 1 && !v._data(a, "parsedAttrs")) {
                        s = a.attributes;
                        for (u = s.length; f < u; f++)o = s[f].name, o.indexOf("data-") || (o = v.camelCase(o.substring(5)), H(a, o, l[o]));
                        v._data(a, "parsedAttrs", !0)
                    }
                }
                return l
            }
            return typeof e == "object" ? this.each(function () {
                v.data(this, e)
            }) : (r = e.split(".", 2), r[1] = r[1] ? "." + r[1] : "", i = r[1] + "!", v.access(this, function (n) {
                if (n === t)return l = this.triggerHandler("getData" + i, [r[0]]), l === t && a && (l = v.data(a, e), l = H(a, e, l)), l === t && r[1] ? this.data(r[0]) : l;
                r[1] = n, this.each(function () {
                    var t = v(this);
                    t.triggerHandler("setData" + i, r), v.data(this, e, n), t.triggerHandler("changeData" + i, r)
                })
            }, null, n, arguments.length > 1, null, !1))
        }, removeData: function (e) {
            return this.each(function () {
                v.removeData(this, e)
            })
        }
    }), v.extend({
        queue: function (e, t, n) {
            var r;
            if (e)return t = (t || "fx") + "queue", r = v._data(e, t), n && (!r || v.isArray(n) ? r = v._data(e, t, v.makeArray(n)) : r.push(n)), r || []
        }, dequeue: function (e, t) {
            t = t || "fx";
            var n = v.queue(e, t), r = n.length, i = n.shift(), s = v._queueHooks(e, t), o = function () {
                v.dequeue(e, t)
            };
            i === "inprogress" && (i = n.shift(), r--), i && (t === "fx" && n.unshift("inprogress"), delete s.stop, i.call(e, o, s)), !r && s && s.empty.fire()
        }, _queueHooks: function (e, t) {
            var n = t + "queueHooks";
            return v._data(e, n) || v._data(e, n, {
                    empty: v.Callbacks("once memory").add(function () {
                        v.removeData(e, t + "queue", !0), v.removeData(e, n, !0)
                    })
                })
        }
    }), v.fn.extend({
        queue: function (e, n) {
            var r = 2;
            return typeof e != "string" && (n = e, e = "fx", r--), arguments.length < r ? v.queue(this[0], e) : n === t ? this : this.each(function () {
                var t = v.queue(this, e, n);
                v._queueHooks(this, e), e === "fx" && t[0] !== "inprogress" && v.dequeue(this, e)
            })
        }, dequeue: function (e) {
            return this.each(function () {
                v.dequeue(this, e)
            })
        }, delay: function (e, t) {
            return e = v.fx ? v.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) {
                var r = setTimeout(t, e);
                n.stop = function () {
                    clearTimeout(r)
                }
            })
        }, clearQueue: function (e) {
            return this.queue(e || "fx", [])
        }, promise: function (e, n) {
            var r, i = 1, s = v.Deferred(), o = this, u = this.length, a = function () {
                --i || s.resolveWith(o, [o])
            };
            typeof e != "string" && (n = e, e = t), e = e || "fx";
            while (u--)r = v._data(o[u], e + "queueHooks"), r && r.empty && (i++, r.empty.add(a));
            return a(), s.promise(n)
        }
    });
    var j, F, I, q = /[\t\r\n]/g, R = /\r/g, U = /^(?:button|input)$/i, z = /^(?:button|input|object|select|textarea)$/i, W = /^a(?:rea|)$/i, X = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, V = v.support.getSetAttribute;
    v.fn.extend({
        attr: function (e, t) {
            return v.access(this, v.attr, e, t, arguments.length > 1)
        }, removeAttr: function (e) {
            return this.each(function () {
                v.removeAttr(this, e)
            })
        }, prop: function (e, t) {
            return v.access(this, v.prop, e, t, arguments.length > 1)
        }, removeProp: function (e) {
            return e = v.propFix[e] || e, this.each(function () {
                try {
                    this[e] = t, delete this[e]
                } catch (n) {
                }
            })
        }, addClass: function (e) {
            var t, n, r, i, s, o, u;
            if (v.isFunction(e))return this.each(function (t) {
                v(this).addClass(e.call(this, t, this.className))
            });
            if (e && typeof e == "string") {
                t = e.split(y);
                for (n = 0, r = this.length; n < r; n++) {
                    i = this[n];
                    if (i.nodeType === 1)if (!i.className && t.length === 1)i.className = e; else {
                        s = " " + i.className + " ";
                        for (o = 0, u = t.length; o < u; o++)s.indexOf(" " + t[o] + " ") < 0 && (s += t[o] + " ");
                        i.className = v.trim(s)
                    }
                }
            }
            return this
        }, removeClass: function (e) {
            var n, r, i, s, o, u, a;
            if (v.isFunction(e))return this.each(function (t) {
                v(this).removeClass(e.call(this, t, this.className))
            });
            if (e && typeof e == "string" || e === t) {
                n = (e || "").split(y);
                for (u = 0, a = this.length; u < a; u++) {
                    i = this[u];
                    if (i.nodeType === 1 && i.className) {
                        r = (" " + i.className + " ").replace(q, " ");
                        for (s = 0, o = n.length; s < o; s++)while (r.indexOf(" " + n[s] + " ") >= 0)r = r.replace(" " + n[s] + " ", " ");
                        i.className = e ? v.trim(r) : ""
                    }
                }
            }
            return this
        }, toggleClass: function (e, t) {
            var n = typeof e, r = typeof t == "boolean";
            return v.isFunction(e) ? this.each(function (n) {
                v(this).toggleClass(e.call(this, n, this.className, t), t)
            }) : this.each(function () {
                if (n === "string") {
                    var i, s = 0, o = v(this), u = t, a = e.split(y);
                    while (i = a[s++])u = r ? u : !o.hasClass(i), o[u ? "addClass" : "removeClass"](i)
                } else if (n === "undefined" || n === "boolean")this.className && v._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : v._data(this, "__className__") || ""
            })
        }, hasClass: function (e) {
            var t = " " + e + " ", n = 0, r = this.length;
            for (; n < r; n++)if (this[n].nodeType === 1 && (" " + this[n].className + " ").replace(q, " ").indexOf(t) >= 0)return !0;
            return !1
        }, val: function (e) {
            var n, r, i, s = this[0];
            if (!arguments.length) {
                if (s)return n = v.valHooks[s.type] || v.valHooks[s.nodeName.toLowerCase()], n && "get"in n && (r = n.get(s, "value")) !== t ? r : (r = s.value, typeof r == "string" ? r.replace(R, "") : r == null ? "" : r);
                return
            }
            return i = v.isFunction(e), this.each(function (r) {
                var s, o = v(this);
                if (this.nodeType !== 1)return;
                i ? s = e.call(this, r, o.val()) : s = e, s == null ? s = "" : typeof s == "number" ? s += "" : v.isArray(s) && (s = v.map(s, function (e) {
                    return e == null ? "" : e + ""
                })), n = v.valHooks[this.type] || v.valHooks[this.nodeName.toLowerCase()];
                if (!n || !("set"in n) || n.set(this, s, "value") === t)this.value = s
            })
        }
    }), v.extend({
        valHooks: {
            option: {
                get: function (e) {
                    var t = e.attributes.value;
                    return !t || t.specified ? e.value : e.text
                }
            }, select: {
                get: function (e) {
                    var t, n, r = e.options, i = e.selectedIndex, s = e.type === "select-one" || i < 0, o = s ? null : [], u = s ? i + 1 : r.length, a = i < 0 ? u : s ? i : 0;
                    for (; a < u; a++) {
                        n = r[a];
                        if ((n.selected || a === i) && (v.support.optDisabled ? !n.disabled : n.getAttribute("disabled") === null) && (!n.parentNode.disabled || !v.nodeName(n.parentNode, "optgroup"))) {
                            t = v(n).val();
                            if (s)return t;
                            o.push(t)
                        }
                    }
                    return o
                }, set: function (e, t) {
                    var n = v.makeArray(t);
                    return v(e).find("option").each(function () {
                        this.selected = v.inArray(v(this).val(), n) >= 0
                    }), n.length || (e.selectedIndex = -1), n
                }
            }
        },
        attrFn: {},
        attr: function (e, n, r, i) {
            var s, o, u, a = e.nodeType;
            if (!e || a === 3 || a === 8 || a === 2)return;
            if (i && v.isFunction(v.fn[n]))return v(e)[n](r);
            if (typeof e.getAttribute == "undefined")return v.prop(e, n, r);
            u = a !== 1 || !v.isXMLDoc(e), u && (n = n.toLowerCase(), o = v.attrHooks[n] || (X.test(n) ? F : j));
            if (r !== t) {
                if (r === null) {
                    v.removeAttr(e, n);
                    return
                }
                return o && "set"in o && u && (s = o.set(e, r, n)) !== t ? s : (e.setAttribute(n, r + ""), r)
            }
            return o && "get"in o && u && (s = o.get(e, n)) !== null ? s : (s = e.getAttribute(n), s === null ? t : s)
        },
        removeAttr: function (e, t) {
            var n, r, i, s, o = 0;
            if (t && e.nodeType === 1) {
                r = t.split(y);
                for (; o < r.length; o++)i = r[o], i && (n = v.propFix[i] || i, s = X.test(i), s || v.attr(e, i, ""), e.removeAttribute(V ? i : n), s && n in e && (e[n] = !1))
            }
        },
        attrHooks: {
            type: {
                set: function (e, t) {
                    if (U.test(e.nodeName) && e.parentNode)v.error("type property can't be changed"); else if (!v.support.radioValue && t === "radio" && v.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t
                    }
                }
            }, value: {
                get: function (e, t) {
                    return j && v.nodeName(e, "button") ? j.get(e, t) : t in e ? e.value : null
                }, set: function (e, t, n) {
                    if (j && v.nodeName(e, "button"))return j.set(e, t, n);
                    e.value = t
                }
            }
        },
        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },
        prop: function (e, n, r) {
            var i, s, o, u = e.nodeType;
            if (!e || u === 3 || u === 8 || u === 2)return;
            return o = u !== 1 || !v.isXMLDoc(e), o && (n = v.propFix[n] || n, s = v.propHooks[n]), r !== t ? s && "set"in s && (i = s.set(e, r, n)) !== t ? i : e[n] = r : s && "get"in s && (i = s.get(e, n)) !== null ? i : e[n]
        },
        propHooks: {
            tabIndex: {
                get: function (e) {
                    var n = e.getAttributeNode("tabindex");
                    return n && n.specified ? parseInt(n.value, 10) : z.test(e.nodeName) || W.test(e.nodeName) && e.href ? 0 : t
                }
            }
        }
    }), F = {
        get: function (e, n) {
            var r, i = v.prop(e, n);
            return i === !0 || typeof i != "boolean" && (r = e.getAttributeNode(n)) && r.nodeValue !== !1 ? n.toLowerCase() : t
        }, set: function (e, t, n) {
            var r;
            return t === !1 ? v.removeAttr(e, n) : (r = v.propFix[n] || n, r in e && (e[r] = !0), e.setAttribute(n, n.toLowerCase())), n
        }
    }, V || (I = {name: !0, id: !0, coords: !0}, j = v.valHooks.button = {
        get: function (e, n) {
            var r;
            return r = e.getAttributeNode(n), r && (I[n] ? r.value !== "" : r.specified) ? r.value : t
        }, set: function (e, t, n) {
            var r = e.getAttributeNode(n);
            return r || (r = i.createAttribute(n), e.setAttributeNode(r)), r.value = t + ""
        }
    }, v.each(["width", "height"], function (e, t) {
        v.attrHooks[t] = v.extend(v.attrHooks[t], {
            set: function (e, n) {
                if (n === "")return e.setAttribute(t, "auto"), n
            }
        })
    }), v.attrHooks.contenteditable = {
        get: j.get, set: function (e, t, n) {
            t === "" && (t = "false"), j.set(e, t, n)
        }
    }), v.support.hrefNormalized || v.each(["href", "src", "width", "height"], function (e, n) {
        v.attrHooks[n] = v.extend(v.attrHooks[n], {
            get: function (e) {
                var r = e.getAttribute(n, 2);
                return r === null ? t : r
            }
        })
    }), v.support.style || (v.attrHooks.style = {
        get: function (e) {
            return e.style.cssText.toLowerCase() || t
        }, set: function (e, t) {
            return e.style.cssText = t + ""
        }
    }), v.support.optSelected || (v.propHooks.selected = v.extend(v.propHooks.selected, {
        get: function (e) {
            var t = e.parentNode;
            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null
        }
    })), v.support.enctype || (v.propFix.enctype = "encoding"), v.support.checkOn || v.each(["radio", "checkbox"], function () {
        v.valHooks[this] = {
            get: function (e) {
                return e.getAttribute("value") === null ? "on" : e.value
            }
        }
    }), v.each(["radio", "checkbox"], function () {
        v.valHooks[this] = v.extend(v.valHooks[this], {
            set: function (e, t) {
                if (v.isArray(t))return e.checked = v.inArray(v(e).val(), t) >= 0
            }
        })
    });
    var $ = /^(?:textarea|input|select)$/i, J = /^([^\.]*|)(?:\.(.+)|)$/, K = /(?:^|\s)hover(\.\S+|)\b/, Q = /^key/, G = /^(?:mouse|contextmenu)|click/, Y = /^(?:focusinfocus|focusoutblur)$/, Z = function (e) {
        return v.event.special.hover ? e : e.replace(K, "mouseenter$1 mouseleave$1")
    };
    v.event = {
        add: function (e, n, r, i, s) {
            var o, u, a, f, l, c, h, p, d, m, g;
            if (e.nodeType === 3 || e.nodeType === 8 || !n || !r || !(o = v._data(e)))return;
            r.handler && (d = r, r = d.handler, s = d.selector), r.guid || (r.guid = v.guid++), a = o.events, a || (o.events = a = {}), u = o.handle, u || (o.handle = u = function (e) {
                return typeof v == "undefined" || !!e && v.event.triggered === e.type ? t : v.event.dispatch.apply(u.elem, arguments)
            }, u.elem = e), n = v.trim(Z(n)).split(" ");
            for (f = 0; f < n.length; f++) {
                l = J.exec(n[f]) || [], c = l[1], h = (l[2] || "").split(".").sort(), g = v.event.special[c] || {}, c = (s ? g.delegateType : g.bindType) || c, g = v.event.special[c] || {}, p = v.extend({
                    type: c,
                    origType: l[1],
                    data: i,
                    handler: r,
                    guid: r.guid,
                    selector: s,
                    needsContext: s && v.expr.match.needsContext.test(s),
                    namespace: h.join(".")
                }, d), m = a[c];
                if (!m) {
                    m = a[c] = [], m.delegateCount = 0;
                    if (!g.setup || g.setup.call(e, i, h, u) === !1)e.addEventListener ? e.addEventListener(c, u, !1) : e.attachEvent && e.attachEvent("on" + c, u)
                }
                g.add && (g.add.call(e, p), p.handler.guid || (p.handler.guid = r.guid)), s ? m.splice(m.delegateCount++, 0, p) : m.push(p), v.event.global[c] = !0
            }
            e = null
        },
        global: {},
        remove: function (e, t, n, r, i) {
            var s, o, u, a, f, l, c, h, p, d, m, g = v.hasData(e) && v._data(e);
            if (!g || !(h = g.events))return;
            t = v.trim(Z(t || "")).split(" ");
            for (s = 0; s < t.length; s++) {
                o = J.exec(t[s]) || [], u = a = o[1], f = o[2];
                if (!u) {
                    for (u in h)v.event.remove(e, u + t[s], n, r, !0);
                    continue
                }
                p = v.event.special[u] || {}, u = (r ? p.delegateType : p.bindType) || u, d = h[u] || [], l = d.length, f = f ? new RegExp("(^|\\.)" + f.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                for (c = 0; c < d.length; c++)m = d[c], (i || a === m.origType) && (!n || n.guid === m.guid) && (!f || f.test(m.namespace)) && (!r || r === m.selector || r === "**" && m.selector) && (d.splice(c--, 1), m.selector && d.delegateCount--, p.remove && p.remove.call(e, m));
                d.length === 0 && l !== d.length && ((!p.teardown || p.teardown.call(e, f, g.handle) === !1) && v.removeEvent(e, u, g.handle), delete h[u])
            }
            v.isEmptyObject(h) && (delete g.handle, v.removeData(e, "events", !0))
        },
        customEvent: {getData: !0, setData: !0, changeData: !0},
        trigger: function (n, r, s, o) {
            if (!s || s.nodeType !== 3 && s.nodeType !== 8) {
                var u, a, f, l, c, h, p, d, m, g, y = n.type || n, b = [];
                if (Y.test(y + v.event.triggered))return;
                y.indexOf("!") >= 0 && (y = y.slice(0, -1), a = !0), y.indexOf(".") >= 0 && (b = y.split("."), y = b.shift(), b.sort());
                if ((!s || v.event.customEvent[y]) && !v.event.global[y])return;
                n = typeof n == "object" ? n[v.expando] ? n : new v.Event(y, n) : new v.Event(y), n.type = y, n.isTrigger = !0, n.exclusive = a, n.namespace = b.join("."), n.namespace_re = n.namespace ? new RegExp("(^|\\.)" + b.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, h = y.indexOf(":") < 0 ? "on" + y : "";
                if (!s) {
                    u = v.cache;
                    for (f in u)u[f].events && u[f].events[y] && v.event.trigger(n, r, u[f].handle.elem, !0);
                    return
                }
                n.result = t, n.target || (n.target = s), r = r != null ? v.makeArray(r) : [], r.unshift(n), p = v.event.special[y] || {};
                if (p.trigger && p.trigger.apply(s, r) === !1)return;
                m = [[s, p.bindType || y]];
                if (!o && !p.noBubble && !v.isWindow(s)) {
                    g = p.delegateType || y, l = Y.test(g + y) ? s : s.parentNode;
                    for (c = s; l; l = l.parentNode)m.push([l, g]), c = l;
                    c === (s.ownerDocument || i) && m.push([c.defaultView || c.parentWindow || e, g])
                }
                for (f = 0; f < m.length && !n.isPropagationStopped(); f++)l = m[f][0], n.type = m[f][1], d = (v._data(l, "events") || {})[n.type] && v._data(l, "handle"), d && d.apply(l, r), d = h && l[h], d && v.acceptData(l) && d.apply && d.apply(l, r) === !1 && n.preventDefault();
                return n.type = y, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(s.ownerDocument, r) === !1) && (y !== "click" || !v.nodeName(s, "a")) && v.acceptData(s) && h && s[y] && (y !== "focus" && y !== "blur" || n.target.offsetWidth !== 0) && !v.isWindow(s) && (c = s[h], c && (s[h] = null), v.event.triggered = y, s[y](), v.event.triggered = t, c && (s[h] = c)), n.result
            }
            return
        },
        dispatch: function (n) {
            n = v.event.fix(n || e.event);
            var r, i, s, o, u, a, f, c, h, p, d = (v._data(this, "events") || {})[n.type] || [], m = d.delegateCount, g = l.call(arguments), y = !n.exclusive && !n.namespace, b = v.event.special[n.type] || {}, w = [];
            g[0] = n, n.delegateTarget = this;
            if (b.preDispatch && b.preDispatch.call(this, n) === !1)return;
            if (m && (!n.button || n.type !== "click"))for (s = n.target; s != this; s = s.parentNode || this)if (s.disabled !== !0 || n.type !== "click") {
                u = {}, f = [];
                for (r = 0; r < m; r++)c = d[r], h = c.selector, u[h] === t && (u[h] = c.needsContext ? v(h, this).index(s) >= 0 : v.find(h, this, null, [s]).length), u[h] && f.push(c);
                f.length && w.push({elem: s, matches: f})
            }
            d.length > m && w.push({elem: this, matches: d.slice(m)});
            for (r = 0; r < w.length && !n.isPropagationStopped(); r++) {
                a = w[r], n.currentTarget = a.elem;
                for (i = 0; i < a.matches.length && !n.isImmediatePropagationStopped(); i++) {
                    c = a.matches[i];
                    if (y || !n.namespace && !c.namespace || n.namespace_re && n.namespace_re.test(c.namespace))n.data = c.data, n.handleObj = c, o = ((v.event.special[c.origType] || {}).handle || c.handler).apply(a.elem, g), o !== t && (n.result = o, o === !1 && (n.preventDefault(), n.stopPropagation()))
                }
            }
            return b.postDispatch && b.postDispatch.call(this, n), n.result
        },
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "), filter: function (e, t) {
                return e.which == null && (e.which = t.charCode != null ? t.charCode : t.keyCode), e
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (e, n) {
                var r, s, o, u = n.button, a = n.fromElement;
                return e.pageX == null && n.clientX != null && (r = e.target.ownerDocument || i, s = r.documentElement, o = r.body, e.pageX = n.clientX + (s && s.scrollLeft || o && o.scrollLeft || 0) - (s && s.clientLeft || o && o.clientLeft || 0), e.pageY = n.clientY + (s && s.scrollTop || o && o.scrollTop || 0) - (s && s.clientTop || o && o.clientTop || 0)), !e.relatedTarget && a && (e.relatedTarget = a === e.target ? n.toElement : a), !e.which && u !== t && (e.which = u & 1 ? 1 : u & 2 ? 3 : u & 4 ? 2 : 0), e
            }
        },
        fix: function (e) {
            if (e[v.expando])return e;
            var t, n, r = e, s = v.event.fixHooks[e.type] || {}, o = s.props ? this.props.concat(s.props) : this.props;
            e = v.Event(r);
            for (t = o.length; t;)n = o[--t], e[n] = r[n];
            return e.target || (e.target = r.srcElement || i), e.target.nodeType === 3 && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, r) : e
        },
        special: {
            load: {noBubble: !0},
            focus: {delegateType: "focusin"},
            blur: {delegateType: "focusout"},
            beforeunload: {
                setup: function (e, t, n) {
                    v.isWindow(this) && (this.onbeforeunload = n)
                }, teardown: function (e, t) {
                    this.onbeforeunload === t && (this.onbeforeunload = null)
                }
            }
        },
        simulate: function (e, t, n, r) {
            var i = v.extend(new v.Event, n, {type: e, isSimulated: !0, originalEvent: {}});
            r ? v.event.trigger(i, null, t) : v.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
        }
    }, v.event.handle = v.event.dispatch, v.removeEvent = i.removeEventListener ? function (e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1)
    } : function (e, t, n) {
        var r = "on" + t;
        e.detachEvent && (typeof e[r] == "undefined" && (e[r] = null), e.detachEvent(r, n))
    }, v.Event = function (e, t) {
        if (!(this instanceof v.Event))return new v.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? tt : et) : this.type = e, t && v.extend(this, t), this.timeStamp = e && e.timeStamp || v.now(), this[v.expando] = !0
    }, v.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = tt;
            var e = this.originalEvent;
            if (!e)return;
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
        }, stopPropagation: function () {
            this.isPropagationStopped = tt;
            var e = this.originalEvent;
            if (!e)return;
            e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0
        }, stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = tt, this.stopPropagation()
        }, isDefaultPrevented: et, isPropagationStopped: et, isImmediatePropagationStopped: et
    }, v.each({mouseenter: "mouseover", mouseleave: "mouseout"}, function (e, t) {
        v.event.special[e] = {
            delegateType: t, bindType: t, handle: function (e) {
                var n, r = this, i = e.relatedTarget, s = e.handleObj, o = s.selector;
                if (!i || i !== r && !v.contains(r, i))e.type = s.origType, n = s.handler.apply(this, arguments), e.type = t;
                return n
            }
        }
    }), v.support.submitBubbles || (v.event.special.submit = {
        setup: function () {
            if (v.nodeName(this, "form"))return !1;
            v.event.add(this, "click._submit keypress._submit", function (e) {
                var n = e.target, r = v.nodeName(n, "input") || v.nodeName(n, "button") ? n.form : t;
                r && !v._data(r, "_submit_attached") && (v.event.add(r, "submit._submit", function (e) {
                    e._submit_bubble = !0
                }), v._data(r, "_submit_attached", !0))
            })
        }, postDispatch: function (e) {
            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && v.event.simulate("submit", this.parentNode, e, !0))
        }, teardown: function () {
            if (v.nodeName(this, "form"))return !1;
            v.event.remove(this, "._submit")
        }
    }), v.support.changeBubbles || (v.event.special.change = {
        setup: function () {
            if ($.test(this.nodeName)) {
                if (this.type === "checkbox" || this.type === "radio")v.event.add(this, "propertychange._change", function (e) {
                    e.originalEvent.propertyName === "checked" && (this._just_changed = !0)
                }), v.event.add(this, "click._change", function (e) {
                    this._just_changed && !e.isTrigger && (this._just_changed = !1), v.event.simulate("change", this, e, !0)
                });
                return !1
            }
            v.event.add(this, "beforeactivate._change", function (e) {
                var t = e.target;
                $.test(t.nodeName) && !v._data(t, "_change_attached") && (v.event.add(t, "change._change", function (e) {
                    this.parentNode && !e.isSimulated && !e.isTrigger && v.event.simulate("change", this.parentNode, e, !0)
                }), v._data(t, "_change_attached", !0))
            })
        }, handle: function (e) {
            var t = e.target;
            if (this !== t || e.isSimulated || e.isTrigger || t.type !== "radio" && t.type !== "checkbox")return e.handleObj.handler.apply(this, arguments)
        }, teardown: function () {
            return v.event.remove(this, "._change"), !$.test(this.nodeName)
        }
    }), v.support.focusinBubbles || v.each({focus: "focusin", blur: "focusout"}, function (e, t) {
        var n = 0, r = function (e) {
            v.event.simulate(t, e.target, v.event.fix(e), !0)
        };
        v.event.special[t] = {
            setup: function () {
                n++ === 0 && i.addEventListener(e, r, !0)
            }, teardown: function () {
                --n === 0 && i.removeEventListener(e, r, !0)
            }
        }
    }), v.fn.extend({
        on: function (e, n, r, i, s) {
            var o, u;
            if (typeof e == "object") {
                typeof n != "string" && (r = r || n, n = t);
                for (u in e)this.on(u, n, r, e[u], s);
                return this
            }
            r == null && i == null ? (i = n, r = n = t) : i == null && (typeof n == "string" ? (i = r, r = t) : (i = r, r = n, n = t));
            if (i === !1)i = et; else if (!i)return this;
            return s === 1 && (o = i, i = function (e) {
                return v().off(e), o.apply(this, arguments)
            }, i.guid = o.guid || (o.guid = v.guid++)), this.each(function () {
                v.event.add(this, e, i, r, n)
            })
        }, one: function (e, t, n, r) {
            return this.on(e, t, n, r, 1)
        }, off: function (e, n, r) {
            var i, s;
            if (e && e.preventDefault && e.handleObj)return i = e.handleObj, v(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
            if (typeof e == "object") {
                for (s in e)this.off(s, n, e[s]);
                return this
            }
            if (n === !1 || typeof n == "function")r = n, n = t;
            return r === !1 && (r = et), this.each(function () {
                v.event.remove(this, e, r, n)
            })
        }, bind: function (e, t, n) {
            return this.on(e, null, t, n)
        }, unbind: function (e, t) {
            return this.off(e, null, t)
        }, live: function (e, t, n) {
            return v(this.context).on(e, this.selector, t, n), this
        }, die: function (e, t) {
            return v(this.context).off(e, this.selector || "**", t), this
        }, delegate: function (e, t, n, r) {
            return this.on(t, e, n, r)
        }, undelegate: function (e, t, n) {
            return arguments.length === 1 ? this.off(e, "**") : this.off(t, e || "**", n)
        }, trigger: function (e, t) {
            return this.each(function () {
                v.event.trigger(e, t, this)
            })
        }, triggerHandler: function (e, t) {
            if (this[0])return v.event.trigger(e, t, this[0], !0)
        }, toggle: function (e) {
            var t = arguments, n = e.guid || v.guid++, r = 0, i = function (n) {
                var i = (v._data(this, "lastToggle" + e.guid) || 0) % r;
                return v._data(this, "lastToggle" + e.guid, i + 1), n.preventDefault(), t[i].apply(this, arguments) || !1
            };
            i.guid = n;
            while (r < t.length)t[r++].guid = n;
            return this.click(i)
        }, hover: function (e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        }
    }), v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) {
        v.fn[t] = function (e, n) {
            return n == null && (n = e, e = null), arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
        }, Q.test(t) && (v.event.fixHooks[t] = v.event.keyHooks), G.test(t) && (v.event.fixHooks[t] = v.event.mouseHooks)
    }), function (e, t) {
        function nt(e, t, n, r) {
            n = n || [], t = t || g;
            var i, s, a, f, l = t.nodeType;
            if (!e || typeof e != "string")return n;
            if (l !== 1 && l !== 9)return [];
            a = o(t);
            if (!a && !r)if (i = R.exec(e))if (f = i[1]) {
                if (l === 9) {
                    s = t.getElementById(f);
                    if (!s || !s.parentNode)return n;
                    if (s.id === f)return n.push(s), n
                } else if (t.ownerDocument && (s = t.ownerDocument.getElementById(f)) && u(t, s) && s.id === f)return n.push(s), n
            } else {
                if (i[2])return S.apply(n, x.call(t.getElementsByTagName(e), 0)), n;
                if ((f = i[3]) && Z && t.getElementsByClassName)return S.apply(n, x.call(t.getElementsByClassName(f), 0)), n
            }
            return vt(e.replace(j, "$1"), t, n, r, a)
        }

        function rt(e) {
            return function (t) {
                var n = t.nodeName.toLowerCase();
                return n === "input" && t.type === e
            }
        }

        function it(e) {
            return function (t) {
                var n = t.nodeName.toLowerCase();
                return (n === "input" || n === "button") && t.type === e
            }
        }

        function st(e) {
            return N(function (t) {
                return t = +t, N(function (n, r) {
                    var i, s = e([], n.length, t), o = s.length;
                    while (o--)n[i = s[o]] && (n[i] = !(r[i] = n[i]))
                })
            })
        }

        function ot(e, t, n) {
            if (e === t)return n;
            var r = e.nextSibling;
            while (r) {
                if (r === t)return -1;
                r = r.nextSibling
            }
            return 1
        }

        function ut(e, t) {
            var n, r, s, o, u, a, f, l = L[d][e + " "];
            if (l)return t ? 0 : l.slice(0);
            u = e, a = [], f = i.preFilter;
            while (u) {
                if (!n || (r = F.exec(u)))r && (u = u.slice(r[0].length) || u), a.push(s = []);
                n = !1;
                if (r = I.exec(u))s.push(n = new m(r.shift())), u = u.slice(n.length), n.type = r[0].replace(j, " ");
                for (o in i.filter)(r = J[o].exec(u)) && (!f[o] || (r = f[o](r))) && (s.push(n = new m(r.shift())), u = u.slice(n.length), n.type = o, n.matches = r);
                if (!n)break
            }
            return t ? u.length : u ? nt.error(e) : L(e, a).slice(0)
        }

        function at(e, t, r) {
            var i = t.dir, s = r && t.dir === "parentNode", o = w++;
            return t.first ? function (t, n, r) {
                while (t = t[i])if (s || t.nodeType === 1)return e(t, n, r)
            } : function (t, r, u) {
                if (!u) {
                    var a, f = b + " " + o + " ", l = f + n;
                    while (t = t[i])if (s || t.nodeType === 1) {
                        if ((a = t[d]) === l)return t.sizset;
                        if (typeof a == "string" && a.indexOf(f) === 0) {
                            if (t.sizset)return t
                        } else {
                            t[d] = l;
                            if (e(t, r, u))return t.sizset = !0, t;
                            t.sizset = !1
                        }
                    }
                } else while (t = t[i])if (s || t.nodeType === 1)if (e(t, r, u))return t
            }
        }

        function ft(e) {
            return e.length > 1 ? function (t, n, r) {
                var i = e.length;
                while (i--)if (!e[i](t, n, r))return !1;
                return !0
            } : e[0]
        }

        function lt(e, t, n, r, i) {
            var s, o = [], u = 0, a = e.length, f = t != null;
            for (; u < a; u++)if (s = e[u])if (!n || n(s, r, i))o.push(s), f && t.push(u);
            return o
        }

        function ct(e, t, n, r, i, s) {
            return r && !r[d] && (r = ct(r)), i && !i[d] && (i = ct(i, s)), N(function (s, o, u, a) {
                var f, l, c, h = [], p = [], d = o.length, v = s || dt(t || "*", u.nodeType ? [u] : u, []), m = e && (s || !t) ? lt(v, h, e, u, a) : v, g = n ? i || (s ? e : d || r) ? [] : o : m;
                n && n(m, g, u, a);
                if (r) {
                    f = lt(g, p), r(f, [], u, a), l = f.length;
                    while (l--)if (c = f[l])g[p[l]] = !(m[p[l]] = c)
                }
                if (s) {
                    if (i || e) {
                        if (i) {
                            f = [], l = g.length;
                            while (l--)(c = g[l]) && f.push(m[l] = c);
                            i(null, g = [], f, a)
                        }
                        l = g.length;
                        while (l--)(c = g[l]) && (f = i ? T.call(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c))
                    }
                } else g = lt(g === o ? g.splice(d, g.length) : g), i ? i(null, o, g, a) : S.apply(o, g)
            })
        }

        function ht(e) {
            var t, n, r, s = e.length, o = i.relative[e[0].type], u = o || i.relative[" "], a = o ? 1 : 0, f = at(function (e) {
                return e === t
            }, u, !0), l = at(function (e) {
                return T.call(t, e) > -1
            }, u, !0), h = [function (e, n, r) {
                return !o && (r || n !== c) || ((t = n).nodeType ? f(e, n, r) : l(e, n, r))
            }];
            for (; a < s; a++)if (n = i.relative[e[a].type])h = [at(ft(h), n)]; else {
                n = i.filter[e[a].type].apply(null, e[a].matches);
                if (n[d]) {
                    r = ++a;
                    for (; r < s; r++)if (i.relative[e[r].type])break;
                    return ct(a > 1 && ft(h), a > 1 && e.slice(0, a - 1).join("").replace(j, "$1"), n, a < r && ht(e.slice(a, r)), r < s && ht(e = e.slice(r)), r < s && e.join(""))
                }
                h.push(n)
            }
            return ft(h)
        }

        function pt(e, t) {
            var r = t.length > 0, s = e.length > 0, o = function (u, a, f, l, h) {
                var p, d, v, m = [], y = 0, w = "0", x = u && [], T = h != null, N = c, C = u || s && i.find.TAG("*", h && a.parentNode || a), k = b += N == null ? 1 : Math.E;
                T && (c = a !== g && a, n = o.el);
                for (; (p = C[w]) != null; w++) {
                    if (s && p) {
                        for (d = 0; v = e[d]; d++)if (v(p, a, f)) {
                            l.push(p);
                            break
                        }
                        T && (b = k, n = ++o.el)
                    }
                    r && ((p = !v && p) && y--, u && x.push(p))
                }
                y += w;
                if (r && w !== y) {
                    for (d = 0; v = t[d]; d++)v(x, m, a, f);
                    if (u) {
                        if (y > 0)while (w--)!x[w] && !m[w] && (m[w] = E.call(l));
                        m = lt(m)
                    }
                    S.apply(l, m), T && !u && m.length > 0 && y + t.length > 1 && nt.uniqueSort(l)
                }
                return T && (b = k, c = N), x
            };
            return o.el = 0, r ? N(o) : o
        }

        function dt(e, t, n) {
            var r = 0, i = t.length;
            for (; r < i; r++)nt(e, t[r], n);
            return n
        }

        function vt(e, t, n, r, s) {
            var o, u, f, l, c, h = ut(e), p = h.length;
            if (!r && h.length === 1) {
                u = h[0] = h[0].slice(0);
                if (u.length > 2 && (f = u[0]).type === "ID" && t.nodeType === 9 && !s && i.relative[u[1].type]) {
                    t = i.find.ID(f.matches[0].replace($, ""), t, s)[0];
                    if (!t)return n;
                    e = e.slice(u.shift().length)
                }
                for (o = J.POS.test(e) ? -1 : u.length - 1; o >= 0; o--) {
                    f = u[o];
                    if (i.relative[l = f.type])break;
                    if (c = i.find[l])if (r = c(f.matches[0].replace($, ""), z.test(u[0].type) && t.parentNode || t, s)) {
                        u.splice(o, 1), e = r.length && u.join("");
                        if (!e)return S.apply(n, x.call(r, 0)), n;
                        break
                    }
                }
            }
            return a(e, h)(r, t, s, n, z.test(e)), n
        }

        function mt() {
        }

        var n, r, i, s, o, u, a, f, l, c, h = !0, p = "undefined", d = ("sizcache" + Math.random()).replace(".", ""), m = String, g = e.document, y = g.documentElement, b = 0, w = 0, E = [].pop, S = [].push, x = [].slice, T = [].indexOf || function (e) {
                var t = 0, n = this.length;
                for (; t < n; t++)if (this[t] === e)return t;
                return -1
            }, N = function (e, t) {
            return e[d] = t == null || t, e
        }, C = function () {
            var e = {}, t = [];
            return N(function (n, r) {
                return t.push(n) > i.cacheLength && delete e[t.shift()], e[n + " "] = r
            }, e)
        }, k = C(), L = C(), A = C(), O = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+", _ = M.replace("w", "w#"), D = "([*^$|!~]?=)", P = "\\[" + O + "*(" + M + ")" + O + "*(?:" + D + O + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + _ + ")|)|)" + O + "*\\]", H = ":(" + M + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + P + ")|[^:]|\\\\.)*|.*))\\)|)", B = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", j = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"), F = new RegExp("^" + O + "*," + O + "*"), I = new RegExp("^" + O + "*([\\x20\\t\\r\\n\\f>+~])" + O + "*"), q = new RegExp(H), R = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/, U = /^:not/, z = /[\x20\t\r\n\f]*[+~]/, W = /:not\($/, X = /h\d/i, V = /input|select|textarea|button/i, $ = /\\(?!\\)/g, J = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            NAME: new RegExp("^\\[name=['\"]?(" + M + ")['\"]?\\]"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + P),
            PSEUDO: new RegExp("^" + H),
            POS: new RegExp(B, "i"),
            CHILD: new RegExp("^:(only|nth|first|last)-child(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"),
            needsContext: new RegExp("^" + O + "*[>+~]|" + B, "i")
        }, K = function (e) {
            var t = g.createElement("div");
            try {
                return e(t)
            } catch (n) {
                return !1
            } finally {
                t = null
            }
        }, Q = K(function (e) {
            return e.appendChild(g.createComment("")), !e.getElementsByTagName("*").length
        }), G = K(function (e) {
            return e.innerHTML = "<a href='#'></a>", e.firstChild && typeof e.firstChild.getAttribute !== p && e.firstChild.getAttribute("href") === "#"
        }), Y = K(function (e) {
            e.innerHTML = "<select></select>";
            var t = typeof e.lastChild.getAttribute("multiple");
            return t !== "boolean" && t !== "string"
        }), Z = K(function (e) {
            return e.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>", !e.getElementsByClassName || !e.getElementsByClassName("e").length ? !1 : (e.lastChild.className = "e", e.getElementsByClassName("e").length === 2)
        }), et = K(function (e) {
            e.id = d + 0, e.innerHTML = "<a name='" + d + "'></a><div name='" + d + "'></div>", y.insertBefore(e, y.firstChild);
            var t = g.getElementsByName && g.getElementsByName(d).length === 2 + g.getElementsByName(d + 0).length;
            return r = !g.getElementById(d), y.removeChild(e), t
        });
        try {
            x.call(y.childNodes, 0)[0].nodeType
        } catch (tt) {
            x = function (e) {
                var t, n = [];
                for (; t = this[e]; e++)n.push(t);
                return n
            }
        }
        nt.matches = function (e, t) {
            return nt(e, null, null, t)
        }, nt.matchesSelector = function (e, t) {
            return nt(t, null, null, [e]).length > 0
        }, s = nt.getText = function (e) {
            var t, n = "", r = 0, i = e.nodeType;
            if (i) {
                if (i === 1 || i === 9 || i === 11) {
                    if (typeof e.textContent == "string")return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling)n += s(e)
                } else if (i === 3 || i === 4)return e.nodeValue
            } else for (; t = e[r]; r++)n += s(t);
            return n
        }, o = nt.isXML = function (e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return t ? t.nodeName !== "HTML" : !1
        }, u = nt.contains = y.contains ? function (e, t) {
            var n = e.nodeType === 9 ? e.documentElement : e, r = t && t.parentNode;
            return e === r || !!(r && r.nodeType === 1 && n.contains && n.contains(r))
        } : y.compareDocumentPosition ? function (e, t) {
            return t && !!(e.compareDocumentPosition(t) & 16)
        } : function (e, t) {
            while (t = t.parentNode)if (t === e)return !0;
            return !1
        }, nt.attr = function (e, t) {
            var n, r = o(e);
            return r || (t = t.toLowerCase()), (n = i.attrHandle[t]) ? n(e) : r || Y ? e.getAttribute(t) : (n = e.getAttributeNode(t), n ? typeof e[t] == "boolean" ? e[t] ? t : null : n.specified ? n.value : null : null)
        }, i = nt.selectors = {
            cacheLength: 50,
            createPseudo: N,
            match: J,
            attrHandle: G ? {} : {
                href: function (e) {
                    return e.getAttribute("href", 2)
                }, type: function (e) {
                    return e.getAttribute("type")
                }
            },
            find: {
                ID: r ? function (e, t, n) {
                    if (typeof t.getElementById !== p && !n) {
                        var r = t.getElementById(e);
                        return r && r.parentNode ? [r] : []
                    }
                } : function (e, n, r) {
                    if (typeof n.getElementById !== p && !r) {
                        var i = n.getElementById(e);
                        return i ? i.id === e || typeof i.getAttributeNode !== p && i.getAttributeNode("id").value === e ? [i] : t : []
                    }
                }, TAG: Q ? function (e, t) {
                    if (typeof t.getElementsByTagName !== p)return t.getElementsByTagName(e)
                } : function (e, t) {
                    var n = t.getElementsByTagName(e);
                    if (e === "*") {
                        var r, i = [], s = 0;
                        for (; r = n[s]; s++)r.nodeType === 1 && i.push(r);
                        return i
                    }
                    return n
                }, NAME: et && function (e, t) {
                    if (typeof t.getElementsByName !== p)return t.getElementsByName(name)
                }, CLASS: Z && function (e, t, n) {
                    if (typeof t.getElementsByClassName !== p && !n)return t.getElementsByClassName(e)
                }
            },
            relative: {
                ">": {dir: "parentNode", first: !0},
                " ": {dir: "parentNode"},
                "+": {dir: "previousSibling", first: !0},
                "~": {dir: "previousSibling"}
            },
            preFilter: {
                ATTR: function (e) {
                    return e[1] = e[1].replace($, ""), e[3] = (e[4] || e[5] || "").replace($, ""), e[2] === "~=" && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                }, CHILD: function (e) {
                    return e[1] = e[1].toLowerCase(), e[1] === "nth" ? (e[2] || nt.error(e[0]), e[3] = +(e[3] ? e[4] + (e[5] || 1) : 2 * (e[2] === "even" || e[2] === "odd")), e[4] = +(e[6] + e[7] || e[2] === "odd")) : e[2] && nt.error(e[0]), e
                }, PSEUDO: function (e) {
                    var t, n;
                    if (J.CHILD.test(e[0]))return null;
                    if (e[3])e[2] = e[3]; else if (t = e[4])q.test(t) && (n = ut(t, !0)) && (n = t.indexOf(")", t.length - n) - t.length) && (t = t.slice(0, n), e[0] = e[0].slice(0, n)), e[2] = t;
                    return e.slice(0, 3)
                }
            },
            filter: {
                ID: r ? function (e) {
                    return e = e.replace($, ""), function (t) {
                        return t.getAttribute("id") === e
                    }
                } : function (e) {
                    return e = e.replace($, ""), function (t) {
                        var n = typeof t.getAttributeNode !== p && t.getAttributeNode("id");
                        return n && n.value === e
                    }
                }, TAG: function (e) {
                    return e === "*" ? function () {
                        return !0
                    } : (e = e.replace($, "").toLowerCase(), function (t) {
                        return t.nodeName && t.nodeName.toLowerCase() === e
                    })
                }, CLASS: function (e) {
                    var t = k[d][e + " "];
                    return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && k(e, function (e) {
                            return t.test(e.className || typeof e.getAttribute !== p && e.getAttribute("class") || "")
                        })
                }, ATTR: function (e, t, n) {
                    return function (r, i) {
                        var s = nt.attr(r, e);
                        return s == null ? t === "!=" : t ? (s += "", t === "=" ? s === n : t === "!=" ? s !== n : t === "^=" ? n && s.indexOf(n) === 0 : t === "*=" ? n && s.indexOf(n) > -1 : t === "$=" ? n && s.substr(s.length - n.length) === n : t === "~=" ? (" " + s + " ").indexOf(n) > -1 : t === "|=" ? s === n || s.substr(0, n.length + 1) === n + "-" : !1) : !0
                    }
                }, CHILD: function (e, t, n, r) {
                    return e === "nth" ? function (e) {
                        var t, i, s = e.parentNode;
                        if (n === 1 && r === 0)return !0;
                        if (s) {
                            i = 0;
                            for (t = s.firstChild; t; t = t.nextSibling)if (t.nodeType === 1) {
                                i++;
                                if (e === t)break
                            }
                        }
                        return i -= r, i === n || i % n === 0 && i / n >= 0
                    } : function (t) {
                        var n = t;
                        switch (e) {
                            case"only":
                            case"first":
                                while (n = n.previousSibling)if (n.nodeType === 1)return !1;
                                if (e === "first")return !0;
                                n = t;
                            case"last":
                                while (n = n.nextSibling)if (n.nodeType === 1)return !1;
                                return !0
                        }
                    }
                }, PSEUDO: function (e, t) {
                    var n, r = i.pseudos[e] || i.setFilters[e.toLowerCase()] || nt.error("unsupported pseudo: " + e);
                    return r[d] ? r(t) : r.length > 1 ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? N(function (e, n) {
                        var i, s = r(e, t), o = s.length;
                        while (o--)i = T.call(e, s[o]), e[i] = !(n[i] = s[o])
                    }) : function (e) {
                        return r(e, 0, n)
                    }) : r
                }
            },
            pseudos: {
                not: N(function (e) {
                    var t = [], n = [], r = a(e.replace(j, "$1"));
                    return r[d] ? N(function (e, t, n, i) {
                        var s, o = r(e, null, i, []), u = e.length;
                        while (u--)if (s = o[u])e[u] = !(t[u] = s)
                    }) : function (e, i, s) {
                        return t[0] = e, r(t, null, s, n), !n.pop()
                    }
                }),
                has: N(function (e) {
                    return function (t) {
                        return nt(e, t).length > 0
                    }
                }),
                contains: N(function (e) {
                    return function (t) {
                        return (t.textContent || t.innerText || s(t)).indexOf(e) > -1
                    }
                }),
                enabled: function (e) {
                    return e.disabled === !1
                },
                disabled: function (e) {
                    return e.disabled === !0
                },
                checked: function (e) {
                    var t = e.nodeName.toLowerCase();
                    return t === "input" && !!e.checked || t === "option" && !!e.selected
                },
                selected: function (e) {
                    return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                },
                parent: function (e) {
                    return !i.pseudos.empty(e)
                },
                empty: function (e) {
                    var t;
                    e = e.firstChild;
                    while (e) {
                        if (e.nodeName > "@" || (t = e.nodeType) === 3 || t === 4)return !1;
                        e = e.nextSibling
                    }
                    return !0
                },
                header: function (e) {
                    return X.test(e.nodeName)
                },
                text: function (e) {
                    var t, n;
                    return e.nodeName.toLowerCase() === "input" && (t = e.type) === "text" && ((n = e.getAttribute("type")) == null || n.toLowerCase() === t)
                },
                radio: rt("radio"),
                checkbox: rt("checkbox"),
                file: rt("file"),
                password: rt("password"),
                image: rt("image"),
                submit: it("submit"),
                reset: it("reset"),
                button: function (e) {
                    var t = e.nodeName.toLowerCase();
                    return t === "input" && e.type === "button" || t === "button"
                },
                input: function (e) {
                    return V.test(e.nodeName)
                },
                focus: function (e) {
                    var t = e.ownerDocument;
                    return e === t.activeElement && (!t.hasFocus || t.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                },
                active: function (e) {
                    return e === e.ownerDocument.activeElement
                },
                first: st(function () {
                    return [0]
                }),
                last: st(function (e, t) {
                    return [t - 1]
                }),
                eq: st(function (e, t, n) {
                    return [n < 0 ? n + t : n]
                }),
                even: st(function (e, t) {
                    for (var n = 0; n < t; n += 2)e.push(n);
                    return e
                }),
                odd: st(function (e, t) {
                    for (var n = 1; n < t; n += 2)e.push(n);
                    return e
                }),
                lt: st(function (e, t, n) {
                    for (var r = n < 0 ? n + t : n; --r >= 0;)e.push(r);
                    return e
                }),
                gt: st(function (e, t, n) {
                    for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r);
                    return e
                })
            }
        }, f = y.compareDocumentPosition ? function (e, t) {
            return e === t ? (l = !0, 0) : (!e.compareDocumentPosition || !t.compareDocumentPosition ? e.compareDocumentPosition : e.compareDocumentPosition(t) & 4) ? -1 : 1
        } : function (e, t) {
            if (e === t)return l = !0, 0;
            if (e.sourceIndex && t.sourceIndex)return e.sourceIndex - t.sourceIndex;
            var n, r, i = [], s = [], o = e.parentNode, u = t.parentNode, a = o;
            if (o === u)return ot(e, t);
            if (!o)return -1;
            if (!u)return 1;
            while (a)i.unshift(a), a = a.parentNode;
            a = u;
            while (a)s.unshift(a), a = a.parentNode;
            n = i.length, r = s.length;
            for (var f = 0; f < n && f < r; f++)if (i[f] !== s[f])return ot(i[f], s[f]);
            return f === n ? ot(e, s[f], -1) : ot(i[f], t, 1)
        }, [0, 0].sort(f), h = !l, nt.uniqueSort = function (e) {
            var t, n = [], r = 1, i = 0;
            l = h, e.sort(f);
            if (l) {
                for (; t = e[r]; r++)t === e[r - 1] && (i = n.push(r));
                while (i--)e.splice(n[i], 1)
            }
            return e
        }, nt.error = function (e) {
            throw new Error("Syntax error, unrecognized expression: " + e)
        }, a = nt.compile = function (e, t) {
            var n, r = [], i = [], s = A[d][e + " "];
            if (!s) {
                t || (t = ut(e)), n = t.length;
                while (n--)s = ht(t[n]), s[d] ? r.push(s) : i.push(s);
                s = A(e, pt(i, r))
            }
            return s
        }, g.querySelectorAll && function () {
            var e, t = vt, n = /'|\\/g, r = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g, i = [":focus"], s = [":active"], u = y.matchesSelector || y.mozMatchesSelector || y.webkitMatchesSelector || y.oMatchesSelector || y.msMatchesSelector;
            K(function (e) {
                e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || i.push("\\[" + O + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)"), e.querySelectorAll(":checked").length || i.push(":checked")
            }), K(function (e) {
                e.innerHTML = "<p test=''></p>", e.querySelectorAll("[test^='']").length && i.push("[*^$]=" + O + "*(?:\"\"|'')"), e.innerHTML = "<input type='hidden'/>", e.querySelectorAll(":enabled").length || i.push(":enabled", ":disabled")
            }), i = new RegExp(i.join("|")), vt = function (e, r, s, o, u) {
                if (!o && !u && !i.test(e)) {
                    var a, f, l = !0, c = d, h = r, p = r.nodeType === 9 && e;
                    if (r.nodeType === 1 && r.nodeName.toLowerCase() !== "object") {
                        a = ut(e), (l = r.getAttribute("id")) ? c = l.replace(n, "\\$&") : r.setAttribute("id", c), c = "[id='" + c + "'] ", f = a.length;
                        while (f--)a[f] = c + a[f].join("");
                        h = z.test(e) && r.parentNode || r, p = a.join(",")
                    }
                    if (p)try {
                        return S.apply(s, x.call(h.querySelectorAll(p), 0)), s
                    } catch (v) {
                    } finally {
                        l || r.removeAttribute("id")
                    }
                }
                return t(e, r, s, o, u)
            }, u && (K(function (t) {
                e = u.call(t, "div");
                try {
                    u.call(t, "[test!='']:sizzle"), s.push("!=", H)
                } catch (n) {
                }
            }), s = new RegExp(s.join("|")), nt.matchesSelector = function (t, n) {
                n = n.replace(r, "='$1']");
                if (!o(t) && !s.test(n) && !i.test(n))try {
                    var a = u.call(t, n);
                    if (a || e || t.document && t.document.nodeType !== 11)return a
                } catch (f) {
                }
                return nt(n, null, null, [t]).length > 0
            })
        }(), i.pseudos.nth = i.pseudos.eq, i.filters = mt.prototype = i.pseudos, i.setFilters = new mt, nt.attr = v.attr, v.find = nt, v.expr = nt.selectors, v.expr[":"] = v.expr.pseudos, v.unique = nt.uniqueSort, v.text = nt.getText, v.isXMLDoc = nt.isXML, v.contains = nt.contains
    }(e);
    var nt = /Until$/, rt = /^(?:parents|prev(?:Until|All))/, it = /^.[^:#\[\.,]*$/, st = v.expr.match.needsContext, ot = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    v.fn.extend({
        find: function (e) {
            var t, n, r, i, s, o, u = this;
            if (typeof e != "string")return v(e).filter(function () {
                for (t = 0, n = u.length; t < n; t++)if (v.contains(u[t], this))return !0
            });
            o = this.pushStack("", "find", e);
            for (t = 0, n = this.length; t < n; t++) {
                r = o.length, v.find(e, this[t], o);
                if (t > 0)for (i = r; i < o.length; i++)for (s = 0; s < r; s++)if (o[s] === o[i]) {
                    o.splice(i--, 1);
                    break
                }
            }
            return o
        }, has: function (e) {
            var t, n = v(e, this), r = n.length;
            return this.filter(function () {
                for (t = 0; t < r; t++)if (v.contains(this, n[t]))return !0
            })
        }, not: function (e) {
            return this.pushStack(ft(this, e, !1), "not", e)
        }, filter: function (e) {
            return this.pushStack(ft(this, e, !0), "filter", e)
        }, is: function (e) {
            return !!e && (typeof e == "string" ? st.test(e) ? v(e, this.context).index(this[0]) >= 0 : v.filter(e, this).length > 0 : this.filter(e).length > 0)
        }, closest: function (e, t) {
            var n, r = 0, i = this.length, s = [], o = st.test(e) || typeof e != "string" ? v(e, t || this.context) : 0;
            for (; r < i; r++) {
                n = this[r];
                while (n && n.ownerDocument && n !== t && n.nodeType !== 11) {
                    if (o ? o.index(n) > -1 : v.find.matchesSelector(n, e)) {
                        s.push(n);
                        break
                    }
                    n = n.parentNode
                }
            }
            return s = s.length > 1 ? v.unique(s) : s, this.pushStack(s, "closest", e)
        }, index: function (e) {
            return e ? typeof e == "string" ? v.inArray(this[0], v(e)) : v.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.prevAll().length : -1
        }, add: function (e, t) {
            var n = typeof e == "string" ? v(e, t) : v.makeArray(e && e.nodeType ? [e] : e), r = v.merge(this.get(), n);
            return this.pushStack(ut(n[0]) || ut(r[0]) ? r : v.unique(r))
        }, addBack: function (e) {
            return this.add(e == null ? this.prevObject : this.prevObject.filter(e))
        }
    }), v.fn.andSelf = v.fn.addBack, v.each({
        parent: function (e) {
            var t = e.parentNode;
            return t && t.nodeType !== 11 ? t : null
        }, parents: function (e) {
            return v.dir(e, "parentNode")
        }, parentsUntil: function (e, t, n) {
            return v.dir(e, "parentNode", n)
        }, next: function (e) {
            return at(e, "nextSibling")
        }, prev: function (e) {
            return at(e, "previousSibling")
        }, nextAll: function (e) {
            return v.dir(e, "nextSibling")
        }, prevAll: function (e) {
            return v.dir(e, "previousSibling")
        }, nextUntil: function (e, t, n) {
            return v.dir(e, "nextSibling", n)
        }, prevUntil: function (e, t, n) {
            return v.dir(e, "previousSibling", n)
        }, siblings: function (e) {
            return v.sibling((e.parentNode || {}).firstChild, e)
        }, children: function (e) {
            return v.sibling(e.firstChild)
        }, contents: function (e) {
            return v.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : v.merge([], e.childNodes)
        }
    }, function (e, t) {
        v.fn[e] = function (n, r) {
            var i = v.map(this, t, n);
            return nt.test(e) || (r = n), r && typeof r == "string" && (i = v.filter(r, i)), i = this.length > 1 && !ot[e] ? v.unique(i) : i, this.length > 1 && rt.test(e) && (i = i.reverse()), this.pushStack(i, e, l.call(arguments).join(","))
        }
    }), v.extend({
        filter: function (e, t, n) {
            return n && (e = ":not(" + e + ")"), t.length === 1 ? v.find.matchesSelector(t[0], e) ? [t[0]] : [] : v.find.matches(e, t)
        }, dir: function (e, n, r) {
            var i = [], s = e[n];
            while (s && s.nodeType !== 9 && (r === t || s.nodeType !== 1 || !v(s).is(r)))s.nodeType === 1 && i.push(s), s = s[n];
            return i
        }, sibling: function (e, t) {
            var n = [];
            for (; e; e = e.nextSibling)e.nodeType === 1 && e !== t && n.push(e);
            return n
        }
    });
    var ct = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", ht = / jQuery\d+="(?:null|\d+)"/g, pt = /^\s+/, dt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, vt = /<([\w:]+)/, mt = /<tbody/i, gt = /<|&#?\w+;/, yt = /<(?:script|style|link)/i, bt = /<(?:script|object|embed|option|style)/i, wt = new RegExp("<(?:" + ct + ")[\\s/>]", "i"), Et = /^(?:checkbox|radio)$/, St = /checked\s*(?:[^=]|=\s*.checked.)/i, xt = /\/(java|ecma)script/i, Tt = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g, Nt = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        area: [1, "<map>", "</map>"],
        _default: [0, "", ""]
    }, Ct = lt(i), kt = Ct.appendChild(i.createElement("div"));
    Nt.optgroup = Nt.option, Nt.tbody = Nt.tfoot = Nt.colgroup = Nt.caption = Nt.thead, Nt.th = Nt.td, v.support.htmlSerialize || (Nt._default = [1, "X<div>", "</div>"]), v.fn.extend({
        text: function (e) {
            return v.access(this, function (e) {
                return e === t ? v.text(this) : this.empty().append((this[0] && this[0].ownerDocument || i).createTextNode(e))
            }, null, e, arguments.length)
        }, wrapAll: function (e) {
            if (v.isFunction(e))return this.each(function (t) {
                v(this).wrapAll(e.call(this, t))
            });
            if (this[0]) {
                var t = v(e, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
                    var e = this;
                    while (e.firstChild && e.firstChild.nodeType === 1)e = e.firstChild;
                    return e
                }).append(this)
            }
            return this
        }, wrapInner: function (e) {
            return v.isFunction(e) ? this.each(function (t) {
                v(this).wrapInner(e.call(this, t))
            }) : this.each(function () {
                var t = v(this), n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e)
            })
        }, wrap: function (e) {
            var t = v.isFunction(e);
            return this.each(function (n) {
                v(this).wrapAll(t ? e.call(this, n) : e)
            })
        }, unwrap: function () {
            return this.parent().each(function () {
                v.nodeName(this, "body") || v(this).replaceWith(this.childNodes)
            }).end()
        }, append: function () {
            return this.domManip(arguments, !0, function (e) {
                (this.nodeType === 1 || this.nodeType === 11) && this.appendChild(e)
            })
        }, prepend: function () {
            return this.domManip(arguments, !0, function (e) {
                (this.nodeType === 1 || this.nodeType === 11) && this.insertBefore(e, this.firstChild)
            })
        }, before: function () {
            if (!ut(this[0]))return this.domManip(arguments, !1, function (e) {
                this.parentNode.insertBefore(e, this)
            });
            if (arguments.length) {
                var e = v.clean(arguments);
                return this.pushStack(v.merge(e, this), "before", this.selector)
            }
        }, after: function () {
            if (!ut(this[0]))return this.domManip(arguments, !1, function (e) {
                this.parentNode.insertBefore(e, this.nextSibling)
            });
            if (arguments.length) {
                var e = v.clean(arguments);
                return this.pushStack(v.merge(this, e), "after", this.selector)
            }
        }, remove: function (e, t) {
            var n, r = 0;
            for (; (n = this[r]) != null; r++)if (!e || v.filter(e, [n]).length)!t && n.nodeType === 1 && (v.cleanData(n.getElementsByTagName("*")), v.cleanData([n])), n.parentNode && n.parentNode.removeChild(n);
            return this
        }, empty: function () {
            var e, t = 0;
            for (; (e = this[t]) != null; t++) {
                e.nodeType === 1 && v.cleanData(e.getElementsByTagName("*"));
                while (e.firstChild)e.removeChild(e.firstChild)
            }
            return this
        }, clone: function (e, t) {
            return e = e == null ? !1 : e, t = t == null ? e : t, this.map(function () {
                return v.clone(this, e, t)
            })
        }, html: function (e) {
            return v.access(this, function (e) {
                var n = this[0] || {}, r = 0, i = this.length;
                if (e === t)return n.nodeType === 1 ? n.innerHTML.replace(ht, "") : t;
                if (typeof e == "string" && !yt.test(e) && (v.support.htmlSerialize || !wt.test(e)) && (v.support.leadingWhitespace || !pt.test(e)) && !Nt[(vt.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = e.replace(dt, "<$1></$2>");
                    try {
                        for (; r < i; r++)n = this[r] || {}, n.nodeType === 1 && (v.cleanData(n.getElementsByTagName("*")), n.innerHTML = e);
                        n = 0
                    } catch (s) {
                    }
                }
                n && this.empty().append(e)
            }, null, e, arguments.length)
        }, replaceWith: function (e) {
            return ut(this[0]) ? this.length ? this.pushStack(v(v.isFunction(e) ? e() : e), "replaceWith", e) : this : v.isFunction(e) ? this.each(function (t) {
                var n = v(this), r = n.html();
                n.replaceWith(e.call(this, t, r))
            }) : (typeof e != "string" && (e = v(e).detach()), this.each(function () {
                var t = this.nextSibling, n = this.parentNode;
                v(this).remove(), t ? v(t).before(e) : v(n).append(e)
            }))
        }, detach: function (e) {
            return this.remove(e, !0)
        }, domManip: function (e, n, r) {
            e = [].concat.apply([], e);
            var i, s, o, u, a = 0, f = e[0], l = [], c = this.length;
            if (!v.support.checkClone && c > 1 && typeof f == "string" && St.test(f))return this.each(function () {
                v(this).domManip(e, n, r)
            });
            if (v.isFunction(f))return this.each(function (i) {
                var s = v(this);
                e[0] = f.call(this, i, n ? s.html() : t), s.domManip(e, n, r)
            });
            if (this[0]) {
                i = v.buildFragment(e, this, l), o = i.fragment, s = o.firstChild, o.childNodes.length === 1 && (o = s);
                if (s) {
                    n = n && v.nodeName(s, "tr");
                    for (u = i.cacheable || c - 1; a < c; a++)r.call(n && v.nodeName(this[a], "table") ? Lt(this[a], "tbody") : this[a], a === u ? o : v.clone(o, !0, !0))
                }
                o = s = null, l.length && v.each(l, function (e, t) {
                    t.src ? v.ajax ? v.ajax({
                        url: t.src,
                        type: "GET",
                        dataType: "script",
                        async: !1,
                        global: !1,
                        "throws": !0
                    }) : v.error("no ajax") : v.globalEval((t.text || t.textContent || t.innerHTML || "").replace(Tt, "")), t.parentNode && t.parentNode.removeChild(t)
                })
            }
            return this
        }
    }), v.buildFragment = function (e, n, r) {
        var s, o, u, a = e[0];
        return n = n || i, n = !n.nodeType && n[0] || n, n = n.ownerDocument || n, e.length === 1 && typeof a == "string" && a.length < 512 && n === i && a.charAt(0) === "<" && !bt.test(a) && (v.support.checkClone || !St.test(a)) && (v.support.html5Clone || !wt.test(a)) && (o = !0, s = v.fragments[a], u = s !== t), s || (s = n.createDocumentFragment(), v.clean(e, n, s, r), o && (v.fragments[a] = u && s)), {
            fragment: s,
            cacheable: o
        }
    }, v.fragments = {}, v.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (e, t) {
        v.fn[e] = function (n) {
            var r, i = 0, s = [], o = v(n), u = o.length, a = this.length === 1 && this[0].parentNode;
            if ((a == null || a && a.nodeType === 11 && a.childNodes.length === 1) && u === 1)return o[t](this[0]), this;
            for (; i < u; i++)r = (i > 0 ? this.clone(!0) : this).get(), v(o[i])[t](r), s = s.concat(r);
            return this.pushStack(s, e, o.selector)
        }
    }), v.extend({
        clone: function (e, t, n) {
            var r, i, s, o;
            v.support.html5Clone || v.isXMLDoc(e) || !wt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (kt.innerHTML = e.outerHTML, kt.removeChild(o = kt.firstChild));
            if ((!v.support.noCloneEvent || !v.support.noCloneChecked) && (e.nodeType === 1 || e.nodeType === 11) && !v.isXMLDoc(e)) {
                Ot(e, o), r = Mt(e), i = Mt(o);
                for (s = 0; r[s]; ++s)i[s] && Ot(r[s], i[s])
            }
            if (t) {
                At(e, o);
                if (n) {
                    r = Mt(e), i = Mt(o);
                    for (s = 0; r[s]; ++s)At(r[s], i[s])
                }
            }
            return r = i = null, o
        }, clean: function (e, t, n, r) {
            var s, o, u, a, f, l, c, h, p, d, m, g, y = t === i && Ct, b = [];
            if (!t || typeof t.createDocumentFragment == "undefined")t = i;
            for (s = 0; (u = e[s]) != null; s++) {
                typeof u == "number" && (u += "");
                if (!u)continue;
                if (typeof u == "string")if (!gt.test(u))u = t.createTextNode(u); else {
                    y = y || lt(t), c = t.createElement("div"), y.appendChild(c), u = u.replace(dt, "<$1></$2>"), a = (vt.exec(u) || ["", ""])[1].toLowerCase(), f = Nt[a] || Nt._default, l = f[0], c.innerHTML = f[1] + u + f[2];
                    while (l--)c = c.lastChild;
                    if (!v.support.tbody) {
                        h = mt.test(u), p = a === "table" && !h ? c.firstChild && c.firstChild.childNodes : f[1] === "<table>" && !h ? c.childNodes : [];
                        for (o = p.length - 1; o >= 0; --o)v.nodeName(p[o], "tbody") && !p[o].childNodes.length && p[o].parentNode.removeChild(p[o])
                    }
                    !v.support.leadingWhitespace && pt.test(u) && c.insertBefore(t.createTextNode(pt.exec(u)[0]), c.firstChild), u = c.childNodes, c.parentNode.removeChild(c)
                }
                u.nodeType ? b.push(u) : v.merge(b, u)
            }
            c && (u = c = y = null);
            if (!v.support.appendChecked)for (s = 0; (u = b[s]) != null; s++)v.nodeName(u, "input") ? _t(u) : typeof u.getElementsByTagName != "undefined" && v.grep(u.getElementsByTagName("input"), _t);
            if (n) {
                m = function (e) {
                    if (!e.type || xt.test(e.type))return r ? r.push(e.parentNode ? e.parentNode.removeChild(e) : e) : n.appendChild(e)
                };
                for (s = 0; (u = b[s]) != null; s++)if (!v.nodeName(u, "script") || !m(u))n.appendChild(u), typeof u.getElementsByTagName != "undefined" && (g = v.grep(v.merge([], u.getElementsByTagName("script")), m), b.splice.apply(b, [s + 1, 0].concat(g)), s += g.length)
            }
            return b
        }, cleanData: function (e, t) {
            var n, r, i, s, o = 0, u = v.expando, a = v.cache, f = v.support.deleteExpando, l = v.event.special;
            for (; (i = e[o]) != null; o++)if (t || v.acceptData(i)) {
                r = i[u], n = r && a[r];
                if (n) {
                    if (n.events)for (s in n.events)l[s] ? v.event.remove(i, s) : v.removeEvent(i, s, n.handle);
                    a[r] && (delete a[r], f ? delete i[u] : i.removeAttribute ? i.removeAttribute(u) : i[u] = null, v.deletedIds.push(r))
                }
            }
        }
    }), function () {
        var e, t;
        v.uaMatch = function (e) {
            e = e.toLowerCase();
            var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
            return {browser: t[1] || "", version: t[2] || "0"}
        }, e = v.uaMatch(o.userAgent), t = {}, e.browser && (t[e.browser] = !0, t.version = e.version), t.chrome ? t.webkit = !0 : t.webkit && (t.safari = !0), v.browser = t, v.sub = function () {
            function e(t, n) {
                return new e.fn.init(t, n)
            }

            v.extend(!0, e, this), e.superclass = this, e.fn = e.prototype = this(), e.fn.constructor = e, e.sub = this.sub, e.fn.init = function (r, i) {
                return i && i instanceof v && !(i instanceof e) && (i = e(i)), v.fn.init.call(this, r, i, t)
            }, e.fn.init.prototype = e.fn;
            var t = e(i);
            return e
        }
    }();
    var Dt, Pt, Ht, Bt = /alpha\([^)]*\)/i, jt = /opacity=([^)]*)/, Ft = /^(top|right|bottom|left)$/, It = /^(none|table(?!-c[ea]).+)/, qt = /^margin/, Rt = new RegExp("^(" + m + ")(.*)$", "i"), Ut = new RegExp("^(" + m + ")(?!px)[a-z%]+$", "i"), zt = new RegExp("^([-+])=(" + m + ")", "i"), Wt = {BODY: "block"}, Xt = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Vt = {
        letterSpacing: 0,
        fontWeight: 400
    }, $t = ["Top", "Right", "Bottom", "Left"], Jt = ["Webkit", "O", "Moz", "ms"], Kt = v.fn.toggle;
    v.fn.extend({
        css: function (e, n) {
            return v.access(this, function (e, n, r) {
                return r !== t ? v.style(e, n, r) : v.css(e, n)
            }, e, n, arguments.length > 1)
        }, show: function () {
            return Yt(this, !0)
        }, hide: function () {
            return Yt(this)
        }, toggle: function (e, t) {
            var n = typeof e == "boolean";
            return v.isFunction(e) && v.isFunction(t) ? Kt.apply(this, arguments) : this.each(function () {
                (n ? e : Gt(this)) ? v(this).show() : v(this).hide()
            })
        }
    }), v.extend({
        cssHooks: {
            opacity: {
                get: function (e, t) {
                    if (t) {
                        var n = Dt(e, "opacity");
                        return n === "" ? "1" : n
                    }
                }
            }
        },
        cssNumber: {
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {"float": v.support.cssFloat ? "cssFloat" : "styleFloat"},
        style: function (e, n, r, i) {
            if (!e || e.nodeType === 3 || e.nodeType === 8 || !e.style)return;
            var s, o, u, a = v.camelCase(n), f = e.style;
            n = v.cssProps[a] || (v.cssProps[a] = Qt(f, a)), u = v.cssHooks[n] || v.cssHooks[a];
            if (r === t)return u && "get"in u && (s = u.get(e, !1, i)) !== t ? s : f[n];
            o = typeof r, o === "string" && (s = zt.exec(r)) && (r = (s[1] + 1) * s[2] + parseFloat(v.css(e, n)), o = "number");
            if (r == null || o === "number" && isNaN(r))return;
            o === "number" && !v.cssNumber[a] && (r += "px");
            if (!u || !("set"in u) || (r = u.set(e, r, i)) !== t)try {
                f[n] = r
            } catch (l) {
            }
        },
        css: function (e, n, r, i) {
            var s, o, u, a = v.camelCase(n);
            return n = v.cssProps[a] || (v.cssProps[a] = Qt(e.style, a)), u = v.cssHooks[n] || v.cssHooks[a], u && "get"in u && (s = u.get(e, !0, i)), s === t && (s = Dt(e, n)), s === "normal" && n in Vt && (s = Vt[n]), r || i !== t ? (o = parseFloat(s), r || v.isNumeric(o) ? o || 0 : s) : s
        },
        swap: function (e, t, n) {
            var r, i, s = {};
            for (i in t)s[i] = e.style[i], e.style[i] = t[i];
            r = n.call(e);
            for (i in t)e.style[i] = s[i];
            return r
        }
    }), e.getComputedStyle ? Dt = function (t, n) {
        var r, i, s, o, u = e.getComputedStyle(t, null), a = t.style;
        return u && (r = u.getPropertyValue(n) || u[n], r === "" && !v.contains(t.ownerDocument, t) && (r = v.style(t, n)), Ut.test(r) && qt.test(n) && (i = a.width, s = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = r, r = u.width, a.width = i, a.minWidth = s, a.maxWidth = o)), r
    } : i.documentElement.currentStyle && (Dt = function (e, t) {
        var n, r, i = e.currentStyle && e.currentStyle[t], s = e.style;
        return i == null && s && s[t] && (i = s[t]), Ut.test(i) && !Ft.test(t) && (n = s.left, r = e.runtimeStyle && e.runtimeStyle.left, r && (e.runtimeStyle.left = e.currentStyle.left), s.left = t === "fontSize" ? "1em" : i, i = s.pixelLeft + "px", s.left = n, r && (e.runtimeStyle.left = r)), i === "" ? "auto" : i
    }), v.each(["height", "width"], function (e, t) {
        v.cssHooks[t] = {
            get: function (e, n, r) {
                if (n)return e.offsetWidth === 0 && It.test(Dt(e, "display")) ? v.swap(e, Xt, function () {
                    return tn(e, t, r)
                }) : tn(e, t, r)
            }, set: function (e, n, r) {
                return Zt(e, n, r ? en(e, t, r, v.support.boxSizing && v.css(e, "boxSizing") === "border-box") : 0)
            }
        }
    }), v.support.opacity || (v.cssHooks.opacity = {
        get: function (e, t) {
            return jt.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : ""
        }, set: function (e, t) {
            var n = e.style, r = e.currentStyle, i = v.isNumeric(t) ? "alpha(opacity=" + t * 100 + ")" : "", s = r && r.filter || n.filter || "";
            n.zoom = 1;
            if (t >= 1 && v.trim(s.replace(Bt, "")) === "" && n.removeAttribute) {
                n.removeAttribute("filter");
                if (r && !r.filter)return
            }
            n.filter = Bt.test(s) ? s.replace(Bt, i) : s + " " + i
        }
    }), v(function () {
        v.support.reliableMarginRight || (v.cssHooks.marginRight = {
            get: function (e, t) {
                return v.swap(e, {display: "inline-block"}, function () {
                    if (t)return Dt(e, "marginRight")
                })
            }
        }), !v.support.pixelPosition && v.fn.position && v.each(["top", "left"], function (e, t) {
            v.cssHooks[t] = {
                get: function (e, n) {
                    if (n) {
                        var r = Dt(e, t);
                        return Ut.test(r) ? v(e).position()[t] + "px" : r
                    }
                }
            }
        })
    }), v.expr && v.expr.filters && (v.expr.filters.hidden = function (e) {
        return e.offsetWidth === 0 && e.offsetHeight === 0 || !v.support.reliableHiddenOffsets && (e.style && e.style.display || Dt(e, "display")) === "none"
    }, v.expr.filters.visible = function (e) {
        return !v.expr.filters.hidden(e)
    }), v.each({margin: "", padding: "", border: "Width"}, function (e, t) {
        v.cssHooks[e + t] = {
            expand: function (n) {
                var r, i = typeof n == "string" ? n.split(" ") : [n], s = {};
                for (r = 0; r < 4; r++)s[e + $t[r] + t] = i[r] || i[r - 2] || i[0];
                return s
            }
        }, qt.test(e) || (v.cssHooks[e + t].set = Zt)
    });
    var rn = /%20/g, sn = /\[\]$/, on = /\r?\n/g, un = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i, an = /^(?:select|textarea)/i;
    v.fn.extend({
        serialize: function () {
            return v.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                return this.elements ? v.makeArray(this.elements) : this
            }).filter(function () {
                return this.name && !this.disabled && (this.checked || an.test(this.nodeName) || un.test(this.type))
            }).map(function (e, t) {
                var n = v(this).val();
                return n == null ? null : v.isArray(n) ? v.map(n, function (e, n) {
                    return {name: t.name, value: e.replace(on, "\r\n")}
                }) : {name: t.name, value: n.replace(on, "\r\n")}
            }).get()
        }
    }), v.param = function (e, n) {
        var r, i = [], s = function (e, t) {
            t = v.isFunction(t) ? t() : t == null ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
        };
        n === t && (n = v.ajaxSettings && v.ajaxSettings.traditional);
        if (v.isArray(e) || e.jquery && !v.isPlainObject(e))v.each(e, function () {
            s(this.name, this.value)
        }); else for (r in e)fn(r, e[r], n, s);
        return i.join("&").replace(rn, "+")
    };
    var ln, cn, hn = /#.*$/, pn = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, dn = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/, vn = /^(?:GET|HEAD)$/, mn = /^\/\//, gn = /\?/, yn = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, bn = /([?&])_=[^&]*/, wn = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, En = v.fn.load, Sn = {}, xn = {}, Tn = ["*/"] + ["*"];
    try {
        cn = s.href
    } catch (Nn) {
        cn = i.createElement("a"), cn.href = "", cn = cn.href
    }
    ln = wn.exec(cn.toLowerCase()) || [], v.fn.load = function (e, n, r) {
        if (typeof e != "string" && En)return En.apply(this, arguments);
        if (!this.length)return this;
        var i, s, o, u = this, a = e.indexOf(" ");
        return a >= 0 && (i = e.slice(a, e.length), e = e.slice(0, a)), v.isFunction(n) ? (r = n, n = t) : n && typeof n == "object" && (s = "POST"), v.ajax({
            url: e,
            type: s,
            dataType: "html",
            data: n,
            complete: function (e, t) {
                r && u.each(r, o || [e.responseText, t, e])
            }
        }).done(function (e) {
            o = arguments, u.html(i ? v("<div>").append(e.replace(yn, "")).find(i) : e)
        }), this
    }, v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (e, t) {
        v.fn[t] = function (e) {
            return this.on(t, e)
        }
    }), v.each(["get", "post"], function (e, n) {
        v[n] = function (e, r, i, s) {
            return v.isFunction(r) && (s = s || i, i = r, r = t), v.ajax({
                type: n,
                url: e,
                data: r,
                success: i,
                dataType: s
            })
        }
    }), v.extend({
        getScript: function (e, n) {
            return v.get(e, t, n, "script")
        },
        getJSON: function (e, t, n) {
            return v.get(e, t, n, "json")
        },
        ajaxSetup: function (e, t) {
            return t ? Ln(e, v.ajaxSettings) : (t = e, e = v.ajaxSettings), Ln(e, t), e
        },
        ajaxSettings: {
            url: cn,
            isLocal: dn.test(ln[1]),
            global: !0,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: !0,
            async: !0,
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": Tn
            },
            contents: {xml: /xml/, html: /html/, json: /json/},
            responseFields: {xml: "responseXML", text: "responseText"},
            converters: {"* text": e.String, "text html": !0, "text json": v.parseJSON, "text xml": v.parseXML},
            flatOptions: {context: !0, url: !0}
        },
        ajaxPrefilter: Cn(Sn),
        ajaxTransport: Cn(xn),
        ajax: function (e, n) {
            function T(e, n, s, a) {
                var l, y, b, w, S, T = n;
                if (E === 2)return;
                E = 2, u && clearTimeout(u), o = t, i = a || "", x.readyState = e > 0 ? 4 : 0, s && (w = An(c, x, s));
                if (e >= 200 && e < 300 || e === 304)c.ifModified && (S = x.getResponseHeader("Last-Modified"), S && (v.lastModified[r] = S), S = x.getResponseHeader("Etag"), S && (v.etag[r] = S)), e === 304 ? (T = "notmodified", l = !0) : (l = On(c, w), T = l.state, y = l.data, b = l.error, l = !b); else {
                    b = T;
                    if (!T || e)T = "error", e < 0 && (e = 0)
                }
                x.status = e, x.statusText = (n || T) + "", l ? d.resolveWith(h, [y, T, x]) : d.rejectWith(h, [x, T, b]), x.statusCode(g), g = t, f && p.trigger("ajax" + (l ? "Success" : "Error"), [x, c, l ? y : b]), m.fireWith(h, [x, T]), f && (p.trigger("ajaxComplete", [x, c]), --v.active || v.event.trigger("ajaxStop"))
            }

            typeof e == "object" && (n = e, e = t), n = n || {};
            var r, i, s, o, u, a, f, l, c = v.ajaxSetup({}, n), h = c.context || c, p = h !== c && (h.nodeType || h instanceof v) ? v(h) : v.event, d = v.Deferred(), m = v.Callbacks("once memory"), g = c.statusCode || {}, b = {}, w = {}, E = 0, S = "canceled", x = {
                readyState: 0,
                setRequestHeader: function (e, t) {
                    if (!E) {
                        var n = e.toLowerCase();
                        e = w[n] = w[n] || e, b[e] = t
                    }
                    return this
                },
                getAllResponseHeaders: function () {
                    return E === 2 ? i : null
                },
                getResponseHeader: function (e) {
                    var n;
                    if (E === 2) {
                        if (!s) {
                            s = {};
                            while (n = pn.exec(i))s[n[1].toLowerCase()] = n[2]
                        }
                        n = s[e.toLowerCase()]
                    }
                    return n === t ? null : n
                },
                overrideMimeType: function (e) {
                    return E || (c.mimeType = e), this
                },
                abort: function (e) {
                    return e = e || S, o && o.abort(e), T(0, e), this
                }
            };
            d.promise(x), x.success = x.done, x.error = x.fail, x.complete = m.add, x.statusCode = function (e) {
                if (e) {
                    var t;
                    if (E < 2)for (t in e)g[t] = [g[t], e[t]]; else t = e[x.status], x.always(t)
                }
                return this
            }, c.url = ((e || c.url) + "").replace(hn, "").replace(mn, ln[1] + "//"), c.dataTypes = v.trim(c.dataType || "*").toLowerCase().split(y), c.crossDomain == null && (a = wn.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === ln[1] && a[2] === ln[2] && (a[3] || (a[1] === "http:" ? 80 : 443)) == (ln[3] || (ln[1] === "http:" ? 80 : 443)))), c.data && c.processData && typeof c.data != "string" && (c.data = v.param(c.data, c.traditional)), kn(Sn, c, n, x);
            if (E === 2)return x;
            f = c.global, c.type = c.type.toUpperCase(), c.hasContent = !vn.test(c.type), f && v.active++ === 0 && v.event.trigger("ajaxStart");
            if (!c.hasContent) {
                c.data && (c.url += (gn.test(c.url) ? "&" : "?") + c.data, delete c.data), r = c.url;
                if (c.cache === !1) {
                    var N = v.now(), C = c.url.replace(bn, "$1_=" + N);
                    c.url = C + (C === c.url ? (gn.test(c.url) ? "&" : "?") + "_=" + N : "")
                }
            }
            (c.data && c.hasContent && c.contentType !== !1 || n.contentType) && x.setRequestHeader("Content-Type", c.contentType), c.ifModified && (r = r || c.url, v.lastModified[r] && x.setRequestHeader("If-Modified-Since", v.lastModified[r]), v.etag[r] && x.setRequestHeader("If-None-Match", v.etag[r])), x.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + (c.dataTypes[0] !== "*" ? ", " + Tn + "; q=0.01" : "") : c.accepts["*"]);
            for (l in c.headers)x.setRequestHeader(l, c.headers[l]);
            if (!c.beforeSend || c.beforeSend.call(h, x, c) !== !1 && E !== 2) {
                S = "abort";
                for (l in{success: 1, error: 1, complete: 1})x[l](c[l]);
                o = kn(xn, c, n, x);
                if (!o)T(-1, "No Transport"); else {
                    x.readyState = 1, f && p.trigger("ajaxSend", [x, c]), c.async && c.timeout > 0 && (u = setTimeout(function () {
                        x.abort("timeout")
                    }, c.timeout));
                    try {
                        E = 1, o.send(b, T)
                    } catch (k) {
                        if (!(E < 2))throw k;
                        T(-1, k)
                    }
                }
                return x
            }
            return x.abort()
        },
        active: 0,
        lastModified: {},
        etag: {}
    });
    var Mn = [], _n = /\?/, Dn = /(=)\?(?=&|$)|\?\?/, Pn = v.now();
    v.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            var e = Mn.pop() || v.expando + "_" + Pn++;
            return this[e] = !0, e
        }
    }), v.ajaxPrefilter("json jsonp", function (n, r, i) {
        var s, o, u, a = n.data, f = n.url, l = n.jsonp !== !1, c = l && Dn.test(f), h = l && !c && typeof a == "string" && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Dn.test(a);
        if (n.dataTypes[0] === "jsonp" || c || h)return s = n.jsonpCallback = v.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, o = e[s], c ? n.url = f.replace(Dn, "$1" + s) : h ? n.data = a.replace(Dn, "$1" + s) : l && (n.url += (_n.test(f) ? "&" : "?") + n.jsonp + "=" + s), n.converters["script json"] = function () {
            return u || v.error(s + " was not called"), u[0]
        }, n.dataTypes[0] = "json", e[s] = function () {
            u = arguments
        }, i.always(function () {
            e[s] = o, n[s] && (n.jsonpCallback = r.jsonpCallback, Mn.push(s)), u && v.isFunction(o) && o(u[0]), u = o = t
        }), "script"
    }), v.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /javascript|ecmascript/},
        converters: {
            "text script": function (e) {
                return v.globalEval(e), e
            }
        }
    }), v.ajaxPrefilter("script", function (e) {
        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1)
    }), v.ajaxTransport("script", function (e) {
        if (e.crossDomain) {
            var n, r = i.head || i.getElementsByTagName("head")[0] || i.documentElement;
            return {
                send: function (s, o) {
                    n = i.createElement("script"), n.async = "async", e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, i) {
                        if (i || !n.readyState || /loaded|complete/.test(n.readyState))n.onload = n.onreadystatechange = null, r && n.parentNode && r.removeChild(n), n = t, i || o(200, "success")
                    }, r.insertBefore(n, r.firstChild)
                }, abort: function () {
                    n && n.onload(0, 1)
                }
            }
        }
    });
    var Hn, Bn = e.ActiveXObject ? function () {
        for (var e in Hn)Hn[e](0, 1)
    } : !1, jn = 0;
    v.ajaxSettings.xhr = e.ActiveXObject ? function () {
        return !this.isLocal && Fn() || In()
    } : Fn, function (e) {
        v.extend(v.support, {ajax: !!e, cors: !!e && "withCredentials"in e})
    }(v.ajaxSettings.xhr()), v.support.ajax && v.ajaxTransport(function (n) {
        if (!n.crossDomain || v.support.cors) {
            var r;
            return {
                send: function (i, s) {
                    var o, u, a = n.xhr();
                    n.username ? a.open(n.type, n.url, n.async, n.username, n.password) : a.open(n.type, n.url, n.async);
                    if (n.xhrFields)for (u in n.xhrFields)a[u] = n.xhrFields[u];
                    n.mimeType && a.overrideMimeType && a.overrideMimeType(n.mimeType), !n.crossDomain && !i["X-Requested-With"] && (i["X-Requested-With"] = "XMLHttpRequest");
                    try {
                        for (u in i)a.setRequestHeader(u, i[u])
                    } catch (f) {
                    }
                    a.send(n.hasContent && n.data || null), r = function (e, i) {
                        var u, f, l, c, h;
                        try {
                            if (r && (i || a.readyState === 4)) {
                                r = t, o && (a.onreadystatechange = v.noop, Bn && delete Hn[o]);
                                if (i)a.readyState !== 4 && a.abort(); else {
                                    u = a.status, l = a.getAllResponseHeaders(), c = {}, h = a.responseXML, h && h.documentElement && (c.xml = h);
                                    try {
                                        c.text = a.responseText
                                    } catch (p) {
                                    }
                                    try {
                                        f = a.statusText
                                    } catch (p) {
                                        f = ""
                                    }
                                    !u && n.isLocal && !n.crossDomain ? u = c.text ? 200 : 404 : u === 1223 && (u = 204)
                                }
                            }
                        } catch (d) {
                            i || s(-1, d)
                        }
                        c && s(u, f, c, l)
                    }, n.async ? a.readyState === 4 ? setTimeout(r, 0) : (o = ++jn, Bn && (Hn || (Hn = {}, v(e).unload(Bn)), Hn[o] = r), a.onreadystatechange = r) : r()
                }, abort: function () {
                    r && r(0, 1)
                }
            }
        }
    });
    var qn, Rn, Un = /^(?:toggle|show|hide)$/, zn = new RegExp("^(?:([-+])=|)(" + m + ")([a-z%]*)$", "i"), Wn = /queueHooks$/, Xn = [Gn], Vn = {
        "*": [function (e, t) {
            var n, r, i = this.createTween(e, t), s = zn.exec(t), o = i.cur(), u = +o || 0, a = 1, f = 20;
            if (s) {
                n = +s[2], r = s[3] || (v.cssNumber[e] ? "" : "px");
                if (r !== "px" && u) {
                    u = v.css(i.elem, e, !0) || n || 1;
                    do a = a || ".5", u /= a, v.style(i.elem, e, u + r); while (a !== (a = i.cur() / o) && a !== 1 && --f)
                }
                i.unit = r, i.start = u, i.end = s[1] ? u + (s[1] + 1) * n : n
            }
            return i
        }]
    };
    v.Animation = v.extend(Kn, {
        tweener: function (e, t) {
            v.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
            var n, r = 0, i = e.length;
            for (; r < i; r++)n = e[r], Vn[n] = Vn[n] || [], Vn[n].unshift(t)
        }, prefilter: function (e, t) {
            t ? Xn.unshift(e) : Xn.push(e)
        }
    }), v.Tween = Yn, Yn.prototype = {
        constructor: Yn, init: function (e, t, n, r, i, s) {
            this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = s || (v.cssNumber[n] ? "" : "px")
        }, cur: function () {
            var e = Yn.propHooks[this.prop];
            return e && e.get ? e.get(this) : Yn.propHooks._default.get(this)
        }, run: function (e) {
            var t, n = Yn.propHooks[this.prop];
            return this.options.duration ? this.pos = t = v.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Yn.propHooks._default.set(this), this
        }
    }, Yn.prototype.init.prototype = Yn.prototype, Yn.propHooks = {
        _default: {
            get: function (e) {
                var t;
                return e.elem[e.prop] == null || !!e.elem.style && e.elem.style[e.prop] != null ? (t = v.css(e.elem, e.prop, !1, ""), !t || t === "auto" ? 0 : t) : e.elem[e.prop]
            }, set: function (e) {
                v.fx.step[e.prop] ? v.fx.step[e.prop](e) : e.elem.style && (e.elem.style[v.cssProps[e.prop]] != null || v.cssHooks[e.prop]) ? v.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    }, Yn.propHooks.scrollTop = Yn.propHooks.scrollLeft = {
        set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    }, v.each(["toggle", "show", "hide"], function (e, t) {
        var n = v.fn[t];
        v.fn[t] = function (r, i, s) {
            return r == null || typeof r == "boolean" || !e && v.isFunction(r) && v.isFunction(i) ? n.apply(this, arguments) : this.animate(Zn(t, !0), r, i, s)
        }
    }), v.fn.extend({
        fadeTo: function (e, t, n, r) {
            return this.filter(Gt).css("opacity", 0).show().end().animate({opacity: t}, e, n, r)
        }, animate: function (e, t, n, r) {
            var i = v.isEmptyObject(e), s = v.speed(t, n, r), o = function () {
                var t = Kn(this, v.extend({}, e), s);
                i && t.stop(!0)
            };
            return i || s.queue === !1 ? this.each(o) : this.queue(s.queue, o)
        }, stop: function (e, n, r) {
            var i = function (e) {
                var t = e.stop;
                delete e.stop, t(r)
            };
            return typeof e != "string" && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function () {
                var t = !0, n = e != null && e + "queueHooks", s = v.timers, o = v._data(this);
                if (n)o[n] && o[n].stop && i(o[n]); else for (n in o)o[n] && o[n].stop && Wn.test(n) && i(o[n]);
                for (n = s.length; n--;)s[n].elem === this && (e == null || s[n].queue === e) && (s[n].anim.stop(r), t = !1, s.splice(n, 1));
                (t || !r) && v.dequeue(this, e)
            })
        }
    }), v.each({
        slideDown: Zn("show"),
        slideUp: Zn("hide"),
        slideToggle: Zn("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (e, t) {
        v.fn[e] = function (e, n, r) {
            return this.animate(t, e, n, r)
        }
    }), v.speed = function (e, t, n) {
        var r = e && typeof e == "object" ? v.extend({}, e) : {
            complete: n || !n && t || v.isFunction(e) && e,
            duration: e,
            easing: n && t || t && !v.isFunction(t) && t
        };
        r.duration = v.fx.off ? 0 : typeof r.duration == "number" ? r.duration : r.duration in v.fx.speeds ? v.fx.speeds[r.duration] : v.fx.speeds._default;
        if (r.queue == null || r.queue === !0)r.queue = "fx";
        return r.old = r.complete, r.complete = function () {
            v.isFunction(r.old) && r.old.call(this), r.queue && v.dequeue(this, r.queue)
        }, r
    }, v.easing = {
        linear: function (e) {
            return e
        }, swing: function (e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }
    }, v.timers = [], v.fx = Yn.prototype.init, v.fx.tick = function () {
        var e, n = v.timers, r = 0;
        qn = v.now();
        for (; r < n.length; r++)e = n[r], !e() && n[r] === e && n.splice(r--, 1);
        n.length || v.fx.stop(), qn = t
    }, v.fx.timer = function (e) {
        e() && v.timers.push(e) && !Rn && (Rn = setInterval(v.fx.tick, v.fx.interval))
    }, v.fx.interval = 13, v.fx.stop = function () {
        clearInterval(Rn), Rn = null
    }, v.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, v.fx.step = {}, v.expr && v.expr.filters && (v.expr.filters.animated = function (e) {
        return v.grep(v.timers, function (t) {
            return e === t.elem
        }).length
    });
    var er = /^(?:body|html)$/i;
    v.fn.offset = function (e) {
        if (arguments.length)return e === t ? this : this.each(function (t) {
            v.offset.setOffset(this, e, t)
        });
        var n, r, i, s, o, u, a, f = {top: 0, left: 0}, l = this[0], c = l && l.ownerDocument;
        if (!c)return;
        return (r = c.body) === l ? v.offset.bodyOffset(l) : (n = c.documentElement, v.contains(n, l) ? (typeof l.getBoundingClientRect != "undefined" && (f = l.getBoundingClientRect()), i = tr(c), s = n.clientTop || r.clientTop || 0, o = n.clientLeft || r.clientLeft || 0, u = i.pageYOffset || n.scrollTop, a = i.pageXOffset || n.scrollLeft, {
            top: f.top + u - s,
            left: f.left + a - o
        }) : f)
    }, v.offset = {
        bodyOffset: function (e) {
            var t = e.offsetTop, n = e.offsetLeft;
            return v.support.doesNotIncludeMarginInBodyOffset && (t += parseFloat(v.css(e, "marginTop")) || 0, n += parseFloat(v.css(e, "marginLeft")) || 0), {
                top: t,
                left: n
            }
        }, setOffset: function (e, t, n) {
            var r = v.css(e, "position");
            r === "static" && (e.style.position = "relative");
            var i = v(e), s = i.offset(), o = v.css(e, "top"), u = v.css(e, "left"), a = (r === "absolute" || r === "fixed") && v.inArray("auto", [o, u]) > -1, f = {}, l = {}, c, h;
            a ? (l = i.position(), c = l.top, h = l.left) : (c = parseFloat(o) || 0, h = parseFloat(u) || 0), v.isFunction(t) && (t = t.call(e, n, s)), t.top != null && (f.top = t.top - s.top + c), t.left != null && (f.left = t.left - s.left + h), "using"in t ? t.using.call(e, f) : i.css(f)
        }
    }, v.fn.extend({
        position: function () {
            if (!this[0])return;
            var e = this[0], t = this.offsetParent(), n = this.offset(), r = er.test(t[0].nodeName) ? {
                top: 0,
                left: 0
            } : t.offset();
            return n.top -= parseFloat(v.css(e, "marginTop")) || 0, n.left -= parseFloat(v.css(e, "marginLeft")) || 0, r.top += parseFloat(v.css(t[0], "borderTopWidth")) || 0, r.left += parseFloat(v.css(t[0], "borderLeftWidth")) || 0, {
                top: n.top - r.top,
                left: n.left - r.left
            }
        }, offsetParent: function () {
            return this.map(function () {
                var e = this.offsetParent || i.body;
                while (e && !er.test(e.nodeName) && v.css(e, "position") === "static")e = e.offsetParent;
                return e || i.body
            })
        }
    }), v.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (e, n) {
        var r = /Y/.test(n);
        v.fn[e] = function (i) {
            return v.access(this, function (e, i, s) {
                var o = tr(e);
                if (s === t)return o ? n in o ? o[n] : o.document.documentElement[i] : e[i];
                o ? o.scrollTo(r ? v(o).scrollLeft() : s, r ? s : v(o).scrollTop()) : e[i] = s
            }, e, i, arguments.length, null)
        }
    }), v.each({Height: "height", Width: "width"}, function (e, n) {
        v.each({padding: "inner" + e, content: n, "": "outer" + e}, function (r, i) {
            v.fn[i] = function (i, s) {
                var o = arguments.length && (r || typeof i != "boolean"), u = r || (i === !0 || s === !0 ? "margin" : "border");
                return v.access(this, function (n, r, i) {
                    var s;
                    return v.isWindow(n) ? n.document.documentElement["client" + e] : n.nodeType === 9 ? (s = n.documentElement, Math.max(n.body["scroll" + e], s["scroll" + e], n.body["offset" + e], s["offset" + e], s["client" + e])) : i === t ? v.css(n, r, i, u) : v.style(n, r, i, u)
                }, n, o ? i : t, o, null)
            }
        })
    }), e.jQuery = e.$ = v, typeof define == "function" && define.amd && define.amd.jQuery && define("jquery", [], function () {
        return v
    })
})(window);
/*! jQuery UI - v1.9.1 - 2012-10-25
 * http://jqueryui.com
 * Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
 * Copyright 2012 jQuery Foundation and other contributors; Licensed MIT */
(function (e, t) {
    function i(t, n) {
        var r, i, o, u = t.nodeName.toLowerCase();
        return "area" === u ? (r = t.parentNode, i = r.name, !t.href || !i || r.nodeName.toLowerCase() !== "map" ? !1 : (o = e("img[usemap=#" + i + "]")[0], !!o && s(o))) : (/input|select|textarea|button|object/.test(u) ? !t.disabled : "a" === u ? t.href || n : n) && s(t)
    }

    function s(t) {
        return e.expr.filters.visible(t) && !e(t).parents().andSelf().filter(function () {
                return e.css(this, "visibility") === "hidden"
            }).length
    }

    var n = 0, r = /^ui-id-\d+$/;
    e.ui = e.ui || {};
    if (e.ui.version)return;
    e.extend(e.ui, {
        version: "1.9.1",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), e.fn.extend({
        _focus: e.fn.focus, focus: function (t, n) {
            return typeof t == "number" ? this.each(function () {
                var r = this;
                setTimeout(function () {
                    e(r).focus(), n && n.call(r)
                }, t)
            }) : this._focus.apply(this, arguments)
        }, scrollParent: function () {
            var t;
            return e.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? t = this.parents().filter(function () {
                return /(relative|absolute|fixed)/.test(e.css(this, "position")) && /(auto|scroll)/.test(e.css(this, "overflow") + e.css(this, "overflow-y") + e.css(this, "overflow-x"))
            }).eq(0) : t = this.parents().filter(function () {
                return /(auto|scroll)/.test(e.css(this, "overflow") + e.css(this, "overflow-y") + e.css(this, "overflow-x"))
            }).eq(0), /fixed/.test(this.css("position")) || !t.length ? e(document) : t
        }, zIndex: function (n) {
            if (n !== t)return this.css("zIndex", n);
            if (this.length) {
                var r = e(this[0]), i, s;
                while (r.length && r[0] !== document) {
                    i = r.css("position");
                    if (i === "absolute" || i === "relative" || i === "fixed") {
                        s = parseInt(r.css("zIndex"), 10);
                        if (!isNaN(s) && s !== 0)return s
                    }
                    r = r.parent()
                }
            }
            return 0
        }, uniqueId: function () {
            return this.each(function () {
                this.id || (this.id = "ui-id-" + ++n)
            })
        }, removeUniqueId: function () {
            return this.each(function () {
                r.test(this.id) && e(this).removeAttr("id")
            })
        }
    }), e("<a>").outerWidth(1).jquery || e.each(["Width", "Height"], function (n, r) {
        function u(t, n, r, s) {
            return e.each(i, function () {
                n -= parseFloat(e.css(t, "padding" + this)) || 0, r && (n -= parseFloat(e.css(t, "border" + this + "Width")) || 0), s && (n -= parseFloat(e.css(t, "margin" + this)) || 0)
            }), n
        }

        var i = r === "Width" ? ["Left", "Right"] : ["Top", "Bottom"], s = r.toLowerCase(), o = {
            innerWidth: e.fn.innerWidth,
            innerHeight: e.fn.innerHeight,
            outerWidth: e.fn.outerWidth,
            outerHeight: e.fn.outerHeight
        };
        e.fn["inner" + r] = function (n) {
            return n === t ? o["inner" + r].call(this) : this.each(function () {
                e(this).css(s, u(this, n) + "px")
            })
        }, e.fn["outer" + r] = function (t, n) {
            return typeof t != "number" ? o["outer" + r].call(this, t) : this.each(function () {
                e(this).css(s, u(this, t, !0, n) + "px")
            })
        }
    }), e.extend(e.expr[":"], {
        data: e.expr.createPseudo ? e.expr.createPseudo(function (t) {
            return function (n) {
                return !!e.data(n, t)
            }
        }) : function (t, n, r) {
            return !!e.data(t, r[3])
        }, focusable: function (t) {
            return i(t, !isNaN(e.attr(t, "tabindex")))
        }, tabbable: function (t) {
            var n = e.attr(t, "tabindex"), r = isNaN(n);
            return (r || n >= 0) && i(t, !r)
        }
    }), e(function () {
        var t = document.body, n = t.appendChild(n = document.createElement("div"));
        n.offsetHeight, e.extend(n.style, {
            minHeight: "100px",
            height: "auto",
            padding: 0,
            borderWidth: 0
        }), e.support.minHeight = n.offsetHeight === 100, e.support.selectstart = "onselectstart"in n, t.removeChild(n).style.display = "none"
    }), function () {
        var t = /msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || [];
        e.ui.ie = t.length ? !0 : !1, e.ui.ie6 = parseFloat(t[1], 10) === 6
    }(), e.fn.extend({
        disableSelection: function () {
            return this.bind((e.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function (e) {
                e.preventDefault()
            })
        }, enableSelection: function () {
            return this.unbind(".ui-disableSelection")
        }
    }), e.extend(e.ui, {
        plugin: {
            add: function (t, n, r) {
                var i, s = e.ui[t].prototype;
                for (i in r)s.plugins[i] = s.plugins[i] || [], s.plugins[i].push([n, r[i]])
            }, call: function (e, t, n) {
                var r, i = e.plugins[t];
                if (!i || !e.element[0].parentNode || e.element[0].parentNode.nodeType === 11)return;
                for (r = 0; r < i.length; r++)e.options[i[r][0]] && i[r][1].apply(e.element, n)
            }
        }, contains: e.contains, hasScroll: function (t, n) {
            if (e(t).css("overflow") === "hidden")return !1;
            var r = n && n === "left" ? "scrollLeft" : "scrollTop", i = !1;
            return t[r] > 0 ? !0 : (t[r] = 1, i = t[r] > 0, t[r] = 0, i)
        }, isOverAxis: function (e, t, n) {
            return e > t && e < t + n
        }, isOver: function (t, n, r, i, s, o) {
            return e.ui.isOverAxis(t, r, s) && e.ui.isOverAxis(n, i, o)
        }
    })
})(jQuery), function (e, t) {
    var n = 0, r = Array.prototype.slice, i = e.cleanData;
    e.cleanData = function (t) {
        for (var n = 0, r; (r = t[n]) != null; n++)try {
            e(r).triggerHandler("remove")
        } catch (s) {
        }
        i(t)
    }, e.widget = function (t, n, r) {
        var i, s, o, u, a = t.split(".")[0];
        t = t.split(".")[1], i = a + "-" + t, r || (r = n, n = e.Widget), e.expr[":"][i.toLowerCase()] = function (t) {
            return !!e.data(t, i)
        }, e[a] = e[a] || {}, s = e[a][t], o = e[a][t] = function (e, t) {
            if (!this._createWidget)return new o(e, t);
            arguments.length && this._createWidget(e, t)
        }, e.extend(o, s, {
            version: r.version,
            _proto: e.extend({}, r),
            _childConstructors: []
        }), u = new n, u.options = e.widget.extend({}, u.options), e.each(r, function (t, i) {
            e.isFunction(i) && (r[t] = function () {
                var e = function () {
                    return n.prototype[t].apply(this, arguments)
                }, r = function (e) {
                    return n.prototype[t].apply(this, e)
                };
                return function () {
                    var t = this._super, n = this._superApply, s;
                    return this._super = e, this._superApply = r, s = i.apply(this, arguments), this._super = t, this._superApply = n, s
                }
            }())
        }), o.prototype = e.widget.extend(u, {widgetEventPrefix: u.widgetEventPrefix || t}, r, {
            constructor: o,
            namespace: a,
            widgetName: t,
            widgetBaseClass: i,
            widgetFullName: i
        }), s ? (e.each(s._childConstructors, function (t, n) {
            var r = n.prototype;
            e.widget(r.namespace + "." + r.widgetName, o, n._proto)
        }), delete s._childConstructors) : n._childConstructors.push(o), e.widget.bridge(t, o)
    }, e.widget.extend = function (n) {
        var i = r.call(arguments, 1), s = 0, o = i.length, u, a;
        for (; s < o; s++)for (u in i[s])a = i[s][u], i[s].hasOwnProperty(u) && a !== t && (e.isPlainObject(a) ? n[u] = e.isPlainObject(n[u]) ? e.widget.extend({}, n[u], a) : e.widget.extend({}, a) : n[u] = a);
        return n
    }, e.widget.bridge = function (n, i) {
        var s = i.prototype.widgetFullName;
        e.fn[n] = function (o) {
            var u = typeof o == "string", a = r.call(arguments, 1), f = this;
            return o = !u && a.length ? e.widget.extend.apply(null, [o].concat(a)) : o, u ? this.each(function () {
                var r, i = e.data(this, s);
                if (!i)return e.error("cannot call methods on " + n + " prior to initialization; " + "attempted to call method '" + o + "'");
                if (!e.isFunction(i[o]) || o.charAt(0) === "_")return e.error("no such method '" + o + "' for " + n + " widget instance");
                r = i[o].apply(i, a);
                if (r !== i && r !== t)return f = r && r.jquery ? f.pushStack(r.get()) : r, !1
            }) : this.each(function () {
                var t = e.data(this, s);
                t ? t.option(o || {})._init() : new i(o, this)
            }), f
        }
    }, e.Widget = function () {
    }, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {disabled: !1, create: null},
        _createWidget: function (t, r) {
            r = e(r || this.defaultElement || this)[0], this.element = e(r), this.uuid = n++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this.bindings = e(), this.hoverable = e(), this.focusable = e(), r !== this && (e.data(r, this.widgetName, this), e.data(r, this.widgetFullName, this), this._on(this.element, {
                remove: function (e) {
                    e.target === r && this.destroy()
                }
            }), this.document = e(r.style ? r.ownerDocument : r.document || r), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init()
        },
        _getCreateOptions: e.noop,
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function () {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")
        },
        _destroy: e.noop,
        widget: function () {
            return this.element
        },
        option: function (n, r) {
            var i = n, s, o, u;
            if (arguments.length === 0)return e.widget.extend({}, this.options);
            if (typeof n == "string") {
                i = {}, s = n.split("."), n = s.shift();
                if (s.length) {
                    o = i[n] = e.widget.extend({}, this.options[n]);
                    for (u = 0; u < s.length - 1; u++)o[s[u]] = o[s[u]] || {}, o = o[s[u]];
                    n = s.pop();
                    if (r === t)return o[n] === t ? null : o[n];
                    o[n] = r
                } else {
                    if (r === t)return this.options[n] === t ? null : this.options[n];
                    i[n] = r
                }
            }
            return this._setOptions(i), this
        },
        _setOptions: function (e) {
            var t;
            for (t in e)this._setOption(t, e[t]);
            return this
        },
        _setOption: function (e, t) {
            return this.options[e] = t, e === "disabled" && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!t).attr("aria-disabled", t), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), this
        },
        enable: function () {
            return this._setOption("disabled", !1)
        },
        disable: function () {
            return this._setOption("disabled", !0)
        },
        _on: function (t, n) {
            var r, i = this;
            n ? (t = r = e(t), this.bindings = this.bindings.add(t)) : (n = t, t = this.element, r = this.widget()), e.each(n, function (n, s) {
                function o() {
                    if (i.options.disabled === !0 || e(this).hasClass("ui-state-disabled"))return;
                    return (typeof s == "string" ? i[s] : s).apply(i, arguments)
                }

                typeof s != "string" && (o.guid = s.guid = s.guid || o.guid || e.guid++);
                var u = n.match(/^(\w+)\s*(.*)$/), a = u[1] + i.eventNamespace, f = u[2];
                f ? r.delegate(f, a, o) : t.bind(a, o)
            })
        },
        _off: function (e, t) {
            t = (t || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.unbind(t).undelegate(t)
        },
        _delay: function (e, t) {
            function n() {
                return (typeof e == "string" ? r[e] : e).apply(r, arguments)
            }

            var r = this;
            return setTimeout(n, t || 0)
        },
        _hoverable: function (t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function (t) {
                    e(t.currentTarget).addClass("ui-state-hover")
                }, mouseleave: function (t) {
                    e(t.currentTarget).removeClass("ui-state-hover")
                }
            })
        },
        _focusable: function (t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function (t) {
                    e(t.currentTarget).addClass("ui-state-focus")
                }, focusout: function (t) {
                    e(t.currentTarget).removeClass("ui-state-focus")
                }
            })
        },
        _trigger: function (t, n, r) {
            var i, s, o = this.options[t];
            r = r || {}, n = e.Event(n), n.type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), n.target = this.element[0], s = n.originalEvent;
            if (s)for (i in s)i in n || (n[i] = s[i]);
            return this.element.trigger(n, r), !(e.isFunction(o) && o.apply(this.element[0], [n].concat(r)) === !1 || n.isDefaultPrevented())
        }
    }, e.each({show: "fadeIn", hide: "fadeOut"}, function (t, n) {
        e.Widget.prototype["_" + t] = function (r, i, s) {
            typeof i == "string" && (i = {effect: i});
            var o, u = i ? i === !0 || typeof i == "number" ? n : i.effect || n : t;
            i = i || {}, typeof i == "number" && (i = {duration: i}), o = !e.isEmptyObject(i), i.complete = s, i.delay && r.delay(i.delay), o && e.effects && (e.effects.effect[u] || e.uiBackCompat !== !1 && e.effects[u]) ? r[t](i) : u !== t && r[u] ? r[u](i.duration, i.easing, s) : r.queue(function (n) {
                e(this)[t](), s && s.call(r[0]), n()
            })
        }
    }), e.uiBackCompat !== !1 && (e.Widget.prototype._getCreateOptions = function () {
        return e.metadata && e.metadata.get(this.element[0])[this.widgetName]
    })
}(jQuery), function (e, t) {
    var n = !1;
    e(document).mouseup(function (e) {
        n = !1
    }), e.widget("ui.mouse", {
        version: "1.9.1",
        options: {cancel: "input,textarea,button,select,option", distance: 1, delay: 0},
        _mouseInit: function () {
            var t = this;
            this.element.bind("mousedown." + this.widgetName, function (e) {
                return t._mouseDown(e)
            }).bind("click." + this.widgetName, function (n) {
                if (!0 === e.data(n.target, t.widgetName + ".preventClickEvent"))return e.removeData(n.target, t.widgetName + ".preventClickEvent"), n.stopImmediatePropagation(), !1
            }), this.started = !1
        },
        _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && e(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate)
        },
        _mouseDown: function (t) {
            if (n)return;
            this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
            var r = this, i = t.which === 1, s = typeof this.options.cancel == "string" && t.target.nodeName ? e(t.target).closest(this.options.cancel).length : !1;
            if (!i || s || !this._mouseCapture(t))return !0;
            this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
                r.mouseDelayMet = !0
            }, this.options.delay));
            if (this._mouseDistanceMet(t) && this._mouseDelayMet(t)) {
                this._mouseStarted = this._mouseStart(t) !== !1;
                if (!this._mouseStarted)return t.preventDefault(), !0
            }
            return !0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (e) {
                return r._mouseMove(e)
            }, this._mouseUpDelegate = function (e) {
                return r._mouseUp(e)
            }, e(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), n = !0, !0
        },
        _mouseMove: function (t) {
            return !e.ui.ie || document.documentMode >= 9 || !!t.button ? this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, t) !== !1, this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted) : this._mouseUp(t)
        },
        _mouseUp: function (t) {
            return e(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), !1
        },
        _mouseDistanceMet: function (e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance
        },
        _mouseDelayMet: function (e) {
            return this.mouseDelayMet
        },
        _mouseStart: function (e) {
        },
        _mouseDrag: function (e) {
        },
        _mouseStop: function (e) {
        },
        _mouseCapture: function (e) {
            return !0
        }
    })
}(jQuery), function (e, t) {
    e.widget("ui.draggable", e.ui.mouse, {
        version: "1.9.1",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1
        },
        _create: function () {
            this.options.helper == "original" && !/^(?:r|a|f)/.test(this.element.css("position")) && (this.element[0].style.position = "relative"), this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._mouseInit()
        },
        _destroy: function () {
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), this._mouseDestroy()
        },
        _mouseCapture: function (t) {
            var n = this.options;
            return this.helper || n.disabled || e(t.target).is(".ui-resizable-handle") ? !1 : (this.handle = this._getHandle(t), this.handle ? (e(n.iframeFix === !0 ? "iframe" : n.iframeFix).each(function () {
                e('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({
                    width: this.offsetWidth + "px",
                    height: this.offsetHeight + "px",
                    position: "absolute",
                    opacity: "0.001",
                    zIndex: 1e3
                }).css(e(this).offset()).appendTo("body")
            }), !0) : !1)
        },
        _mouseStart: function (t) {
            var n = this.options;
            return this.helper = this._createHelper(t), this.helper.addClass("ui-draggable-dragging"), this._cacheHelperProportions(), e.ui.ddmanager && (e.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(), this.offset = this.positionAbs = this.element.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, e.extend(this.offset, {
                click: {left: t.pageX - this.offset.left, top: t.pageY - this.offset.top},
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.originalPosition = this.position = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, n.cursorAt && this._adjustOffsetFromHelper(n.cursorAt), n.containment && this._setContainment(), this._trigger("start", t) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this._mouseDrag(t, !0), e.ui.ddmanager && e.ui.ddmanager.dragStart(this, t), !0)
        },
        _mouseDrag: function (t, n) {
            this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute");
            if (!n) {
                var r = this._uiHash();
                if (this._trigger("drag", t, r) === !1)return this._mouseUp({}), !1;
                this.position = r.position
            }
            if (!this.options.axis || this.options.axis != "y")this.helper[0].style.left = this.position.left + "px";
            if (!this.options.axis || this.options.axis != "x")this.helper[0].style.top = this.position.top + "px";
            return e.ui.ddmanager && e.ui.ddmanager.drag(this, t), !1
        },
        _mouseStop: function (t) {
            var n = !1;
            e.ui.ddmanager && !this.options.dropBehaviour && (n = e.ui.ddmanager.drop(this, t)), this.dropped && (n = this.dropped, this.dropped = !1);
            var r = this.element[0], i = !1;
            while (r && (r = r.parentNode))r == document && (i = !0);
            if (!i && this.options.helper === "original")return !1;
            if (this.options.revert == "invalid" && !n || this.options.revert == "valid" && n || this.options.revert === !0 || e.isFunction(this.options.revert) && this.options.revert.call(this.element, n)) {
                var s = this;
                e(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                    s._trigger("stop", t) !== !1 && s._clear()
                })
            } else this._trigger("stop", t) !== !1 && this._clear();
            return !1
        },
        _mouseUp: function (t) {
            return e("div.ui-draggable-iframeFix").each(function () {
                this.parentNode.removeChild(this)
            }), e.ui.ddmanager && e.ui.ddmanager.dragStop(this, t), e.ui.mouse.prototype._mouseUp.call(this, t)
        },
        cancel: function () {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), this
        },
        _getHandle: function (t) {
            var n = !this.options.handle || !e(this.options.handle, this.element).length ? !0 : !1;
            return e(this.options.handle, this.element).find("*").andSelf().each(function () {
                this == t.target && (n = !0)
            }), n
        },
        _createHelper: function (t) {
            var n = this.options, r = e.isFunction(n.helper) ? e(n.helper.apply(this.element[0], [t])) : n.helper == "clone" ? this.element.clone().removeAttr("id") : this.element;
            return r.parents("body").length || r.appendTo(n.appendTo == "parent" ? this.element[0].parentNode : n.appendTo), r[0] != this.element[0] && !/(fixed|absolute)/.test(r.css("position")) && r.css("position", "absolute"), r
        },
        _adjustOffsetFromHelper: function (t) {
            typeof t == "string" && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left"in t && (this.offset.click.left = t.left + this.margins.left), "right"in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top"in t && (this.offset.click.top = t.top + this.margins.top), "bottom"in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
        },
        _getParentOffset: function () {
            this.offsetParent = this.helper.offsetParent();
            var t = this.offsetParent.offset();
            this.cssPosition == "absolute" && this.scrollParent[0] != document && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop());
            if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && e.ui.ie)t = {
                top: 0,
                left: 0
            };
            return {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function () {
            if (this.cssPosition == "relative") {
                var e = this.element.position();
                return {
                    top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                }
            }
            return {top: 0, left: 0}
        },
        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            }
        },
        _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
            var t = this.options;
            t.containment == "parent" && (t.containment = this.helper[0].parentNode);
            if (t.containment == "document" || t.containment == "window")this.containment = [t.containment == "document" ? 0 : e(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, t.containment == "document" ? 0 : e(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, (t.containment == "document" ? 0 : e(window).scrollLeft()) + e(t.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (t.containment == "document" ? 0 : e(window).scrollTop()) + (e(t.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
            if (!/^(document|window|parent)$/.test(t.containment) && t.containment.constructor != Array) {
                var n = e(t.containment), r = n[0];
                if (!r)return;
                var i = n.offset(), s = e(r).css("overflow") != "hidden";
                this.containment = [(parseInt(e(r).css("borderLeftWidth"), 10) || 0) + (parseInt(e(r).css("paddingLeft"), 10) || 0), (parseInt(e(r).css("borderTopWidth"), 10) || 0) + (parseInt(e(r).css("paddingTop"), 10) || 0), (s ? Math.max(r.scrollWidth, r.offsetWidth) : r.offsetWidth) - (parseInt(e(r).css("borderLeftWidth"), 10) || 0) - (parseInt(e(r).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (s ? Math.max(r.scrollHeight, r.offsetHeight) : r.offsetHeight) - (parseInt(e(r).css("borderTopWidth"), 10) || 0) - (parseInt(e(r).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relative_container = n
            } else t.containment.constructor == Array && (this.containment = t.containment)
        },
        _convertPositionTo: function (t, n) {
            n || (n = this.position);
            var r = t == "absolute" ? 1 : -1, i = this.options, s = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, o = /(html|body)/i.test(s[0].tagName);
            return {
                top: n.top + this.offset.relative.top * r + this.offset.parent.top * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : o ? 0 : s.scrollTop()) * r,
                left: n.left + this.offset.relative.left * r + this.offset.parent.left * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : o ? 0 : s.scrollLeft()) * r
            }
        },
        _generatePosition: function (t) {
            var n = this.options, r = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, i = /(html|body)/i.test(r[0].tagName), s = t.pageX, o = t.pageY;
            if (this.originalPosition) {
                var u;
                if (this.containment) {
                    if (this.relative_container) {
                        var a = this.relative_container.offset();
                        u = [this.containment[0] + a.left, this.containment[1] + a.top, this.containment[2] + a.left, this.containment[3] + a.top]
                    } else u = this.containment;
                    t.pageX - this.offset.click.left < u[0] && (s = u[0] + this.offset.click.left), t.pageY - this.offset.click.top < u[1] && (o = u[1] + this.offset.click.top), t.pageX - this.offset.click.left > u[2] && (s = u[2] + this.offset.click.left), t.pageY - this.offset.click.top > u[3] && (o = u[3] + this.offset.click.top)
                }
                if (n.grid) {
                    var f = n.grid[1] ? this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1] : this.originalPageY;
                    o = u ? f - this.offset.click.top < u[1] || f - this.offset.click.top > u[3] ? f - this.offset.click.top < u[1] ? f + n.grid[1] : f - n.grid[1] : f : f;
                    var l = n.grid[0] ? this.originalPageX + Math.round((s - this.originalPageX) / n.grid[0]) * n.grid[0] : this.originalPageX;
                    s = u ? l - this.offset.click.left < u[0] || l - this.offset.click.left > u[2] ? l - this.offset.click.left < u[0] ? l + n.grid[0] : l - n.grid[0] : l : l
                }
            }
            return {
                top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : i ? 0 : r.scrollTop()),
                left: s - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : i ? 0 : r.scrollLeft())
            }
        },
        _clear: function () {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] != this.element[0] && !this.cancelHelperRemoval && this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1
        },
        _trigger: function (t, n, r) {
            return r = r || this._uiHash(), e.ui.plugin.call(this, t, [n, r]), t == "drag" && (this.positionAbs = this._convertPositionTo("absolute")), e.Widget.prototype._trigger.call(this, t, n, r)
        },
        plugins: {},
        _uiHash: function (e) {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            }
        }
    }), e.ui.plugin.add("draggable", "connectToSortable", {
        start: function (t, n) {
            var r = e(this).data("draggable"), i = r.options, s = e.extend({}, n, {item: r.element});
            r.sortables = [], e(i.connectToSortable).each(function () {
                var n = e.data(this, "sortable");
                n && !n.options.disabled && (r.sortables.push({
                    instance: n,
                    shouldRevert: n.options.revert
                }), n.refreshPositions(), n._trigger("activate", t, s))
            })
        }, stop: function (t, n) {
            var r = e(this).data("draggable"), i = e.extend({}, n, {item: r.element});
            e.each(r.sortables, function () {
                this.instance.isOver ? (this.instance.isOver = 0, r.cancelHelperRemoval = !0, this.instance.cancelHelperRemoval = !1, this.shouldRevert && (this.instance.options.revert = !0), this.instance._mouseStop(t), this.instance.options.helper = this.instance.options._helper, r.options.helper == "original" && this.instance.currentItem.css({
                    top: "auto",
                    left: "auto"
                })) : (this.instance.cancelHelperRemoval = !1, this.instance._trigger("deactivate", t, i))
            })
        }, drag: function (t, n) {
            var r = e(this).data("draggable"), i = this, s = function (t) {
                var n = this.offset.click.top, r = this.offset.click.left, i = this.positionAbs.top, s = this.positionAbs.left, o = t.height, u = t.width, a = t.top, f = t.left;
                return e.ui.isOver(i + n, s + r, a, f, o, u)
            };
            e.each(r.sortables, function (s) {
                var o = !1, u = this;
                this.instance.positionAbs = r.positionAbs, this.instance.helperProportions = r.helperProportions, this.instance.offset.click = r.offset.click, this.instance._intersectsWith(this.instance.containerCache) && (o = !0, e.each(r.sortables, function () {
                    return this.instance.positionAbs = r.positionAbs, this.instance.helperProportions = r.helperProportions, this.instance.offset.click = r.offset.click, this != u && this.instance._intersectsWith(this.instance.containerCache) && e.ui.contains(u.instance.element[0], this.instance.element[0]) && (o = !1), o
                })), o ? (this.instance.isOver || (this.instance.isOver = 1, this.instance.currentItem = e(i).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item", !0), this.instance.options._helper = this.instance.options.helper, this.instance.options.helper = function () {
                    return n.helper[0]
                }, t.target = this.instance.currentItem[0], this.instance._mouseCapture(t, !0), this.instance._mouseStart(t, !0, !0), this.instance.offset.click.top = r.offset.click.top, this.instance.offset.click.left = r.offset.click.left, this.instance.offset.parent.left -= r.offset.parent.left - this.instance.offset.parent.left, this.instance.offset.parent.top -= r.offset.parent.top - this.instance.offset.parent.top, r._trigger("toSortable", t), r.dropped = this.instance.element, r.currentItem = r.element, this.instance.fromOutside = r), this.instance.currentItem && this.instance._mouseDrag(t)) : this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, this.instance.options.revert = !1, this.instance._trigger("out", t, this.instance._uiHash(this.instance)), this.instance._mouseStop(t, !0), this.instance.options.helper = this.instance.options._helper, this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), r._trigger("fromSortable", t), r.dropped = !1)
            })
        }
    }), e.ui.plugin.add("draggable", "cursor", {
        start: function (t, n) {
            var r = e("body"), i = e(this).data("draggable").options;
            r.css("cursor") && (i._cursor = r.css("cursor")), r.css("cursor", i.cursor)
        }, stop: function (t, n) {
            var r = e(this).data("draggable").options;
            r._cursor && e("body").css("cursor", r._cursor)
        }
    }), e.ui.plugin.add("draggable", "opacity", {
        start: function (t, n) {
            var r = e(n.helper), i = e(this).data("draggable").options;
            r.css("opacity") && (i._opacity = r.css("opacity")), r.css("opacity", i.opacity)
        }, stop: function (t, n) {
            var r = e(this).data("draggable").options;
            r._opacity && e(n.helper).css("opacity", r._opacity)
        }
    }), e.ui.plugin.add("draggable", "scroll", {
        start: function (t, n) {
            var r = e(this).data("draggable");
            r.scrollParent[0] != document && r.scrollParent[0].tagName != "HTML" && (r.overflowOffset = r.scrollParent.offset())
        }, drag: function (t, n) {
            var r = e(this).data("draggable"), i = r.options, s = !1;
            if (r.scrollParent[0] != document && r.scrollParent[0].tagName != "HTML") {
                if (!i.axis || i.axis != "x")r.overflowOffset.top + r.scrollParent[0].offsetHeight - t.pageY < i.scrollSensitivity ? r.scrollParent[0].scrollTop = s = r.scrollParent[0].scrollTop + i.scrollSpeed : t.pageY - r.overflowOffset.top < i.scrollSensitivity && (r.scrollParent[0].scrollTop = s = r.scrollParent[0].scrollTop - i.scrollSpeed);
                if (!i.axis || i.axis != "y")r.overflowOffset.left + r.scrollParent[0].offsetWidth - t.pageX < i.scrollSensitivity ? r.scrollParent[0].scrollLeft = s = r.scrollParent[0].scrollLeft + i.scrollSpeed : t.pageX - r.overflowOffset.left < i.scrollSensitivity && (r.scrollParent[0].scrollLeft = s = r.scrollParent[0].scrollLeft - i.scrollSpeed)
            } else {
                if (!i.axis || i.axis != "x")t.pageY - e(document).scrollTop() < i.scrollSensitivity ? s = e(document).scrollTop(e(document).scrollTop() - i.scrollSpeed) : e(window).height() - (t.pageY - e(document).scrollTop()) < i.scrollSensitivity && (s = e(document).scrollTop(e(document).scrollTop() + i.scrollSpeed));
                if (!i.axis || i.axis != "y")t.pageX - e(document).scrollLeft() < i.scrollSensitivity ? s = e(document).scrollLeft(e(document).scrollLeft() - i.scrollSpeed) : e(window).width() - (t.pageX - e(document).scrollLeft()) < i.scrollSensitivity && (s = e(document).scrollLeft(e(document).scrollLeft() + i.scrollSpeed))
            }
            s !== !1 && e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(r, t)
        }
    }), e.ui.plugin.add("draggable", "snap", {
        start: function (t, n) {
            var r = e(this).data("draggable"), i = r.options;
            r.snapElements = [], e(i.snap.constructor != String ? i.snap.items || ":data(draggable)" : i.snap).each(function () {
                var t = e(this), n = t.offset();
                this != r.element[0] && r.snapElements.push({
                    item: this,
                    width: t.outerWidth(),
                    height: t.outerHeight(),
                    top: n.top,
                    left: n.left
                })
            })
        }, drag: function (t, n) {
            var r = e(this).data("draggable"), i = r.options, s = i.snapTolerance, o = n.offset.left, u = o + r.helperProportions.width, a = n.offset.top, f = a + r.helperProportions.height;
            for (var l = r.snapElements.length - 1; l >= 0; l--) {
                var c = r.snapElements[l].left, h = c + r.snapElements[l].width, p = r.snapElements[l].top, d = p + r.snapElements[l].height;
                if (!(c - s < o && o < h + s && p - s < a && a < d + s || c - s < o && o < h + s && p - s < f && f < d + s || c - s < u && u < h + s && p - s < a && a < d + s || c - s < u && u < h + s && p - s < f && f < d + s)) {
                    r.snapElements[l].snapping && r.options.snap.release && r.options.snap.release.call(r.element, t, e.extend(r._uiHash(), {snapItem: r.snapElements[l].item})), r.snapElements[l].snapping = !1;
                    continue
                }
                if (i.snapMode != "inner") {
                    var v = Math.abs(p - f) <= s, m = Math.abs(d - a) <= s, g = Math.abs(c - u) <= s, y = Math.abs(h - o) <= s;
                    v && (n.position.top = r._convertPositionTo("relative", {
                            top: p - r.helperProportions.height,
                            left: 0
                        }).top - r.margins.top), m && (n.position.top = r._convertPositionTo("relative", {
                            top: d,
                            left: 0
                        }).top - r.margins.top), g && (n.position.left = r._convertPositionTo("relative", {
                            top: 0,
                            left: c - r.helperProportions.width
                        }).left - r.margins.left), y && (n.position.left = r._convertPositionTo("relative", {
                            top: 0,
                            left: h
                        }).left - r.margins.left)
                }
                var b = v || m || g || y;
                if (i.snapMode != "outer") {
                    var v = Math.abs(p - a) <= s, m = Math.abs(d - f) <= s, g = Math.abs(c - o) <= s, y = Math.abs(h - u) <= s;
                    v && (n.position.top = r._convertPositionTo("relative", {
                            top: p,
                            left: 0
                        }).top - r.margins.top), m && (n.position.top = r._convertPositionTo("relative", {
                            top: d - r.helperProportions.height,
                            left: 0
                        }).top - r.margins.top), g && (n.position.left = r._convertPositionTo("relative", {
                            top: 0,
                            left: c
                        }).left - r.margins.left), y && (n.position.left = r._convertPositionTo("relative", {
                            top: 0,
                            left: h - r.helperProportions.width
                        }).left - r.margins.left)
                }
                !r.snapElements[l].snapping && (v || m || g || y || b) && r.options.snap.snap && r.options.snap.snap.call(r.element, t, e.extend(r._uiHash(), {snapItem: r.snapElements[l].item})), r.snapElements[l].snapping = v || m || g || y || b
            }
        }
    }), e.ui.plugin.add("draggable", "stack", {
        start: function (t, n) {
            var r = e(this).data("draggable").options, i = e.makeArray(e(r.stack)).sort(function (t, n) {
                return (parseInt(e(t).css("zIndex"), 10) || 0) - (parseInt(e(n).css("zIndex"), 10) || 0)
            });
            if (!i.length)return;
            var s = parseInt(i[0].style.zIndex) || 0;
            e(i).each(function (e) {
                this.style.zIndex = s + e
            }), this[0].style.zIndex = s + i.length
        }
    }), e.ui.plugin.add("draggable", "zIndex", {
        start: function (t, n) {
            var r = e(n.helper), i = e(this).data("draggable").options;
            r.css("zIndex") && (i._zIndex = r.css("zIndex")), r.css("zIndex", i.zIndex)
        }, stop: function (t, n) {
            var r = e(this).data("draggable").options;
            r._zIndex && e(n.helper).css("zIndex", r._zIndex)
        }
    })
}(jQuery), function (e, t) {
    e.widget("ui.droppable", {
        version: "1.9.1",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect"
        },
        _create: function () {
            var t = this.options, n = t.accept;
            this.isover = 0, this.isout = 1, this.accept = e.isFunction(n) ? n : function (e) {
                return e.is(n)
            }, this.proportions = {
                width: this.element[0].offsetWidth,
                height: this.element[0].offsetHeight
            }, e.ui.ddmanager.droppables[t.scope] = e.ui.ddmanager.droppables[t.scope] || [], e.ui.ddmanager.droppables[t.scope].push(this), t.addClasses && this.element.addClass("ui-droppable")
        },
        _destroy: function () {
            var t = e.ui.ddmanager.droppables[this.options.scope];
            for (var n = 0; n < t.length; n++)t[n] == this && t.splice(n, 1);
            this.element.removeClass("ui-droppable ui-droppable-disabled")
        },
        _setOption: function (t, n) {
            t == "accept" && (this.accept = e.isFunction(n) ? n : function (e) {
                return e.is(n)
            }), e.Widget.prototype._setOption.apply(this, arguments)
        },
        _activate: function (t) {
            var n = e.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), n && this._trigger("activate", t, this.ui(n))
        },
        _deactivate: function (t) {
            var n = e.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass), n && this._trigger("deactivate", t, this.ui(n))
        },
        _over: function (t) {
            var n = e.ui.ddmanager.current;
            if (!n || (n.currentItem || n.element)[0] == this.element[0])return;
            this.accept.call(this.element[0], n.currentItem || n.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), this._trigger("over", t, this.ui(n)))
        },
        _out: function (t) {
            var n = e.ui.ddmanager.current;
            if (!n || (n.currentItem || n.element)[0] == this.element[0])return;
            this.accept.call(this.element[0], n.currentItem || n.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("out", t, this.ui(n)))
        },
        _drop: function (t, n) {
            var r = n || e.ui.ddmanager.current;
            if (!r || (r.currentItem || r.element)[0] == this.element[0])return !1;
            var i = !1;
            return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function () {
                var t = e.data(this, "droppable");
                if (t.options.greedy && !t.options.disabled && t.options.scope == r.options.scope && t.accept.call(t.element[0], r.currentItem || r.element) && e.ui.intersect(r, e.extend(t, {offset: t.element.offset()}), t.options.tolerance))return i = !0, !1
            }), i ? !1 : this.accept.call(this.element[0], r.currentItem || r.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", t, this.ui(r)), this.element) : !1
        },
        ui: function (e) {
            return {
                draggable: e.currentItem || e.element,
                helper: e.helper,
                position: e.position,
                offset: e.positionAbs
            }
        }
    }), e.ui.intersect = function (t, n, r) {
        if (!n.offset)return !1;
        var i = (t.positionAbs || t.position.absolute).left, s = i + t.helperProportions.width, o = (t.positionAbs || t.position.absolute).top, u = o + t.helperProportions.height, a = n.offset.left, f = a + n.proportions.width, l = n.offset.top, c = l + n.proportions.height;
        switch (r) {
            case"fit":
                return a <= i && s <= f && l <= o && u <= c;
            case"intersect":
                return a < i + t.helperProportions.width / 2 && s - t.helperProportions.width / 2 < f && l < o + t.helperProportions.height / 2 && u - t.helperProportions.height / 2 < c;
            case"pointer":
                var h = (t.positionAbs || t.position.absolute).left + (t.clickOffset || t.offset.click).left, p = (t.positionAbs || t.position.absolute).top + (t.clickOffset || t.offset.click).top, d = e.ui.isOver(p, h, l, a, n.proportions.height, n.proportions.width);
                return d;
            case"touch":
                return (o >= l && o <= c || u >= l && u <= c || o < l && u > c) && (i >= a && i <= f || s >= a && s <= f || i < a && s > f);
            default:
                return !1
        }
    }, e.ui.ddmanager = {
        current: null, droppables: {"default": []}, prepareOffsets: function (t, n) {
            var r = e.ui.ddmanager.droppables[t.options.scope] || [], i = n ? n.type : null, s = (t.currentItem || t.element).find(":data(droppable)").andSelf();
            e:for (var o = 0; o < r.length; o++) {
                if (r[o].options.disabled || t && !r[o].accept.call(r[o].element[0], t.currentItem || t.element))continue;
                for (var u = 0; u < s.length; u++)if (s[u] == r[o].element[0]) {
                    r[o].proportions.height = 0;
                    continue e
                }
                r[o].visible = r[o].element.css("display") != "none";
                if (!r[o].visible)continue;
                i == "mousedown" && r[o]._activate.call(r[o], n), r[o].offset = r[o].element.offset(), r[o].proportions = {
                    width: r[o].element[0].offsetWidth,
                    height: r[o].element[0].offsetHeight
                }
            }
        }, drop: function (t, n) {
            var r = !1;
            return e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function () {
                if (!this.options)return;
                !this.options.disabled && this.visible && e.ui.intersect(t, this, this.options.tolerance) && (r = this._drop.call(this, n) || r), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = 1, this.isover = 0, this._deactivate.call(this, n))
            }), r
        }, dragStart: function (t, n) {
            t.element.parentsUntil("body").bind("scroll.droppable", function () {
                t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, n)
            })
        }, drag: function (t, n) {
            t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, n), e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function () {
                if (this.options.disabled || this.greedyChild || !this.visible)return;
                var r = e.ui.intersect(t, this, this.options.tolerance), i = !r && this.isover == 1 ? "isout" : r && this.isover == 0 ? "isover" : null;
                if (!i)return;
                var s;
                if (this.options.greedy) {
                    var o = this.options.scope, u = this.element.parents(":data(droppable)").filter(function () {
                        return e.data(this, "droppable").options.scope === o
                    });
                    u.length && (s = e.data(u[0], "droppable"), s.greedyChild = i == "isover" ? 1 : 0)
                }
                s && i == "isover" && (s.isover = 0, s.isout = 1, s._out.call(s, n)), this[i] = 1, this[i == "isout" ? "isover" : "isout"] = 0, this[i == "isover" ? "_over" : "_out"].call(this, n), s && i == "isout" && (s.isout = 0, s.isover = 1, s._over.call(s, n))
            })
        }, dragStop: function (t, n) {
            t.element.parentsUntil("body").unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, n)
        }
    }
}(jQuery), function (e, t) {
    e.widget("ui.resizable", e.ui.mouse, {
        version: "1.9.1",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 1e3
        },
        _create: function () {
            var t = this, n = this.options;
            this.element.addClass("ui-resizable"), e.extend(this, {
                _aspectRatio: !!n.aspectRatio,
                aspectRatio: n.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: n.helper || n.ghost || n.animate ? n.helper || "ui-resizable-helper" : null
            }), this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i) && (this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
                position: this.element.css("position"),
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                top: this.element.css("top"),
                left: this.element.css("left")
            })), this.element = this.element.parent().data("resizable", this.element.data("resizable")), this.elementIsWrapper = !0, this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
                position: "static",
                zoom: 1,
                display: "block"
            })), this.originalElement.css({margin: this.originalElement.css("margin")}), this._proportionallyResize()), this.handles = n.handles || (e(".ui-resizable-handle", this.element).length ? {
                    n: ".ui-resizable-n",
                    e: ".ui-resizable-e",
                    s: ".ui-resizable-s",
                    w: ".ui-resizable-w",
                    se: ".ui-resizable-se",
                    sw: ".ui-resizable-sw",
                    ne: ".ui-resizable-ne",
                    nw: ".ui-resizable-nw"
                } : "e,s,se");
            if (this.handles.constructor == String) {
                this.handles == "all" && (this.handles = "n,e,s,w,se,sw,ne,nw");
                var r = this.handles.split(",");
                this.handles = {};
                for (var i = 0; i < r.length; i++) {
                    var s = e.trim(r[i]), o = "ui-resizable-" + s, u = e('<div class="ui-resizable-handle ' + o + '"></div>');
                    u.css({zIndex: n.zIndex}), "se" == s && u.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[s] = ".ui-resizable-" + s, this.element.append(u)
                }
            }
            this._renderAxis = function (t) {
                t = t || this.element;
                for (var n in this.handles) {
                    this.handles[n].constructor == String && (this.handles[n] = e(this.handles[n], this.element).show());
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
                        var r = e(this.handles[n], this.element), i = 0;
                        i = /sw|ne|nw|se|n|s/.test(n) ? r.outerHeight() : r.outerWidth();
                        var s = ["padding", /ne|nw|n/.test(n) ? "Top" : /se|sw|s/.test(n) ? "Bottom" : /^e$/.test(n) ? "Right" : "Left"].join("");
                        t.css(s, i), this._proportionallyResize()
                    }
                    if (!e(this.handles[n]).length)continue
                }
            }, this._renderAxis(this.element), this._handles = e(".ui-resizable-handle", this.element).disableSelection(), this._handles.mouseover(function () {
                if (!t.resizing) {
                    if (this.className)var e = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    t.axis = e && e[1] ? e[1] : "se"
                }
            }), n.autoHide && (this._handles.hide(), e(this.element).addClass("ui-resizable-autohide").mouseenter(function () {
                if (n.disabled)return;
                e(this).removeClass("ui-resizable-autohide"), t._handles.show()
            }).mouseleave(function () {
                if (n.disabled)return;
                t.resizing || (e(this).addClass("ui-resizable-autohide"), t._handles.hide())
            })), this._mouseInit()
        },
        _destroy: function () {
            this._mouseDestroy();
            var t = function (t) {
                e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()
            };
            if (this.elementIsWrapper) {
                t(this.element);
                var n = this.element;
                this.originalElement.css({
                    position: n.css("position"),
                    width: n.outerWidth(),
                    height: n.outerHeight(),
                    top: n.css("top"),
                    left: n.css("left")
                }).insertAfter(n), n.remove()
            }
            return this.originalElement.css("resize", this.originalResizeStyle), t(this.originalElement), this
        },
        _mouseCapture: function (t) {
            var n = !1;
            for (var r in this.handles)e(this.handles[r])[0] == t.target && (n = !0);
            return !this.options.disabled && n
        },
        _mouseStart: function (t) {
            var r = this.options, i = this.element.position(), s = this.element;
            this.resizing = !0, this.documentScroll = {
                top: e(document).scrollTop(),
                left: e(document).scrollLeft()
            }, (s.is(".ui-draggable") || /absolute/.test(s.css("position"))) && s.css({
                position: "absolute",
                top: i.top,
                left: i.left
            }), this._renderProxy();
            var o = n(this.helper.css("left")), u = n(this.helper.css("top"));
            r.containment && (o += e(r.containment).scrollLeft() || 0, u += e(r.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
                left: o,
                top: u
            }, this.size = this._helper ? {width: s.outerWidth(), height: s.outerHeight()} : {
                width: s.width(),
                height: s.height()
            }, this.originalSize = this._helper ? {width: s.outerWidth(), height: s.outerHeight()} : {
                width: s.width(),
                height: s.height()
            }, this.originalPosition = {left: o, top: u}, this.sizeDiff = {
                width: s.outerWidth() - s.width(),
                height: s.outerHeight() - s.height()
            }, this.originalMousePosition = {
                left: t.pageX,
                top: t.pageY
            }, this.aspectRatio = typeof r.aspectRatio == "number" ? r.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
            var a = e(".ui-resizable-" + this.axis).css("cursor");
            return e("body").css("cursor", a == "auto" ? this.axis + "-resize" : a), s.addClass("ui-resizable-resizing"), this._propagate("start", t), !0
        },
        _mouseDrag: function (e) {
            var t = this.helper, n = this.options, r = {}, i = this, s = this.originalMousePosition, o = this.axis, u = e.pageX - s.left || 0, a = e.pageY - s.top || 0, f = this._change[o];
            if (!f)return !1;
            var l = f.apply(this, [e, u, a]);
            this._updateVirtualBoundaries(e.shiftKey);
            if (this._aspectRatio || e.shiftKey)l = this._updateRatio(l, e);
            return l = this._respectSize(l, e), this._propagate("resize", e), t.css({
                top: this.position.top + "px",
                left: this.position.left + "px",
                width: this.size.width + "px",
                height: this.size.height + "px"
            }), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), this._updateCache(l), this._trigger("resize", e, this.ui()), !1
        },
        _mouseStop: function (t) {
            this.resizing = !1;
            var n = this.options, r = this;
            if (this._helper) {
                var i = this._proportionallyResizeElements, s = i.length && /textarea/i.test(i[0].nodeName), o = s && e.ui.hasScroll(i[0], "left") ? 0 : r.sizeDiff.height, u = s ? 0 : r.sizeDiff.width, a = {
                    width: r.helper.width() - u,
                    height: r.helper.height() - o
                }, f = parseInt(r.element.css("left"), 10) + (r.position.left - r.originalPosition.left) || null, l = parseInt(r.element.css("top"), 10) + (r.position.top - r.originalPosition.top) || null;
                n.animate || this.element.css(e.extend(a, {
                    top: l,
                    left: f
                })), r.helper.height(r.size.height), r.helper.width(r.size.width), this._helper && !n.animate && this._proportionallyResize()
            }
            return e("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1
        },
        _updateVirtualBoundaries: function (e) {
            var t = this.options, n, i, s, o, u;
            u = {
                minWidth: r(t.minWidth) ? t.minWidth : 0,
                maxWidth: r(t.maxWidth) ? t.maxWidth : Infinity,
                minHeight: r(t.minHeight) ? t.minHeight : 0,
                maxHeight: r(t.maxHeight) ? t.maxHeight : Infinity
            };
            if (this._aspectRatio || e)n = u.minHeight * this.aspectRatio, s = u.minWidth / this.aspectRatio, i = u.maxHeight * this.aspectRatio, o = u.maxWidth / this.aspectRatio, n > u.minWidth && (u.minWidth = n), s > u.minHeight && (u.minHeight = s), i < u.maxWidth && (u.maxWidth = i), o < u.maxHeight && (u.maxHeight = o);
            this._vBoundaries = u
        },
        _updateCache: function (e) {
            var t = this.options;
            this.offset = this.helper.offset(), r(e.left) && (this.position.left = e.left), r(e.top) && (this.position.top = e.top), r(e.height) && (this.size.height = e.height), r(e.width) && (this.size.width = e.width)
        },
        _updateRatio: function (e, t) {
            var n = this.options, i = this.position, s = this.size, o = this.axis;
            return r(e.height) ? e.width = e.height * this.aspectRatio : r(e.width) && (e.height = e.width / this.aspectRatio), o == "sw" && (e.left = i.left + (s.width - e.width), e.top = null), o == "nw" && (e.top = i.top + (s.height - e.height), e.left = i.left + (s.width - e.width)), e
        },
        _respectSize: function (e, t) {
            var n = this.helper, i = this._vBoundaries, s = this._aspectRatio || t.shiftKey, o = this.axis, u = r(e.width) && i.maxWidth && i.maxWidth < e.width, a = r(e.height) && i.maxHeight && i.maxHeight < e.height, f = r(e.width) && i.minWidth && i.minWidth > e.width, l = r(e.height) && i.minHeight && i.minHeight > e.height;
            f && (e.width = i.minWidth), l && (e.height = i.minHeight), u && (e.width = i.maxWidth), a && (e.height = i.maxHeight);
            var c = this.originalPosition.left + this.originalSize.width, h = this.position.top + this.size.height, p = /sw|nw|w/.test(o), d = /nw|ne|n/.test(o);
            f && p && (e.left = c - i.minWidth), u && p && (e.left = c - i.maxWidth), l && d && (e.top = h - i.minHeight), a && d && (e.top = h - i.maxHeight);
            var v = !e.width && !e.height;
            return v && !e.left && e.top ? e.top = null : v && !e.top && e.left && (e.left = null), e
        },
        _proportionallyResize: function () {
            var t = this.options;
            if (!this._proportionallyResizeElements.length)return;
            var n = this.helper || this.element;
            for (var r = 0; r < this._proportionallyResizeElements.length; r++) {
                var i = this._proportionallyResizeElements[r];
                if (!this.borderDif) {
                    var s = [i.css("borderTopWidth"), i.css("borderRightWidth"), i.css("borderBottomWidth"), i.css("borderLeftWidth")], o = [i.css("paddingTop"), i.css("paddingRight"), i.css("paddingBottom"), i.css("paddingLeft")];
                    this.borderDif = e.map(s, function (e, t) {
                        var n = parseInt(e, 10) || 0, r = parseInt(o[t], 10) || 0;
                        return n + r
                    })
                }
                i.css({
                    height: n.height() - this.borderDif[0] - this.borderDif[2] || 0,
                    width: n.width() - this.borderDif[1] - this.borderDif[3] || 0
                })
            }
        },
        _renderProxy: function () {
            var t = this.element, n = this.options;
            this.elementOffset = t.offset();
            if (this._helper) {
                this.helper = this.helper || e('<div style="overflow:hidden;"></div>');
                var r = e.ui.ie6 ? 1 : 0, i = e.ui.ie6 ? 2 : -1;
                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() + i,
                    height: this.element.outerHeight() + i,
                    position: "absolute",
                    left: this.elementOffset.left - r + "px",
                    top: this.elementOffset.top - r + "px",
                    zIndex: ++n.zIndex
                }), this.helper.appendTo("body").disableSelection()
            } else this.helper = this.element
        },
        _change: {
            e: function (e, t, n) {
                return {width: this.originalSize.width + t}
            }, w: function (e, t, n) {
                var r = this.options, i = this.originalSize, s = this.originalPosition;
                return {left: s.left + t, width: i.width - t}
            }, n: function (e, t, n) {
                var r = this.options, i = this.originalSize, s = this.originalPosition;
                return {top: s.top + n, height: i.height - n}
            }, s: function (e, t, n) {
                return {height: this.originalSize.height + n}
            }, se: function (t, n, r) {
                return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, n, r]))
            }, sw: function (t, n, r) {
                return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, n, r]))
            }, ne: function (t, n, r) {
                return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, n, r]))
            }, nw: function (t, n, r) {
                return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, n, r]))
            }
        },
        _propagate: function (t, n) {
            e.ui.plugin.call(this, t, [n, this.ui()]), t != "resize" && this._trigger(t, n, this.ui())
        },
        plugins: {},
        ui: function () {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            }
        }
    }), e.ui.plugin.add("resizable", "alsoResize", {
        start: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = function (t) {
                e(t).each(function () {
                    var t = e(this);
                    t.data("resizable-alsoresize", {
                        width: parseInt(t.width(), 10),
                        height: parseInt(t.height(), 10),
                        left: parseInt(t.css("left"), 10),
                        top: parseInt(t.css("top"), 10)
                    })
                })
            };
            typeof i.alsoResize == "object" && !i.alsoResize.parentNode ? i.alsoResize.length ? (i.alsoResize = i.alsoResize[0], s(i.alsoResize)) : e.each(i.alsoResize, function (e) {
                s(e)
            }) : s(i.alsoResize)
        }, resize: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r.originalSize, o = r.originalPosition, u = {
                height: r.size.height - s.height || 0,
                width: r.size.width - s.width || 0,
                top: r.position.top - o.top || 0,
                left: r.position.left - o.left || 0
            }, a = function (t, r) {
                e(t).each(function () {
                    var t = e(this), i = e(this).data("resizable-alsoresize"), s = {}, o = r && r.length ? r : t.parents(n.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                    e.each(o, function (e, t) {
                        var n = (i[t] || 0) + (u[t] || 0);
                        n && n >= 0 && (s[t] = n || null)
                    }), t.css(s)
                })
            };
            typeof i.alsoResize == "object" && !i.alsoResize.nodeType ? e.each(i.alsoResize, function (e, t) {
                a(e, t)
            }) : a(i.alsoResize)
        }, stop: function (t, n) {
            e(this).removeData("resizable-alsoresize")
        }
    }), e.ui.plugin.add("resizable", "animate", {
        stop: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r._proportionallyResizeElements, o = s.length && /textarea/i.test(s[0].nodeName), u = o && e.ui.hasScroll(s[0], "left") ? 0 : r.sizeDiff.height, a = o ? 0 : r.sizeDiff.width, f = {
                width: r.size.width - a,
                height: r.size.height - u
            }, l = parseInt(r.element.css("left"), 10) + (r.position.left - r.originalPosition.left) || null, c = parseInt(r.element.css("top"), 10) + (r.position.top - r.originalPosition.top) || null;
            r.element.animate(e.extend(f, c && l ? {top: c, left: l} : {}), {
                duration: i.animateDuration,
                easing: i.animateEasing,
                step: function () {
                    var n = {
                        width: parseInt(r.element.css("width"), 10),
                        height: parseInt(r.element.css("height"), 10),
                        top: parseInt(r.element.css("top"), 10),
                        left: parseInt(r.element.css("left"), 10)
                    };
                    s && s.length && e(s[0]).css({
                        width: n.width,
                        height: n.height
                    }), r._updateCache(n), r._propagate("resize", t)
                }
            })
        }
    }), e.ui.plugin.add("resizable", "containment", {
        start: function (t, r) {
            var i = e(this).data("resizable"), s = i.options, o = i.element, u = s.containment, a = u instanceof e ? u.get(0) : /parent/.test(u) ? o.parent().get(0) : u;
            if (!a)return;
            i.containerElement = e(a);
            if (/document/.test(u) || u == document)i.containerOffset = {left: 0, top: 0}, i.containerPosition = {
                left: 0,
                top: 0
            }, i.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document).width(),
                height: e(document).height() || document.body.parentNode.scrollHeight
            }; else {
                var f = e(a), l = [];
                e(["Top", "Right", "Left", "Bottom"]).each(function (e, t) {
                    l[e] = n(f.css("padding" + t))
                }), i.containerOffset = f.offset(), i.containerPosition = f.position(), i.containerSize = {
                    height: f.innerHeight() - l[3],
                    width: f.innerWidth() - l[1]
                };
                var c = i.containerOffset, h = i.containerSize.height, p = i.containerSize.width, d = e.ui.hasScroll(a, "left") ? a.scrollWidth : p, v = e.ui.hasScroll(a) ? a.scrollHeight : h;
                i.parentData = {element: a, left: c.left, top: c.top, width: d, height: v}
            }
        }, resize: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r.containerSize, o = r.containerOffset, u = r.size, a = r.position, f = r._aspectRatio || t.shiftKey, l = {
                top: 0,
                left: 0
            }, c = r.containerElement;
            c[0] != document && /static/.test(c.css("position")) && (l = o), a.left < (r._helper ? o.left : 0) && (r.size.width = r.size.width + (r._helper ? r.position.left - o.left : r.position.left - l.left), f && (r.size.height = r.size.width / r.aspectRatio), r.position.left = i.helper ? o.left : 0), a.top < (r._helper ? o.top : 0) && (r.size.height = r.size.height + (r._helper ? r.position.top - o.top : r.position.top), f && (r.size.width = r.size.height * r.aspectRatio), r.position.top = r._helper ? o.top : 0), r.offset.left = r.parentData.left + r.position.left, r.offset.top = r.parentData.top + r.position.top;
            var h = Math.abs((r._helper ? r.offset.left - l.left : r.offset.left - l.left) + r.sizeDiff.width), p = Math.abs((r._helper ? r.offset.top - l.top : r.offset.top - o.top) + r.sizeDiff.height), d = r.containerElement.get(0) == r.element.parent().get(0), v = /relative|absolute/.test(r.containerElement.css("position"));
            d && v && (h -= r.parentData.left), h + r.size.width >= r.parentData.width && (r.size.width = r.parentData.width - h, f && (r.size.height = r.size.width / r.aspectRatio)), p + r.size.height >= r.parentData.height && (r.size.height = r.parentData.height - p, f && (r.size.width = r.size.height * r.aspectRatio))
        }, stop: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r.position, o = r.containerOffset, u = r.containerPosition, a = r.containerElement, f = e(r.helper), l = f.offset(), c = f.outerWidth() - r.sizeDiff.width, h = f.outerHeight() - r.sizeDiff.height;
            r._helper && !i.animate && /relative/.test(a.css("position")) && e(this).css({
                left: l.left - u.left - o.left,
                width: c,
                height: h
            }), r._helper && !i.animate && /static/.test(a.css("position")) && e(this).css({
                left: l.left - u.left - o.left,
                width: c,
                height: h
            })
        }
    }), e.ui.plugin.add("resizable", "ghost", {
        start: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r.size;
            r.ghost = r.originalElement.clone(), r.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: s.height,
                width: s.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass(typeof i.ghost == "string" ? i.ghost : ""), r.ghost.appendTo(r.helper)
        }, resize: function (t, n) {
            var r = e(this).data("resizable"), i = r.options;
            r.ghost && r.ghost.css({position: "relative", height: r.size.height, width: r.size.width})
        }, stop: function (t, n) {
            var r = e(this).data("resizable"), i = r.options;
            r.ghost && r.helper && r.helper.get(0).removeChild(r.ghost.get(0))
        }
    }), e.ui.plugin.add("resizable", "grid", {
        resize: function (t, n) {
            var r = e(this).data("resizable"), i = r.options, s = r.size, o = r.originalSize, u = r.originalPosition, a = r.axis, f = i._aspectRatio || t.shiftKey;
            i.grid = typeof i.grid == "number" ? [i.grid, i.grid] : i.grid;
            var l = Math.round((s.width - o.width) / (i.grid[0] || 1)) * (i.grid[0] || 1), c = Math.round((s.height - o.height) / (i.grid[1] || 1)) * (i.grid[1] || 1);
            /^(se|s|e)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c) : /^(ne)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c, r.position.top = u.top - c) : /^(sw)$/.test(a) ? (r.size.width = o.width + l, r.size.height = o.height + c, r.position.left = u.left - l) : (r.size.width = o.width + l, r.size.height = o.height + c, r.position.top = u.top - c, r.position.left = u.left - l)
        }
    });
    var n = function (e) {
        return parseInt(e, 10) || 0
    }, r = function (e) {
        return !isNaN(parseInt(e, 10))
    }
}(jQuery), function (e, t) {
    e.widget("ui.selectable", e.ui.mouse, {
        version: "1.9.1",
        options: {appendTo: "body", autoRefresh: !0, distance: 0, filter: "*", tolerance: "touch"},
        _create: function () {
            var t = this;
            this.element.addClass("ui-selectable"), this.dragged = !1;
            var n;
            this.refresh = function () {
                n = e(t.options.filter, t.element[0]), n.addClass("ui-selectee"), n.each(function () {
                    var t = e(this), n = t.offset();
                    e.data(this, "selectable-item", {
                        element: this,
                        $element: t,
                        left: n.left,
                        top: n.top,
                        right: n.left + t.outerWidth(),
                        bottom: n.top + t.outerHeight(),
                        startselected: !1,
                        selected: t.hasClass("ui-selected"),
                        selecting: t.hasClass("ui-selecting"),
                        unselecting: t.hasClass("ui-unselecting")
                    })
                })
            }, this.refresh(), this.selectees = n.addClass("ui-selectee"), this._mouseInit(), this.helper = e("<div class='ui-selectable-helper'></div>")
        },
        _destroy: function () {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"), this._mouseDestroy()
        },
        _mouseStart: function (t) {
            var n = this;
            this.opos = [t.pageX, t.pageY];
            if (this.options.disabled)return;
            var r = this.options;
            this.selectees = e(r.filter, this.element[0]), this._trigger("start", t), e(r.appendTo).append(this.helper), this.helper.css({
                left: t.clientX,
                top: t.clientY,
                width: 0,
                height: 0
            }), r.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
                var r = e.data(this, "selectable-item");
                r.startselected = !0, !t.metaKey && !t.ctrlKey && (r.$element.removeClass("ui-selected"), r.selected = !1, r.$element.addClass("ui-unselecting"), r.unselecting = !0, n._trigger("unselecting", t, {unselecting: r.element}))
            }), e(t.target).parents().andSelf().each(function () {
                var r = e.data(this, "selectable-item");
                if (r) {
                    var i = !t.metaKey && !t.ctrlKey || !r.$element.hasClass("ui-selected");
                    return r.$element.removeClass(i ? "ui-unselecting" : "ui-selected").addClass(i ? "ui-selecting" : "ui-unselecting"), r.unselecting = !i, r.selecting = i, r.selected = i, i ? n._trigger("selecting", t, {selecting: r.element}) : n._trigger("unselecting", t, {unselecting: r.element}), !1
                }
            })
        },
        _mouseDrag: function (t) {
            var n = this;
            this.dragged = !0;
            if (this.options.disabled)return;
            var r = this.options, i = this.opos[0], s = this.opos[1], o = t.pageX, u = t.pageY;
            if (i > o) {
                var a = o;
                o = i, i = a
            }
            if (s > u) {
                var a = u;
                u = s, s = a
            }
            return this.helper.css({left: i, top: s, width: o - i, height: u - s}), this.selectees.each(function () {
                var a = e.data(this, "selectable-item");
                if (!a || a.element == n.element[0])return;
                var f = !1;
                r.tolerance == "touch" ? f = !(a.left > o || a.right < i || a.top > u || a.bottom < s) : r.tolerance == "fit" && (f = a.left > i && a.right < o && a.top > s && a.bottom < u), f ? (a.selected && (a.$element.removeClass("ui-selected"), a.selected = !1), a.unselecting && (a.$element.removeClass("ui-unselecting"), a.unselecting = !1), a.selecting || (a.$element.addClass("ui-selecting"), a.selecting = !0, n._trigger("selecting", t, {selecting: a.element}))) : (a.selecting && ((t.metaKey || t.ctrlKey) && a.startselected ? (a.$element.removeClass("ui-selecting"), a.selecting = !1, a.$element.addClass("ui-selected"), a.selected = !0) : (a.$element.removeClass("ui-selecting"), a.selecting = !1, a.startselected && (a.$element.addClass("ui-unselecting"), a.unselecting = !0), n._trigger("unselecting", t, {unselecting: a.element}))), a.selected && !t.metaKey && !t.ctrlKey && !a.startselected && (a.$element.removeClass("ui-selected"), a.selected = !1, a.$element.addClass("ui-unselecting"), a.unselecting = !0, n._trigger("unselecting", t, {unselecting: a.element})))
            }), !1
        },
        _mouseStop: function (t) {
            var n = this;
            this.dragged = !1;
            var r = this.options;
            return e(".ui-unselecting", this.element[0]).each(function () {
                var r = e.data(this, "selectable-item");
                r.$element.removeClass("ui-unselecting"), r.unselecting = !1, r.startselected = !1, n._trigger("unselected", t, {unselected: r.element})
            }), e(".ui-selecting", this.element[0]).each(function () {
                var r = e.data(this, "selectable-item");
                r.$element.removeClass("ui-selecting").addClass("ui-selected"), r.selecting = !1, r.selected = !0, r.startselected = !0, n._trigger("selected", t, {selected: r.element})
            }), this._trigger("stop", t), this.helper.remove(), !1
        }
    })
}(jQuery), function (e, t) {
    e.widget("ui.sortable", e.ui.mouse, {
        version: "1.9.1",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3
        },
        _create: function () {
            var e = this.options;
            this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), this.floating = this.items.length ? e.axis === "x" || /left|right/.test(this.items[0].item.css("float")) || /inline|table-cell/.test(this.items[0].item.css("display")) : !1, this.offset = this.element.offset(), this._mouseInit(), this.ready = !0
        },
        _destroy: function () {
            this.element.removeClass("ui-sortable ui-sortable-disabled"), this._mouseDestroy();
            for (var e = this.items.length - 1; e >= 0; e--)this.items[e].item.removeData(this.widgetName + "-item");
            return this
        },
        _setOption: function (t, n) {
            t === "disabled" ? (this.options[t] = n, this.widget().toggleClass("ui-sortable-disabled", !!n)) : e.Widget.prototype._setOption.apply(this, arguments)
        },
        _mouseCapture: function (t, n) {
            var r = this;
            if (this.reverting)return !1;
            if (this.options.disabled || this.options.type == "static")return !1;
            this._refreshItems(t);
            var i = null, s = e(t.target).parents().each(function () {
                if (e.data(this, r.widgetName + "-item") == r)return i = e(this), !1
            });
            e.data(t.target, r.widgetName + "-item") == r && (i = e(t.target));
            if (!i)return !1;
            if (this.options.handle && !n) {
                var o = !1;
                e(this.options.handle, i).find("*").andSelf().each(function () {
                    this == t.target && (o = !0)
                });
                if (!o)return !1
            }
            return this.currentItem = i, this._removeCurrentsFromItems(), !0
        },
        _mouseStart: function (t, n, r) {
            var i = this.options;
            this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, e.extend(this.offset, {
                click: {left: t.pageX - this.offset.left, top: t.pageY - this.offset.top},
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            }, this.helper[0] != this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), i.containment && this._setContainment(), i.cursor && (e("body").css("cursor") && (this._storedCursor = e("body").css("cursor")), e("body").css("cursor", i.cursor)), i.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", i.opacity)), i.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", i.zIndex)), this.scrollParent[0] != document && this.scrollParent[0].tagName != "HTML" && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions();
            if (!r)for (var s = this.containers.length - 1; s >= 0; s--)this.containers[s]._trigger("activate", t, this._uiHash(this));
            return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(t), !0
        },
        _mouseDrag: function (t) {
            this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs);
            if (this.options.scroll) {
                var n = this.options, r = !1;
                this.scrollParent[0] != document && this.scrollParent[0].tagName != "HTML" ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < n.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + n.scrollSpeed : t.pageY - this.overflowOffset.top < n.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - n.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < n.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + n.scrollSpeed : t.pageX - this.overflowOffset.left < n.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - n.scrollSpeed)) : (t.pageY - e(document).scrollTop() < n.scrollSensitivity ? r = e(document).scrollTop(e(document).scrollTop() - n.scrollSpeed) : e(window).height() - (t.pageY - e(document).scrollTop()) < n.scrollSensitivity && (r = e(document).scrollTop(e(document).scrollTop() + n.scrollSpeed)), t.pageX - e(document).scrollLeft() < n.scrollSensitivity ? r = e(document).scrollLeft(e(document).scrollLeft() - n.scrollSpeed) : e(window).width() - (t.pageX - e(document).scrollLeft()) < n.scrollSensitivity && (r = e(document).scrollLeft(e(document).scrollLeft() + n.scrollSpeed))), r !== !1 && e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t)
            }
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.options.axis || this.options.axis != "y")this.helper[0].style.left = this.position.left + "px";
            if (!this.options.axis || this.options.axis != "x")this.helper[0].style.top = this.position.top + "px";
            for (var i = this.items.length - 1; i >= 0; i--) {
                var s = this.items[i], o = s.item[0], u = this._intersectsWithPointer(s);
                if (!u)continue;
                if (s.instance !== this.currentContainer)continue;
                if (o != this.currentItem[0] && this.placeholder[u == 1 ? "next" : "prev"]()[0] != o && !e.contains(this.placeholder[0], o) && (this.options.type == "semi-dynamic" ? !e.contains(this.element[0], o) : !0)) {
                    this.direction = u == 1 ? "down" : "up";
                    if (this.options.tolerance != "pointer" && !this._intersectsWithSides(s))break;
                    this._rearrange(t, s), this._trigger("change", t, this._uiHash());
                    break
                }
            }
            return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
        },
        _mouseStop: function (t, n) {
            if (!t)return;
            e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(this, t);
            if (this.options.revert) {
                var r = this, i = this.placeholder.offset();
                this.reverting = !0, e(this.helper).animate({
                    left: i.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
                    top: i.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
                }, parseInt(this.options.revert, 10) || 500, function () {
                    r._clear(t)
                })
            } else this._clear(t, n);
            return !1
        },
        cancel: function () {
            if (this.dragging) {
                this._mouseUp({target: null}), this.options.helper == "original" ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var t = this.containers.length - 1; t >= 0; t--)this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0)
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.options.helper != "original" && this.helper && this.helper[0].parentNode && this.helper.remove(), e.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? e(this.domPosition.prev).after(this.currentItem) : e(this.domPosition.parent).prepend(this.currentItem)), this
        },
        serialize: function (t) {
            var n = this._getItemsAsjQuery(t && t.connected), r = [];
            return t = t || {}, e(n).each(function () {
                var n = (e(t.item || this).attr(t.attribute || "id") || "").match(t.expression || /(.+)[-=_](.+)/);
                n && r.push((t.key || n[1] + "[]") + "=" + (t.key && t.expression ? n[1] : n[2]))
            }), !r.length && t.key && r.push(t.key + "="), r.join("&")
        },
        toArray: function (t) {
            var n = this._getItemsAsjQuery(t && t.connected), r = [];
            return t = t || {}, n.each(function () {
                r.push(e(t.item || this).attr(t.attribute || "id") || "")
            }), r
        },
        _intersectsWith: function (e) {
            var t = this.positionAbs.left, n = t + this.helperProportions.width, r = this.positionAbs.top, i = r + this.helperProportions.height, s = e.left, o = s + e.width, u = e.top, a = u + e.height, f = this.offset.click.top, l = this.offset.click.left, c = r + f > u && r + f < a && t + l > s && t + l < o;
            return this.options.tolerance == "pointer" || this.options.forcePointerForContainers || this.options.tolerance != "pointer" && this.helperProportions[this.floating ? "width" : "height"] > e[this.floating ? "width" : "height"] ? c : s < t + this.helperProportions.width / 2 && n - this.helperProportions.width / 2 < o && u < r + this.helperProportions.height / 2 && i - this.helperProportions.height / 2 < a
        },
        _intersectsWithPointer: function (t) {
            var n = this.options.axis === "x" || e.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height), r = this.options.axis === "y" || e.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width), i = n && r, s = this._getDragVerticalDirection(), o = this._getDragHorizontalDirection();
            return i ? this.floating ? o && o == "right" || s == "down" ? 2 : 1 : s && (s == "down" ? 2 : 1) : !1
        },
        _intersectsWithSides: function (t) {
            var n = e.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height), r = e.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width), i = this._getDragVerticalDirection(), s = this._getDragHorizontalDirection();
            return this.floating && s ? s == "right" && r || s == "left" && !r : i && (i == "down" && n || i == "up" && !n)
        },
        _getDragVerticalDirection: function () {
            var e = this.positionAbs.top - this.lastPositionAbs.top;
            return e != 0 && (e > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection: function () {
            var e = this.positionAbs.left - this.lastPositionAbs.left;
            return e != 0 && (e > 0 ? "right" : "left")
        },
        refresh: function (e) {
            return this._refreshItems(e), this.refreshPositions(), this
        },
        _connectWith: function () {
            var e = this.options;
            return e.connectWith.constructor == String ? [e.connectWith] : e.connectWith
        },
        _getItemsAsjQuery: function (t) {
            var n = [], r = [], i = this._connectWith();
            if (i && t)for (var s = i.length - 1; s >= 0; s--) {
                var o = e(i[s]);
                for (var u = o.length - 1; u >= 0; u--) {
                    var a = e.data(o[u], this.widgetName);
                    a && a != this && !a.options.disabled && r.push([e.isFunction(a.options.items) ? a.options.items.call(a.element) : e(a.options.items, a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), a])
                }
            }
            r.push([e.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : e(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
            for (var s = r.length - 1; s >= 0; s--)r[s][0].each(function () {
                n.push(this)
            });
            return e(n)
        },
        _removeCurrentsFromItems: function () {
            var t = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = e.grep(this.items, function (e) {
                for (var n = 0; n < t.length; n++)if (t[n] == e.item[0])return !1;
                return !0
            })
        },
        _refreshItems: function (t) {
            this.items = [], this.containers = [this];
            var n = this.items, r = [[e.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {item: this.currentItem}) : e(this.options.items, this.element), this]], i = this._connectWith();
            if (i && this.ready)for (var s = i.length - 1; s >= 0; s--) {
                var o = e(i[s]);
                for (var u = o.length - 1; u >= 0; u--) {
                    var a = e.data(o[u], this.widgetName);
                    a && a != this && !a.options.disabled && (r.push([e.isFunction(a.options.items) ? a.options.items.call(a.element[0], t, {item: this.currentItem}) : e(a.options.items, a.element), a]), this.containers.push(a))
                }
            }
            for (var s = r.length - 1; s >= 0; s--) {
                var f = r[s][1], l = r[s][0];
                for (var u = 0, c = l.length; u < c; u++) {
                    var h = e(l[u]);
                    h.data(this.widgetName + "-item", f), n.push({
                        item: h,
                        instance: f,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    })
                }
            }
        },
        refreshPositions: function (t) {
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            for (var n = this.items.length - 1; n >= 0; n--) {
                var r = this.items[n];
                if (r.instance != this.currentContainer && this.currentContainer && r.item[0] != this.currentItem[0])continue;
                var i = this.options.toleranceElement ? e(this.options.toleranceElement, r.item) : r.item;
                t || (r.width = i.outerWidth(), r.height = i.outerHeight());
                var s = i.offset();
                r.left = s.left, r.top = s.top
            }
            if (this.options.custom && this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this); else for (var n = this.containers.length - 1; n >= 0; n--) {
                var s = this.containers[n].element.offset();
                this.containers[n].containerCache.left = s.left, this.containers[n].containerCache.top = s.top, this.containers[n].containerCache.width = this.containers[n].element.outerWidth(), this.containers[n].containerCache.height = this.containers[n].element.outerHeight()
            }
            return this
        },
        _createPlaceholder: function (t) {
            t = t || this;
            var n = t.options;
            if (!n.placeholder || n.placeholder.constructor == String) {
                var r = n.placeholder;
                n.placeholder = {
                    element: function () {
                        var n = e(document.createElement(t.currentItem[0].nodeName)).addClass(r || t.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];
                        return r || (n.style.visibility = "hidden"), n
                    }, update: function (e, i) {
                        if (r && !n.forcePlaceholderSize)return;
                        i.height() || i.height(t.currentItem.innerHeight() - parseInt(t.currentItem.css("paddingTop") || 0, 10) - parseInt(t.currentItem.css("paddingBottom") || 0, 10)), i.width() || i.width(t.currentItem.innerWidth() - parseInt(t.currentItem.css("paddingLeft") || 0, 10) - parseInt(t.currentItem.css("paddingRight") || 0, 10))
                    }
                }
            }
            t.placeholder = e(n.placeholder.element.call(t.element, t.currentItem)), t.currentItem.after(t.placeholder), n.placeholder.update(t, t.placeholder)
        },
        _contactContainers: function (t) {
            var n = null, r = null;
            for (var i = this.containers.length - 1; i >= 0; i--) {
                if (e.contains(this.currentItem[0], this.containers[i].element[0]))continue;
                if (this._intersectsWith(this.containers[i].containerCache)) {
                    if (n && e.contains(this.containers[i].element[0], n.element[0]))continue;
                    n = this.containers[i], r = i
                } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", t, this._uiHash(this)), this.containers[i].containerCache.over = 0)
            }
            if (!n)return;
            if (this.containers.length === 1)this.containers[r]._trigger("over", t, this._uiHash(this)), this.containers[r].containerCache.over = 1; else {
                var s = 1e4, o = null, u = this.containers[r].floating ? "left" : "top", a = this.containers[r].floating ? "width" : "height", f = this.positionAbs[u] + this.offset.click[u];
                for (var l = this.items.length - 1; l >= 0; l--) {
                    if (!e.contains(this.containers[r].element[0], this.items[l].item[0]))continue;
                    if (this.items[l].item[0] == this.currentItem[0])continue;
                    var c = this.items[l].item.offset()[u], h = !1;
                    Math.abs(c - f) > Math.abs(c + this.items[l][a] - f) && (h = !0, c += this.items[l][a]), Math.abs(c - f) < s && (s = Math.abs(c - f), o = this.items[l], this.direction = h ? "up" : "down")
                }
                if (!o && !this.options.dropOnEmpty)return;
                this.currentContainer = this.containers[r], o ? this._rearrange(t, o, null, !0) : this._rearrange(t, null, this.containers[r].element, !0), this._trigger("change", t, this._uiHash()), this.containers[r]._trigger("change", t, this._uiHash(this)), this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[r]._trigger("over", t, this._uiHash(this)), this.containers[r].containerCache.over = 1
            }
        },
        _createHelper: function (t) {
            var n = this.options, r = e.isFunction(n.helper) ? e(n.helper.apply(this.element[0], [t, this.currentItem])) : n.helper == "clone" ? this.currentItem.clone() : this.currentItem;
            return r.parents("body").length || e(n.appendTo != "parent" ? n.appendTo : this.currentItem[0].parentNode)[0].appendChild(r[0]), r[0] == this.currentItem[0] && (this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            }), (r[0].style.width == "" || n.forceHelperSize) && r.width(this.currentItem.width()), (r[0].style.height == "" || n.forceHelperSize) && r.height(this.currentItem.height()), r
        },
        _adjustOffsetFromHelper: function (t) {
            typeof t == "string" && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left"in t && (this.offset.click.left = t.left + this.margins.left), "right"in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top"in t && (this.offset.click.top = t.top + this.margins.top), "bottom"in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
        },
        _getParentOffset: function () {
            this.offsetParent = this.helper.offsetParent();
            var t = this.offsetParent.offset();
            this.cssPosition == "absolute" && this.scrollParent[0] != document && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop());
            if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && e.ui.ie)t = {
                top: 0,
                left: 0
            };
            return {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function () {
            if (this.cssPosition == "relative") {
                var e = this.currentItem.position();
                return {
                    top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                }
            }
            return {top: 0, left: 0}
        },
        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            }
        },
        _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
            var t = this.options;
            t.containment == "parent" && (t.containment = this.helper[0].parentNode);
            if (t.containment == "document" || t.containment == "window")this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, e(t.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (e(t.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
            if (!/^(document|window|parent)$/.test(t.containment)) {
                var n = e(t.containment)[0], r = e(t.containment).offset(), i = e(n).css("overflow") != "hidden";
                this.containment = [r.left + (parseInt(e(n).css("borderLeftWidth"), 10) || 0) + (parseInt(e(n).css("paddingLeft"), 10) || 0) - this.margins.left, r.top + (parseInt(e(n).css("borderTopWidth"), 10) || 0) + (parseInt(e(n).css("paddingTop"), 10) || 0) - this.margins.top, r.left + (i ? Math.max(n.scrollWidth, n.offsetWidth) : n.offsetWidth) - (parseInt(e(n).css("borderLeftWidth"), 10) || 0) - (parseInt(e(n).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, r.top + (i ? Math.max(n.scrollHeight, n.offsetHeight) : n.offsetHeight) - (parseInt(e(n).css("borderTopWidth"), 10) || 0) - (parseInt(e(n).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top]
            }
        },
        _convertPositionTo: function (t, n) {
            n || (n = this.position);
            var r = t == "absolute" ? 1 : -1, i = this.options, s = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, o = /(html|body)/i.test(s[0].tagName);
            return {
                top: n.top + this.offset.relative.top * r + this.offset.parent.top * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : o ? 0 : s.scrollTop()) * r,
                left: n.left + this.offset.relative.left * r + this.offset.parent.left * r - (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : o ? 0 : s.scrollLeft()) * r
            }
        },
        _generatePosition: function (t) {
            var n = this.options, r = this.cssPosition != "absolute" || this.scrollParent[0] != document && !!e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, i = /(html|body)/i.test(r[0].tagName);
            this.cssPosition == "relative" && (this.scrollParent[0] == document || this.scrollParent[0] == this.offsetParent[0]) && (this.offset.relative = this._getRelativeOffset());
            var s = t.pageX, o = t.pageY;
            if (this.originalPosition) {
                this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (s = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (o = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (s = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (o = this.containment[3] + this.offset.click.top));
                if (n.grid) {
                    var u = this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1];
                    o = this.containment ? u - this.offset.click.top < this.containment[1] || u - this.offset.click.top > this.containment[3] ? u - this.offset.click.top < this.containment[1] ? u + n.grid[1] : u - n.grid[1] : u : u;
                    var a = this.originalPageX + Math.round((s - this.originalPageX) / n.grid[0]) * n.grid[0];
                    s = this.containment ? a - this.offset.click.left < this.containment[0] || a - this.offset.click.left > this.containment[2] ? a - this.offset.click.left < this.containment[0] ? a + n.grid[0] : a - n.grid[0] : a : a
                }
            }
            return {
                top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : i ? 0 : r.scrollTop()),
                left: s - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : i ? 0 : r.scrollLeft())
            }
        },
        _rearrange: function (e, t, n, r) {
            n ? n[0].appendChild(this.placeholder[0]) : t.item[0].parentNode.insertBefore(this.placeholder[0], this.direction == "down" ? t.item[0] : t.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
            var i = this.counter;
            this._delay(function () {
                i == this.counter && this.refreshPositions(!r)
            })
        },
        _clear: function (t, n) {
            this.reverting = !1;
            var r = [];
            !this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null;
            if (this.helper[0] == this.currentItem[0]) {
                for (var i in this._storedCSS)if (this._storedCSS[i] == "auto" || this._storedCSS[i] == "static")this._storedCSS[i] = "";
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
            } else this.currentItem.show();
            this.fromOutside && !n && r.push(function (e) {
                this._trigger("receive", e, this._uiHash(this.fromOutside))
            }), (this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !n && r.push(function (e) {
                this._trigger("update", e, this._uiHash())
            }), this !== this.currentContainer && (n || (r.push(function (e) {
                this._trigger("remove", e, this._uiHash())
            }), r.push(function (e) {
                return function (t) {
                    e._trigger("receive", t, this._uiHash(this))
                }
            }.call(this, this.currentContainer)), r.push(function (e) {
                return function (t) {
                    e._trigger("update", t, this._uiHash(this))
                }
            }.call(this, this.currentContainer))));
            for (var i = this.containers.length - 1; i >= 0; i--)n || r.push(function (e) {
                return function (t) {
                    e._trigger("deactivate", t, this._uiHash(this))
                }
            }.call(this, this.containers[i])), this.containers[i].containerCache.over && (r.push(function (e) {
                return function (t) {
                    e._trigger("out", t, this._uiHash(this))
                }
            }.call(this, this.containers[i])), this.containers[i].containerCache.over = 0);
            this._storedCursor && e("body").css("cursor", this._storedCursor), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", this._storedZIndex == "auto" ? "" : this._storedZIndex), this.dragging = !1;
            if (this.cancelHelperRemoval) {
                if (!n) {
                    this._trigger("beforeStop", t, this._uiHash());
                    for (var i = 0; i < r.length; i++)r[i].call(this, t);
                    this._trigger("stop", t, this._uiHash())
                }
                return this.fromOutside = !1, !1
            }
            n || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.helper[0] != this.currentItem[0] && this.helper.remove(), this.helper = null;
            if (!n) {
                for (var i = 0; i < r.length; i++)r[i].call(this, t);
                this._trigger("stop", t, this._uiHash())
            }
            return this.fromOutside = !1, !0
        },
        _trigger: function () {
            e.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel()
        },
        _uiHash: function (t) {
            var n = t || this;
            return {
                helper: n.helper,
                placeholder: n.placeholder || e([]),
                position: n.position,
                originalPosition: n.originalPosition,
                offset: n.positionAbs,
                item: n.currentItem,
                sender: t ? t.element : null
            }
        }
    })
}(jQuery), jQuery.effects || function (e, t) {
    var n = e.uiBackCompat !== !1, r = "ui-effects-";
    e.effects = {effect: {}}, function (t, n) {
        function p(e, t, n) {
            var r = a[t.type] || {};
            return e == null ? n || !t.def ? null : t.def : (e = r.floor ? ~~e : parseFloat(e), isNaN(e) ? t.def : r.mod ? (e + r.mod) % r.mod : 0 > e ? 0 : r.max < e ? r.max : e)
        }

        function d(e) {
            var n = o(), r = n._rgba = [];
            return e = e.toLowerCase(), h(s, function (t, i) {
                var s, o = i.re.exec(e), a = o && i.parse(o), f = i.space || "rgba";
                if (a)return s = n[f](a), n[u[f].cache] = s[u[f].cache], r = n._rgba = s._rgba, !1
            }), r.length ? (r.join() === "0,0,0,0" && t.extend(r, c.transparent), n) : c[e]
        }

        function v(e, t, n) {
            return n = (n + 1) % 1, n * 6 < 1 ? e + (t - e) * n * 6 : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e
        }

        var r = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "), i = /^([\-+])=\s*(\d+\.?\d*)/, s = [{
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            parse: function (e) {
                return [e[1], e[2], e[3], e[4]]
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            parse: function (e) {
                return [e[1] * 2.55, e[2] * 2.55, e[3] * 2.55, e[4]]
            }
        }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse: function (e) {
                return [parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16)]
            }
        }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse: function (e) {
                return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)]
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function (e) {
                return [e[1], e[2] / 100, e[3] / 100, e[4]]
            }
        }], o = t.Color = function (e, n, r, i) {
            return new t.Color.fn.parse(e, n, r, i)
        }, u = {
            rgba: {
                props: {
                    red: {idx: 0, type: "byte"},
                    green: {idx: 1, type: "byte"},
                    blue: {idx: 2, type: "byte"}
                }
            },
            hsla: {
                props: {
                    hue: {idx: 0, type: "degrees"},
                    saturation: {idx: 1, type: "percent"},
                    lightness: {idx: 2, type: "percent"}
                }
            }
        }, a = {
            "byte": {floor: !0, max: 255},
            percent: {max: 1},
            degrees: {mod: 360, floor: !0}
        }, f = o.support = {}, l = t("<p>")[0], c, h = t.each;
        l.style.cssText = "background-color:rgba(1,1,1,.5)", f.rgba = l.style.backgroundColor.indexOf("rgba") > -1, h(u, function (e, t) {
            t.cache = "_" + e, t.props.alpha = {idx: 3, type: "percent", def: 1}
        }), o.fn = t.extend(o.prototype, {
            parse: function (r, i, s, a) {
                if (r === n)return this._rgba = [null, null, null, null], this;
                if (r.jquery || r.nodeType)r = t(r).css(i), i = n;
                var f = this, l = t.type(r), v = this._rgba = [];
                i !== n && (r = [r, i, s, a], l = "array");
                if (l === "string")return this.parse(d(r) || c._default);
                if (l === "array")return h(u.rgba.props, function (e, t) {
                    v[t.idx] = p(r[t.idx], t)
                }), this;
                if (l === "object")return r instanceof o ? h(u, function (e, t) {
                    r[t.cache] && (f[t.cache] = r[t.cache].slice())
                }) : h(u, function (t, n) {
                    var i = n.cache;
                    h(n.props, function (e, t) {
                        if (!f[i] && n.to) {
                            if (e === "alpha" || r[e] == null)return;
                            f[i] = n.to(f._rgba)
                        }
                        f[i][t.idx] = p(r[e], t, !0)
                    }), f[i] && e.inArray(null, f[i].slice(0, 3)) < 0 && (f[i][3] = 1, n.from && (f._rgba = n.from(f[i])))
                }), this
            }, is: function (e) {
                var t = o(e), n = !0, r = this;
                return h(u, function (e, i) {
                    var s, o = t[i.cache];
                    return o && (s = r[i.cache] || i.to && i.to(r._rgba) || [], h(i.props, function (e, t) {
                        if (o[t.idx] != null)return n = o[t.idx] === s[t.idx], n
                    })), n
                }), n
            }, _space: function () {
                var e = [], t = this;
                return h(u, function (n, r) {
                    t[r.cache] && e.push(n)
                }), e.pop()
            }, transition: function (e, t) {
                var n = o(e), r = n._space(), i = u[r], s = this.alpha() === 0 ? o("transparent") : this, f = s[i.cache] || i.to(s._rgba), l = f.slice();
                return n = n[i.cache], h(i.props, function (e, r) {
                    var i = r.idx, s = f[i], o = n[i], u = a[r.type] || {};
                    if (o === null)return;
                    s === null ? l[i] = o : (u.mod && (o - s > u.mod / 2 ? s += u.mod : s - o > u.mod / 2 && (s -= u.mod)), l[i] = p((o - s) * t + s, r))
                }), this[r](l)
            }, blend: function (e) {
                if (this._rgba[3] === 1)return this;
                var n = this._rgba.slice(), r = n.pop(), i = o(e)._rgba;
                return o(t.map(n, function (e, t) {
                    return (1 - r) * i[t] + r * e
                }))
            }, toRgbaString: function () {
                var e = "rgba(", n = t.map(this._rgba, function (e, t) {
                    return e == null ? t > 2 ? 1 : 0 : e
                });
                return n[3] === 1 && (n.pop(), e = "rgb("), e + n.join() + ")"
            }, toHslaString: function () {
                var e = "hsla(", n = t.map(this.hsla(), function (e, t) {
                    return e == null && (e = t > 2 ? 1 : 0), t && t < 3 && (e = Math.round(e * 100) + "%"), e
                });
                return n[3] === 1 && (n.pop(), e = "hsl("), e + n.join() + ")"
            }, toHexString: function (e) {
                var n = this._rgba.slice(), r = n.pop();
                return e && n.push(~~(r * 255)), "#" + t.map(n, function (e) {
                    return e = (e || 0).toString(16), e.length === 1 ? "0" + e : e
                }).join("")
            }, toString: function () {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString()
            }
        }), o.fn.parse.prototype = o.fn, u.hsla.to = function (e) {
            if (e[0] == null || e[1] == null || e[2] == null)return [null, null, null, e[3]];
            var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = e[3], s = Math.max(t, n, r), o = Math.min(t, n, r), u = s - o, a = s + o, f = a * .5, l, c;
            return o === s ? l = 0 : t === s ? l = 60 * (n - r) / u + 360 : n === s ? l = 60 * (r - t) / u + 120 : l = 60 * (t - n) / u + 240, f === 0 || f === 1 ? c = f : f <= .5 ? c = u / a : c = u / (2 - a), [Math.round(l) % 360, c, f, i == null ? 1 : i]
        }, u.hsla.from = function (e) {
            if (e[0] == null || e[1] == null || e[2] == null)return [null, null, null, e[3]];
            var t = e[0] / 360, n = e[1], r = e[2], i = e[3], s = r <= .5 ? r * (1 + n) : r + n - r * n, o = 2 * r - s;
            return [Math.round(v(o, s, t + 1 / 3) * 255), Math.round(v(o, s, t) * 255), Math.round(v(o, s, t - 1 / 3) * 255), i]
        }, h(u, function (e, r) {
            var s = r.props, u = r.cache, a = r.to, f = r.from;
            o.fn[e] = function (e) {
                a && !this[u] && (this[u] = a(this._rgba));
                if (e === n)return this[u].slice();
                var r, i = t.type(e), l = i === "array" || i === "object" ? e : arguments, c = this[u].slice();
                return h(s, function (e, t) {
                    var n = l[i === "object" ? e : t.idx];
                    n == null && (n = c[t.idx]), c[t.idx] = p(n, t)
                }), f ? (r = o(f(c)), r[u] = c, r) : o(c)
            }, h(s, function (n, r) {
                if (o.fn[n])return;
                o.fn[n] = function (s) {
                    var o = t.type(s), u = n === "alpha" ? this._hsla ? "hsla" : "rgba" : e, a = this[u](), f = a[r.idx], l;
                    return o === "undefined" ? f : (o === "function" && (s = s.call(this, f), o = t.type(s)), s == null && r.empty ? this : (o === "string" && (l = i.exec(s), l && (s = f + parseFloat(l[2]) * (l[1] === "+" ? 1 : -1))), a[r.idx] = s, this[u](a)))
                }
            })
        }), h(r, function (e, n) {
            t.cssHooks[n] = {
                set: function (e, r) {
                    var i, s, u = "";
                    if (t.type(r) !== "string" || (i = d(r))) {
                        r = o(i || r);
                        if (!f.rgba && r._rgba[3] !== 1) {
                            s = n === "backgroundColor" ? e.parentNode : e;
                            while ((u === "" || u === "transparent") && s && s.style)try {
                                u = t.css(s, "backgroundColor"), s = s.parentNode
                            } catch (a) {
                            }
                            r = r.blend(u && u !== "transparent" ? u : "_default")
                        }
                        r = r.toRgbaString()
                    }
                    try {
                        e.style[n] = r
                    } catch (l) {
                    }
                }
            }, t.fx.step[n] = function (e) {
                e.colorInit || (e.start = o(e.elem, n), e.end = o(e.end), e.colorInit = !0), t.cssHooks[n].set(e.elem, e.start.transition(e.end, e.pos))
            }
        }), t.cssHooks.borderColor = {
            expand: function (e) {
                var t = {};
                return h(["Top", "Right", "Bottom", "Left"], function (n, r) {
                    t["border" + r + "Color"] = e
                }), t
            }
        }, c = t.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [null, null, null, 0],
            _default: "#ffffff"
        }
    }(jQuery), function () {
        function i() {
            var t = this.ownerDocument.defaultView ? this.ownerDocument.defaultView.getComputedStyle(this, null) : this.currentStyle, n = {}, r, i;
            if (t && t.length && t[0] && t[t[0]]) {
                i = t.length;
                while (i--)r = t[i], typeof t[r] == "string" && (n[e.camelCase(r)] = t[r])
            } else for (r in t)typeof t[r] == "string" && (n[r] = t[r]);
            return n
        }

        function s(t, n) {
            var i = {}, s, o;
            for (s in n)o = n[s], t[s] !== o && !r[s] && (e.fx.step[s] || !isNaN(parseFloat(o))) && (i[s] = o);
            return i
        }

        var n = ["add", "remove", "toggle"], r = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        e.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (t, n) {
            e.fx.step[n] = function (e) {
                if (e.end !== "none" && !e.setAttr || e.pos === 1 && !e.setAttr)jQuery.style(e.elem, n, e.end), e.setAttr = !0
            }
        }), e.effects.animateClass = function (t, r, o, u) {
            var a = e.speed(r, o, u);
            return this.queue(function () {
                var r = e(this), o = r.attr("class") || "", u, f = a.children ? r.find("*").andSelf() : r;
                f = f.map(function () {
                    var t = e(this);
                    return {el: t, start: i.call(this)}
                }), u = function () {
                    e.each(n, function (e, n) {
                        t[n] && r[n + "Class"](t[n])
                    })
                }, u(), f = f.map(function () {
                    return this.end = i.call(this.el[0]), this.diff = s(this.start, this.end), this
                }), r.attr("class", o), f = f.map(function () {
                    var t = this, n = e.Deferred(), r = jQuery.extend({}, a, {
                        queue: !1, complete: function () {
                            n.resolve(t)
                        }
                    });
                    return this.el.animate(this.diff, r), n.promise()
                }), e.when.apply(e, f.get()).done(function () {
                    u(), e.each(arguments, function () {
                        var t = this.el;
                        e.each(this.diff, function (e) {
                            t.css(e, "")
                        })
                    }), a.complete.call(r[0])
                })
            })
        }, e.fn.extend({
            _addClass: e.fn.addClass, addClass: function (t, n, r, i) {
                return n ? e.effects.animateClass.call(this, {add: t}, n, r, i) : this._addClass(t)
            }, _removeClass: e.fn.removeClass, removeClass: function (t, n, r, i) {
                return n ? e.effects.animateClass.call(this, {remove: t}, n, r, i) : this._removeClass(t)
            }, _toggleClass: e.fn.toggleClass, toggleClass: function (n, r, i, s, o) {
                return typeof r == "boolean" || r === t ? i ? e.effects.animateClass.call(this, r ? {add: n} : {remove: n}, i, s, o) : this._toggleClass(n, r) : e.effects.animateClass.call(this, {toggle: n}, r, i, s)
            }, switchClass: function (t, n, r, i, s) {
                return e.effects.animateClass.call(this, {add: n, remove: t}, r, i, s)
            }
        })
    }(), function () {
        function i(t, n, r, i) {
            e.isPlainObject(t) && (n = t, t = t.effect), t = {effect: t}, n == null && (n = {}), e.isFunction(n) && (i = n, r = null, n = {});
            if (typeof n == "number" || e.fx.speeds[n])i = r, r = n, n = {};
            return e.isFunction(r) && (i = r, r = null), n && e.extend(t, n), r = r || n.duration, t.duration = e.fx.off ? 0 : typeof r == "number" ? r : r in e.fx.speeds ? e.fx.speeds[r] : e.fx.speeds._default, t.complete = i || n.complete, t
        }

        function s(t) {
            return !t || typeof t == "number" || e.fx.speeds[t] ? !0 : typeof t == "string" && !e.effects.effect[t] ? n && e.effects[t] ? !1 : !0 : !1
        }

        e.extend(e.effects, {
            version: "1.9.1", save: function (e, t) {
                for (var n = 0; n < t.length; n++)t[n] !== null && e.data(r + t[n], e[0].style[t[n]])
            }, restore: function (e, n) {
                var i, s;
                for (s = 0; s < n.length; s++)n[s] !== null && (i = e.data(r + n[s]), i === t && (i = ""), e.css(n[s], i))
            }, setMode: function (e, t) {
                return t === "toggle" && (t = e.is(":hidden") ? "show" : "hide"), t
            }, getBaseline: function (e, t) {
                var n, r;
                switch (e[0]) {
                    case"top":
                        n = 0;
                        break;
                    case"middle":
                        n = .5;
                        break;
                    case"bottom":
                        n = 1;
                        break;
                    default:
                        n = e[0] / t.height
                }
                switch (e[1]) {
                    case"left":
                        r = 0;
                        break;
                    case"center":
                        r = .5;
                        break;
                    case"right":
                        r = 1;
                        break;
                    default:
                        r = e[1] / t.width
                }
                return {x: r, y: n}
            }, createWrapper: function (t) {
                if (t.parent().is(".ui-effects-wrapper"))return t.parent();
                var n = {
                    width: t.outerWidth(!0),
                    height: t.outerHeight(!0),
                    "float": t.css("float")
                }, r = e("<div></div>").addClass("ui-effects-wrapper").css({
                    fontSize: "100%",
                    background: "transparent",
                    border: "none",
                    margin: 0,
                    padding: 0
                }), i = {width: t.width(), height: t.height()}, s = document.activeElement;
                try {
                    s.id
                } catch (o) {
                    s = document.body
                }
                return t.wrap(r), (t[0] === s || e.contains(t[0], s)) && e(s).focus(), r = t.parent(), t.css("position") === "static" ? (r.css({position: "relative"}), t.css({position: "relative"})) : (e.extend(n, {
                    position: t.css("position"),
                    zIndex: t.css("z-index")
                }), e.each(["top", "left", "bottom", "right"], function (e, r) {
                    n[r] = t.css(r), isNaN(parseInt(n[r], 10)) && (n[r] = "auto")
                }), t.css({
                    position: "relative",
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                })), t.css(i), r.css(n).show()
            }, removeWrapper: function (t) {
                var n = document.activeElement;
                return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), (t[0] === n || e.contains(t[0], n)) && e(n).focus()), t
            }, setTransition: function (t, n, r, i) {
                return i = i || {}, e.each(n, function (e, n) {
                    var s = t.cssUnit(n);
                    s[0] > 0 && (i[n] = s[0] * r + s[1])
                }), i
            }
        }), e.fn.extend({
            effect: function () {
                function a(n) {
                    function u() {
                        e.isFunction(i) && i.call(r[0]), e.isFunction(n) && n()
                    }

                    var r = e(this), i = t.complete, s = t.mode;
                    (r.is(":hidden") ? s === "hide" : s === "show") ? u() : o.call(r[0], t, u)
                }

                var t = i.apply(this, arguments), r = t.mode, s = t.queue, o = e.effects.effect[t.effect], u = !o && n && e.effects[t.effect];
                return e.fx.off || !o && !u ? r ? this[r](t.duration, t.complete) : this.each(function () {
                    t.complete && t.complete.call(this)
                }) : o ? s === !1 ? this.each(a) : this.queue(s || "fx", a) : u.call(this, {
                    options: t,
                    duration: t.duration,
                    callback: t.complete,
                    mode: t.mode
                })
            }, _show: e.fn.show, show: function (e) {
                if (s(e))return this._show.apply(this, arguments);
                var t = i.apply(this, arguments);
                return t.mode = "show", this.effect.call(this, t)
            }, _hide: e.fn.hide, hide: function (e) {
                if (s(e))return this._hide.apply(this, arguments);
                var t = i.apply(this, arguments);
                return t.mode = "hide", this.effect.call(this, t)
            }, __toggle: e.fn.toggle, toggle: function (t) {
                if (s(t) || typeof t == "boolean" || e.isFunction(t))return this.__toggle.apply(this, arguments);
                var n = i.apply(this, arguments);
                return n.mode = "toggle", this.effect.call(this, n)
            }, cssUnit: function (t) {
                var n = this.css(t), r = [];
                return e.each(["em", "px", "%", "pt"], function (e, t) {
                    n.indexOf(t) > 0 && (r = [parseFloat(n), t])
                }), r
            }
        })
    }(), function () {
        var t = {};
        e.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (e, n) {
            t[n] = function (t) {
                return Math.pow(t, e + 2)
            }
        }), e.extend(t, {
            Sine: function (e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }, Circ: function (e) {
                return 1 - Math.sqrt(1 - e * e)
            }, Elastic: function (e) {
                return e === 0 || e === 1 ? e : -Math.pow(2, 8 * (e - 1)) * Math.sin(((e - 1) * 80 - 7.5) * Math.PI / 15)
            }, Back: function (e) {
                return e * e * (3 * e - 2)
            }, Bounce: function (e) {
                var t, n = 4;
                while (e < ((t = Math.pow(2, --n)) - 1) / 11);
                return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((t * 3 - 2) / 22 - e, 2)
            }
        }), e.each(t, function (t, n) {
            e.easing["easeIn" + t] = n, e.easing["easeOut" + t] = function (e) {
                return 1 - n(1 - e)
            }, e.easing["easeInOut" + t] = function (e) {
                return e < .5 ? n(e * 2) / 2 : 1 - n(e * -2 + 2) / 2
            }
        })
    }()
}(jQuery), function (e, t) {
    var n = 0, r = {}, i = {};
    r.height = r.paddingTop = r.paddingBottom = r.borderTopWidth = r.borderBottomWidth = "hide", i.height = i.paddingTop = i.paddingBottom = i.borderTopWidth = i.borderBottomWidth = "show", e.widget("ui.accordion", {
        version: "1.9.1",
        options: {
            active: 0,
            animate: {},
            collapsible: !1,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {activeHeader: "ui-icon-triangle-1-s", header: "ui-icon-triangle-1-e"},
            activate: null,
            beforeActivate: null
        },
        _create: function () {
            var t = this.accordionId = "ui-accordion-" + (this.element.attr("id") || ++n), r = this.options;
            this.prevShow = this.prevHide = e(), this.element.addClass("ui-accordion ui-widget ui-helper-reset"), this.headers = this.element.find(r.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all"), this._hoverable(this.headers), this._focusable(this.headers), this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide(), !r.collapsible && (r.active === !1 || r.active == null) && (r.active = 0), r.active < 0 && (r.active += this.headers.length), this.active = this._findActive(r.active).addClass("ui-accordion-header-active ui-state-active").toggleClass("ui-corner-all ui-corner-top"), this.active.next().addClass("ui-accordion-content-active").show(), this._createIcons(), this.refresh(), this.element.attr("role", "tablist"), this.headers.attr("role", "tab").each(function (n) {
                var r = e(this), i = r.attr("id"), s = r.next(), o = s.attr("id");
                i || (i = t + "-header-" + n, r.attr("id", i)), o || (o = t + "-panel-" + n, s.attr("id", o)), r.attr("aria-controls", o), s.attr("aria-labelledby", i)
            }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            }).next().attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            }).hide(), this.active.length ? this.active.attr({
                "aria-selected": "true",
                tabIndex: 0
            }).next().attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            }) : this.headers.eq(0).attr("tabIndex", 0), this._on(this.headers, {keydown: "_keydown"}), this._on(this.headers.next(), {keydown: "_panelKeyDown"}), this._setupEvents(r.event)
        },
        _getCreateEventData: function () {
            return {header: this.active, content: this.active.length ? this.active.next() : e()}
        },
        _createIcons: function () {
            var t = this.options.icons;
            t && (e("<span>").addClass("ui-accordion-header-icon ui-icon " + t.header).prependTo(this.headers), this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader), this.headers.addClass("ui-accordion-icons"))
        },
        _destroyIcons: function () {
            this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()
        },
        _destroy: function () {
            var e;
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"), this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function () {
                /^ui-accordion/.test(this.id) && this.removeAttribute("id")
            }), this._destroyIcons(), e = this.headers.next().css("display", "").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function () {
                /^ui-accordion/.test(this.id) && this.removeAttribute("id")
            }), this.options.heightStyle !== "content" && e.css("height", "")
        },
        _setOption: function (e, t) {
            if (e === "active") {
                this._activate(t);
                return
            }
            e === "event" && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(t)), this._super(e, t), e === "collapsible" && !t && this.options.active === !1 && this._activate(0), e === "icons" && (this._destroyIcons(), t && this._createIcons()), e === "disabled" && this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!t)
        },
        _keydown: function (t) {
            if (t.altKey || t.ctrlKey)return;
            var n = e.ui.keyCode, r = this.headers.length, i = this.headers.index(t.target), s = !1;
            switch (t.keyCode) {
                case n.RIGHT:
                case n.DOWN:
                    s = this.headers[(i + 1) % r];
                    break;
                case n.LEFT:
                case n.UP:
                    s = this.headers[(i - 1 + r) % r];
                    break;
                case n.SPACE:
                case n.ENTER:
                    this._eventHandler(t);
                    break;
                case n.HOME:
                    s = this.headers[0];
                    break;
                case n.END:
                    s = this.headers[r - 1]
            }
            s && (e(t.target).attr("tabIndex", -1), e(s).attr("tabIndex", 0), s.focus(), t.preventDefault())
        },
        _panelKeyDown: function (t) {
            t.keyCode === e.ui.keyCode.UP && t.ctrlKey && e(t.currentTarget).prev().focus()
        },
        refresh: function () {
            var t, n, r = this.options.heightStyle, i = this.element.parent();
            r === "fill" ? (e.support.minHeight || (n = i.css("overflow"), i.css("overflow", "hidden")), t = i.height(), this.element.siblings(":visible").each(function () {
                var n = e(this), r = n.css("position");
                if (r === "absolute" || r === "fixed")return;
                t -= n.outerHeight(!0)
            }), n && i.css("overflow", n), this.headers.each(function () {
                t -= e(this).outerHeight(!0)
            }), this.headers.next().each(function () {
                e(this).height(Math.max(0, t - e(this).innerHeight() + e(this).height()))
            }).css("overflow", "auto")) : r === "auto" && (t = 0, this.headers.next().each(function () {
                t = Math.max(t, e(this).height("").height())
            }).height(t))
        },
        _activate: function (t) {
            var n = this._findActive(t)[0];
            if (n === this.active[0])return;
            n = n || this.active[0], this._eventHandler({target: n, currentTarget: n, preventDefault: e.noop})
        },
        _findActive: function (t) {
            return typeof t == "number" ? this.headers.eq(t) : e()
        },
        _setupEvents: function (t) {
            var n = {};
            if (!t)return;
            e.each(t.split(" "), function (e, t) {
                n[t] = "_eventHandler"
            }), this._on(this.headers, n)
        },
        _eventHandler: function (t) {
            var n = this.options, r = this.active, i = e(t.currentTarget), s = i[0] === r[0], o = s && n.collapsible, u = o ? e() : i.next(), a = r.next(), f = {
                oldHeader: r,
                oldPanel: a,
                newHeader: o ? e() : i,
                newPanel: u
            };
            t.preventDefault();
            if (s && !n.collapsible || this._trigger("beforeActivate", t, f) === !1)return;
            n.active = o ? !1 : this.headers.index(i), this.active = s ? e() : i, this._toggle(f), r.removeClass("ui-accordion-header-active ui-state-active"), n.icons && r.children(".ui-accordion-header-icon").removeClass(n.icons.activeHeader).addClass(n.icons.header), s || (i.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"), n.icons && i.children(".ui-accordion-header-icon").removeClass(n.icons.header).addClass(n.icons.activeHeader), i.next().addClass("ui-accordion-content-active"))
        },
        _toggle: function (t) {
            var n = t.newPanel, r = this.prevShow.length ? this.prevShow : t.oldPanel;
            this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = n, this.prevHide = r, this.options.animate ? this._animate(n, r, t) : (r.hide(), n.show(), this._toggleComplete(t)), r.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            }), r.prev().attr("aria-selected", "false"), n.length && r.length ? r.prev().attr("tabIndex", -1) : n.length && this.headers.filter(function () {
                return e(this).attr("tabIndex") === 0
            }).attr("tabIndex", -1), n.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            }).prev().attr({"aria-selected": "true", tabIndex: 0})
        },
        _animate: function (e, t, n) {
            var s, o, u, a = this, f = 0, l = e.length && (!t.length || e.index() < t.index()), c = this.options.animate || {}, h = l && c.down || c, p = function () {
                a._toggleComplete(n)
            };
            typeof h == "number" && (u = h), typeof h == "string" && (o = h), o = o || h.easing || c.easing, u = u || h.duration || c.duration;
            if (!t.length)return e.animate(i, u, o, p);
            if (!e.length)return t.animate(r, u, o, p);
            s = e.show().outerHeight(), t.animate(r, {
                duration: u, easing: o, step: function (e, t) {
                    t.now = Math.round(e)
                }
            }), e.hide().animate(i, {
                duration: u, easing: o, complete: p, step: function (e, n) {
                    n.now = Math.round(e), n.prop !== "height" ? f += n.now : a.options.heightStyle !== "content" && (n.now = Math.round(s - t.outerHeight() - f), f = 0)
                }
            })
        },
        _toggleComplete: function (e) {
            var t = e.oldPanel;
            t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"), t.length && (t.parent()[0].className = t.parent()[0].className), this._trigger("activate", null, e)
        }
    }), e.uiBackCompat !== !1 && (function (e, t) {
        e.extend(t.options, {
            navigation: !1, navigationFilter: function () {
                return this.href.toLowerCase() === location.href.toLowerCase()
            }
        });
        var n = t._create;
        t._create = function () {
            if (this.options.navigation) {
                var t = this, r = this.element.find(this.options.header), i = r.next(), s = r.add(i).find("a").filter(this.options.navigationFilter)[0];
                s && r.add(i).each(function (n) {
                    if (e.contains(this, s))return t.options.active = Math.floor(n / 2), !1
                })
            }
            n.call(this)
        }
    }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
        e.extend(t.options, {heightStyle: null, autoHeight: !0, clearStyle: !1, fillSpace: !1});
        var n = t._create, r = t._setOption;
        e.extend(t, {
            _create: function () {
                this.options.heightStyle = this.options.heightStyle || this._mergeHeightStyle(), n.call(this)
            }, _setOption: function (e) {
                if (e === "autoHeight" || e === "clearStyle" || e === "fillSpace")this.options.heightStyle = this._mergeHeightStyle();
                r.apply(this, arguments)
            }, _mergeHeightStyle: function () {
                var e = this.options;
                if (e.fillSpace)return "fill";
                if (e.clearStyle)return "content";
                if (e.autoHeight)return "auto"
            }
        })
    }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
        e.extend(t.options.icons, {activeHeader: null, headerSelected: "ui-icon-triangle-1-s"});
        var n = t._createIcons;
        t._createIcons = function () {
            this.options.icons && (this.options.icons.activeHeader = this.options.icons.activeHeader || this.options.icons.headerSelected), n.call(this)
        }
    }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
        t.activate = t._activate;
        var n = t._findActive;
        t._findActive = function (e) {
            return e === -1 && (e = !1), e && typeof e != "number" && (e = this.headers.index(this.headers.filter(e)), e === -1 && (e = !1)), n.call(this, e)
        }
    }(jQuery, jQuery.ui.accordion.prototype), jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh, function (e, t) {
        e.extend(t.options, {change: null, changestart: null});
        var n = t._trigger;
        t._trigger = function (e, t, r) {
            var i = n.apply(this, arguments);
            return i ? (e === "beforeActivate" ? i = n.call(this, "changestart", t, {
                oldHeader: r.oldHeader,
                oldContent: r.oldPanel,
                newHeader: r.newHeader,
                newContent: r.newPanel
            }) : e === "activate" && (i = n.call(this, "change", t, {
                oldHeader: r.oldHeader,
                oldContent: r.oldPanel,
                newHeader: r.newHeader,
                newContent: r.newPanel
            })), i) : !1
        }
    }(jQuery, jQuery.ui.accordion.prototype), function (e, t) {
        e.extend(t.options, {animate: null, animated: "slide"});
        var n = t._create;
        t._create = function () {
            var e = this.options;
            e.animate === null && (e.animated ? e.animated === "slide" ? e.animate = 300 : e.animated === "bounceslide" ? e.animate = {
                duration: 200,
                down: {easing: "easeOutBounce", duration: 1e3}
            } : e.animate = e.animated : e.animate = !1), n.call(this)
        }
    }(jQuery, jQuery.ui.accordion.prototype))
}(jQuery), function (e, t) {
    var n = 0;
    e.widget("ui.autocomplete", {
        version: "1.9.1",
        defaultElement: "<input>",
        options: {
            appendTo: "body",
            autoFocus: !1,
            delay: 300,
            minLength: 1,
            position: {my: "left top", at: "left bottom", collision: "none"},
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        pending: 0,
        _create: function () {
            var t, n, r;
            this.isMultiLine = this._isMultiLine(), this.valueMethod = this.element[this.element.is("input,textarea") ? "val" : "text"], this.isNewMenu = !0, this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off"), this._on(this.element, {
                keydown: function (i) {
                    if (this.element.prop("readOnly")) {
                        t = !0, r = !0, n = !0;
                        return
                    }
                    t = !1, r = !1, n = !1;
                    var s = e.ui.keyCode;
                    switch (i.keyCode) {
                        case s.PAGE_UP:
                            t = !0, this._move("previousPage", i);
                            break;
                        case s.PAGE_DOWN:
                            t = !0, this._move("nextPage", i);
                            break;
                        case s.UP:
                            t = !0, this._keyEvent("previous", i);
                            break;
                        case s.DOWN:
                            t = !0, this._keyEvent("next", i);
                            break;
                        case s.ENTER:
                        case s.NUMPAD_ENTER:
                            this.menu.active && (t = !0, i.preventDefault(), this.menu.select(i));
                            break;
                        case s.TAB:
                            this.menu.active && this.menu.select(i);
                            break;
                        case s.ESCAPE:
                            this.menu.element.is(":visible") && (this._value(this.term), this.close(i), i.preventDefault());
                            break;
                        default:
                            n = !0, this._searchTimeout(i)
                    }
                }, keypress: function (r) {
                    if (t) {
                        t = !1, r.preventDefault();
                        return
                    }
                    if (n)return;
                    var i = e.ui.keyCode;
                    switch (r.keyCode) {
                        case i.PAGE_UP:
                            this._move("previousPage", r);
                            break;
                        case i.PAGE_DOWN:
                            this._move("nextPage", r);
                            break;
                        case i.UP:
                            this._keyEvent("previous", r);
                            break;
                        case i.DOWN:
                            this._keyEvent("next", r)
                    }
                }, input: function (e) {
                    if (r) {
                        r = !1, e.preventDefault();
                        return
                    }
                    this._searchTimeout(e)
                }, focus: function () {
                    this.selectedItem = null, this.previous = this._value()
                }, blur: function (e) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return
                    }
                    clearTimeout(this.searching), this.close(e), this._change(e)
                }
            }), this._initSource(), this.menu = e("<ul>").addClass("ui-autocomplete").appendTo(this.document.find(this.options.appendTo || "body")[0]).menu({
                input: e(),
                role: null
            }).zIndex(this.element.zIndex() + 1).hide().data("menu"), this._on(this.menu.element, {
                mousedown: function (t) {
                    t.preventDefault(), this.cancelBlur = !0, this._delay(function () {
                        delete this.cancelBlur
                    });
                    var n = this.menu.element[0];
                    e(t.target).closest(".ui-menu-item").length || this._delay(function () {
                        var t = this;
                        this.document.one("mousedown", function (r) {
                            r.target !== t.element[0] && r.target !== n && !e.contains(n, r.target) && t.close()
                        })
                    })
                }, menufocus: function (t, n) {
                    if (this.isNewMenu) {
                        this.isNewMenu = !1;
                        if (t.originalEvent && /^mouse/.test(t.originalEvent.type)) {
                            this.menu.blur(), this.document.one("mousemove", function () {
                                e(t.target).trigger(t.originalEvent)
                            });
                            return
                        }
                    }
                    var r = n.item.data("ui-autocomplete-item") || n.item.data("item.autocomplete");
                    !1 !== this._trigger("focus", t, {item: r}) ? t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(r.value) : this.liveRegion.text(r.value)
                }, menuselect: function (e, t) {
                    var n = t.item.data("ui-autocomplete-item") || t.item.data("item.autocomplete"), r = this.previous;
                    this.element[0] !== this.document[0].activeElement && (this.element.focus(), this.previous = r, this._delay(function () {
                        this.previous = r, this.selectedItem = n
                    })), !1 !== this._trigger("select", e, {item: n}) && this._value(n.value), this.term = this._value(), this.close(e), this.selectedItem = n
                }
            }), this.liveRegion = e("<span>", {
                role: "status",
                "aria-live": "polite"
            }).addClass("ui-helper-hidden-accessible").insertAfter(this.element), e.fn.bgiframe && this.menu.element.bgiframe(), this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _destroy: function () {
            clearTimeout(this.searching), this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
        },
        _setOption: function (e, t) {
            this._super(e, t), e === "source" && this._initSource(), e === "appendTo" && this.menu.element.appendTo(this.document.find(t || "body")[0]), e === "disabled" && t && this.xhr && this.xhr.abort()
        },
        _isMultiLine: function () {
            return this.element.is("textarea") ? !0 : this.element.is("input") ? !1 : this.element.prop("isContentEditable")
        },
        _initSource: function () {
            var t, n, r = this;
            e.isArray(this.options.source) ? (t = this.options.source, this.source = function (n, r) {
                r(e.ui.autocomplete.filter(t, n.term))
            }) : typeof this.options.source == "string" ? (n = this.options.source, this.source = function (t, i) {
                r.xhr && r.xhr.abort(), r.xhr = e.ajax({
                    url: n, data: t, dataType: "json", success: function (e) {
                        i(e)
                    }, error: function () {
                        i([])
                    }
                })
            }) : this.source = this.options.source
        },
        _searchTimeout: function (e) {
            clearTimeout(this.searching), this.searching = this._delay(function () {
                this.term !== this._value() && (this.selectedItem = null, this.search(null, e))
            }, this.options.delay)
        },
        search: function (e, t) {
            e = e != null ? e : this._value(), this.term = this._value();
            if (e.length < this.options.minLength)return this.close(t);
            if (this._trigger("search", t) === !1)return;
            return this._search(e)
        },
        _search: function (e) {
            this.pending++, this.element.addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({term: e}, this._response())
        },
        _response: function () {
            var e = this, t = ++n;
            return function (r) {
                t === n && e.__response(r), e.pending--, e.pending || e.element.removeClass("ui-autocomplete-loading")
            }
        },
        __response: function (e) {
            e && (e = this._normalize(e)), this._trigger("response", null, {content: e}), !this.options.disabled && e && e.length && !this.cancelSearch ? (this._suggest(e), this._trigger("open")) : this._close()
        },
        close: function (e) {
            this.cancelSearch = !0, this._close(e)
        },
        _close: function (e) {
            this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", e))
        },
        _change: function (e) {
            this.previous !== this._value() && this._trigger("change", e, {item: this.selectedItem})
        },
        _normalize: function (t) {
            return t.length && t[0].label && t[0].value ? t : e.map(t, function (t) {
                return typeof t == "string" ? {label: t, value: t} : e.extend({
                    label: t.label || t.value,
                    value: t.value || t.label
                }, t)
            })
        },
        _suggest: function (t) {
            var n = this.menu.element.empty().zIndex(this.element.zIndex() + 1);
            this._renderMenu(n, t), this.menu.refresh(), n.show(), this._resizeMenu(), n.position(e.extend({of: this.element}, this.options.position)), this.options.autoFocus && this.menu.next()
        },
        _resizeMenu: function () {
            var e = this.menu.element;
            e.outerWidth(Math.max(e.width("").outerWidth() + 1, this.element.outerWidth()))
        },
        _renderMenu: function (t, n) {
            var r = this;
            e.each(n, function (e, n) {
                r._renderItemData(t, n)
            })
        },
        _renderItemData: function (e, t) {
            return this._renderItem(e, t).data("ui-autocomplete-item", t)
        },
        _renderItem: function (t, n) {
            return e("<li>").append(e("<a>").text(n.label)).appendTo(t)
        },
        _move: function (e, t) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, t);
                return
            }
            if (this.menu.isFirstItem() && /^previous/.test(e) || this.menu.isLastItem() && /^next/.test(e)) {
                this._value(this.term), this.menu.blur();
                return
            }
            this.menu[e](t)
        },
        widget: function () {
            return this.menu.element
        },
        _value: function () {
            return this.valueMethod.apply(this.element, arguments)
        },
        _keyEvent: function (e, t) {
            if (!this.isMultiLine || this.menu.element.is(":visible"))this._move(e, t), t.preventDefault()
        }
    }), e.extend(e.ui.autocomplete, {
        escapeRegex: function (e) {
            return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
        }, filter: function (t, n) {
            var r = new RegExp(e.ui.autocomplete.escapeRegex(n), "i");
            return e.grep(t, function (e) {
                return r.test(e.label || e.value || e)
            })
        }
    }), e.widget("ui.autocomplete", e.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (e) {
                    return e + (e > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
                }
            }
        }, __response: function (e) {
            var t;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch)return;
            e && e.length ? t = this.options.messages.results(e.length) : t = this.options.messages.noResults, this.liveRegion.text(t)
        }
    })
}(jQuery), function (e, t) {
    var n, r, i, s, o = "ui-button ui-widget ui-state-default ui-corner-all", u = "ui-state-hover ui-state-active ", a = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", f = function () {
        var t = e(this).find(":ui-button");
        setTimeout(function () {
            t.button("refresh")
        }, 1)
    }, l = function (t) {
        var n = t.name, r = t.form, i = e([]);
        return n && (r ? i = e(r).find("[name='" + n + "']") : i = e("[name='" + n + "']", t.ownerDocument).filter(function () {
            return !this.form
        })), i
    };
    e.widget("ui.button", {
        version: "1.9.1",
        defaultElement: "<button>",
        options: {disabled: null, text: !0, label: null, icons: {primary: null, secondary: null}},
        _create: function () {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, f), typeof this.options.disabled != "boolean" ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
            var t = this, u = this.options, a = this.type === "checkbox" || this.type === "radio", c = "ui-state-hover" + (a ? "" : " ui-state-active"), h = "ui-state-focus";
            u.label === null && (u.label = this.type === "input" ? this.buttonElement.val() : this.buttonElement.html()), this.buttonElement.addClass(o).attr("role", "button").bind("mouseenter" + this.eventNamespace, function () {
                if (u.disabled)return;
                e(this).addClass("ui-state-hover"), this === n && e(this).addClass("ui-state-active")
            }).bind("mouseleave" + this.eventNamespace, function () {
                if (u.disabled)return;
                e(this).removeClass(c)
            }).bind("click" + this.eventNamespace, function (e) {
                u.disabled && (e.preventDefault(), e.stopImmediatePropagation())
            }), this.element.bind("focus" + this.eventNamespace, function () {
                t.buttonElement.addClass(h)
            }).bind("blur" + this.eventNamespace, function () {
                t.buttonElement.removeClass(h)
            }), a && (this.element.bind("change" + this.eventNamespace, function () {
                if (s)return;
                t.refresh()
            }), this.buttonElement.bind("mousedown" + this.eventNamespace, function (e) {
                if (u.disabled)return;
                s = !1, r = e.pageX, i = e.pageY
            }).bind("mouseup" + this.eventNamespace, function (e) {
                if (u.disabled)return;
                if (r !== e.pageX || i !== e.pageY)s = !0
            })), this.type === "checkbox" ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                if (u.disabled || s)return !1;
                e(this).toggleClass("ui-state-active"), t.buttonElement.attr("aria-pressed", t.element[0].checked)
            }) : this.type === "radio" ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                if (u.disabled || s)return !1;
                e(this).addClass("ui-state-active"), t.buttonElement.attr("aria-pressed", "true");
                var n = t.element[0];
                l(n).not(n).map(function () {
                    return e(this).button("widget")[0]
                }).removeClass("ui-state-active").attr("aria-pressed", "false")
            }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function () {
                if (u.disabled)return !1;
                e(this).addClass("ui-state-active"), n = this, t.document.one("mouseup", function () {
                    n = null
                })
            }).bind("mouseup" + this.eventNamespace, function () {
                if (u.disabled)return !1;
                e(this).removeClass("ui-state-active")
            }).bind("keydown" + this.eventNamespace, function (t) {
                if (u.disabled)return !1;
                (t.keyCode === e.ui.keyCode.SPACE || t.keyCode === e.ui.keyCode.ENTER) && e(this).addClass("ui-state-active")
            }).bind("keyup" + this.eventNamespace, function () {
                e(this).removeClass("ui-state-active")
            }), this.buttonElement.is("a") && this.buttonElement.keyup(function (t) {
                t.keyCode === e.ui.keyCode.SPACE && e(this).click()
            })), this._setOption("disabled", u.disabled), this._resetButton()
        },
        _determineButtonType: function () {
            var e, t, n;
            this.element.is("[type=checkbox]") ? this.type = "checkbox" : this.element.is("[type=radio]") ? this.type = "radio" : this.element.is("input") ? this.type = "input" : this.type = "button", this.type === "checkbox" || this.type === "radio" ? (e = this.element.parents().last(), t = "label[for='" + this.element.attr("id") + "']", this.buttonElement = e.find(t), this.buttonElement.length || (e = e.length ? e.siblings() : this.element.siblings(), this.buttonElement = e.filter(t), this.buttonElement.length || (this.buttonElement = e.find(t))), this.element.addClass("ui-helper-hidden-accessible"), n = this.element.is(":checked"), n && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", n)) : this.buttonElement = this.element
        },
        widget: function () {
            return this.buttonElement
        },
        _destroy: function () {
            this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(o + " " + u + " " + a).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), this.hasTitle || this.buttonElement.removeAttr("title")
        },
        _setOption: function (e, t) {
            this._super(e, t);
            if (e === "disabled") {
                t ? this.element.prop("disabled", !0) : this.element.prop("disabled", !1);
                return
            }
            this._resetButton()
        },
        refresh: function () {
            var t = this.element.is(":disabled") || this.element.hasClass("ui-button-disabled");
            t !== this.options.disabled && this._setOption("disabled", t), this.type === "radio" ? l(this.element[0]).each(function () {
                e(this).is(":checked") ? e(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false")
            }) : this.type === "checkbox" && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"))
        },
        _resetButton: function () {
            if (this.type === "input") {
                this.options.label && this.element.val(this.options.label);
                return
            }
            var t = this.buttonElement.removeClass(a), n = e("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(), r = this.options.icons, i = r.primary && r.secondary, s = [];
            r.primary || r.secondary ? (this.options.text && s.push("ui-button-text-icon" + (i ? "s" : r.primary ? "-primary" : "-secondary")), r.primary && t.prepend("<span class='ui-button-icon-primary ui-icon " + r.primary + "'></span>"), r.secondary && t.append("<span class='ui-button-icon-secondary ui-icon " + r.secondary + "'></span>"), this.options.text || (s.push(i ? "ui-button-icons-only" : "ui-button-icon-only"), this.hasTitle || t.attr("title", e.trim(n)))) : s.push("ui-button-text-only"), t.addClass(s.join(" "))
        }
    }), e.widget("ui.buttonset", {
        version: "1.9.1",
        options: {items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"},
        _create: function () {
            this.element.addClass("ui-buttonset")
        },
        _init: function () {
            this.refresh()
        },
        _setOption: function (e, t) {
            e === "disabled" && this.buttons.button("option", e, t), this._super(e, t)
        },
        refresh: function () {
            var t = this.element.css("direction") === "rtl";
            this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function () {
                return e(this).button("widget")[0]
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(t ? "ui-corner-left" : "ui-corner-right").end().end()
        },
        _destroy: function () {
            this.element.removeClass("ui-buttonset"), this.buttons.map(function () {
                return e(this).button("widget")[0]
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy")
        }
    })
}(jQuery), function ($, undefined) {
    function Datepicker() {
        this.debug = !1, this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: !1,
            showMonthAfterYear: !1,
            yearSuffix: ""
        }, this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: !1,
            hideIfNoPrevNext: !1,
            navigationAsDateFormat: !1,
            gotoCurrent: !1,
            changeMonth: !1,
            changeYear: !1,
            yearRange: "c-10:c+10",
            showOtherMonths: !1,
            selectOtherMonths: !1,
            showWeek: !1,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: !0,
            showButtonPanel: !1,
            autoSize: !1,
            disabled: !1
        }, $.extend(this._defaults, this.regional[""]), this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))
    }

    function bindHover(e) {
        var t = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return e.delegate(t, "mouseout", function () {
            $(this).removeClass("ui-state-hover"), this.className.indexOf("ui-datepicker-prev") != -1 && $(this).removeClass("ui-datepicker-prev-hover"), this.className.indexOf("ui-datepicker-next") != -1 && $(this).removeClass("ui-datepicker-next-hover")
        }).delegate(t, "mouseover", function () {
            $.datepicker._isDisabledDatepicker(instActive.inline ? e.parent()[0] : instActive.input[0]) || ($(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), $(this).addClass("ui-state-hover"), this.className.indexOf("ui-datepicker-prev") != -1 && $(this).addClass("ui-datepicker-prev-hover"), this.className.indexOf("ui-datepicker-next") != -1 && $(this).addClass("ui-datepicker-next-hover"))
        })
    }

    function extendRemove(e, t) {
        $.extend(e, t);
        for (var n in t)if (t[n] == null || t[n] == undefined)e[n] = t[n];
        return e
    }

    $.extend($.ui, {datepicker: {version: "1.9.1"}});
    var PROP_NAME = "datepicker", dpuuid = (new Date).getTime(), instActive;
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        log: function () {
            this.debug && console.log.apply("", arguments)
        },
        _widgetDatepicker: function () {
            return this.dpDiv
        },
        setDefaults: function (e) {
            return extendRemove(this._defaults, e || {}), this
        },
        _attachDatepicker: function (target, settings) {
            var inlineSettings = null;
            for (var attrName in this._defaults) {
                var attrValue = target.getAttribute("date:" + attrName);
                if (attrValue) {
                    inlineSettings = inlineSettings || {};
                    try {
                        inlineSettings[attrName] = eval(attrValue)
                    } catch (err) {
                        inlineSettings[attrName] = attrValue
                    }
                }
            }
            var nodeName = target.nodeName.toLowerCase(), inline = nodeName == "div" || nodeName == "span";
            target.id || (this.uuid += 1, target.id = "dp" + this.uuid);
            var inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {}, inlineSettings || {}), nodeName == "input" ? this._connectDatepicker(target, inst) : inline && this._inlineDatepicker(target, inst)
        },
        _newInst: function (e, t) {
            var n = e[0].id.replace(/([^A-Za-z0-9_-])/g, "\\\\$1");
            return {
                id: n,
                input: e,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: t,
                dpDiv: t ? bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')) : this.dpDiv
            }
        },
        _connectDatepicker: function (e, t) {
            var n = $(e);
            t.append = $([]), t.trigger = $([]);
            if (n.hasClass(this.markerClassName))return;
            this._attachments(n, t), n.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker", function (e, n, r) {
                t.settings[n] = r
            }).bind("getData.datepicker", function (e, n) {
                return this._get(t, n)
            }), this._autoSize(t), $.data(e, PROP_NAME, t), t.settings.disabled && this._disableDatepicker(e)
        },
        _attachments: function (e, t) {
            var n = this._get(t, "appendText"), r = this._get(t, "isRTL");
            t.append && t.append.remove(), n && (t.append = $('<span class="' + this._appendClass + '">' + n + "</span>"), e[r ? "before" : "after"](t.append)), e.unbind("focus", this._showDatepicker), t.trigger && t.trigger.remove();
            var i = this._get(t, "showOn");
            (i == "focus" || i == "both") && e.focus(this._showDatepicker);
            if (i == "button" || i == "both") {
                var s = this._get(t, "buttonText"), o = this._get(t, "buttonImage");
                t.trigger = $(this._get(t, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: o,
                    alt: s,
                    title: s
                }) : $('<button type="button"></button>').addClass(this._triggerClass).html(o == "" ? s : $("<img/>").attr({
                    src: o,
                    alt: s,
                    title: s
                }))), e[r ? "before" : "after"](t.trigger), t.trigger.click(function () {
                    return $.datepicker._datepickerShowing && $.datepicker._lastInput == e[0] ? $.datepicker._hideDatepicker() : $.datepicker._datepickerShowing && $.datepicker._lastInput != e[0] ? ($.datepicker._hideDatepicker(), $.datepicker._showDatepicker(e[0])) : $.datepicker._showDatepicker(e[0]), !1
                })
            }
        },
        _autoSize: function (e) {
            if (this._get(e, "autoSize") && !e.inline) {
                var t = new Date(2009, 11, 20), n = this._get(e, "dateFormat");
                if (n.match(/[DM]/)) {
                    var r = function (e) {
                        var t = 0, n = 0;
                        for (var r = 0; r < e.length; r++)e[r].length > t && (t = e[r].length, n = r);
                        return n
                    };
                    t.setMonth(r(this._get(e, n.match(/MM/) ? "monthNames" : "monthNamesShort"))), t.setDate(r(this._get(e, n.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - t.getDay())
                }
                e.input.attr("size", this._formatDate(e, t).length)
            }
        },
        _inlineDatepicker: function (e, t) {
            var n = $(e);
            if (n.hasClass(this.markerClassName))return;
            n.addClass(this.markerClassName).append(t.dpDiv).bind("setData.datepicker", function (e, n, r) {
                t.settings[n] = r
            }).bind("getData.datepicker", function (e, n) {
                return this._get(t, n)
            }), $.data(e, PROP_NAME, t), this._setDate(t, this._getDefaultDate(t), !0), this._updateDatepicker(t), this._updateAlternate(t), t.settings.disabled && this._disableDatepicker(e), t.dpDiv.css("display", "block")
        },
        _dialogDatepicker: function (e, t, n, r, i) {
            var s = this._dialogInst;
            if (!s) {
                this.uuid += 1;
                var o = "dp" + this.uuid;
                this._dialogInput = $('<input type="text" id="' + o + '" style="position: absolute; top: -100px; width: 0px;"/>'), this._dialogInput.keydown(this._doKeyDown), $("body").append(this._dialogInput), s = this._dialogInst = this._newInst(this._dialogInput, !1), s.settings = {}, $.data(this._dialogInput[0], PROP_NAME, s)
            }
            extendRemove(s.settings, r || {}), t = t && t.constructor == Date ? this._formatDate(s, t) : t, this._dialogInput.val(t), this._pos = i ? i.length ? i : [i.pageX, i.pageY] : null;
            if (!this._pos) {
                var u = document.documentElement.clientWidth, a = document.documentElement.clientHeight, f = document.documentElement.scrollLeft || document.body.scrollLeft, l = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [u / 2 - 100 + f, a / 2 - 150 + l]
            }
            return this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), s.settings.onSelect = n, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), $.blockUI && $.blockUI(this.dpDiv), $.data(this._dialogInput[0], PROP_NAME, s), this
        },
        _destroyDatepicker: function (e) {
            var t = $(e), n = $.data(e, PROP_NAME);
            if (!t.hasClass(this.markerClassName))return;
            var r = e.nodeName.toLowerCase();
            $.removeData(e, PROP_NAME), r == "input" ? (n.append.remove(), n.trigger.remove(), t.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : (r == "div" || r == "span") && t.removeClass(this.markerClassName).empty()
        },
        _enableDatepicker: function (e) {
            var t = $(e), n = $.data(e, PROP_NAME);
            if (!t.hasClass(this.markerClassName))return;
            var r = e.nodeName.toLowerCase();
            if (r == "input")e.disabled = !1, n.trigger.filter("button").each(function () {
                this.disabled = !1
            }).end().filter("img").css({opacity: "1.0", cursor: ""}); else if (r == "div" || r == "span") {
                var i = t.children("." + this._inlineClass);
                i.children().removeClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)
            }
            this._disabledInputs = $.map(this._disabledInputs, function (t) {
                return t == e ? null : t
            })
        },
        _disableDatepicker: function (e) {
            var t = $(e), n = $.data(e, PROP_NAME);
            if (!t.hasClass(this.markerClassName))return;
            var r = e.nodeName.toLowerCase();
            if (r == "input")e.disabled = !0, n.trigger.filter("button").each(function () {
                this.disabled = !0
            }).end().filter("img").css({opacity: "0.5", cursor: "default"}); else if (r == "div" || r == "span") {
                var i = t.children("." + this._inlineClass);
                i.children().addClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)
            }
            this._disabledInputs = $.map(this._disabledInputs, function (t) {
                return t == e ? null : t
            }), this._disabledInputs[this._disabledInputs.length] = e
        },
        _isDisabledDatepicker: function (e) {
            if (!e)return !1;
            for (var t = 0; t < this._disabledInputs.length; t++)if (this._disabledInputs[t] == e)return !0;
            return !1
        },
        _getInst: function (e) {
            try {
                return $.data(e, PROP_NAME)
            } catch (t) {
                throw"Missing instance data for this datepicker"
            }
        },
        _optionDatepicker: function (e, t, n) {
            var r = this._getInst(e);
            if (arguments.length == 2 && typeof t == "string")return t == "defaults" ? $.extend({}, $.datepicker._defaults) : r ? t == "all" ? $.extend({}, r.settings) : this._get(r, t) : null;
            var i = t || {};
            typeof t == "string" && (i = {}, i[t] = n);
            if (r) {
                this._curInst == r && this._hideDatepicker();
                var s = this._getDateDatepicker(e, !0), o = this._getMinMaxDate(r, "min"), u = this._getMinMaxDate(r, "max");
                extendRemove(r.settings, i), o !== null && i.dateFormat !== undefined && i.minDate === undefined && (r.settings.minDate = this._formatDate(r, o)), u !== null && i.dateFormat !== undefined && i.maxDate === undefined && (r.settings.maxDate = this._formatDate(r, u)), this._attachments($(e), r), this._autoSize(r), this._setDate(r, s), this._updateAlternate(r), this._updateDatepicker(r)
            }
        },
        _changeDatepicker: function (e, t, n) {
            this._optionDatepicker(e, t, n)
        },
        _refreshDatepicker: function (e) {
            var t = this._getInst(e);
            t && this._updateDatepicker(t)
        },
        _setDateDatepicker: function (e, t) {
            var n = this._getInst(e);
            n && (this._setDate(n, t), this._updateDatepicker(n), this._updateAlternate(n))
        },
        _getDateDatepicker: function (e, t) {
            var n = this._getInst(e);
            return n && !n.inline && this._setDateFromField(n, t), n ? this._getDate(n) : null
        },
        _doKeyDown: function (e) {
            var t = $.datepicker._getInst(e.target), n = !0, r = t.dpDiv.is(".ui-datepicker-rtl");
            t._keyEvent = !0;
            if ($.datepicker._datepickerShowing)switch (e.keyCode) {
                case 9:
                    $.datepicker._hideDatepicker(), n = !1;
                    break;
                case 13:
                    var i = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", t.dpDiv);
                    i[0] && $.datepicker._selectDay(e.target, t.selectedMonth, t.selectedYear, i[0]);
                    var s = $.datepicker._get(t, "onSelect");
                    if (s) {
                        var o = $.datepicker._formatDate(t);
                        s.apply(t.input ? t.input[0] : null, [o, t])
                    } else $.datepicker._hideDatepicker();
                    return !1;
                case 27:
                    $.datepicker._hideDatepicker();
                    break;
                case 33:
                    $.datepicker._adjustDate(e.target, e.ctrlKey ? -$.datepicker._get(t, "stepBigMonths") : -$.datepicker._get(t, "stepMonths"), "M");
                    break;
                case 34:
                    $.datepicker._adjustDate(e.target, e.ctrlKey ? +$.datepicker._get(t, "stepBigMonths") : +$.datepicker._get(t, "stepMonths"), "M");
                    break;
                case 35:
                    (e.ctrlKey || e.metaKey) && $.datepicker._clearDate(e.target), n = e.ctrlKey || e.metaKey;
                    break;
                case 36:
                    (e.ctrlKey || e.metaKey) && $.datepicker._gotoToday(e.target), n = e.ctrlKey || e.metaKey;
                    break;
                case 37:
                    (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, r ? 1 : -1, "D"), n = e.ctrlKey || e.metaKey, e.originalEvent.altKey && $.datepicker._adjustDate(e.target, e.ctrlKey ? -$.datepicker._get(t, "stepBigMonths") : -$.datepicker._get(t, "stepMonths"), "M");
                    break;
                case 38:
                    (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, -7, "D"), n = e.ctrlKey || e.metaKey;
                    break;
                case 39:
                    (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, r ? -1 : 1, "D"), n = e.ctrlKey || e.metaKey, e.originalEvent.altKey && $.datepicker._adjustDate(e.target, e.ctrlKey ? +$.datepicker._get(t, "stepBigMonths") : +$.datepicker._get(t, "stepMonths"), "M");
                    break;
                case 40:
                    (e.ctrlKey || e.metaKey) && $.datepicker._adjustDate(e.target, 7, "D"), n = e.ctrlKey || e.metaKey;
                    break;
                default:
                    n = !1
            } else e.keyCode == 36 && e.ctrlKey ? $.datepicker._showDatepicker(this) : n = !1;
            n && (e.preventDefault(), e.stopPropagation())
        },
        _doKeyPress: function (e) {
            var t = $.datepicker._getInst(e.target);
            if ($.datepicker._get(t, "constrainInput")) {
                var n = $.datepicker._possibleChars($.datepicker._get(t, "dateFormat")), r = String.fromCharCode(e.charCode == undefined ? e.keyCode : e.charCode);
                return e.ctrlKey || e.metaKey || r < " " || !n || n.indexOf(r) > -1
            }
        },
        _doKeyUp: function (e) {
            var t = $.datepicker._getInst(e.target);
            if (t.input.val() != t.lastVal)try {
                var n = $.datepicker.parseDate($.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, $.datepicker._getFormatConfig(t));
                n && ($.datepicker._setDateFromField(t), $.datepicker._updateAlternate(t), $.datepicker._updateDatepicker(t))
            } catch (r) {
                $.datepicker.log(r)
            }
            return !0
        },
        _showDatepicker: function (e) {
            e = e.target || e, e.nodeName.toLowerCase() != "input" && (e = $("input", e.parentNode)[0]);
            if ($.datepicker._isDisabledDatepicker(e) || $.datepicker._lastInput == e)return;
            var t = $.datepicker._getInst(e);
            $.datepicker._curInst && $.datepicker._curInst != t && ($.datepicker._curInst.dpDiv.stop(!0, !0), t && $.datepicker._datepickerShowing && $.datepicker._hideDatepicker($.datepicker._curInst.input[0]));
            var n = $.datepicker._get(t, "beforeShow"), r = n ? n.apply(e, [e, t]) : {};
            if (r === !1)return;
            extendRemove(t.settings, r), t.lastVal = null, $.datepicker._lastInput = e, $.datepicker._setDateFromField(t), $.datepicker._inDialog && (e.value = ""), $.datepicker._pos || ($.datepicker._pos = $.datepicker._findPos(e), $.datepicker._pos[1] += e.offsetHeight);
            var i = !1;
            $(e).parents().each(function () {
                return i |= $(this).css("position") == "fixed", !i
            });
            var s = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
            $.datepicker._pos = null, t.dpDiv.empty(), t.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            }), $.datepicker._updateDatepicker(t), s = $.datepicker._checkOffset(t, s, i), t.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? "static" : i ? "fixed" : "absolute",
                display: "none",
                left: s.left + "px",
                top: s.top + "px"
            });
            if (!t.inline) {
                var o = $.datepicker._get(t, "showAnim"), u = $.datepicker._get(t, "duration"), a = function () {
                    var e = t.dpDiv.find("iframe.ui-datepicker-cover");
                    if (!!e.length) {
                        var n = $.datepicker._getBorders(t.dpDiv);
                        e.css({left: -n[0], top: -n[1], width: t.dpDiv.outerWidth(), height: t.dpDiv.outerHeight()})
                    }
                };
                t.dpDiv.zIndex($(e).zIndex() + 1), $.datepicker._datepickerShowing = !0, $.effects && ($.effects.effect[o] || $.effects[o]) ? t.dpDiv.show(o, $.datepicker._get(t, "showOptions"), u, a) : t.dpDiv[o || "show"](o ? u : null, a), (!o || !u) && a(), t.input.is(":visible") && !t.input.is(":disabled") && t.input.focus(), $.datepicker._curInst = t
            }
        },
        _updateDatepicker: function (e) {
            this.maxRows = 4;
            var t = $.datepicker._getBorders(e.dpDiv);
            instActive = e, e.dpDiv.empty().append(this._generateHTML(e)), this._attachHandlers(e);
            var n = e.dpDiv.find("iframe.ui-datepicker-cover");
            !n.length || n.css({
                left: -t[0],
                top: -t[1],
                width: e.dpDiv.outerWidth(),
                height: e.dpDiv.outerHeight()
            }), e.dpDiv.find("." + this._dayOverClass + " a").mouseover();
            var r = this._getNumberOfMonths(e), i = r[1], s = 17;
            e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), i > 1 && e.dpDiv.addClass("ui-datepicker-multi-" + i).css("width", s * i + "em"), e.dpDiv[(r[0] != 1 || r[1] != 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi"), e.dpDiv[(this._get(e, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), e == $.datepicker._curInst && $.datepicker._datepickerShowing && e.input && e.input.is(":visible") && !e.input.is(":disabled") && e.input[0] != document.activeElement && e.input.focus();
            if (e.yearshtml) {
                var o = e.yearshtml;
                setTimeout(function () {
                    o === e.yearshtml && e.yearshtml && e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml), o = e.yearshtml = null
                }, 0)
            }
        },
        _getBorders: function (e) {
            var t = function (e) {
                return {thin: 1, medium: 2, thick: 3}[e] || e
            };
            return [parseFloat(t(e.css("border-left-width"))), parseFloat(t(e.css("border-top-width")))]
        },
        _checkOffset: function (e, t, n) {
            var r = e.dpDiv.outerWidth(), i = e.dpDiv.outerHeight(), s = e.input ? e.input.outerWidth() : 0, o = e.input ? e.input.outerHeight() : 0, u = document.documentElement.clientWidth + (n ? 0 : $(document).scrollLeft()), a = document.documentElement.clientHeight + (n ? 0 : $(document).scrollTop());
            return t.left -= this._get(e, "isRTL") ? r - s : 0, t.left -= n && t.left == e.input.offset().left ? $(document).scrollLeft() : 0, t.top -= n && t.top == e.input.offset().top + o ? $(document).scrollTop() : 0, t.left -= Math.min(t.left, t.left + r > u && u > r ? Math.abs(t.left + r - u) : 0), t.top -= Math.min(t.top, t.top + i > a && a > i ? Math.abs(i + o) : 0), t
        },
        _findPos: function (e) {
            var t = this._getInst(e), n = this._get(t, "isRTL");
            while (e && (e.type == "hidden" || e.nodeType != 1 || $.expr.filters.hidden(e)))e = e[n ? "previousSibling" : "nextSibling"];
            var r = $(e).offset();
            return [r.left, r.top]
        },
        _hideDatepicker: function (e) {
            var t = this._curInst;
            if (!t || e && t != $.data(e, PROP_NAME))return;
            if (this._datepickerShowing) {
                var n = this._get(t, "showAnim"), r = this._get(t, "duration"), i = function () {
                    $.datepicker._tidyDialog(t)
                };
                $.effects && ($.effects.effect[n] || $.effects[n]) ? t.dpDiv.hide(n, $.datepicker._get(t, "showOptions"), r, i) : t.dpDiv[n == "slideDown" ? "slideUp" : n == "fadeIn" ? "fadeOut" : "hide"](n ? r : null, i), n || i(), this._datepickerShowing = !1;
                var s = this._get(t, "onClose");
                s && s.apply(t.input ? t.input[0] : null, [t.input ? t.input.val() : "", t]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
                    position: "absolute",
                    left: "0",
                    top: "-100px"
                }), $.blockUI && ($.unblockUI(), $("body").append(this.dpDiv))), this._inDialog = !1
            }
        },
        _tidyDialog: function (e) {
            e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")
        },
        _checkExternalClick: function (e) {
            if (!$.datepicker._curInst)return;
            var t = $(e.target), n = $.datepicker._getInst(t[0]);
            (t[0].id != $.datepicker._mainDivId && t.parents("#" + $.datepicker._mainDivId).length == 0 && !t.hasClass($.datepicker.markerClassName) && !t.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && (!$.datepicker._inDialog || !$.blockUI) || t.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != n) && $.datepicker._hideDatepicker()
        },
        _adjustDate: function (e, t, n) {
            var r = $(e), i = this._getInst(r[0]);
            if (this._isDisabledDatepicker(r[0]))return;
            this._adjustInstDate(i, t + (n == "M" ? this._get(i, "showCurrentAtPos") : 0), n), this._updateDatepicker(i)
        },
        _gotoToday: function (e) {
            var t = $(e), n = this._getInst(t[0]);
            if (this._get(n, "gotoCurrent") && n.currentDay)n.selectedDay = n.currentDay, n.drawMonth = n.selectedMonth = n.currentMonth, n.drawYear = n.selectedYear = n.currentYear; else {
                var r = new Date;
                n.selectedDay = r.getDate(), n.drawMonth = n.selectedMonth = r.getMonth(), n.drawYear = n.selectedYear = r.getFullYear()
            }
            this._notifyChange(n), this._adjustDate(t)
        },
        _selectMonthYear: function (e, t, n) {
            var r = $(e), i = this._getInst(r[0]);
            i["selected" + (n == "M" ? "Month" : "Year")] = i["draw" + (n == "M" ? "Month" : "Year")] = parseInt(t.options[t.selectedIndex].value, 10), this._notifyChange(i), this._adjustDate(r)
        },
        _selectDay: function (e, t, n, r) {
            var i = $(e);
            if ($(r).hasClass(this._unselectableClass) || this._isDisabledDatepicker(i[0]))return;
            var s = this._getInst(i[0]);
            s.selectedDay = s.currentDay = $("a", r).html(), s.selectedMonth = s.currentMonth = t, s.selectedYear = s.currentYear = n, this._selectDate(e, this._formatDate(s, s.currentDay, s.currentMonth, s.currentYear))
        },
        _clearDate: function (e) {
            var t = $(e), n = this._getInst(t[0]);
            this._selectDate(t, "")
        },
        _selectDate: function (e, t) {
            var n = $(e), r = this._getInst(n[0]);
            t = t != null ? t : this._formatDate(r), r.input && r.input.val(t), this._updateAlternate(r);
            var i = this._get(r, "onSelect");
            i ? i.apply(r.input ? r.input[0] : null, [t, r]) : r.input && r.input.trigger("change"), r.inline ? this._updateDatepicker(r) : (this._hideDatepicker(), this._lastInput = r.input[0], typeof r.input[0] != "object" && r.input.focus(), this._lastInput = null)
        },
        _updateAlternate: function (e) {
            var t = this._get(e, "altField");
            if (t) {
                var n = this._get(e, "altFormat") || this._get(e, "dateFormat"), r = this._getDate(e), i = this.formatDate(n, r, this._getFormatConfig(e));
                $(t).each(function () {
                    $(this).val(i)
                })
            }
        },
        noWeekends: function (e) {
            var t = e.getDay();
            return [t > 0 && t < 6, ""]
        },
        iso8601Week: function (e) {
            var t = new Date(e.getTime());
            t.setDate(t.getDate() + 4 - (t.getDay() || 7));
            var n = t.getTime();
            return t.setMonth(0), t.setDate(1), Math.floor(Math.round((n - t) / 864e5) / 7) + 1
        },
        parseDate: function (e, t, n) {
            if (e == null || t == null)throw"Invalid arguments";
            t = typeof t == "object" ? t.toString() : t + "";
            if (t == "")return null;
            var r = (n ? n.shortYearCutoff : null) || this._defaults.shortYearCutoff;
            r = typeof r != "string" ? r : (new Date).getFullYear() % 100 + parseInt(r, 10);
            var i = (n ? n.dayNamesShort : null) || this._defaults.dayNamesShort, s = (n ? n.dayNames : null) || this._defaults.dayNames, o = (n ? n.monthNamesShort : null) || this._defaults.monthNamesShort, u = (n ? n.monthNames : null) || this._defaults.monthNames, a = -1, f = -1, l = -1, c = -1, h = !1, p = function (t) {
                var n = y + 1 < e.length && e.charAt(y + 1) == t;
                return n && y++, n
            }, d = function (e) {
                var n = p(e), r = e == "@" ? 14 : e == "!" ? 20 : e == "y" && n ? 4 : e == "o" ? 3 : 2, i = new RegExp("^\\d{1," + r + "}"), s = t.substring(g).match(i);
                if (!s)throw"Missing number at position " + g;
                return g += s[0].length, parseInt(s[0], 10)
            }, v = function (e, n, r) {
                var i = $.map(p(e) ? r : n, function (e, t) {
                    return [[t, e]]
                }).sort(function (e, t) {
                    return -(e[1].length - t[1].length)
                }), s = -1;
                $.each(i, function (e, n) {
                    var r = n[1];
                    if (t.substr(g, r.length).toLowerCase() == r.toLowerCase())return s = n[0], g += r.length, !1
                });
                if (s != -1)return s + 1;
                throw"Unknown name at position " + g
            }, m = function () {
                if (t.charAt(g) != e.charAt(y))throw"Unexpected literal at position " + g;
                g++
            }, g = 0;
            for (var y = 0; y < e.length; y++)if (h)e.charAt(y) == "'" && !p("'") ? h = !1 : m(); else switch (e.charAt(y)) {
                case"d":
                    l = d("d");
                    break;
                case"D":
                    v("D", i, s);
                    break;
                case"o":
                    c = d("o");
                    break;
                case"m":
                    f = d("m");
                    break;
                case"M":
                    f = v("M", o, u);
                    break;
                case"y":
                    a = d("y");
                    break;
                case"@":
                    var b = new Date(d("@"));
                    a = b.getFullYear(), f = b.getMonth() + 1, l = b.getDate();
                    break;
                case"!":
                    var b = new Date((d("!") - this._ticksTo1970) / 1e4);
                    a = b.getFullYear(), f = b.getMonth() + 1, l = b.getDate();
                    break;
                case"'":
                    p("'") ? m() : h = !0;
                    break;
                default:
                    m()
            }
            if (g < t.length) {
                var w = t.substr(g);
                if (!/^\s+/.test(w))throw"Extra/unparsed characters found in date: " + w
            }
            a == -1 ? a = (new Date).getFullYear() : a < 100 && (a += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (a <= r ? 0 : -100));
            if (c > -1) {
                f = 1, l = c;
                do {
                    var E = this._getDaysInMonth(a, f - 1);
                    if (l <= E)break;
                    f++, l -= E
                } while (!0)
            }
            var b = this._daylightSavingAdjust(new Date(a, f - 1, l));
            if (b.getFullYear() != a || b.getMonth() + 1 != f || b.getDate() != l)throw"Invalid date";
            return b
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 24 * 60 * 60 * 1e7,
        formatDate: function (e, t, n) {
            if (!t)return "";
            var r = (n ? n.dayNamesShort : null) || this._defaults.dayNamesShort, i = (n ? n.dayNames : null) || this._defaults.dayNames, s = (n ? n.monthNamesShort : null) || this._defaults.monthNamesShort, o = (n ? n.monthNames : null) || this._defaults.monthNames, u = function (t) {
                var n = h + 1 < e.length && e.charAt(h + 1) == t;
                return n && h++, n
            }, a = function (e, t, n) {
                var r = "" + t;
                if (u(e))while (r.length < n)r = "0" + r;
                return r
            }, f = function (e, t, n, r) {
                return u(e) ? r[t] : n[t]
            }, l = "", c = !1;
            if (t)for (var h = 0; h < e.length; h++)if (c)e.charAt(h) == "'" && !u("'") ? c = !1 : l += e.charAt(h); else switch (e.charAt(h)) {
                case"d":
                    l += a("d", t.getDate(), 2);
                    break;
                case"D":
                    l += f("D", t.getDay(), r, i);
                    break;
                case"o":
                    l += a("o", Math.round(((new Date(t.getFullYear(), t.getMonth(), t.getDate())).getTime() - (new Date(t.getFullYear(), 0, 0)).getTime()) / 864e5), 3);
                    break;
                case"m":
                    l += a("m", t.getMonth() + 1, 2);
                    break;
                case"M":
                    l += f("M", t.getMonth(), s, o);
                    break;
                case"y":
                    l += u("y") ? t.getFullYear() : (t.getYear() % 100 < 10 ? "0" : "") + t.getYear() % 100;
                    break;
                case"@":
                    l += t.getTime();
                    break;
                case"!":
                    l += t.getTime() * 1e4 + this._ticksTo1970;
                    break;
                case"'":
                    u("'") ? l += "'" : c = !0;
                    break;
                default:
                    l += e.charAt(h)
            }
            return l
        },
        _possibleChars: function (e) {
            var t = "", n = !1, r = function (t) {
                var n = i + 1 < e.length && e.charAt(i + 1) == t;
                return n && i++, n
            };
            for (var i = 0; i < e.length; i++)if (n)e.charAt(i) == "'" && !r("'") ? n = !1 : t += e.charAt(i); else switch (e.charAt(i)) {
                case"d":
                case"m":
                case"y":
                case"@":
                    t += "0123456789";
                    break;
                case"D":
                case"M":
                    return null;
                case"'":
                    r("'") ? t += "'" : n = !0;
                    break;
                default:
                    t += e.charAt(i)
            }
            return t
        },
        _get: function (e, t) {
            return e.settings[t] !== undefined ? e.settings[t] : this._defaults[t]
        },
        _setDateFromField: function (e, t) {
            if (e.input.val() == e.lastVal)return;
            var n = this._get(e, "dateFormat"), r = e.lastVal = e.input ? e.input.val() : null, i, s;
            i = s = this._getDefaultDate(e);
            var o = this._getFormatConfig(e);
            try {
                i = this.parseDate(n, r, o) || s
            } catch (u) {
                this.log(u), r = t ? "" : r
            }
            e.selectedDay = i.getDate(), e.drawMonth = e.selectedMonth = i.getMonth(), e.drawYear = e.selectedYear = i.getFullYear(), e.currentDay = r ? i.getDate() : 0, e.currentMonth = r ? i.getMonth() : 0, e.currentYear = r ? i.getFullYear() : 0, this._adjustInstDate(e)
        },
        _getDefaultDate: function (e) {
            return this._restrictMinMax(e, this._determineDate(e, this._get(e, "defaultDate"), new Date))
        },
        _determineDate: function (e, t, n) {
            var r = function (e) {
                var t = new Date;
                return t.setDate(t.getDate() + e), t
            }, i = function (t) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(e, "dateFormat"), t, $.datepicker._getFormatConfig(e))
                } catch (n) {
                }
                var r = (t.toLowerCase().match(/^c/) ? $.datepicker._getDate(e) : null) || new Date, i = r.getFullYear(), s = r.getMonth(), o = r.getDate(), u = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, a = u.exec(t);
                while (a) {
                    switch (a[2] || "d") {
                        case"d":
                        case"D":
                            o += parseInt(a[1], 10);
                            break;
                        case"w":
                        case"W":
                            o += parseInt(a[1], 10) * 7;
                            break;
                        case"m":
                        case"M":
                            s += parseInt(a[1], 10), o = Math.min(o, $.datepicker._getDaysInMonth(i, s));
                            break;
                        case"y":
                        case"Y":
                            i += parseInt(a[1], 10), o = Math.min(o, $.datepicker._getDaysInMonth(i, s))
                    }
                    a = u.exec(t)
                }
                return new Date(i, s, o)
            }, s = t == null || t === "" ? n : typeof t == "string" ? i(t) : typeof t == "number" ? isNaN(t) ? n : r(t) : new Date(t.getTime());
            return s = s && s.toString() == "Invalid Date" ? n : s, s && (s.setHours(0), s.setMinutes(0), s.setSeconds(0), s.setMilliseconds(0)), this._daylightSavingAdjust(s)
        },
        _daylightSavingAdjust: function (e) {
            return e ? (e.setHours(e.getHours() > 12 ? e.getHours() + 2 : 0), e) : null
        },
        _setDate: function (e, t, n) {
            var r = !t, i = e.selectedMonth, s = e.selectedYear, o = this._restrictMinMax(e, this._determineDate(e, t, new Date));
            e.selectedDay = e.currentDay = o.getDate(), e.drawMonth = e.selectedMonth = e.currentMonth = o.getMonth(), e.drawYear = e.selectedYear = e.currentYear = o.getFullYear(), (i != e.selectedMonth || s != e.selectedYear) && !n && this._notifyChange(e), this._adjustInstDate(e), e.input && e.input.val(r ? "" : this._formatDate(e))
        },
        _getDate: function (e) {
            var t = !e.currentYear || e.input && e.input.val() == "" ? null : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
            return t
        },
        _attachHandlers: function (e) {
            var t = this._get(e, "stepMonths"), n = "#" + e.id.replace(/\\\\/g, "\\");
            e.dpDiv.find("[data-handler]").map(function () {
                var e = {
                    prev: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._adjustDate(n, -t, "M")
                    }, next: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._adjustDate(n, +t, "M")
                    }, hide: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._hideDatepicker()
                    }, today: function () {
                        window["DP_jQuery_" + dpuuid].datepicker._gotoToday(n)
                    }, selectDay: function () {
                        return window["DP_jQuery_" + dpuuid].datepicker._selectDay(n, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
                    }, selectMonth: function () {
                        return window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(n, this, "M"), !1
                    }, selectYear: function () {
                        return window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(n, this, "Y"), !1
                    }
                };
                $(this).bind(this.getAttribute("data-event"), e[this.getAttribute("data-handler")])
            })
        },
        _generateHTML: function (e) {
            var t = new Date;
            t = this._daylightSavingAdjust(new Date(t.getFullYear(), t.getMonth(), t.getDate()));
            var n = this._get(e, "isRTL"), r = this._get(e, "showButtonPanel"), i = this._get(e, "hideIfNoPrevNext"), s = this._get(e, "navigationAsDateFormat"), o = this._getNumberOfMonths(e), u = this._get(e, "showCurrentAtPos"), a = this._get(e, "stepMonths"), f = o[0] != 1 || o[1] != 1, l = this._daylightSavingAdjust(e.currentDay ? new Date(e.currentYear, e.currentMonth, e.currentDay) : new Date(9999, 9, 9)), c = this._getMinMaxDate(e, "min"), h = this._getMinMaxDate(e, "max"), p = e.drawMonth - u, d = e.drawYear;
            p < 0 && (p += 12, d--);
            if (h) {
                var v = this._daylightSavingAdjust(new Date(h.getFullYear(), h.getMonth() - o[0] * o[1] + 1, h.getDate()));
                v = c && v < c ? c : v;
                while (this._daylightSavingAdjust(new Date(d, p, 1)) > v)p--, p < 0 && (p = 11, d--)
            }
            e.drawMonth = p, e.drawYear = d;
            var m = this._get(e, "prevText");
            m = s ? this.formatDate(m, this._daylightSavingAdjust(new Date(d, p - a, 1)), this._getFormatConfig(e)) : m;
            var g = this._canAdjustMonth(e, -1, d, p) ? '<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click" title="' + m + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "e" : "w") + '">' + m + "</span></a>" : i ? "" : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="' + m + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "e" : "w") + '">' + m + "</span></a>", y = this._get(e, "nextText");
            y = s ? this.formatDate(y, this._daylightSavingAdjust(new Date(d, p + a, 1)), this._getFormatConfig(e)) : y;
            var b = this._canAdjustMonth(e, 1, d, p) ? '<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click" title="' + y + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "w" : "e") + '">' + y + "</span></a>" : i ? "" : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="' + y + '"><span class="ui-icon ui-icon-circle-triangle-' + (n ? "w" : "e") + '">' + y + "</span></a>", w = this._get(e, "currentText"), E = this._get(e, "gotoCurrent") && e.currentDay ? l : t;
            w = s ? this.formatDate(w, E, this._getFormatConfig(e)) : w;
            var S = e.inline ? "" : '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' + this._get(e, "closeText") + "</button>", x = r ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (n ? S : "") + (this._isInRange(e, E) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click">' + w + "</button>" : "") + (n ? "" : S) + "</div>" : "", T = parseInt(this._get(e, "firstDay"), 10);
            T = isNaN(T) ? 0 : T;
            var N = this._get(e, "showWeek"), C = this._get(e, "dayNames"), k = this._get(e, "dayNamesShort"), L = this._get(e, "dayNamesMin"), A = this._get(e, "monthNames"), O = this._get(e, "monthNamesShort"), M = this._get(e, "beforeShowDay"), _ = this._get(e, "showOtherMonths"), D = this._get(e, "selectOtherMonths"), P = this._get(e, "calculateWeek") || this.iso8601Week, H = this._getDefaultDate(e), B = "";
            for (var j = 0; j < o[0]; j++) {
                var F = "";
                this.maxRows = 4;
                for (var I = 0; I < o[1]; I++) {
                    var q = this._daylightSavingAdjust(new Date(d, p, e.selectedDay)), R = " ui-corner-all", U = "";
                    if (f) {
                        U += '<div class="ui-datepicker-group';
                        if (o[1] > 1)switch (I) {
                            case 0:
                                U += " ui-datepicker-group-first", R = " ui-corner-" + (n ? "right" : "left");
                                break;
                            case o[1] - 1:
                                U += " ui-datepicker-group-last", R = " ui-corner-" + (n ? "left" : "right");
                                break;
                            default:
                                U += " ui-datepicker-group-middle", R = ""
                        }
                        U += '">'
                    }
                    U += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + R + '">' + (/all|left/.test(R) && j == 0 ? n ? b : g : "") + (/all|right/.test(R) && j == 0 ? n ? g : b : "") + this._generateMonthYearHeader(e, p, d, c, h, j > 0 || I > 0, A, O) + '</div><table class="ui-datepicker-calendar"><thead>' + "<tr>";
                    var z = N ? '<th class="ui-datepicker-week-col">' + this._get(e, "weekHeader") + "</th>" : "";
                    for (var W = 0; W < 7; W++) {
                        var X = (W + T) % 7;
                        z += "<th" + ((W + T + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : "") + ">" + '<span title="' + C[X] + '">' + L[X] + "</span></th>"
                    }
                    U += z + "</tr></thead><tbody>";
                    var V = this._getDaysInMonth(d, p);
                    d == e.selectedYear && p == e.selectedMonth && (e.selectedDay = Math.min(e.selectedDay, V));
                    var J = (this._getFirstDayOfMonth(d, p) - T + 7) % 7, K = Math.ceil((J + V) / 7), Q = f ? this.maxRows > K ? this.maxRows : K : K;
                    this.maxRows = Q;
                    var G = this._daylightSavingAdjust(new Date(d, p, 1 - J));
                    for (var Y = 0; Y < Q; Y++) {
                        U += "<tr>";
                        var Z = N ? '<td class="ui-datepicker-week-col">' + this._get(e, "calculateWeek")(G) + "</td>" : "";
                        for (var W = 0; W < 7; W++) {
                            var et = M ? M.apply(e.input ? e.input[0] : null, [G]) : [!0, ""], tt = G.getMonth() != p, nt = tt && !D || !et[0] || c && G < c || h && G > h;
                            Z += '<td class="' + ((W + T + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (tt ? " ui-datepicker-other-month" : "") + (G.getTime() == q.getTime() && p == e.selectedMonth && e._keyEvent || H.getTime() == G.getTime() && H.getTime() == q.getTime() ? " " + this._dayOverClass : "") + (nt ? " " + this._unselectableClass + " ui-state-disabled" : "") + (tt && !_ ? "" : " " + et[1] + (G.getTime() == l.getTime() ? " " + this._currentClass : "") + (G.getTime() == t.getTime() ? " ui-datepicker-today" : "")) + '"' + ((!tt || _) && et[2] ? ' title="' + et[2] + '"' : "") + (nt ? "" : ' data-handler="selectDay" data-event="click" data-month="' + G.getMonth() + '" data-year="' + G.getFullYear() + '"') + ">" + (tt && !_ ? "&#xa0;" : nt ? '<span class="ui-state-default">' + G.getDate() + "</span>" : '<a class="ui-state-default' + (G.getTime() == t.getTime() ? " ui-state-highlight" : "") + (G.getTime() == l.getTime() ? " ui-state-active" : "") + (tt ? " ui-priority-secondary" : "") + '" href="#">' + G.getDate() + "</a>") + "</td>", G.setDate(G.getDate() + 1), G = this._daylightSavingAdjust(G)
                        }
                        U += Z + "</tr>"
                    }
                    p++, p > 11 && (p = 0, d++), U += "</tbody></table>" + (f ? "</div>" + (o[0] > 0 && I == o[1] - 1 ? '<div class="ui-datepicker-row-break"></div>' : "") : ""), F += U
                }
                B += F
            }
            return B += x + ($.ui.ie6 && !e.inline ? '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : ""), e._keyEvent = !1, B
        },
        _generateMonthYearHeader: function (e, t, n, r, i, s, o, u) {
            var a = this._get(e, "changeMonth"), f = this._get(e, "changeYear"), l = this._get(e, "showMonthAfterYear"), c = '<div class="ui-datepicker-title">', h = "";
            if (s || !a)h += '<span class="ui-datepicker-month">' + o[t] + "</span>"; else {
                var p = r && r.getFullYear() == n, d = i && i.getFullYear() == n;
                h += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';
                for (var v = 0; v < 12; v++)(!p || v >= r.getMonth()) && (!d || v <= i.getMonth()) && (h += '<option value="' + v + '"' + (v == t ? ' selected="selected"' : "") + ">" + u[v] + "</option>");
                h += "</select>"
            }
            l || (c += h + (s || !a || !f ? "&#xa0;" : ""));
            if (!e.yearshtml) {
                e.yearshtml = "";
                if (s || !f)c += '<span class="ui-datepicker-year">' + n + "</span>"; else {
                    var m = this._get(e, "yearRange").split(":"), g = (new Date).getFullYear(), y = function (e) {
                        var t = e.match(/c[+-].*/) ? n + parseInt(e.substring(1), 10) : e.match(/[+-].*/) ? g + parseInt(e, 10) : parseInt(e, 10);
                        return isNaN(t) ? g : t
                    }, b = y(m[0]), w = Math.max(b, y(m[1] || ""));
                    b = r ? Math.max(b, r.getFullYear()) : b, w = i ? Math.min(w, i.getFullYear()) : w, e.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';
                    for (; b <= w; b++)e.yearshtml += '<option value="' + b + '"' + (b == n ? ' selected="selected"' : "") + ">" + b + "</option>";
                    e.yearshtml += "</select>", c += e.yearshtml, e.yearshtml = null
                }
            }
            return c += this._get(e, "yearSuffix"), l && (c += (s || !a || !f ? "&#xa0;" : "") + h), c += "</div>", c
        },
        _adjustInstDate: function (e, t, n) {
            var r = e.drawYear + (n == "Y" ? t : 0), i = e.drawMonth + (n == "M" ? t : 0), s = Math.min(e.selectedDay, this._getDaysInMonth(r, i)) + (n == "D" ? t : 0), o = this._restrictMinMax(e, this._daylightSavingAdjust(new Date(r, i, s)));
            e.selectedDay = o.getDate(), e.drawMonth = e.selectedMonth = o.getMonth(), e.drawYear = e.selectedYear = o.getFullYear(), (n == "M" || n == "Y") && this._notifyChange(e)
        },
        _restrictMinMax: function (e, t) {
            var n = this._getMinMaxDate(e, "min"), r = this._getMinMaxDate(e, "max"), i = n && t < n ? n : t;
            return i = r && i > r ? r : i, i
        },
        _notifyChange: function (e) {
            var t = this._get(e, "onChangeMonthYear");
            t && t.apply(e.input ? e.input[0] : null, [e.selectedYear, e.selectedMonth + 1, e])
        },
        _getNumberOfMonths: function (e) {
            var t = this._get(e, "numberOfMonths");
            return t == null ? [1, 1] : typeof t == "number" ? [1, t] : t
        },
        _getMinMaxDate: function (e, t) {
            return this._determineDate(e, this._get(e, t + "Date"), null)
        },
        _getDaysInMonth: function (e, t) {
            return 32 - this._daylightSavingAdjust(new Date(e, t, 32)).getDate()
        },
        _getFirstDayOfMonth: function (e, t) {
            return (new Date(e, t, 1)).getDay()
        },
        _canAdjustMonth: function (e, t, n, r) {
            var i = this._getNumberOfMonths(e), s = this._daylightSavingAdjust(new Date(n, r + (t < 0 ? t : i[0] * i[1]), 1));
            return t < 0 && s.setDate(this._getDaysInMonth(s.getFullYear(), s.getMonth())), this._isInRange(e, s)
        },
        _isInRange: function (e, t) {
            var n = this._getMinMaxDate(e, "min"), r = this._getMinMaxDate(e, "max");
            return (!n || t.getTime() >= n.getTime()) && (!r || t.getTime() <= r.getTime())
        },
        _getFormatConfig: function (e) {
            var t = this._get(e, "shortYearCutoff");
            return t = typeof t != "string" ? t : (new Date).getFullYear() % 100 + parseInt(t, 10), {
                shortYearCutoff: t,
                dayNamesShort: this._get(e, "dayNamesShort"),
                dayNames: this._get(e, "dayNames"),
                monthNamesShort: this._get(e, "monthNamesShort"),
                monthNames: this._get(e, "monthNames")
            }
        },
        _formatDate: function (e, t, n, r) {
            t || (e.currentDay = e.selectedDay, e.currentMonth = e.selectedMonth, e.currentYear = e.selectedYear);
            var i = t ? typeof t == "object" ? t : this._daylightSavingAdjust(new Date(r, n, t)) : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
            return this.formatDate(this._get(e, "dateFormat"), i, this._getFormatConfig(e))
        }
    }), $.fn.datepicker = function (e) {
        if (!this.length)return this;
        $.datepicker.initialized || ($(document).mousedown($.datepicker._checkExternalClick).find(document.body).append($.datepicker.dpDiv), $.datepicker.initialized = !0);
        var t = Array.prototype.slice.call(arguments, 1);
        return typeof e != "string" || e != "isDisabled" && e != "getDate" && e != "widget" ? e == "option" && arguments.length == 2 && typeof arguments[1] == "string" ? $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this[0]].concat(t)) : this.each(function () {
            typeof e == "string" ? $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this].concat(t)) : $.datepicker._attachDatepicker(this, e)
        }) : $.datepicker["_" + e + "Datepicker"].apply($.datepicker, [this[0]].concat(t))
    }, $.datepicker = new Datepicker, $.datepicker.initialized = !1, $.datepicker.uuid = (new Date).getTime(), $.datepicker.version = "1.9.1", window["DP_jQuery_" + dpuuid] = $
}(jQuery), function (e, t) {
    var n = "ui-dialog ui-widget ui-widget-content ui-corner-all ", r = {
        buttons: !0,
        height: !0,
        maxHeight: !0,
        maxWidth: !0,
        minHeight: !0,
        minWidth: !0,
        width: !0
    }, i = {maxHeight: !0, maxWidth: !0, minHeight: !0, minWidth: !0};
    e.widget("ui.dialog", {
        version: "1.9.1",
        options: {
            autoOpen: !0,
            buttons: {},
            closeOnEscape: !0,
            closeText: "close",
            dialogClass: "",
            draggable: !0,
            hide: null,
            height: "auto",
            maxHeight: !1,
            maxWidth: !1,
            minHeight: 150,
            minWidth: 150,
            modal: !1,
            position: {
                my: "center", at: "center", of: window, collision: "fit", using: function (t) {
                    var n = e(this).css(t).offset().top;
                    n < 0 && e(this).css("top", t.top - n)
                }
            },
            resizable: !0,
            show: null,
            stack: !0,
            title: "",
            width: 300,
            zIndex: 1e3
        },
        _create: function () {
            this.originalTitle = this.element.attr("title"), typeof this.originalTitle != "string" && (this.originalTitle = ""), this.oldPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            }, this.options.title = this.options.title || this.originalTitle;
            var t = this, r = this.options, i = r.title || "&#160;", s, o, u, a, f;
            s = (this.uiDialog = e("<div>")).addClass(n + r.dialogClass).css({
                display: "none",
                outline: 0,
                zIndex: r.zIndex
            }).attr("tabIndex", -1).keydown(function (n) {
                r.closeOnEscape && !n.isDefaultPrevented() && n.keyCode && n.keyCode === e.ui.keyCode.ESCAPE && (t.close(n), n.preventDefault())
            }).mousedown(function (e) {
                t.moveToTop(!1, e)
            }).appendTo("body"), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(s), o = (this.uiDialogTitlebar = e("<div>")).addClass("ui-dialog-titlebar  ui-widget-header  ui-corner-all  ui-helper-clearfix").bind("mousedown", function () {
                s.focus()
            }).prependTo(s), u = e("<a href='#'></a>").addClass("ui-dialog-titlebar-close  ui-corner-all").attr("role", "button").click(function (e) {
                e.preventDefault(), t.close(e)
            }).appendTo(o), (this.uiDialogTitlebarCloseText = e("<span>")).addClass("ui-icon ui-icon-closethick").text(r.closeText).appendTo(u), a = e("<span>").uniqueId().addClass("ui-dialog-title").html(i).prependTo(o), f = (this.uiDialogButtonPane = e("<div>")).addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), (this.uiButtonSet = e("<div>")).addClass("ui-dialog-buttonset").appendTo(f), s.attr({
                role: "dialog",
                "aria-labelledby": a.attr("id")
            }), o.find("*").add(o).disableSelection(), this._hoverable(u), this._focusable(u), r.draggable && e.fn.draggable && this._makeDraggable(), r.resizable && e.fn.resizable && this._makeResizable(), this._createButtons(r.buttons), this._isOpen = !1, e.fn.bgiframe && s.bgiframe(), this._on(s, {
                keydown: function (t) {
                    if (!r.modal || t.keyCode !== e.ui.keyCode.TAB)return;
                    var n = e(":tabbable", s), i = n.filter(":first"), o = n.filter(":last");
                    if (t.target === o[0] && !t.shiftKey)return i.focus(1), !1;
                    if (t.target === i[0] && t.shiftKey)return o.focus(1), !1
                }
            })
        },
        _init: function () {
            this.options.autoOpen && this.open()
        },
        _destroy: function () {
            var e, t = this.oldPosition;
            this.overlay && this.overlay.destroy(), this.uiDialog.hide(), this.element.removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body"), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), e = t.parent.children().eq(t.index), e.length && e[0] !== this.element[0] ? e.before(this.element) : t.parent.append(this.element)
        },
        widget: function () {
            return this.uiDialog
        },
        close: function (t) {
            var n = this, r, i;
            if (!this._isOpen)return;
            if (!1 === this._trigger("beforeClose", t))return;
            return this._isOpen = !1, this.overlay && this.overlay.destroy(), this.options.hide ? this._hide(this.uiDialog, this.options.hide, function () {
                n._trigger("close", t)
            }) : (this.uiDialog.hide(), this._trigger("close", t)), e.ui.dialog.overlay.resize(), this.options.modal && (r = 0, e(".ui-dialog").each(function () {
                this !== n.uiDialog[0] && (i = e(this).css("z-index"), isNaN(i) || (r = Math.max(r, i)))
            }), e.ui.dialog.maxZ = r), this
        },
        isOpen: function () {
            return this._isOpen
        },
        moveToTop: function (t, n) {
            var r = this.options, i;
            return r.modal && !t || !r.stack && !r.modal ? this._trigger("focus", n) : (r.zIndex > e.ui.dialog.maxZ && (e.ui.dialog.maxZ = r.zIndex), this.overlay && (e.ui.dialog.maxZ += 1, e.ui.dialog.overlay.maxZ = e.ui.dialog.maxZ, this.overlay.$el.css("z-index", e.ui.dialog.overlay.maxZ)), i = {
                scrollTop: this.element.scrollTop(),
                scrollLeft: this.element.scrollLeft()
            }, e.ui.dialog.maxZ += 1, this.uiDialog.css("z-index", e.ui.dialog.maxZ), this.element.attr(i), this._trigger("focus", n), this)
        },
        open: function () {
            if (this._isOpen)return;
            var t, n = this.options, r = this.uiDialog;
            return this._size(), this._position(n.position), r.show(n.show), this.overlay = n.modal ? new e.ui.dialog.overlay(this) : null, this.moveToTop(!0), t = this.element.find(":tabbable"), t.length || (t = this.uiDialogButtonPane.find(":tabbable"), t.length || (t = r)), t.eq(0).focus(), this._isOpen = !0, this._trigger("open"), this
        },
        _createButtons: function (t) {
            var n = this, r = !1;
            this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), typeof t == "object" && t !== null && e.each(t, function () {
                return !(r = !0)
            }), r ? (e.each(t, function (t, r) {
                r = e.isFunction(r) ? {click: r, text: t} : r;
                var i = e("<button type='button'></button>").attr(r, !0).unbind("click").click(function () {
                    r.click.apply(n.element[0], arguments)
                }).appendTo(n.uiButtonSet);
                e.fn.button && i.button()
            }), this.uiDialog.addClass("ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog)) : this.uiDialog.removeClass("ui-dialog-buttons")
        },
        _makeDraggable: function () {
            function r(e) {
                return {position: e.position, offset: e.offset}
            }

            var t = this, n = this.options;
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function (n, i) {
                    e(this).addClass("ui-dialog-dragging"), t._trigger("dragStart", n, r(i))
                },
                drag: function (e, n) {
                    t._trigger("drag", e, r(n))
                },
                stop: function (i, s) {
                    n.position = [s.position.left - t.document.scrollLeft(), s.position.top - t.document.scrollTop()], e(this).removeClass("ui-dialog-dragging"), t._trigger("dragStop", i, r(s)), e.ui.dialog.overlay.resize()
                }
            })
        },
        _makeResizable: function (n) {
            function u(e) {
                return {
                    originalPosition: e.originalPosition,
                    originalSize: e.originalSize,
                    position: e.position,
                    size: e.size
                }
            }

            n = n === t ? this.options.resizable : n;
            var r = this, i = this.options, s = this.uiDialog.css("position"), o = typeof n == "string" ? n : "n,e,s,w,se,sw,ne,nw";
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: i.maxWidth,
                maxHeight: i.maxHeight,
                minWidth: i.minWidth,
                minHeight: this._minHeight(),
                handles: o,
                start: function (t, n) {
                    e(this).addClass("ui-dialog-resizing"), r._trigger("resizeStart", t, u(n))
                },
                resize: function (e, t) {
                    r._trigger("resize", e, u(t))
                },
                stop: function (t, n) {
                    e(this).removeClass("ui-dialog-resizing"), i.height = e(this).height(), i.width = e(this).width(), r._trigger("resizeStop", t, u(n)), e.ui.dialog.overlay.resize()
                }
            }).css("position", s).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")
        },
        _minHeight: function () {
            var e = this.options;
            return e.height === "auto" ? e.minHeight : Math.min(e.minHeight, e.height)
        },
        _position: function (t) {
            var n = [], r = [0, 0], i;
            if (t) {
                if (typeof t == "string" || typeof t == "object" && "0"in t)n = t.split ? t.split(" ") : [t[0], t[1]], n.length === 1 && (n[1] = n[0]), e.each(["left", "top"], function (e, t) {
                    +n[e] === n[e] && (r[e] = n[e], n[e] = t)
                }), t = {
                    my: n[0] + (r[0] < 0 ? r[0] : "+" + r[0]) + " " + n[1] + (r[1] < 0 ? r[1] : "+" + r[1]),
                    at: n.join(" ")
                };
                t = e.extend({}, e.ui.dialog.prototype.options.position, t)
            } else t = e.ui.dialog.prototype.options.position;
            i = this.uiDialog.is(":visible"), i || this.uiDialog.show(), this.uiDialog.position(t), i || this.uiDialog.hide()
        },
        _setOptions: function (t) {
            var n = this, s = {}, o = !1;
            e.each(t, function (e, t) {
                n._setOption(e, t), e in r && (o = !0), e in i && (s[e] = t)
            }), o && this._size(), this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", s)
        },
        _setOption: function (t, r) {
            var i, s, o = this.uiDialog;
            switch (t) {
                case"buttons":
                    this._createButtons(r);
                    break;
                case"closeText":
                    this.uiDialogTitlebarCloseText.text("" + r);
                    break;
                case"dialogClass":
                    o.removeClass(this.options.dialogClass).addClass(n + r);
                    break;
                case"disabled":
                    r ? o.addClass("ui-dialog-disabled") : o.removeClass("ui-dialog-disabled");
                    break;
                case"draggable":
                    i = o.is(":data(draggable)"), i && !r && o.draggable("destroy"), !i && r && this._makeDraggable();
                    break;
                case"position":
                    this._position(r);
                    break;
                case"resizable":
                    s = o.is(":data(resizable)"), s && !r && o.resizable("destroy"), s && typeof r == "string" && o.resizable("option", "handles", r), !s && r !== !1 && this._makeResizable(r);
                    break;
                case"title":
                    e(".ui-dialog-title", this.uiDialogTitlebar).html("" + (r || "&#160;"))
            }
            this._super(t, r)
        },
        _size: function () {
            var t, n, r, i = this.options, s = this.uiDialog.is(":visible");
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                height: 0
            }), i.minWidth > i.width && (i.width = i.minWidth), t = this.uiDialog.css({
                height: "auto",
                width: i.width
            }).outerHeight(), n = Math.max(0, i.minHeight - t), i.height === "auto" ? e.support.minHeight ? this.element.css({
                minHeight: n,
                height: "auto"
            }) : (this.uiDialog.show(), r = this.element.css("height", "auto").height(), s || this.uiDialog.hide(), this.element.height(Math.max(r, n))) : this.element.height(Math.max(i.height - t, 0)), this.uiDialog.is(":data(resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
        }
    }), e.extend(e.ui.dialog, {
        uuid: 0, maxZ: 0, getTitleId: function (e) {
            var t = e.attr("id");
            return t || (this.uuid += 1, t = this.uuid), "ui-dialog-title-" + t
        }, overlay: function (t) {
            this.$el = e.ui.dialog.overlay.create(t)
        }
    }), e.extend(e.ui.dialog.overlay, {
        instances: [],
        oldInstances: [],
        maxZ: 0,
        events: e.map("focus,mousedown,mouseup,keydown,keypress,click".split(","), function (e) {
            return e + ".dialog-overlay"
        }).join(" "),
        create: function (t) {
            this.instances.length === 0 && (setTimeout(function () {
                e.ui.dialog.overlay.instances.length && e(document).bind(e.ui.dialog.overlay.events, function (t) {
                    if (e(t.target).zIndex() < e.ui.dialog.overlay.maxZ)return !1
                })
            }, 1), e(window).bind("resize.dialog-overlay", e.ui.dialog.overlay.resize));
            var n = this.oldInstances.pop() || e("<div>").addClass("ui-widget-overlay");
            return e(document).bind("keydown.dialog-overlay", function (r) {
                var i = e.ui.dialog.overlay.instances;
                i.length !== 0 && i[i.length - 1] === n && t.options.closeOnEscape && !r.isDefaultPrevented() && r.keyCode && r.keyCode === e.ui.keyCode.ESCAPE && (t.close(r), r.preventDefault())
            }), n.appendTo(document.body).css({
                width: this.width(),
                height: this.height()
            }), e.fn.bgiframe && n.bgiframe(), this.instances.push(n), n
        },
        destroy: function (t) {
            var n = e.inArray(t, this.instances), r = 0;
            n !== -1 && this.oldInstances.push(this.instances.splice(n, 1)[0]), this.instances.length === 0 && e([document, window]).unbind(".dialog-overlay"), t.height(0).width(0).remove(), e.each(this.instances, function () {
                r = Math.max(r, this.css("z-index"))
            }), this.maxZ = r
        },
        height: function () {
            var t, n;
            return e.ui.ie ? (t = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight), n = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight), t < n ? e(window).height() + "px" : t + "px") : e(document).height() + "px"
        },
        width: function () {
            var t, n;
            return e.ui.ie ? (t = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth), n = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth), t < n ? e(window).width() + "px" : t + "px") : e(document).width() + "px"
        },
        resize: function () {
            var t = e([]);
            e.each(e.ui.dialog.overlay.instances, function () {
                t = t.add(this)
            }), t.css({width: 0, height: 0}).css({
                width: e.ui.dialog.overlay.width(),
                height: e.ui.dialog.overlay.height()
            })
        }
    }), e.extend(e.ui.dialog.overlay.prototype, {
        destroy: function () {
            e.ui.dialog.overlay.destroy(this.$el)
        }
    })
}(jQuery), function (e, t) {
    var n = /up|down|vertical/, r = /up|left|vertical|horizontal/;
    e.effects.effect.blind = function (t, i) {
        var s = e(this), o = ["position", "top", "bottom", "left", "right", "height", "width"], u = e.effects.setMode(s, t.mode || "hide"), a = t.direction || "up", f = n.test(a), l = f ? "height" : "width", c = f ? "top" : "left", h = r.test(a), p = {}, d = u === "show", v, m, g;
        s.parent().is(".ui-effects-wrapper") ? e.effects.save(s.parent(), o) : e.effects.save(s, o), s.show(), v = e.effects.createWrapper(s).css({overflow: "hidden"}), m = v[l](), g = parseFloat(v.css(c)) || 0, p[l] = d ? m : 0, h || (s.css(f ? "bottom" : "right", 0).css(f ? "top" : "left", "auto").css({position: "absolute"}), p[c] = d ? g : m + g), d && (v.css(l, 0), h || v.css(c, g + m)), v.animate(p, {
            duration: t.duration,
            easing: t.easing,
            queue: !1,
            complete: function () {
                u === "hide" && s.hide(), e.effects.restore(s, o), e.effects.removeWrapper(s), i()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.bounce = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "height", "width"], s = e.effects.setMode(r, t.mode || "effect"), o = s === "hide", u = s === "show", a = t.direction || "up", f = t.distance, l = t.times || 5, c = l * 2 + (u || o ? 1 : 0), h = t.duration / c, p = t.easing, d = a === "up" || a === "down" ? "top" : "left", v = a === "up" || a === "left", m, g, y, b = r.queue(), w = b.length;
        (u || o) && i.push("opacity"), e.effects.save(r, i), r.show(), e.effects.createWrapper(r), f || (f = r[d === "top" ? "outerHeight" : "outerWidth"]() / 3), u && (y = {opacity: 1}, y[d] = 0, r.css("opacity", 0).css(d, v ? -f * 2 : f * 2).animate(y, h, p)), o && (f /= Math.pow(2, l - 1)), y = {}, y[d] = 0;
        for (m = 0; m < l; m++)g = {}, g[d] = (v ? "-=" : "+=") + f, r.animate(g, h, p).animate(y, h, p), f = o ? f * 2 : f / 2;
        o && (g = {opacity: 0}, g[d] = (v ? "-=" : "+=") + f, r.animate(g, h, p)), r.queue(function () {
            o && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
        }), w > 1 && b.splice.apply(b, [1, 0].concat(b.splice(w, c + 1))), r.dequeue()
    }
}(jQuery), function (e, t) {
    e.effects.effect.clip = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "height", "width"], s = e.effects.setMode(r, t.mode || "hide"), o = s === "show", u = t.direction || "vertical", a = u === "vertical", f = a ? "height" : "width", l = a ? "top" : "left", c = {}, h, p, d;
        e.effects.save(r, i), r.show(), h = e.effects.createWrapper(r).css({overflow: "hidden"}), p = r[0].tagName === "IMG" ? h : r, d = p[f](), o && (p.css(f, 0), p.css(l, d / 2)), c[f] = o ? d : 0, c[l] = o ? 0 : d / 2, p.animate(c, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                o || r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.drop = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"], s = e.effects.setMode(r, t.mode || "hide"), o = s === "show", u = t.direction || "left", a = u === "up" || u === "down" ? "top" : "left", f = u === "up" || u === "left" ? "pos" : "neg", l = {opacity: o ? 1 : 0}, c;
        e.effects.save(r, i), r.show(), e.effects.createWrapper(r), c = t.distance || r[a === "top" ? "outerHeight" : "outerWidth"](!0) / 2, o && r.css("opacity", 0).css(a, f === "pos" ? -c : c), l[a] = (o ? f === "pos" ? "+=" : "-=" : f === "pos" ? "-=" : "+=") + c, r.animate(l, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.explode = function (t, n) {
        function y() {
            c.push(this), c.length === r * i && b()
        }

        function b() {
            s.css({visibility: "visible"}), e(c).remove(), u || s.hide(), n()
        }

        var r = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3, i = r, s = e(this), o = e.effects.setMode(s, t.mode || "hide"), u = o === "show", a = s.show().css("visibility", "hidden").offset(), f = Math.ceil(s.outerWidth() / i), l = Math.ceil(s.outerHeight() / r), c = [], h, p, d, v, m, g;
        for (h = 0; h < r; h++) {
            v = a.top + h * l, g = h - (r - 1) / 2;
            for (p = 0; p < i; p++)d = a.left + p * f, m = p - (i - 1) / 2, s.clone().appendTo("body").wrap("<div></div>").css({
                position: "absolute",
                visibility: "visible",
                left: -p * f,
                top: -h * l
            }).parent().addClass("ui-effects-explode").css({
                position: "absolute",
                overflow: "hidden",
                width: f,
                height: l,
                left: d + (u ? m * f : 0),
                top: v + (u ? g * l : 0),
                opacity: u ? 0 : 1
            }).animate({
                left: d + (u ? 0 : m * f),
                top: v + (u ? 0 : g * l),
                opacity: u ? 1 : 0
            }, t.duration || 500, t.easing, y)
        }
    }
}(jQuery), function (e, t) {
    e.effects.effect.fade = function (t, n) {
        var r = e(this), i = e.effects.setMode(r, t.mode || "toggle");
        r.animate({opacity: i}, {queue: !1, duration: t.duration, easing: t.easing, complete: n})
    }
}(jQuery), function (e, t) {
    e.effects.effect.fold = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "height", "width"], s = e.effects.setMode(r, t.mode || "hide"), o = s === "show", u = s === "hide", a = t.size || 15, f = /([0-9]+)%/.exec(a), l = !!t.horizFirst, c = o !== l, h = c ? ["width", "height"] : ["height", "width"], p = t.duration / 2, d, v, m = {}, g = {};
        e.effects.save(r, i), r.show(), d = e.effects.createWrapper(r).css({overflow: "hidden"}), v = c ? [d.width(), d.height()] : [d.height(), d.width()], f && (a = parseInt(f[1], 10) / 100 * v[u ? 0 : 1]), o && d.css(l ? {
            height: 0,
            width: a
        } : {
            height: a,
            width: 0
        }), m[h[0]] = o ? v[0] : a, g[h[1]] = o ? v[1] : 0, d.animate(m, p, t.easing).animate(g, p, t.easing, function () {
            u && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.highlight = function (t, n) {
        var r = e(this), i = ["backgroundImage", "backgroundColor", "opacity"], s = e.effects.setMode(r, t.mode || "show"), o = {backgroundColor: r.css("backgroundColor")};
        s === "hide" && (o.opacity = 0), e.effects.save(r, i), r.show().css({
            backgroundImage: "none",
            backgroundColor: t.color || "#ffff99"
        }).animate(o, {
            queue: !1, duration: t.duration, easing: t.easing, complete: function () {
                s === "hide" && r.hide(), e.effects.restore(r, i), n()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.pulsate = function (t, n) {
        var r = e(this), i = e.effects.setMode(r, t.mode || "show"), s = i === "show", o = i === "hide", u = s || i === "hide", a = (t.times || 5) * 2 + (u ? 1 : 0), f = t.duration / a, l = 0, c = r.queue(), h = c.length, p;
        if (s || !r.is(":visible"))r.css("opacity", 0).show(), l = 1;
        for (p = 1; p < a; p++)r.animate({opacity: l}, f, t.easing), l = 1 - l;
        r.animate({opacity: l}, f, t.easing), r.queue(function () {
            o && r.hide(), n()
        }), h > 1 && c.splice.apply(c, [1, 0].concat(c.splice(h, a + 1))), r.dequeue()
    }
}(jQuery), function (e, t) {
    e.effects.effect.puff = function (t, n) {
        var r = e(this), i = e.effects.setMode(r, t.mode || "hide"), s = i === "hide", o = parseInt(t.percent, 10) || 150, u = o / 100, a = {
            height: r.height(),
            width: r.width()
        };
        e.extend(t, {
            effect: "scale",
            queue: !1,
            fade: !0,
            mode: i,
            complete: n,
            percent: s ? o : 100,
            from: s ? a : {height: a.height * u, width: a.width * u}
        }), r.effect(t)
    }, e.effects.effect.scale = function (t, n) {
        var r = e(this), i = e.extend(!0, {}, t), s = e.effects.setMode(r, t.mode || "effect"), o = parseInt(t.percent, 10) || (parseInt(t.percent, 10) === 0 ? 0 : s === "hide" ? 0 : 100), u = t.direction || "both", a = t.origin, f = {
            height: r.height(),
            width: r.width(),
            outerHeight: r.outerHeight(),
            outerWidth: r.outerWidth()
        }, l = {y: u !== "horizontal" ? o / 100 : 1, x: u !== "vertical" ? o / 100 : 1};
        i.effect = "size", i.queue = !1, i.complete = n, s !== "effect" && (i.origin = a || ["middle", "center"], i.restore = !0), i.from = t.from || (s === "show" ? {
                height: 0,
                width: 0
            } : f), i.to = {
            height: f.height * l.y,
            width: f.width * l.x,
            outerHeight: f.outerHeight * l.y,
            outerWidth: f.outerWidth * l.x
        }, i.fade && (s === "show" && (i.from.opacity = 0, i.to.opacity = 1), s === "hide" && (i.from.opacity = 1, i.to.opacity = 0)), r.effect(i)
    }, e.effects.effect.size = function (t, n) {
        var r, i, s, o = e(this), u = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"], a = ["position", "top", "bottom", "left", "right", "overflow", "opacity"], f = ["width", "height", "overflow"], l = ["fontSize"], c = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"], h = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"], p = e.effects.setMode(o, t.mode || "effect"), d = t.restore || p !== "effect", v = t.scale || "both", m = t.origin || ["middle", "center"], g = o.css("position"), y = d ? u : a, b = {
            height: 0,
            width: 0
        };
        p === "show" && o.show(), r = {
            height: o.height(),
            width: o.width(),
            outerHeight: o.outerHeight(),
            outerWidth: o.outerWidth()
        }, t.mode === "toggle" && p === "show" ? (o.from = t.to || b, o.to = t.from || r) : (o.from = t.from || (p === "show" ? b : r), o.to = t.to || (p === "hide" ? b : r)), s = {
            from: {
                y: o.from.height / r.height,
                x: o.from.width / r.width
            }, to: {y: o.to.height / r.height, x: o.to.width / r.width}
        };
        if (v === "box" || v === "both")s.from.y !== s.to.y && (y = y.concat(c), o.from = e.effects.setTransition(o, c, s.from.y, o.from), o.to = e.effects.setTransition(o, c, s.to.y, o.to)), s.from.x !== s.to.x && (y = y.concat(h), o.from = e.effects.setTransition(o, h, s.from.x, o.from), o.to = e.effects.setTransition(o, h, s.to.x, o.to));
        (v === "content" || v === "both") && s.from.y !== s.to.y && (y = y.concat(l).concat(f), o.from = e.effects.setTransition(o, l, s.from.y, o.from), o.to = e.effects.setTransition(o, l, s.to.y, o.to)), e.effects.save(o, y), o.show(), e.effects.createWrapper(o), o.css("overflow", "hidden").css(o.from), m && (i = e.effects.getBaseline(m, r), o.from.top = (r.outerHeight - o.outerHeight()) * i.y, o.from.left = (r.outerWidth - o.outerWidth()) * i.x, o.to.top = (r.outerHeight - o.to.outerHeight) * i.y, o.to.left = (r.outerWidth - o.to.outerWidth) * i.x), o.css(o.from);
        if (v === "content" || v === "both")c = c.concat(["marginTop", "marginBottom"]).concat(l), h = h.concat(["marginLeft", "marginRight"]), f = u.concat(c).concat(h), o.find("*[width]").each(function () {
            var n = e(this), r = {height: n.height(), width: n.width()};
            d && e.effects.save(n, f), n.from = {
                height: r.height * s.from.y,
                width: r.width * s.from.x
            }, n.to = {
                height: r.height * s.to.y,
                width: r.width * s.to.x
            }, s.from.y !== s.to.y && (n.from = e.effects.setTransition(n, c, s.from.y, n.from), n.to = e.effects.setTransition(n, c, s.to.y, n.to)), s.from.x !== s.to.x && (n.from = e.effects.setTransition(n, h, s.from.x, n.from), n.to = e.effects.setTransition(n, h, s.to.x, n.to)), n.css(n.from), n.animate(n.to, t.duration, t.easing, function () {
                d && e.effects.restore(n, f)
            })
        });
        o.animate(o.to, {
            queue: !1, duration: t.duration, easing: t.easing, complete: function () {
                o.to.opacity === 0 && o.css("opacity", o.from.opacity), p === "hide" && o.hide(), e.effects.restore(o, y), d || (g === "static" ? o.css({
                    position: "relative",
                    top: o.to.top,
                    left: o.to.left
                }) : e.each(["top", "left"], function (e, t) {
                    o.css(t, function (t, n) {
                        var r = parseInt(n, 10), i = e ? o.to.left : o.to.top;
                        return n === "auto" ? i + "px" : r + i + "px"
                    })
                })), e.effects.removeWrapper(o), n()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.shake = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "height", "width"], s = e.effects.setMode(r, t.mode || "effect"), o = t.direction || "left", u = t.distance || 20, a = t.times || 3, f = a * 2 + 1, l = Math.round(t.duration / f), c = o === "up" || o === "down" ? "top" : "left", h = o === "up" || o === "left", p = {}, d = {}, v = {}, m, g = r.queue(), y = g.length;
        e.effects.save(r, i), r.show(), e.effects.createWrapper(r), p[c] = (h ? "-=" : "+=") + u, d[c] = (h ? "+=" : "-=") + u * 2, v[c] = (h ? "-=" : "+=") + u * 2, r.animate(p, l, t.easing);
        for (m = 1; m < a; m++)r.animate(d, l, t.easing).animate(v, l, t.easing);
        r.animate(d, l, t.easing).animate(p, l / 2, t.easing).queue(function () {
            s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
        }), y > 1 && g.splice.apply(g, [1, 0].concat(g.splice(y, f + 1))), r.dequeue()
    }
}(jQuery), function (e, t) {
    e.effects.effect.slide = function (t, n) {
        var r = e(this), i = ["position", "top", "bottom", "left", "right", "width", "height"], s = e.effects.setMode(r, t.mode || "show"), o = s === "show", u = t.direction || "left", a = u === "up" || u === "down" ? "top" : "left", f = u === "up" || u === "left", l, c = {};
        e.effects.save(r, i), r.show(), l = t.distance || r[a === "top" ? "outerHeight" : "outerWidth"](!0), e.effects.createWrapper(r).css({overflow: "hidden"}), o && r.css(a, f ? isNaN(l) ? "-" + l : -l : l), c[a] = (o ? f ? "+=" : "-=" : f ? "-=" : "+=") + l, r.animate(c, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                s === "hide" && r.hide(), e.effects.restore(r, i), e.effects.removeWrapper(r), n()
            }
        })
    }
}(jQuery), function (e, t) {
    e.effects.effect.transfer = function (t, n) {
        var r = e(this), i = e(t.to), s = i.css("position") === "fixed", o = e("body"), u = s ? o.scrollTop() : 0, a = s ? o.scrollLeft() : 0, f = i.offset(), l = {
            top: f.top - u,
            left: f.left - a,
            height: i.innerHeight(),
            width: i.innerWidth()
        }, c = r.offset(), h = e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(t.className).css({
            top: c.top - u,
            left: c.left - a,
            height: r.innerHeight(),
            width: r.innerWidth(),
            position: s ? "fixed" : "absolute"
        }).animate(l, t.duration, t.easing, function () {
            h.remove(), n()
        })
    }
}(jQuery), function (e, t) {
    var n = !1;
    e.widget("ui.menu", {
        version: "1.9.1",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {submenu: "ui-icon-carat-1-e"},
            menus: "ul",
            position: {my: "left top", at: "right top"},
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create: function () {
            this.activeMenu = this.element, this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                role: this.options.role,
                tabIndex: 0
            }).bind("click" + this.eventNamespace, e.proxy(function (e) {
                this.options.disabled && e.preventDefault()
            }, this)), this.options.disabled && this.element.addClass("ui-state-disabled").attr("aria-disabled", "true"), this._on({
                "mousedown .ui-menu-item > a": function (e) {
                    e.preventDefault()
                }, "click .ui-state-disabled > a": function (e) {
                    e.preventDefault()
                }, "click .ui-menu-item:has(a)": function (t) {
                    var r = e(t.target).closest(".ui-menu-item");
                    !n && r.not(".ui-state-disabled").length && (n = !0, this.select(t), r.has(".ui-menu").length ? this.expand(t) : this.element.is(":focus") || (this.element.trigger("focus", [!0]), this.active && this.active.parents(".ui-menu").length === 1 && clearTimeout(this.timer)))
                }, "mouseenter .ui-menu-item": function (t) {
                    var n = e(t.currentTarget);
                    n.siblings().children(".ui-state-active").removeClass("ui-state-active"), this.focus(t, n)
                }, mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function (e, t) {
                    var n = this.active || this.element.children(".ui-menu-item").eq(0);
                    t || this.focus(e, n)
                }, blur: function (t) {
                    this._delay(function () {
                        e.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(t)
                    })
                }, keydown: "_keydown"
            }), this.refresh(), this._on(this.document, {
                click: function (t) {
                    e(t.target).closest(".ui-menu").length || this.collapseAll(t), n = !1
                }
            })
        },
        _destroy: function () {
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").andSelf().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(), this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function () {
                var t = e(this);
                t.data("ui-menu-submenu-carat") && t.remove()
            }), this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")
        },
        _keydown: function (t) {
            function a(e) {
                return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
            }

            var n, r, i, s, o, u = !0;
            switch (t.keyCode) {
                case e.ui.keyCode.PAGE_UP:
                    this.previousPage(t);
                    break;
                case e.ui.keyCode.PAGE_DOWN:
                    this.nextPage(t);
                    break;
                case e.ui.keyCode.HOME:
                    this._move("first", "first", t);
                    break;
                case e.ui.keyCode.END:
                    this._move("last", "last", t);
                    break;
                case e.ui.keyCode.UP:
                    this.previous(t);
                    break;
                case e.ui.keyCode.DOWN:
                    this.next(t);
                    break;
                case e.ui.keyCode.LEFT:
                    this.collapse(t);
                    break;
                case e.ui.keyCode.RIGHT:
                    this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
                    break;
                case e.ui.keyCode.ENTER:
                case e.ui.keyCode.SPACE:
                    this._activate(t);
                    break;
                case e.ui.keyCode.ESCAPE:
                    this.collapse(t);
                    break;
                default:
                    u = !1, r = this.previousFilter || "", i = String.fromCharCode(t.keyCode), s = !1, clearTimeout(this.filterTimer), i === r ? s = !0 : i = r + i, o = new RegExp("^" + a(i), "i"), n = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return o.test(e(this).children("a").text())
                    }), n = s && n.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : n, n.length || (i = String.fromCharCode(t.keyCode), o = new RegExp("^" + a(i), "i"), n = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return o.test(e(this).children("a").text())
                    })), n.length ? (this.focus(t, n), n.length > 1 ? (this.previousFilter = i, this.filterTimer = this._delay(function () {
                        delete this.previousFilter
                    }, 1e3)) : delete this.previousFilter) : delete this.previousFilter
            }
            u && t.preventDefault()
        },
        _activate: function (e) {
            this.active.is(".ui-state-disabled") || (this.active.children("a[aria-haspopup='true']").length ? this.expand(e) : this.select(e))
        },
        refresh: function () {
            var t, n = this.options.icons.submenu, r = this.element.find(this.options.menus + ":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            });
            t = r.add(this.element), t.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "presentation").children("a").uniqueId().addClass("ui-corner-all").attr({
                tabIndex: -1,
                role: this._itemRole()
            }), t.children(":not(.ui-menu-item)").each(function () {
                var t = e(this);
                /[^\-—–\s]/.test(t.text()) || t.addClass("ui-widget-content ui-menu-divider")
            }), t.children(".ui-state-disabled").attr("aria-disabled", "true"), r.each(function () {
                var t = e(this), r = t.prev("a"), i = e("<span>").addClass("ui-menu-icon ui-icon " + n).data("ui-menu-submenu-carat", !0);
                r.attr("aria-haspopup", "true").prepend(i), t.attr("aria-labelledby", r.attr("id"))
            }), this.active && !e.contains(this.element[0], this.active[0]) && this.blur()
        },
        _itemRole: function () {
            return {menu: "menuitem", listbox: "option"}[this.options.role]
        },
        focus: function (e, t) {
            var n, r;
            this.blur(e, e && e.type === "focus"), this._scrollIntoView(t), this.active = t.first(), r = this.active.children("a").addClass("ui-state-focus"), this.options.role && this.element.attr("aria-activedescendant", r.attr("id")), this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active"), e && e.type === "keydown" ? this._close() : this.timer = this._delay(function () {
                this._close()
            }, this.delay), n = t.children(".ui-menu"), n.length && /^mouse/.test(e.type) && this._startOpening(n), this.activeMenu = t.parent(), this._trigger("focus", e, {item: t})
        },
        _scrollIntoView: function (t) {
            var n, r, i, s, o, u;
            this._hasScroll() && (n = parseFloat(e.css(this.activeMenu[0], "borderTopWidth")) || 0, r = parseFloat(e.css(this.activeMenu[0], "paddingTop")) || 0, i = t.offset().top - this.activeMenu.offset().top - n - r, s = this.activeMenu.scrollTop(), o = this.activeMenu.height(), u = t.height(), i < 0 ? this.activeMenu.scrollTop(s + i) : i + u > o && this.activeMenu.scrollTop(s + i - o + u))
        },
        blur: function (e, t) {
            t || clearTimeout(this.timer);
            if (!this.active)return;
            this.active.children("a").removeClass("ui-state-focus"), this.active = null, this._trigger("blur", e, {item: this.active})
        },
        _startOpening: function (e) {
            clearTimeout(this.timer);
            if (e.attr("aria-hidden") !== "true")return;
            this.timer = this._delay(function () {
                this._close(), this._open(e)
            }, this.delay)
        },
        _open: function (t) {
            var n = e.extend({of: this.active}, this.options.position);
            clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(n)
        },
        collapseAll: function (t, n) {
            clearTimeout(this.timer), this.timer = this._delay(function () {
                var r = n ? this.element : e(t && t.target).closest(this.element.find(".ui-menu"));
                r.length || (r = this.element), this._close(r), this.blur(t), this.activeMenu = r
            }, this.delay)
        },
        _close: function (e) {
            e || (e = this.active ? this.active.parent() : this.element), e.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find("a.ui-state-active").removeClass("ui-state-active")
        },
        collapse: function (e) {
            var t = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            t && t.length && (this._close(), this.focus(e, t))
        },
        expand: function (e) {
            var t = this.active && this.active.children(".ui-menu ").children(".ui-menu-item").first();
            t && t.length && (this._open(t.parent()), this._delay(function () {
                this.focus(e, t)
            }))
        },
        next: function (e) {
            this._move("next", "first", e)
        },
        previous: function (e) {
            this._move("prev", "last", e)
        },
        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length
        },
        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length
        },
        _move: function (e, t, n) {
            var r;
            this.active && (e === "first" || e === "last" ? r = this.active[e === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : r = this.active[e + "All"](".ui-menu-item").eq(0));
            if (!r || !r.length || !this.active)r = this.activeMenu.children(".ui-menu-item")[t]();
            this.focus(n, r)
        },
        nextPage: function (t) {
            var n, r, i;
            if (!this.active) {
                this.next(t);
                return
            }
            if (this.isLastItem())return;
            this._hasScroll() ? (r = this.active.offset().top, i = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
                return n = e(this), n.offset().top - r - i < 0
            }), this.focus(t, n)) : this.focus(t, this.activeMenu.children(".ui-menu-item")[this.active ? "last" : "first"]())
        },
        previousPage: function (t) {
            var n, r, i;
            if (!this.active) {
                this.next(t);
                return
            }
            if (this.isFirstItem())return;
            this._hasScroll() ? (r = this.active.offset().top, i = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
                return n = e(this), n.offset().top - r + i > 0
            }), this.focus(t, n)) : this.focus(t, this.activeMenu.children(".ui-menu-item").first())
        },
        _hasScroll: function () {
            return this.element.outerHeight() < this.element.prop("scrollHeight")
        },
        select: function (t) {
            this.active = this.active || e(t.target).closest(".ui-menu-item");
            var n = {item: this.active};
            this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, n)
        }
    })
}(jQuery), function (e, t) {
    function h(e, t, n) {
        return [parseInt(e[0], 10) * (l.test(e[0]) ? t / 100 : 1), parseInt(e[1], 10) * (l.test(e[1]) ? n / 100 : 1)]
    }

    function p(t, n) {
        return parseInt(e.css(t, n), 10) || 0
    }

    e.ui = e.ui || {};
    var n, r = Math.max, i = Math.abs, s = Math.round, o = /left|center|right/, u = /top|center|bottom/, a = /[\+\-]\d+%?/, f = /^\w+/, l = /%$/, c = e.fn.position;
    e.position = {
        scrollbarWidth: function () {
            if (n !== t)return n;
            var r, i, s = e("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), o = s.children()[0];
            return e("body").append(s), r = o.offsetWidth, s.css("overflow", "scroll"), i = o.offsetWidth, r === i && (i = s[0].clientWidth), s.remove(), n = r - i
        }, getScrollInfo: function (t) {
            var n = t.isWindow ? "" : t.element.css("overflow-x"), r = t.isWindow ? "" : t.element.css("overflow-y"), i = n === "scroll" || n === "auto" && t.width < t.element[0].scrollWidth, s = r === "scroll" || r === "auto" && t.height < t.element[0].scrollHeight;
            return {width: i ? e.position.scrollbarWidth() : 0, height: s ? e.position.scrollbarWidth() : 0}
        }, getWithinInfo: function (t) {
            var n = e(t || window), r = e.isWindow(n[0]);
            return {
                element: n,
                isWindow: r,
                offset: n.offset() || {left: 0, top: 0},
                scrollLeft: n.scrollLeft(),
                scrollTop: n.scrollTop(),
                width: r ? n.width() : n.outerWidth(),
                height: r ? n.height() : n.outerHeight()
            }
        }
    }, e.fn.position = function (t) {
        if (!t || !t.of)return c.apply(this, arguments);
        t = e.extend({}, t);
        var n, l, d, v, m, g = e(t.of), y = e.position.getWithinInfo(t.within), b = e.position.getScrollInfo(y), w = g[0], E = (t.collision || "flip").split(" "), S = {};
        return w.nodeType === 9 ? (l = g.width(), d = g.height(), v = {
            top: 0,
            left: 0
        }) : e.isWindow(w) ? (l = g.width(), d = g.height(), v = {
            top: g.scrollTop(),
            left: g.scrollLeft()
        }) : w.preventDefault ? (t.at = "left top", l = d = 0, v = {
            top: w.pageY,
            left: w.pageX
        }) : (l = g.outerWidth(), d = g.outerHeight(), v = g.offset()), m = e.extend({}, v), e.each(["my", "at"], function () {
            var e = (t[this] || "").split(" "), n, r;
            e.length === 1 && (e = o.test(e[0]) ? e.concat(["center"]) : u.test(e[0]) ? ["center"].concat(e) : ["center", "center"]), e[0] = o.test(e[0]) ? e[0] : "center", e[1] = u.test(e[1]) ? e[1] : "center", n = a.exec(e[0]), r = a.exec(e[1]), S[this] = [n ? n[0] : 0, r ? r[0] : 0], t[this] = [f.exec(e[0])[0], f.exec(e[1])[0]]
        }), E.length === 1 && (E[1] = E[0]), t.at[0] === "right" ? m.left += l : t.at[0] === "center" && (m.left += l / 2), t.at[1] === "bottom" ? m.top += d : t.at[1] === "center" && (m.top += d / 2), n = h(S.at, l, d), m.left += n[0], m.top += n[1], this.each(function () {
            var o, u, a = e(this), f = a.outerWidth(), c = a.outerHeight(), w = p(this, "marginLeft"), x = p(this, "marginTop"), T = f + w + p(this, "marginRight") + b.width, N = c + x + p(this, "marginBottom") + b.height, C = e.extend({}, m), k = h(S.my, a.outerWidth(), a.outerHeight());
            t.my[0] === "right" ? C.left -= f : t.my[0] === "center" && (C.left -= f / 2), t.my[1] === "bottom" ? C.top -= c : t.my[1] === "center" && (C.top -= c / 2), C.left += k[0], C.top += k[1], e.support.offsetFractions || (C.left = s(C.left), C.top = s(C.top)), o = {
                marginLeft: w,
                marginTop: x
            }, e.each(["left", "top"], function (r, i) {
                e.ui.position[E[r]] && e.ui.position[E[r]][i](C, {
                    targetWidth: l,
                    targetHeight: d,
                    elemWidth: f,
                    elemHeight: c,
                    collisionPosition: o,
                    collisionWidth: T,
                    collisionHeight: N,
                    offset: [n[0] + k[0], n[1] + k[1]],
                    my: t.my,
                    at: t.at,
                    within: y,
                    elem: a
                })
            }), e.fn.bgiframe && a.bgiframe(), t.using && (u = function (e) {
                var n = v.left - C.left, s = n + l - f, o = v.top - C.top, u = o + d - c, h = {
                    target: {
                        element: g,
                        left: v.left,
                        top: v.top,
                        width: l,
                        height: d
                    },
                    element: {element: a, left: C.left, top: C.top, width: f, height: c},
                    horizontal: s < 0 ? "left" : n > 0 ? "right" : "center",
                    vertical: u < 0 ? "top" : o > 0 ? "bottom" : "middle"
                };
                l < f && i(n + s) < l && (h.horizontal = "center"), d < c && i(o + u) < d && (h.vertical = "middle"), r(i(n), i(s)) > r(i(o), i(u)) ? h.important = "horizontal" : h.important = "vertical", t.using.call(this, e, h)
            }), a.offset(e.extend(C, {using: u}))
        })
    }, e.ui.position = {
        fit: {
            left: function (e, t) {
                var n = t.within, i = n.isWindow ? n.scrollLeft : n.offset.left, s = n.width, o = e.left - t.collisionPosition.marginLeft, u = i - o, a = o + t.collisionWidth - s - i, f;
                t.collisionWidth > s ? u > 0 && a <= 0 ? (f = e.left + u + t.collisionWidth - s - i, e.left += u - f) : a > 0 && u <= 0 ? e.left = i : u > a ? e.left = i + s - t.collisionWidth : e.left = i : u > 0 ? e.left += u : a > 0 ? e.left -= a : e.left = r(e.left - o, e.left)
            }, top: function (e, t) {
                var n = t.within, i = n.isWindow ? n.scrollTop : n.offset.top, s = t.within.height, o = e.top - t.collisionPosition.marginTop, u = i - o, a = o + t.collisionHeight - s - i, f;
                t.collisionHeight > s ? u > 0 && a <= 0 ? (f = e.top + u + t.collisionHeight - s - i, e.top += u - f) : a > 0 && u <= 0 ? e.top = i : u > a ? e.top = i + s - t.collisionHeight : e.top = i : u > 0 ? e.top += u : a > 0 ? e.top -= a : e.top = r(e.top - o, e.top)
            }
        }, flip: {
            left: function (e, t) {
                var n = t.within, r = n.offset.left + n.scrollLeft, s = n.width, o = n.isWindow ? n.scrollLeft : n.offset.left, u = e.left - t.collisionPosition.marginLeft, a = u - o, f = u + t.collisionWidth - s - o, l = t.my[0] === "left" ? -t.elemWidth : t.my[0] === "right" ? t.elemWidth : 0, c = t.at[0] === "left" ? t.targetWidth : t.at[0] === "right" ? -t.targetWidth : 0, h = -2 * t.offset[0], p, d;
                if (a < 0) {
                    p = e.left + l + c + h + t.collisionWidth - s - r;
                    if (p < 0 || p < i(a))e.left += l + c + h
                } else if (f > 0) {
                    d = e.left - t.collisionPosition.marginLeft + l + c + h - o;
                    if (d > 0 || i(d) < f)e.left += l + c + h
                }
            }, top: function (e, t) {
                var n = t.within, r = n.offset.top + n.scrollTop, s = n.height, o = n.isWindow ? n.scrollTop : n.offset.top, u = e.top - t.collisionPosition.marginTop, a = u - o, f = u + t.collisionHeight - s - o, l = t.my[1] === "top", c = l ? -t.elemHeight : t.my[1] === "bottom" ? t.elemHeight : 0, h = t.at[1] === "top" ? t.targetHeight : t.at[1] === "bottom" ? -t.targetHeight : 0, p = -2 * t.offset[1], d, v;
                a < 0 ? (v = e.top + c + h + p + t.collisionHeight - s - r, e.top + c + h + p > a && (v < 0 || v < i(a)) && (e.top += c + h + p)) : f > 0 && (d = e.top - t.collisionPosition.marginTop + c + h + p - o, e.top + c + h + p > f && (d > 0 || i(d) < f) && (e.top += c + h + p))
            }
        }, flipfit: {
            left: function () {
                e.ui.position.flip.left.apply(this, arguments), e.ui.position.fit.left.apply(this, arguments)
            }, top: function () {
                e.ui.position.flip.top.apply(this, arguments), e.ui.position.fit.top.apply(this, arguments)
            }
        }
    }, function () {
        var t, n, r, i, s, o = document.getElementsByTagName("body")[0], u = document.createElement("div");
        t = document.createElement(o ? "div" : "body"), r = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        }, o && e.extend(r, {position: "absolute", left: "-1000px", top: "-1000px"});
        for (s in r)t.style[s] = r[s];
        t.appendChild(u), n = o || document.documentElement, n.insertBefore(t, n.firstChild), u.style.cssText = "position: absolute; left: 10.7432222px;", i = e(u).offset().left, e.support.offsetFractions = i > 10 && i < 11, t.innerHTML = "", n.removeChild(t)
    }(), e.uiBackCompat !== !1 && function (e) {
        var n = e.fn.position;
        e.fn.position = function (r) {
            if (!r || !r.offset)return n.call(this, r);
            var i = r.offset.split(" "), s = r.at.split(" ");
            return i.length === 1 && (i[1] = i[0]), /^\d/.test(i[0]) && (i[0] = "+" + i[0]), /^\d/.test(i[1]) && (i[1] = "+" + i[1]), s.length === 1 && (/left|center|right/.test(s[0]) ? s[1] = "center" : (s[1] = s[0], s[0] = "center")), n.call(this, e.extend(r, {
                at: s[0] + i[0] + " " + s[1] + i[1],
                offset: t
            }))
        }
    }(jQuery)
}(jQuery), function (e, t) {
    e.widget("ui.progressbar", {
        version: "1.9.1", options: {value: 0, max: 100}, min: 0, _create: function () {
            this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                role: "progressbar",
                "aria-valuemin": this.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._value()
            }), this.valueDiv = e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element), this.oldValue = this._value(), this._refreshValue()
        }, _destroy: function () {
            this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.valueDiv.remove()
        }, value: function (e) {
            return e === t ? this._value() : (this._setOption("value", e), this)
        }, _setOption: function (e, t) {
            e === "value" && (this.options.value = t, this._refreshValue(), this._value() === this.options.max && this._trigger("complete")), this._super(e, t)
        }, _value: function () {
            var e = this.options.value;
            return typeof e != "number" && (e = 0), Math.min(this.options.max, Math.max(this.min, e))
        }, _percentage: function () {
            return 100 * this._value() / this.options.max
        }, _refreshValue: function () {
            var e = this.value(), t = this._percentage();
            this.oldValue !== e && (this.oldValue = e, this._trigger("change")), this.valueDiv.toggle(e > this.min).toggleClass("ui-corner-right", e === this.options.max).width(t.toFixed(0) + "%"), this.element.attr("aria-valuenow", e)
        }
    })
}(jQuery), function (e, t) {
    var n = 5;
    e.widget("ui.slider", e.ui.mouse, {
        version: "1.9.1",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null
        },
        _create: function () {
            var t, r, i = this.options, s = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), o = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", u = [];
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all" + (i.disabled ? " ui-slider-disabled ui-disabled" : "")), this.range = e([]), i.range && (i.range === !0 && (i.values || (i.values = [this._valueMin(), this._valueMin()]), i.values.length && i.values.length !== 2 && (i.values = [i.values[0], i.values[0]])), this.range = e("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header" + (i.range === "min" || i.range === "max" ? " ui-slider-range-" + i.range : ""))), r = i.values && i.values.length || 1;
            for (t = s.length; t < r; t++)u.push(o);
            this.handles = s.add(e(u.join("")).appendTo(this.element)), this.handle = this.handles.eq(0), this.handles.add(this.range).filter("a").click(function (e) {
                e.preventDefault()
            }).mouseenter(function () {
                i.disabled || e(this).addClass("ui-state-hover")
            }).mouseleave(function () {
                e(this).removeClass("ui-state-hover")
            }).focus(function () {
                i.disabled ? e(this).blur() : (e(".ui-slider .ui-state-focus").removeClass("ui-state-focus"), e(this).addClass("ui-state-focus"))
            }).blur(function () {
                e(this).removeClass("ui-state-focus")
            }), this.handles.each(function (t) {
                e(this).data("ui-slider-handle-index", t)
            }), this._on(this.handles, {
                keydown: function (t) {
                    var r, i, s, o, u = e(t.target).data("ui-slider-handle-index");
                    switch (t.keyCode) {
                        case e.ui.keyCode.HOME:
                        case e.ui.keyCode.END:
                        case e.ui.keyCode.PAGE_UP:
                        case e.ui.keyCode.PAGE_DOWN:
                        case e.ui.keyCode.UP:
                        case e.ui.keyCode.RIGHT:
                        case e.ui.keyCode.DOWN:
                        case e.ui.keyCode.LEFT:
                            t.preventDefault();
                            if (!this._keySliding) {
                                this._keySliding = !0, e(t.target).addClass("ui-state-active"), r = this._start(t, u);
                                if (r === !1)return
                            }
                    }
                    o = this.options.step, this.options.values && this.options.values.length ? i = s = this.values(u) : i = s = this.value();
                    switch (t.keyCode) {
                        case e.ui.keyCode.HOME:
                            s = this._valueMin();
                            break;
                        case e.ui.keyCode.END:
                            s = this._valueMax();
                            break;
                        case e.ui.keyCode.PAGE_UP:
                            s = this._trimAlignValue(i + (this._valueMax() - this._valueMin()) / n);
                            break;
                        case e.ui.keyCode.PAGE_DOWN:
                            s = this._trimAlignValue(i - (this._valueMax() - this._valueMin()) / n);
                            break;
                        case e.ui.keyCode.UP:
                        case e.ui.keyCode.RIGHT:
                            if (i === this._valueMax())return;
                            s = this._trimAlignValue(i + o);
                            break;
                        case e.ui.keyCode.DOWN:
                        case e.ui.keyCode.LEFT:
                            if (i === this._valueMin())return;
                            s = this._trimAlignValue(i - o)
                    }
                    this._slide(t, u, s)
                }, keyup: function (t) {
                    var n = e(t.target).data("ui-slider-handle-index");
                    this._keySliding && (this._keySliding = !1, this._stop(t, n), this._change(t, n), e(t.target).removeClass("ui-state-active"))
                }
            }), this._refreshValue(), this._animateOff = !1
        },
        _destroy: function () {
            this.handles.remove(), this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all"), this._mouseDestroy()
        },
        _mouseCapture: function (t) {
            var n, r, i, s, o, u, a, f, l = this, c = this.options;
            return c.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), n = {
                x: t.pageX,
                y: t.pageY
            }, r = this._normValueFromMouse(n), i = this._valueMax() - this._valueMin() + 1, this.handles.each(function (t) {
                var n = Math.abs(r - l.values(t));
                i > n && (i = n, s = e(this), o = t)
            }), c.range === !0 && this.values(1) === c.min && (o += 1, s = e(this.handles[o])), u = this._start(t, o), u === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = o, s.addClass("ui-state-active").focus(), a = s.offset(), f = !e(t.target).parents().andSelf().is(".ui-slider-handle"), this._clickOffset = f ? {
                left: 0,
                top: 0
            } : {
                left: t.pageX - a.left - s.width() / 2,
                top: t.pageY - a.top - s.height() / 2 - (parseInt(s.css("borderTopWidth"), 10) || 0) - (parseInt(s.css("borderBottomWidth"), 10) || 0) + (parseInt(s.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, r), this._animateOff = !0, !0))
        },
        _mouseStart: function () {
            return !0
        },
        _mouseDrag: function (e) {
            var t = {x: e.pageX, y: e.pageY}, n = this._normValueFromMouse(t);
            return this._slide(e, this._handleIndex, n), !1
        },
        _mouseStop: function (e) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1
        },
        _detectOrientation: function () {
            this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal"
        },
        _normValueFromMouse: function (e) {
            var t, n, r, i, s;
            return this.orientation === "horizontal" ? (t = this.elementSize.width, n = e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, n = e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), r = n / t, r > 1 && (r = 1), r < 0 && (r = 0), this.orientation === "vertical" && (r = 1 - r), i = this._valueMax() - this._valueMin(), s = this._valueMin() + r * i, this._trimAlignValue(s)
        },
        _start: function (e, t) {
            var n = {handle: this.handles[t], value: this.value()};
            return this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("start", e, n)
        },
        _slide: function (e, t, n) {
            var r, i, s;
            this.options.values && this.options.values.length ? (r = this.values(t ? 0 : 1), this.options.values.length === 2 && this.options.range === !0 && (t === 0 && n > r || t === 1 && n < r) && (n = r), n !== this.values(t) && (i = this.values(), i[t] = n, s = this._trigger("slide", e, {
                handle: this.handles[t],
                value: n,
                values: i
            }), r = this.values(t ? 0 : 1), s !== !1 && this.values(t, n, !0))) : n !== this.value() && (s = this._trigger("slide", e, {
                handle: this.handles[t],
                value: n
            }), s !== !1 && this.value(n))
        },
        _stop: function (e, t) {
            var n = {handle: this.handles[t], value: this.value()};
            this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("stop", e, n)
        },
        _change: function (e, t) {
            if (!this._keySliding && !this._mouseSliding) {
                var n = {handle: this.handles[t], value: this.value()};
                this.options.values && this.options.values.length && (n.value = this.values(t), n.values = this.values()), this._trigger("change", e, n)
            }
        },
        value: function (e) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(e), this._refreshValue(), this._change(null, 0);
                return
            }
            return this._value()
        },
        values: function (t, n) {
            var r, i, s;
            if (arguments.length > 1) {
                this.options.values[t] = this._trimAlignValue(n), this._refreshValue(), this._change(null, t);
                return
            }
            if (!arguments.length)return this._values();
            if (!e.isArray(arguments[0]))return this.options.values && this.options.values.length ? this._values(t) : this.value();
            r = this.options.values, i = arguments[0];
            for (s = 0; s < r.length; s += 1)r[s] = this._trimAlignValue(i[s]), this._change(null, s);
            this._refreshValue()
        },
        _setOption: function (t, n) {
            var r, i = 0;
            e.isArray(this.options.values) && (i = this.options.values.length), e.Widget.prototype._setOption.apply(this, arguments);
            switch (t) {
                case"disabled":
                    n ? (this.handles.filter(".ui-state-focus").blur(), this.handles.removeClass("ui-state-hover"), this.handles.prop("disabled", !0), this.element.addClass("ui-disabled")) : (this.handles.prop("disabled", !1), this.element.removeClass("ui-disabled"));
                    break;
                case"orientation":
                    this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), this._refreshValue();
                    break;
                case"value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                    break;
                case"values":
                    this._animateOff = !0, this._refreshValue();
                    for (r = 0; r < i; r += 1)this._change(null, r);
                    this._animateOff = !1;
                    break;
                case"min":
                case"max":
                    this._animateOff = !0, this._refreshValue(), this._animateOff = !1
            }
        },
        _value: function () {
            var e = this.options.value;
            return e = this._trimAlignValue(e), e
        },
        _values: function (e) {
            var t, n, r;
            if (arguments.length)return t = this.options.values[e], t = this._trimAlignValue(t), t;
            n = this.options.values.slice();
            for (r = 0; r < n.length; r += 1)n[r] = this._trimAlignValue(n[r]);
            return n
        },
        _trimAlignValue: function (e) {
            if (e <= this._valueMin())return this._valueMin();
            if (e >= this._valueMax())return this._valueMax();
            var t = this.options.step > 0 ? this.options.step : 1, n = (e - this._valueMin()) % t, r = e - n;
            return Math.abs(n) * 2 >= t && (r += n > 0 ? t : -t), parseFloat(r.toFixed(5))
        },
        _valueMin: function () {
            return this.options.min
        },
        _valueMax: function () {
            return this.options.max
        },
        _refreshValue: function () {
            var t, n, r, i, s, o = this.options.range, u = this.options, a = this, f = this._animateOff ? !1 : u.animate, l = {};
            this.options.values && this.options.values.length ? this.handles.each(function (r) {
                n = (a.values(r) - a._valueMin()) / (a._valueMax() - a._valueMin()) * 100, l[a.orientation === "horizontal" ? "left" : "bottom"] = n + "%", e(this).stop(1, 1)[f ? "animate" : "css"](l, u.animate), a.options.range === !0 && (a.orientation === "horizontal" ? (r === 0 && a.range.stop(1, 1)[f ? "animate" : "css"]({left: n + "%"}, u.animate), r === 1 && a.range[f ? "animate" : "css"]({width: n - t + "%"}, {
                    queue: !1,
                    duration: u.animate
                })) : (r === 0 && a.range.stop(1, 1)[f ? "animate" : "css"]({bottom: n + "%"}, u.animate), r === 1 && a.range[f ? "animate" : "css"]({height: n - t + "%"}, {
                    queue: !1,
                    duration: u.animate
                }))), t = n
            }) : (r = this.value(), i = this._valueMin(), s = this._valueMax(), n = s !== i ? (r - i) / (s - i) * 100 : 0, l[this.orientation === "horizontal" ? "left" : "bottom"] = n + "%", this.handle.stop(1, 1)[f ? "animate" : "css"](l, u.animate), o === "min" && this.orientation === "horizontal" && this.range.stop(1, 1)[f ? "animate" : "css"]({width: n + "%"}, u.animate), o === "max" && this.orientation === "horizontal" && this.range[f ? "animate" : "css"]({width: 100 - n + "%"}, {
                queue: !1,
                duration: u.animate
            }), o === "min" && this.orientation === "vertical" && this.range.stop(1, 1)[f ? "animate" : "css"]({height: n + "%"}, u.animate), o === "max" && this.orientation === "vertical" && this.range[f ? "animate" : "css"]({height: 100 - n + "%"}, {
                queue: !1,
                duration: u.animate
            }))
        }
    })
}(jQuery), function (e) {
    function t(e) {
        return function () {
            var t = this.element.val();
            e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change")
        }
    }

    e.widget("ui.spinner", {
        version: "1.9.1",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {down: "ui-icon-triangle-1-s", up: "ui-icon-triangle-1-n"},
            incremental: !0,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function () {
            this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _getCreateOptions: function () {
            var t = {}, n = this.element;
            return e.each(["min", "max", "step"], function (e, r) {
                var i = n.attr(r);
                i !== undefined && i.length && (t[r] = i)
            }), t
        },
        _events: {
            keydown: function (e) {
                this._start(e) && this._keydown(e) && e.preventDefault()
            }, keyup: "_stop", focus: function () {
                this.previous = this.element.val()
            }, blur: function (e) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return
                }
                this._refresh(), this.previous !== this.element.val() && this._trigger("change", e)
            }, mousewheel: function (e, t) {
                if (!t)return;
                if (!this.spinning && !this._start(e))return !1;
                this._spin((t > 0 ? 1 : -1) * this.options.step, e), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
                    this.spinning && this._stop(e)
                }, 100), e.preventDefault()
            }, "mousedown .ui-spinner-button": function (t) {
                function r() {
                    var e = this.element[0] === this.document[0].activeElement;
                    e || (this.element.focus(), this.previous = n, this._delay(function () {
                        this.previous = n
                    }))
                }

                var n;
                n = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), t.preventDefault(), r.call(this), this.cancelBlur = !0, this._delay(function () {
                    delete this.cancelBlur, r.call(this)
                });
                if (this._start(t) === !1)return;
                this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
            }, "mouseup .ui-spinner-button": "_stop", "mouseenter .ui-spinner-button": function (t) {
                if (!e(t.currentTarget).hasClass("ui-state-active"))return;
                if (this._start(t) === !1)return !1;
                this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
            }, "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function () {
            var e = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            this.element.attr("role", "spinbutton"), this.buttons = e.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all"), this.buttons.height() > Math.ceil(e.height() * .5) && e.height() > 0 && e.height(e.height()), this.options.disabled && this.disable()
        },
        _keydown: function (t) {
            var n = this.options, r = e.ui.keyCode;
            switch (t.keyCode) {
                case r.UP:
                    return this._repeat(null, 1, t), !0;
                case r.DOWN:
                    return this._repeat(null, -1, t), !0;
                case r.PAGE_UP:
                    return this._repeat(null, n.page, t), !0;
                case r.PAGE_DOWN:
                    return this._repeat(null, -n.page, t), !0
            }
            return !1
        },
        _uiSpinnerHtml: function () {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"
        },
        _buttonHtml: function () {
            return "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>"
        },
        _start: function (e) {
            return !this.spinning && this._trigger("start", e) === !1 ? !1 : (this.counter || (this.counter = 1), this.spinning = !0, !0)
        },
        _repeat: function (e, t, n) {
            e = e || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
                this._repeat(40, t, n)
            }, e), this._spin(t * this.options.step, n)
        },
        _spin: function (e, t) {
            var n = this.value() || 0;
            this.counter || (this.counter = 1), n = this._adjustValue(n + e * this._increment(this.counter));
            if (!this.spinning || this._trigger("spin", t, {value: n}) !== !1)this._value(n), this.counter++
        },
        _increment: function (t) {
            var n = this.options.incremental;
            return n ? e.isFunction(n) ? n(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1
        },
        _precision: function () {
            var e = this._precisionOf(this.options.step);
            return this.options.min !== null && (e = Math.max(e, this._precisionOf(this.options.min))), e
        },
        _precisionOf: function (e) {
            var t = e.toString(), n = t.indexOf(".");
            return n === -1 ? 0 : t.length - n - 1
        },
        _adjustValue: function (e) {
            var t, n, r = this.options;
            return t = r.min !== null ? r.min : 0, n = e - t, n = Math.round(n / r.step) * r.step, e = t + n, e = parseFloat(e.toFixed(this._precision())), r.max !== null && e > r.max ? r.max : r.min !== null && e < r.min ? r.min : e
        },
        _stop: function (e) {
            if (!this.spinning)return;
            clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", e)
        },
        _setOption: function (e, t) {
            if (e === "culture" || e === "numberFormat") {
                var n = this._parse(this.element.val());
                this.options[e] = t, this.element.val(this._format(n));
                return
            }
            (e === "max" || e === "min" || e === "step") && typeof t == "string" && (t = this._parse(t)), this._super(e, t), e === "disabled" && (t ? (this.element.prop("disabled", !0), this.buttons.button("disable")) : (this.element.prop("disabled", !1), this.buttons.button("enable")))
        },
        _setOptions: t(function (e) {
            this._super(e), this._value(this.element.val())
        }),
        _parse: function (e) {
            return typeof e == "string" && e !== "" && (e = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(e, 10, this.options.culture) : +e), e === "" || isNaN(e) ? null : e
        },
        _format: function (e) {
            return e === "" ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(e, this.options.numberFormat, this.options.culture) : e
        },
        _refresh: function () {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            })
        },
        _value: function (e, t) {
            var n;
            e !== "" && (n = this._parse(e), n !== null && (t || (n = this._adjustValue(n)), e = this._format(n))), this.element.val(e), this._refresh()
        },
        _destroy: function () {
            this.element.removeClass("ui-spinner-input").prop("disabled", !1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.uiSpinner.replaceWith(this.element)
        },
        stepUp: t(function (e) {
            this._stepUp(e)
        }),
        _stepUp: function (e) {
            this._spin((e || 1) * this.options.step)
        },
        stepDown: t(function (e) {
            this._stepDown(e)
        }),
        _stepDown: function (e) {
            this._spin((e || 1) * -this.options.step)
        },
        pageUp: t(function (e) {
            this._stepUp((e || 1) * this.options.page)
        }),
        pageDown: t(function (e) {
            this._stepDown((e || 1) * this.options.page)
        }),
        value: function (e) {
            if (!arguments.length)return this._parse(this.element.val());
            t(this._value).call(this, e)
        },
        widget: function () {
            return this.uiSpinner
        }
    })
}(jQuery), function (e, t) {
    function i() {
        return ++n
    }

    function s(e) {
        return e.hash.length > 1 && e.href.replace(r, "") === location.href.replace(r, "")
    }

    var n = 0, r = /#.*$/;
    e.widget("ui.tabs", {
        version: "1.9.1",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _create: function () {
            var t = this, n = this.options, r = n.active, i = location.hash.substring(1);
            this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", n.collapsible).delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function (t) {
                e(this).is(".ui-state-disabled") && t.preventDefault()
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
                e(this).closest("li").is(".ui-state-disabled") && this.blur()
            }), this._processTabs();
            if (r === null) {
                i && this.tabs.each(function (t, n) {
                    if (e(n).attr("aria-controls") === i)return r = t, !1
                }), r === null && (r = this.tabs.index(this.tabs.filter(".ui-tabs-active")));
                if (r === null || r === -1)r = this.tabs.length ? 0 : !1
            }
            r !== !1 && (r = this.tabs.index(this.tabs.eq(r)), r === -1 && (r = n.collapsible ? !1 : 0)), n.active = r, !n.collapsible && n.active === !1 && this.anchors.length && (n.active = 0), e.isArray(n.disabled) && (n.disabled = e.unique(n.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"), function (e) {
                return t.tabs.index(e)
            }))).sort()), this.options.active !== !1 && this.anchors.length ? this.active = this._findActive(this.options.active) : this.active = e(), this._refresh(), this.active.length && this.load(n.active)
        },
        _getCreateEventData: function () {
            return {tab: this.active, panel: this.active.length ? this._getPanelForTab(this.active) : e()}
        },
        _tabKeydown: function (t) {
            var n = e(this.document[0].activeElement).closest("li"), r = this.tabs.index(n), i = !0;
            if (this._handlePageNav(t))return;
            switch (t.keyCode) {
                case e.ui.keyCode.RIGHT:
                case e.ui.keyCode.DOWN:
                    r++;
                    break;
                case e.ui.keyCode.UP:
                case e.ui.keyCode.LEFT:
                    i = !1, r--;
                    break;
                case e.ui.keyCode.END:
                    r = this.anchors.length - 1;
                    break;
                case e.ui.keyCode.HOME:
                    r = 0;
                    break;
                case e.ui.keyCode.SPACE:
                    t.preventDefault(), clearTimeout(this.activating), this._activate(r);
                    return;
                case e.ui.keyCode.ENTER:
                    t.preventDefault(), clearTimeout(this.activating), this._activate(r === this.options.active ? !1 : r);
                    return;
                default:
                    return
            }
            t.preventDefault(), clearTimeout(this.activating), r = this._focusNextTab(r, i), t.ctrlKey || (n.attr("aria-selected", "false"), this.tabs.eq(r).attr("aria-selected", "true"), this.activating = this._delay(function () {
                this.option("active", r)
            }, this.delay))
        },
        _panelKeydown: function (t) {
            if (this._handlePageNav(t))return;
            t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t.preventDefault(), this.active.focus())
        },
        _handlePageNav: function (t) {
            if (t.altKey && t.keyCode === e.ui.keyCode.PAGE_UP)return this._activate(this._focusNextTab(this.options.active - 1, !1)), !0;
            if (t.altKey && t.keyCode === e.ui.keyCode.PAGE_DOWN)return this._activate(this._focusNextTab(this.options.active + 1, !0)), !0
        },
        _findNextTab: function (t, n) {
            function i() {
                return t > r && (t = 0), t < 0 && (t = r), t
            }

            var r = this.tabs.length - 1;
            while (e.inArray(i(), this.options.disabled) !== -1)t = n ? t + 1 : t - 1;
            return t
        },
        _focusNextTab: function (e, t) {
            return e = this._findNextTab(e, t), this.tabs.eq(e).focus(), e
        },
        _setOption: function (e, t) {
            if (e === "active") {
                this._activate(t);
                return
            }
            if (e === "disabled") {
                this._setupDisabled(t);
                return
            }
            this._super(e, t), e === "collapsible" && (this.element.toggleClass("ui-tabs-collapsible", t), !t && this.options.active === !1 && this._activate(0)), e === "event" && this._setupEvents(t), e === "heightStyle" && this._setupHeightStyle(t)
        },
        _tabId: function (e) {
            return e.attr("aria-controls") || "ui-tabs-" + i()
        },
        _sanitizeSelector: function (e) {
            return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
        },
        refresh: function () {
            var t = this.options, n = this.tablist.children(":has(a[href])");
            t.disabled = e.map(n.filter(".ui-state-disabled"), function (e) {
                return n.index(e)
            }), this._processTabs(), t.active === !1 || !this.anchors.length ? (t.active = !1, this.active = e()) : this.active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = e()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active), this._refresh()
        },
        _refresh: function () {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            }), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                "aria-selected": "true",
                tabIndex: 0
            }), this._getPanelForTab(this.active).show().attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            })) : this.tabs.eq(0).attr("tabIndex", 0)
        },
        _processTabs: function () {
            var t = this;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist"), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            }), this.anchors = this.tabs.map(function () {
                return e("a", this)[0]
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            }), this.panels = e(), this.anchors.each(function (n, r) {
                var i, o, u, a = e(r).uniqueId().attr("id"), f = e(r).closest("li"), l = f.attr("aria-controls");
                s(r) ? (i = r.hash, o = t.element.find(t._sanitizeSelector(i))) : (u = t._tabId(f), i = "#" + u, o = t.element.find(i), o.length || (o = t._createPanel(u), o.insertAfter(t.panels[n - 1] || t.tablist)), o.attr("aria-live", "polite")), o.length && (t.panels = t.panels.add(o)), l && f.data("ui-tabs-aria-controls", l), f.attr({
                    "aria-controls": i.substring(1),
                    "aria-labelledby": a
                }), o.attr("aria-labelledby", a)
            }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel")
        },
        _getList: function () {
            return this.element.find("ol,ul").eq(0)
        },
        _createPanel: function (t) {
            return e("<div>").attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0)
        },
        _setupDisabled: function (t) {
            e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1);
            for (var n = 0, r; r = this.tabs[n]; n++)t === !0 || e.inArray(n, t) !== -1 ? e(r).addClass("ui-state-disabled").attr("aria-disabled", "true") : e(r).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            this.options.disabled = t
        },
        _setupEvents: function (t) {
            var n = {
                click: function (e) {
                    e.preventDefault()
                }
            };
            t && e.each(t.split(" "), function (e, t) {
                n[t] = "_eventHandler"
            }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(this.anchors, n), this._on(this.tabs, {keydown: "_tabKeydown"}), this._on(this.panels, {keydown: "_panelKeydown"}), this._focusable(this.tabs), this._hoverable(this.tabs)
        },
        _setupHeightStyle: function (t) {
            var n, r, i = this.element.parent();
            t === "fill" ? (e.support.minHeight || (r = i.css("overflow"), i.css("overflow", "hidden")), n = i.height(), this.element.siblings(":visible").each(function () {
                var t = e(this), r = t.css("position");
                if (r === "absolute" || r === "fixed")return;
                n -= t.outerHeight(!0)
            }), r && i.css("overflow", r), this.element.children().not(this.panels).each(function () {
                n -= e(this).outerHeight(!0)
            }), this.panels.each(function () {
                e(this).height(Math.max(0, n - e(this).innerHeight() + e(this).height()))
            }).css("overflow", "auto")) : t === "auto" && (n = 0, this.panels.each(function () {
                n = Math.max(n, e(this).height("").height())
            }).height(n))
        },
        _eventHandler: function (t) {
            var n = this.options, r = this.active, i = e(t.currentTarget), s = i.closest("li"), o = s[0] === r[0], u = o && n.collapsible, a = u ? e() : this._getPanelForTab(s), f = r.length ? this._getPanelForTab(r) : e(), l = {
                oldTab: r,
                oldPanel: f,
                newTab: u ? e() : s,
                newPanel: a
            };
            t.preventDefault();
            if (s.hasClass("ui-state-disabled") || s.hasClass("ui-tabs-loading") || this.running || o && !n.collapsible || this._trigger("beforeActivate", t, l) === !1)return;
            n.active = u ? !1 : this.tabs.index(s), this.active = o ? e() : s, this.xhr && this.xhr.abort(), !f.length && !a.length && e.error("jQuery UI Tabs: Mismatching fragment identifier."), a.length && this.load(this.tabs.index(s), t), this._toggle(t, l)
        },
        _toggle: function (t, n) {
            function o() {
                r.running = !1, r._trigger("activate", t, n)
            }

            function u() {
                n.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), i.length && r.options.show ? r._show(i, r.options.show, o) : (i.show(), o())
            }

            var r = this, i = n.newPanel, s = n.oldPanel;
            this.running = !0, s.length && this.options.hide ? this._hide(s, this.options.hide, function () {
                n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), u()
            }) : (n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), s.hide(), u()), s.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            }), n.oldTab.attr("aria-selected", "false"), i.length && s.length ? n.oldTab.attr("tabIndex", -1) : i.length && this.tabs.filter(function () {
                return e(this).attr("tabIndex") === 0
            }).attr("tabIndex", -1), i.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            }), n.newTab.attr({"aria-selected": "true", tabIndex: 0})
        },
        _activate: function (t) {
            var n, r = this._findActive(t);
            if (r[0] === this.active[0])return;
            r.length || (r = this.active), n = r.find(".ui-tabs-anchor")[0], this._eventHandler({
                target: n,
                currentTarget: n,
                preventDefault: e.noop
            })
        },
        _findActive: function (t) {
            return t === !1 ? e() : this.tabs.eq(t)
        },
        _getIndex: function (e) {
            return typeof e == "string" && (e = this.anchors.index(this.anchors.filter("[href$='" + e + "']"))), e
        },
        _destroy: function () {
            this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeData("href.tabs").removeData("load.tabs").removeUniqueId(), this.tabs.add(this.panels).each(function () {
                e.data(this, "ui-tabs-destroy") ? e(this).remove() : e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")
            }), this.tabs.each(function () {
                var t = e(this), n = t.data("ui-tabs-aria-controls");
                n ? t.attr("aria-controls", n) : t.removeAttr("aria-controls")
            }), this.options.heightStyle !== "content" && this.panels.css("height", "")
        },
        enable: function (n) {
            var r = this.options.disabled;
            if (r === !1)return;
            n === t ? r = !1 : (n = this._getIndex(n), e.isArray(r) ? r = e.map(r, function (e) {
                return e !== n ? e : null
            }) : r = e.map(this.tabs, function (e, t) {
                return t !== n ? t : null
            })), this._setupDisabled(r)
        },
        disable: function (n) {
            var r = this.options.disabled;
            if (r === !0)return;
            if (n === t)r = !0; else {
                n = this._getIndex(n);
                if (e.inArray(n, r) !== -1)return;
                e.isArray(r) ? r = e.merge([n], r).sort() : r = [n]
            }
            this._setupDisabled(r)
        },
        load: function (t, n) {
            t = this._getIndex(t);
            var r = this, i = this.tabs.eq(t), o = i.find(".ui-tabs-anchor"), u = this._getPanelForTab(i), a = {
                tab: i,
                panel: u
            };
            if (s(o[0]))return;
            this.xhr = e.ajax(this._ajaxSettings(o, n, a)), this.xhr && this.xhr.statusText !== "canceled" && (i.addClass("ui-tabs-loading"), u.attr("aria-busy", "true"), this.xhr.success(function (e) {
                setTimeout(function () {
                    u.html(e), r._trigger("load", n, a)
                }, 1)
            }).complete(function (e, t) {
                setTimeout(function () {
                    t === "abort" && r.panels.stop(!1, !0), i.removeClass("ui-tabs-loading"), u.removeAttr("aria-busy"), e === r.xhr && delete r.xhr
                }, 1)
            }))
        },
        _ajaxSettings: function (t, n, r) {
            var i = this;
            return {
                url: t.attr("href"), beforeSend: function (t, s) {
                    return i._trigger("beforeLoad", n, e.extend({jqXHR: t, ajaxSettings: s}, r))
                }
            }
        },
        _getPanelForTab: function (t) {
            var n = e(t).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + n))
        }
    }), e.uiBackCompat !== !1 && (e.ui.tabs.prototype._ui = function (e, t) {
        return {tab: e, panel: t, index: this.anchors.index(e)}
    }, e.widget("ui.tabs", e.ui.tabs, {
        url: function (e, t) {
            this.anchors.eq(e).attr("href", t)
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {ajaxOptions: null, cache: !1}, _create: function () {
            this._super();
            var t = this;
            this._on({
                tabsbeforeload: function (n, r) {
                    if (e.data(r.tab[0], "cache.tabs")) {
                        n.preventDefault();
                        return
                    }
                    r.jqXHR.success(function () {
                        t.options.cache && e.data(r.tab[0], "cache.tabs", !0)
                    })
                }
            })
        }, _ajaxSettings: function (t, n, r) {
            var i = this.options.ajaxOptions;
            return e.extend({}, i, {
                error: function (e, t) {
                    try {
                        i.error(e, t, r.tab.closest("li").index(), r.tab[0])
                    } catch (n) {
                    }
                }
            }, this._superApply(arguments))
        }, _setOption: function (e, t) {
            e === "cache" && t === !1 && this.anchors.removeData("cache.tabs"), this._super(e, t)
        }, _destroy: function () {
            this.anchors.removeData("cache.tabs"), this._super()
        }, url: function (e) {
            this.anchors.eq(e).removeData("cache.tabs"), this._superApply(arguments)
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        abort: function () {
            this.xhr && this.xhr.abort()
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {spinner: "<em>Loading&#8230;</em>"}, _create: function () {
            this._super(), this._on({
                tabsbeforeload: function (e, t) {
                    if (e.target !== this.element[0] || !this.options.spinner)return;
                    var n = t.tab.find("span"), r = n.html();
                    n.html(this.options.spinner), t.jqXHR.complete(function () {
                        n.html(r)
                    })
                }
            })
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {enable: null, disable: null}, enable: function (t) {
            var n = this.options, r;
            if (t && n.disabled === !0 || e.isArray(n.disabled) && e.inArray(t, n.disabled) !== -1)r = !0;
            this._superApply(arguments), r && this._trigger("enable", null, this._ui(this.anchors[t], this.panels[t]))
        }, disable: function (t) {
            var n = this.options, r;
            if (t && n.disabled === !1 || e.isArray(n.disabled) && e.inArray(t, n.disabled) === -1)r = !0;
            this._superApply(arguments), r && this._trigger("disable", null, this._ui(this.anchors[t], this.panels[t]))
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {
            add: null,
            remove: null,
            tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
        }, add: function (n, r, i) {
            i === t && (i = this.anchors.length);
            var s, o, u = this.options, a = e(u.tabTemplate.replace(/#\{href\}/g, n).replace(/#\{label\}/g, r)), f = n.indexOf("#") ? this._tabId(a) : n.replace("#", "");
            return a.addClass("ui-state-default ui-corner-top").data("ui-tabs-destroy", !0), a.attr("aria-controls", f), s = i >= this.tabs.length, o = this.element.find("#" + f), o.length || (o = this._createPanel(f), s ? i > 0 ? o.insertAfter(this.panels.eq(-1)) : o.appendTo(this.element) : o.insertBefore(this.panels[i])), o.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").hide(), s ? a.appendTo(this.tablist) : a.insertBefore(this.tabs[i]), u.disabled = e.map(u.disabled, function (e) {
                return e >= i ? ++e : e
            }), this.refresh(), this.tabs.length === 1 && u.active === !1 && this.option("active", 0), this._trigger("add", null, this._ui(this.anchors[i], this.panels[i])), this
        }, remove: function (t) {
            t = this._getIndex(t);
            var n = this.options, r = this.tabs.eq(t).remove(), i = this._getPanelForTab(r).remove();
            return r.hasClass("ui-tabs-active") && this.anchors.length > 2 && this._activate(t + (t + 1 < this.anchors.length ? 1 : -1)), n.disabled = e.map(e.grep(n.disabled, function (e) {
                return e !== t
            }), function (e) {
                return e >= t ? --e : e
            }), this.refresh(), this._trigger("remove", null, this._ui(r.find("a")[0], i[0])), this
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        length: function () {
            return this.anchors.length
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {idPrefix: "ui-tabs-"}, _tabId: function (t) {
            var n = t.is("li") ? t.find("a[href]") : t;
            return n = n[0], e(n).closest("li").attr("aria-controls") || n.title && n.title.replace(/\s/g, "_").replace(/[^\w\u00c0-\uFFFF\-]/g, "") || this.options.idPrefix + i()
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {panelTemplate: "<div></div>"}, _createPanel: function (t) {
            return e(this.options.panelTemplate).attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0)
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        _create: function () {
            var e = this.options;
            e.active === null && e.selected !== t && (e.active = e.selected === -1 ? !1 : e.selected), this._super(), e.selected = e.active, e.selected === !1 && (e.selected = -1)
        }, _setOption: function (e, t) {
            if (e !== "selected")return this._super(e, t);
            var n = this.options;
            this._super("active", t === -1 ? !1 : t), n.selected = n.active, n.selected === !1 && (n.selected = -1)
        }, _eventHandler: function () {
            this._superApply(arguments), this.options.selected = this.options.active, this.options.selected === !1 && (this.options.selected = -1)
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {show: null, select: null}, _create: function () {
            this._super(), this.options.active !== !1 && this._trigger("show", null, this._ui(this.active.find(".ui-tabs-anchor")[0], this._getPanelForTab(this.active)[0]))
        }, _trigger: function (e, t, n) {
            var r = this._superApply(arguments);
            return r ? (e === "beforeActivate" && n.newTab.length ? r = this._super("select", t, {
                tab: n.newTab.find(".ui-tabs-anchor")[0],
                panel: n.newPanel[0],
                index: n.newTab.closest("li").index()
            }) : e === "activate" && n.newTab.length && (r = this._super("show", t, {
                tab: n.newTab.find(".ui-tabs-anchor")[0],
                panel: n.newPanel[0],
                index: n.newTab.closest("li").index()
            })), r) : !1
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        select: function (e) {
            e = this._getIndex(e);
            if (e === -1) {
                if (!this.options.collapsible || this.options.selected === -1)return;
                e = this.options.selected
            }
            this.anchors.eq(e).trigger(this.options.event + this.eventNamespace)
        }
    }), function () {
        var t = 0;
        e.widget("ui.tabs", e.ui.tabs, {
            options: {cookie: null}, _create: function () {
                var e = this.options, t;
                e.active == null && e.cookie && (t = parseInt(this._cookie(), 10), t === -1 && (t = !1), e.active = t), this._super()
            }, _cookie: function (n) {
                var r = [this.cookie || (this.cookie = this.options.cookie.name || "ui-tabs-" + ++t)];
                return arguments.length && (r.push(n === !1 ? -1 : n), r.push(this.options.cookie)), e.cookie.apply(null, r)
            }, _refresh: function () {
                this._super(), this.options.cookie && this._cookie(this.options.active, this.options.cookie)
            }, _eventHandler: function () {
                this._superApply(arguments), this.options.cookie && this._cookie(this.options.active, this.options.cookie)
            }, _destroy: function () {
                this._super(), this.options.cookie && this._cookie(null, this.options.cookie)
            }
        })
    }(), e.widget("ui.tabs", e.ui.tabs, {
        _trigger: function (t, n, r) {
            var i = e.extend({}, r);
            return t === "load" && (i.panel = i.panel[0], i.tab = i.tab.find(".ui-tabs-anchor")[0]), this._super(t, n, i)
        }
    }), e.widget("ui.tabs", e.ui.tabs, {
        options: {fx: null}, _getFx: function () {
            var t, n, r = this.options.fx;
            return r && (e.isArray(r) ? (t = r[0], n = r[1]) : t = n = r), r ? {show: n, hide: t} : null
        }, _toggle: function (e, t) {
            function o() {
                n.running = !1, n._trigger("activate", e, t)
            }

            function u() {
                t.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), r.length && s.show ? r.animate(s.show, s.show.duration, function () {
                    o()
                }) : (r.show(), o())
            }

            var n = this, r = t.newPanel, i = t.oldPanel, s = this._getFx();
            if (!s)return this._super(e, t);
            n.running = !0, i.length && s.hide ? i.animate(s.hide, s.hide.duration, function () {
                t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), u()
            }) : (t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), i.hide(), u())
        }
    }))
}(jQuery), function (e) {
    function n(t, n) {
        var r = (t.attr("aria-describedby") || "").split(/\s+/);
        r.push(n), t.data("ui-tooltip-id", n).attr("aria-describedby", e.trim(r.join(" ")))
    }

    function r(t) {
        var n = t.data("ui-tooltip-id"), r = (t.attr("aria-describedby") || "").split(/\s+/), i = e.inArray(n, r);
        i !== -1 && r.splice(i, 1), t.removeData("ui-tooltip-id"), r = e.trim(r.join(" ")), r ? t.attr("aria-describedby", r) : t.removeAttr("aria-describedby")
    }

    var t = 0;
    e.widget("ui.tooltip", {
        version: "1.9.1", options: {
            content: function () {
                return e(this).attr("title")
            },
            hide: !0,
            items: "[title]:not([disabled])",
            position: {my: "left top+15", at: "left bottom", collision: "flipfit flipfit"},
            show: !0,
            tooltipClass: null,
            track: !1,
            close: null,
            open: null
        }, _create: function () {
            this._on({
                mouseover: "open",
                focusin: "open"
            }), this.tooltips = {}, this.parents = {}, this.options.disabled && this._disable()
        }, _setOption: function (t, n) {
            var r = this;
            if (t === "disabled") {
                this[n ? "_disable" : "_enable"](), this.options[t] = n;
                return
            }
            this._super(t, n), t === "content" && e.each(this.tooltips, function (e, t) {
                r._updateContent(t)
            })
        }, _disable: function () {
            var t = this;
            e.each(this.tooltips, function (n, r) {
                var i = e.Event("blur");
                i.target = i.currentTarget = r[0], t.close(i, !0)
            }), this.element.find(this.options.items).andSelf().each(function () {
                var t = e(this);
                t.is("[title]") && t.data("ui-tooltip-title", t.attr("title")).attr("title", "")
            })
        }, _enable: function () {
            this.element.find(this.options.items).andSelf().each(function () {
                var t = e(this);
                t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"))
            })
        }, open: function (t) {
            var n = this, r = e(t ? t.target : this.element).closest(this.options.items);
            if (!r.length)return;
            if (this.options.track && r.data("ui-tooltip-id")) {
                this._find(r).position(e.extend({of: r}, this.options.position)), this._off(this.document, "mousemove");
                return
            }
            r.attr("title") && r.data("ui-tooltip-title", r.attr("title")), r.data("tooltip-open", !0), t && t.type === "mouseover" && r.parents().each(function () {
                var t;
                e(this).data("tooltip-open") && (t = e.Event("blur"), t.target = t.currentTarget = this, n.close(t, !0)), this.title && (e(this).uniqueId(), n.parents[this.id] = {
                    element: this,
                    title: this.title
                }, this.title = "")
            }), this._updateContent(r, t)
        }, _updateContent: function (e, t) {
            var n, r = this.options.content, i = this;
            if (typeof r == "string")return this._open(t, e, r);
            n = r.call(e[0], function (n) {
                if (!e.data("tooltip-open"))return;
                i._delay(function () {
                    this._open(t, e, n)
                })
            }), n && this._open(t, e, n)
        }, _open: function (t, r, i) {
            function f(e) {
                a.of = e;
                if (s.is(":hidden"))return;
                s.position(a)
            }

            var s, o, u, a = e.extend({}, this.options.position);
            if (!i)return;
            s = this._find(r);
            if (s.length) {
                s.find(".ui-tooltip-content").html(i);
                return
            }
            r.is("[title]") && (t && t.type === "mouseover" ? r.attr("title", "") : r.removeAttr("title")), s = this._tooltip(r), n(r, s.attr("id")), s.find(".ui-tooltip-content").html(i), this.options.track && t && /^mouse/.test(t.originalEvent.type) ? (this._on(this.document, {mousemove: f}), f(t)) : s.position(e.extend({of: r}, this.options.position)), s.hide(), this._show(s, this.options.show), this.options.show && this.options.show.delay && (u = setInterval(function () {
                s.is(":visible") && (f(a.of), clearInterval(u))
            }, e.fx.interval)), this._trigger("open", t, {tooltip: s}), o = {
                keyup: function (t) {
                    if (t.keyCode === e.ui.keyCode.ESCAPE) {
                        var n = e.Event(t);
                        n.currentTarget = r[0], this.close(n, !0)
                    }
                }, remove: function () {
                    this._removeTooltip(s)
                }
            };
            if (!t || t.type === "mouseover")o.mouseleave = "close";
            if (!t || t.type === "focusin")o.focusout = "close";
            this._on(r, o)
        }, close: function (t) {
            var n = this, i = e(t ? t.currentTarget : this.element), s = this._find(i);
            if (this.closing)return;
            i.data("ui-tooltip-title") && i.attr("title", i.data("ui-tooltip-title")), r(i), s.stop(!0), this._hide(s, this.options.hide, function () {
                n._removeTooltip(e(this))
            }), i.removeData("tooltip-open"), this._off(i, "mouseleave focusout keyup"), i[0] !== this.element[0] && this._off(i, "remove"), this._off(this.document, "mousemove"), t && t.type === "mouseleave" && e.each(this.parents, function (e, t) {
                t.element.title = t.title, delete n.parents[e]
            }), this.closing = !0, this._trigger("close", t, {tooltip: s}), this.closing = !1
        }, _tooltip: function (n) {
            var r = "ui-tooltip-" + t++, i = e("<div>").attr({
                id: r,
                role: "tooltip"
            }).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || ""));
            return e("<div>").addClass("ui-tooltip-content").appendTo(i), i.appendTo(this.document[0].body), e.fn.bgiframe && i.bgiframe(), this.tooltips[r] = n, i
        }, _find: function (t) {
            var n = t.data("ui-tooltip-id");
            return n ? e("#" + n) : e()
        }, _removeTooltip: function (e) {
            e.remove(), delete this.tooltips[e.attr("id")]
        }, _destroy: function () {
            var t = this;
            e.each(this.tooltips, function (n, r) {
                var i = e.Event("blur");
                i.target = i.currentTarget = r[0], t.close(i, !0), e("#" + n).remove(), r.data("ui-tooltip-title") && (r.attr("title", r.data("ui-tooltip-title")), r.removeData("ui-tooltip-title"))
            })
        }
    })
}(jQuery);
/*!
 * jQuery Cookie Plugin
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function ($) {
    $.cookie = function (key, value, options) {

        // key and at least value given, set cookie...
        if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value === null || value === undefined)) {
            options = $.extend({}, options);

            if (value === null || value === undefined) {
                options.expires = -1;
            }

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            value = String(value);

            return (document.cookie = [
                encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // key and possibly options given, get cookie...
        options = value || {};
        var decode = options.raw ? function (s) {
            return s;
        } : decodeURIComponent;

        var pairs = document.cookie.split('; ');
        for (var i = 0, pair; pair = pairs[i] && pairs[i].split('='); i++) {
            if (decode(pair[0]) === key) return decode(pair[1] || ''); // IE saves cookies with empty string as "c; ", e.g. without "=" as opposed to EOMB, thus pair[1] may be undefined
        }
        return null;
    };
})(jQuery);
/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-05-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See http://www.datejs.com/license/.
 * @website: http://www.datejs.com/
 */
Date.CultureInfo = {
    name: "en-US",
    englishName: "English (United States)",
    nativeName: "English (United States)",
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    amDesignator: "AM",
    pmDesignator: "PM",
    firstDayOfWeek: 0,
    twoDigitYearMax: 2029,
    dateElementOrder: "mdy",
    formatPatterns: {
        shortDate: "M/d/yyyy",
        longDate: "dddd, MMMM dd, yyyy",
        shortTime: "h:mm tt",
        longTime: "h:mm:ss tt",
        fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt",
        sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
        universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
        rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
        monthDay: "MMMM dd",
        yearMonth: "MMMM, yyyy"
    },
    regexPatterns: {
        jan: /^jan(uary)?/i,
        feb: /^feb(ruary)?/i,
        mar: /^mar(ch)?/i,
        apr: /^apr(il)?/i,
        may: /^may/i,
        jun: /^jun(e)?/i,
        jul: /^jul(y)?/i,
        aug: /^aug(ust)?/i,
        sep: /^sep(t(ember)?)?/i,
        oct: /^oct(ober)?/i,
        nov: /^nov(ember)?/i,
        dec: /^dec(ember)?/i,
        sun: /^su(n(day)?)?/i,
        mon: /^mo(n(day)?)?/i,
        tue: /^tu(e(s(day)?)?)?/i,
        wed: /^we(d(nesday)?)?/i,
        thu: /^th(u(r(s(day)?)?)?)?/i,
        fri: /^fr(i(day)?)?/i,
        sat: /^sa(t(urday)?)?/i,
        future: /^next/i,
        past: /^last|past|prev(ious)?/i,
        add: /^(\+|aft(er)?|from|hence)/i,
        subtract: /^(\-|bef(ore)?|ago)/i,
        yesterday: /^yes(terday)?/i,
        today: /^t(od(ay)?)?/i,
        tomorrow: /^tom(orrow)?/i,
        now: /^n(ow)?/i,
        millisecond: /^ms|milli(second)?s?/i,
        second: /^sec(ond)?s?/i,
        minute: /^mn|min(ute)?s?/i,
        hour: /^h(our)?s?/i,
        week: /^w(eek)?s?/i,
        month: /^m(onth)?s?/i,
        day: /^d(ay)?s?/i,
        year: /^y(ear)?s?/i,
        shortMeridian: /^(a|p)/i,
        longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i,
        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,
        ordinalSuffix: /^\s*(st|nd|rd|th)/i,
        timeContext: /^\s*(\:|a(?!u|p)|p)/i
    },
    timezones: [{name: "UTC", offset: "-000"}, {name: "GMT", offset: "-000"}, {
        name: "EST",
        offset: "-0500"
    }, {name: "EDT", offset: "-0400"}, {name: "CST", offset: "-0600"}, {name: "CDT", offset: "-0500"}, {
        name: "MST",
        offset: "-0700"
    }, {name: "MDT", offset: "-0600"}, {name: "PST", offset: "-0800"}, {name: "PDT", offset: "-0700"}]
};
(function () {
    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo, p = function (s, l) {
        if (!l) {
            l = 2;
        }
        return ("000" + s).slice(l * -1);
    };
    $P.clearTime = function () {
        this.setHours(0);
        this.setMinutes(0);
        this.setSeconds(0);
        this.setMilliseconds(0);
        return this;
    };
    $P.setTimeToNow = function () {
        var n = new Date();
        this.setHours(n.getHours());
        this.setMinutes(n.getMinutes());
        this.setSeconds(n.getSeconds());
        this.setMilliseconds(n.getMilliseconds());
        return this;
    };
    $D.today = function () {
        return new Date().clearTime();
    };
    $D.compare = function (date1, date2) {
        if (isNaN(date1) || isNaN(date2)) {
            throw new Error(date1 + " - " + date2);
        } else if (date1 instanceof Date && date2 instanceof Date) {
            return (date1 < date2) ? -1 : (date1 > date2) ? 1 : 0;
        } else {
            throw new TypeError(date1 + " - " + date2);
        }
    };
    $D.equals = function (date1, date2) {
        return (date1.compareTo(date2) === 0);
    };
    $D.getDayNumberFromName = function (name) {
        var n = $C.dayNames, m = $C.abbreviatedDayNames, o = $C.shortestDayNames, s = name.toLowerCase();
        for (var i = 0; i < n.length; i++) {
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s) {
                return i;
            }
        }
        return -1;
    };
    $D.getMonthNumberFromName = function (name) {
        var n = $C.monthNames, m = $C.abbreviatedMonthNames, s = name.toLowerCase();
        for (var i = 0; i < n.length; i++) {
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
                return i;
            }
        }
        return -1;
    };
    $D.isLeapYear = function (year) {
        return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    };
    $D.getDaysInMonth = function (year, month) {
        return [31, ($D.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    };
    $D.getTimezoneAbbreviation = function (offset) {
        var z = $C.timezones, p;
        for (var i = 0; i < z.length; i++) {
            if (z[i].offset === offset) {
                return z[i].name;
            }
        }
        return null;
    };
    $D.getTimezoneOffset = function (name) {
        var z = $C.timezones, p;
        for (var i = 0; i < z.length; i++) {
            if (z[i].name === name.toUpperCase()) {
                return z[i].offset;
            }
        }
        return null;
    };
    $P.clone = function () {
        return new Date(this.getTime());
    };
    $P.compareTo = function (date) {
        return Date.compare(this, date);
    };
    $P.equals = function (date) {
        return Date.equals(this, date || new Date());
    };
    $P.between = function (start, end) {
        return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();
    };
    $P.isAfter = function (date) {
        return this.compareTo(date || new Date()) === 1;
    };
    $P.isBefore = function (date) {
        return (this.compareTo(date || new Date()) === -1);
    };
    $P.isToday = function () {
        return this.isSameDay(new Date());
    };
    $P.isSameDay = function (date) {
        return this.clone().clearTime().equals(date.clone().clearTime());
    };
    $P.addMilliseconds = function (value) {
        this.setMilliseconds(this.getMilliseconds() + value);
        return this;
    };
    $P.addSeconds = function (value) {
        return this.addMilliseconds(value * 1000);
    };
    $P.addMinutes = function (value) {
        return this.addMilliseconds(value * 60000);
    };
    $P.addHours = function (value) {
        return this.addMilliseconds(value * 3600000);
    };
    $P.addDays = function (value) {
        this.setDate(this.getDate() + value);
        return this;
    };
    $P.addWeeks = function (value) {
        return this.addDays(value * 7);
    };
    $P.addMonths = function (value) {
        var n = this.getDate();
        this.setDate(1);
        this.setMonth(this.getMonth() + value);
        this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth())));
        return this;
    };
    $P.addYears = function (value) {
        return this.addMonths(value * 12);
    };
    $P.add = function (config) {
        if (typeof config == "number") {
            this._orient = config;
            return this;
        }
        var x = config;
        if (x.milliseconds) {
            this.addMilliseconds(x.milliseconds);
        }
        if (x.seconds) {
            this.addSeconds(x.seconds);
        }
        if (x.minutes) {
            this.addMinutes(x.minutes);
        }
        if (x.hours) {
            this.addHours(x.hours);
        }
        if (x.weeks) {
            this.addWeeks(x.weeks);
        }
        if (x.months) {
            this.addMonths(x.months);
        }
        if (x.years) {
            this.addYears(x.years);
        }
        if (x.days) {
            this.addDays(x.days);
        }
        return this;
    };
    var $y, $m, $d;
    $P.getWeek = function () {
        var a, b, c, d, e, f, g, n, s, w;
        $y = (!$y) ? this.getFullYear() : $y;
        $m = (!$m) ? this.getMonth() + 1 : $m;
        $d = (!$d) ? this.getDate() : $d;
        if ($m <= 2) {
            a = $y - 1;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = 0;
            f = $d - 1 + (31 * ($m - 1));
        } else {
            a = $y;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = s + 1;
            f = $d + ((153 * ($m - 3) + 2) / 5) + 58 + s;
        }
        g = (a + b) % 7;
        d = (f + g - e) % 7;
        n = (f + 3 - d) | 0;
        if (n < 0) {
            w = 53 - ((g - s) / 5 | 0);
        } else if (n > 364 + s) {
            w = 1;
        } else {
            w = (n / 7 | 0) + 1;
        }
        $y = $m = $d = null;
        return w;
    };
    $P.getISOWeek = function () {
        $y = this.getUTCFullYear();
        $m = this.getUTCMonth() + 1;
        $d = this.getUTCDate();
        return p(this.getWeek());
    };
    $P.setWeek = function (n) {
        return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek());
    };
    $D._validate = function (n, min, max, name) {
        if (typeof n == "undefined") {
            return false;
        } else if (typeof n != "number") {
            throw new TypeError(n + " is not a Number.");
        } else if (n < min || n > max) {
            throw new RangeError(n + " is not a valid value for " + name + ".");
        }
        return true;
    };
    $D.validateMillisecond = function (value) {
        return $D._validate(value, 0, 999, "millisecond");
    };
    $D.validateSecond = function (value) {
        return $D._validate(value, 0, 59, "second");
    };
    $D.validateMinute = function (value) {
        return $D._validate(value, 0, 59, "minute");
    };
    $D.validateHour = function (value) {
        return $D._validate(value, 0, 23, "hour");
    };
    $D.validateDay = function (value, year, month) {
        return $D._validate(value, 1, $D.getDaysInMonth(year, month), "day");
    };
    $D.validateMonth = function (value) {
        return $D._validate(value, 0, 11, "month");
    };
    $D.validateYear = function (value) {
        return $D._validate(value, 0, 9999, "year");
    };
    $P.set = function (config) {
        if ($D.validateMillisecond(config.millisecond)) {
            this.addMilliseconds(config.millisecond - this.getMilliseconds());
        }
        if ($D.validateSecond(config.second)) {
            this.addSeconds(config.second - this.getSeconds());
        }
        if ($D.validateMinute(config.minute)) {
            this.addMinutes(config.minute - this.getMinutes());
        }
        if ($D.validateHour(config.hour)) {
            this.addHours(config.hour - this.getHours());
        }
        if ($D.validateMonth(config.month)) {
            this.addMonths(config.month - this.getMonth());
        }
        if ($D.validateYear(config.year)) {
            this.addYears(config.year - this.getFullYear());
        }
        if ($D.validateDay(config.day, this.getFullYear(), this.getMonth())) {
            this.addDays(config.day - this.getDate());
        }
        if (config.timezone) {
            this.setTimezone(config.timezone);
        }
        if (config.timezoneOffset) {
            this.setTimezoneOffset(config.timezoneOffset);
        }
        if (config.week && $D._validate(config.week, 0, 53, "week")) {
            this.setWeek(config.week);
        }
        return this;
    };
    $P.moveToFirstDayOfMonth = function () {
        return this.set({day: 1});
    };
    $P.moveToLastDayOfMonth = function () {
        return this.set({day: $D.getDaysInMonth(this.getFullYear(), this.getMonth())});
    };
    $P.moveToNthOccurrence = function (dayOfWeek, occurrence) {
        var shift = 0;
        if (occurrence > 0) {
            shift = occurrence - 1;
        }
        else if (occurrence === -1) {
            this.moveToLastDayOfMonth();
            if (this.getDay() !== dayOfWeek) {
                this.moveToDayOfWeek(dayOfWeek, -1);
            }
            return this;
        }
        return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, +1).addWeeks(shift);
    };
    $P.moveToDayOfWeek = function (dayOfWeek, orient) {
        var diff = (dayOfWeek - this.getDay() + 7 * (orient || +1)) % 7;
        return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff);
    };
    $P.moveToMonth = function (month, orient) {
        var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;
        return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff);
    };
    $P.getOrdinalNumber = function () {
        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;
    };
    $P.getTimezone = function () {
        return $D.getTimezoneAbbreviation(this.getUTCOffset());
    };
    $P.setTimezoneOffset = function (offset) {
        var here = this.getTimezoneOffset(), there = Number(offset) * -6 / 10;
        return this.addMinutes(there - here);
    };
    $P.setTimezone = function (offset) {
        return this.setTimezoneOffset($D.getTimezoneOffset(offset));
    };
    $P.hasDaylightSavingTime = function () {
        return (Date.today().set({month: 0, day: 1}).getTimezoneOffset() !== Date.today().set({
            month: 6,
            day: 1
        }).getTimezoneOffset());
    };
    $P.isDaylightSavingTime = function () {
        return (this.hasDaylightSavingTime() && new Date().getTimezoneOffset() === Date.today().set({
            month: 6,
            day: 1
        }).getTimezoneOffset());
    };
    $P.getUTCOffset = function () {
        var n = this.getTimezoneOffset() * -10 / 6, r;
        if (n < 0) {
            r = (n - 10000).toString();
            return r.charAt(0) + r.substr(2);
        } else {
            r = (n + 10000).toString();
            return "+" + r.substr(1);
        }
    };
    $P.getElapsed = function (date) {
        return (date || new Date()) - this;
    };
    if (!$P.toISOString) {
        $P.toISOString = function () {
            function f(n) {
                return n < 10 ? '0' + n : n;
            }

            return '"' + this.getUTCFullYear() + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate()) + 'T' +
                f(this.getUTCHours()) + ':' +
                f(this.getUTCMinutes()) + ':' +
                f(this.getUTCSeconds()) + 'Z"';
        };
    }
    $P._toString = $P.toString;
    $P.toString = function (format) {
        var x = this;
        if (format && format.length == 1) {
            var c = $C.formatPatterns;
            x.t = x.toString;
            switch (format) {
                case"d":
                    return x.t(c.shortDate);
                case"D":
                    return x.t(c.longDate);
                case"F":
                    return x.t(c.fullDateTime);
                case"m":
                    return x.t(c.monthDay);
                case"r":
                    return x.t(c.rfc1123);
                case"s":
                    return x.t(c.sortableDateTime);
                case"t":
                    return x.t(c.shortTime);
                case"T":
                    return x.t(c.longTime);
                case"u":
                    return x.t(c.universalSortableDateTime);
                case"y":
                    return x.t(c.yearMonth);
            }
        }
        var ord = function (n) {
            switch (n * 1) {
                case 1:
                case 21:
                case 31:
                    return "st";
                case 2:
                case 22:
                    return "nd";
                case 3:
                case 23:
                    return "rd";
                default:
                    return "th";
            }
        };
        return format ? format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g, function (m) {
            if (m.charAt(0) === "\\") {
                return m.replace("\\", "");
            }
            x.h = x.getHours;
            switch (m) {
                case"hh":
                    return p(x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12));
                case"h":
                    return x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12);
                case"HH":
                    return p(x.h());
                case"H":
                    return x.h();
                case"mm":
                    return p(x.getMinutes());
                case"m":
                    return x.getMinutes();
                case"ss":
                    return p(x.getSeconds());
                case"s":
                    return x.getSeconds();
                case"yyyy":
                    return p(x.getFullYear(), 4);
                case"yy":
                    return p(x.getFullYear());
                case"dddd":
                    return $C.dayNames[x.getDay()];
                case"ddd":
                    return $C.abbreviatedDayNames[x.getDay()];
                case"dd":
                    return p(x.getDate());
                case"d":
                    return x.getDate();
                case"MMMM":
                    return $C.monthNames[x.getMonth()];
                case"MMM":
                    return $C.abbreviatedMonthNames[x.getMonth()];
                case"MM":
                    return p((x.getMonth() + 1));
                case"M":
                    return x.getMonth() + 1;
                case"t":
                    return x.h() < 12 ? $C.amDesignator.substring(0, 1) : $C.pmDesignator.substring(0, 1);
                case"tt":
                    return x.h() < 12 ? $C.amDesignator : $C.pmDesignator;
                case"S":
                    return ord(x.getDate());
                default:
                    return m;
            }
        }) : this._toString();
    };
}());
(function () {
    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo, $N = Number.prototype;
    $P._orient = +1;
    $P._nth = null;
    $P._is = false;
    $P._same = false;
    $P._isSecond = false;
    $N._dateElement = "day";
    $P.next = function () {
        this._orient = +1;
        return this;
    };
    $D.next = function () {
        return $D.today().next();
    };
    $P.last = $P.prev = $P.previous = function () {
        this._orient = -1;
        return this;
    };
    $D.last = $D.prev = $D.previous = function () {
        return $D.today().last();
    };
    $P.is = function () {
        this._is = true;
        return this;
    };
    $P.same = function () {
        this._same = true;
        this._isSecond = false;
        return this;
    };
    $P.today = function () {
        return this.same().day();
    };
    $P.weekday = function () {
        if (this._is) {
            this._is = false;
            return (!this.is().sat() && !this.is().sun());
        }
        return false;
    };
    $P.at = function (time) {
        return (typeof time === "string") ? $D.parse(this.toString("d") + " " + time) : this.set(time);
    };
    $N.fromNow = $N.after = function (date) {
        var c = {};
        c[this._dateElement] = this;
        return ((!date) ? new Date() : date.clone()).add(c);
    };
    $N.ago = $N.before = function (date) {
        var c = {};
        c[this._dateElement] = this * -1;
        return ((!date) ? new Date() : date.clone()).add(c);
    };
    var dx = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/), mx = ("january february march april may june july august september october november december").split(/\s/), px = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/), pxf = ("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/), nth = ("final first second third fourth fifth").split(/\s/), de;
    $P.toObject = function () {
        var o = {};
        for (var i = 0; i < px.length; i++) {
            o[px[i].toLowerCase()] = this["get" + pxf[i]]();
        }
        return o;
    };
    $D.fromObject = function (config) {
        config.week = null;
        return Date.today().set(config);
    };
    var df = function (n) {
        return function () {
            if (this._is) {
                this._is = false;
                return this.getDay() == n;
            }
            if (this._nth !== null) {
                if (this._isSecond) {
                    this.addSeconds(this._orient * -1);
                }
                this._isSecond = false;
                var ntemp = this._nth;
                this._nth = null;
                var temp = this.clone().moveToLastDayOfMonth();
                this.moveToNthOccurrence(n, ntemp);
                if (this > temp) {
                    throw new RangeError($D.getDayName(n) + " does not occur " + ntemp + " times in the month of " + $D.getMonthName(temp.getMonth()) + " " + temp.getFullYear() + ".");
                }
                return this;
            }
            return this.moveToDayOfWeek(n, this._orient);
        };
    };
    var sdf = function (n) {
        return function () {
            var t = $D.today(), shift = n - t.getDay();
            if (n === 0 && $C.firstDayOfWeek === 1 && t.getDay() !== 0) {
                shift = shift + 7;
            }
            return t.addDays(shift);
        };
    };
    for (var i = 0; i < dx.length; i++) {
        $D[dx[i].toUpperCase()] = $D[dx[i].toUpperCase().substring(0, 3)] = i;
        $D[dx[i]] = $D[dx[i].substring(0, 3)] = sdf(i);
        $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i);
    }
    var mf = function (n) {
        return function () {
            if (this._is) {
                this._is = false;
                return this.getMonth() === n;
            }
            return this.moveToMonth(n, this._orient);
        };
    };
    var smf = function (n) {
        return function () {
            return $D.today().set({month: n, day: 1});
        };
    };
    for (var j = 0; j < mx.length; j++) {
        $D[mx[j].toUpperCase()] = $D[mx[j].toUpperCase().substring(0, 3)] = j;
        $D[mx[j]] = $D[mx[j].substring(0, 3)] = smf(j);
        $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j);
    }
    var ef = function (j) {
        return function () {
            if (this._isSecond) {
                this._isSecond = false;
                return this;
            }
            if (this._same) {
                this._same = this._is = false;
                var o1 = this.toObject(), o2 = (arguments[0] || new Date()).toObject(), v = "", k = j.toLowerCase();
                for (var m = (px.length - 1); m > -1; m--) {
                    v = px[m].toLowerCase();
                    if (o1[v] != o2[v]) {
                        return false;
                    }
                    if (k == v) {
                        break;
                    }
                }
                return true;
            }
            if (j.substring(j.length - 1) != "s") {
                j += "s";
            }
            return this["add" + j](this._orient);
        };
    };
    var nf = function (n) {
        return function () {
            this._dateElement = n;
            return this;
        };
    };
    for (var k = 0; k < px.length; k++) {
        de = px[k].toLowerCase();
        $P[de] = $P[de + "s"] = ef(px[k]);
        $N[de] = $N[de + "s"] = nf(de);
    }
    $P._ss = ef("Second");
    var nthfn = function (n) {
        return function (dayOfWeek) {
            if (this._same) {
                return this._ss(arguments[0]);
            }
            if (dayOfWeek || dayOfWeek === 0) {
                return this.moveToNthOccurrence(dayOfWeek, n);
            }
            this._nth = n;
            if (n === 2 && (dayOfWeek === undefined || dayOfWeek === null)) {
                this._isSecond = true;
                return this.addSeconds(this._orient);
            }
            return this;
        };
    };
    for (var l = 0; l < nth.length; l++) {
        $P[nth[l]] = (l === 0) ? nthfn(-1) : nthfn(l);
    }
}());
(function () {
    Date.Parsing = {
        Exception: function (s) {
            this.message = "Parse error at '" + s.substring(0, 10) + " ...'";
        }
    };
    var $P = Date.Parsing;
    var _ = $P.Operators = {
        rtoken: function (r) {
            return function (s) {
                var mx = s.match(r);
                if (mx) {
                    return ([mx[0], s.substring(mx[0].length)]);
                } else {
                    throw new $P.Exception(s);
                }
            };
        }, token: function (s) {
            return function (s) {
                return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s);
            };
        }, stoken: function (s) {
            return _.rtoken(new RegExp("^" + s));
        }, until: function (p) {
            return function (s) {
                var qx = [], rx = null;
                while (s.length) {
                    try {
                        rx = p.call(this, s);
                    } catch (e) {
                        qx.push(rx[0]);
                        s = rx[1];
                        continue;
                    }
                    break;
                }
                return [qx, s];
            };
        }, many: function (p) {
            return function (s) {
                var rx = [], r = null;
                while (s.length) {
                    try {
                        r = p.call(this, s);
                    } catch (e) {
                        return [rx, s];
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        }, optional: function (p) {
            return function (s) {
                var r = null;
                try {
                    r = p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                return [r[0], r[1]];
            };
        }, not: function (p) {
            return function (s) {
                try {
                    p.call(this, s);
                } catch (e) {
                    return [null, s];
                }
                throw new $P.Exception(s);
            };
        }, ignore: function (p) {
            return p ? function (s) {
                var r = null;
                r = p.call(this, s);
                return [null, r[1]];
            } : null;
        }, product: function () {
            var px = arguments[0], qx = Array.prototype.slice.call(arguments, 1), rx = [];
            for (var i = 0; i < px.length; i++) {
                rx.push(_.each(px[i], qx));
            }
            return rx;
        }, cache: function (rule) {
            var cache = {}, r = null;
            return function (s) {
                try {
                    r = cache[s] = (cache[s] || rule.call(this, s));
                } catch (e) {
                    r = cache[s] = e;
                }
                if (r instanceof $P.Exception) {
                    throw r;
                } else {
                    return r;
                }
            };
        }, any: function () {
            var px = arguments;
            return function (s) {
                var r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        r = null;
                    }
                    if (r) {
                        return r;
                    }
                }
                throw new $P.Exception(s);
            };
        }, each: function () {
            var px = arguments;
            return function (s) {
                var rx = [], r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null) {
                        continue;
                    }
                    try {
                        r = (px[i].call(this, s));
                    } catch (e) {
                        throw new $P.Exception(s);
                    }
                    rx.push(r[0]);
                    s = r[1];
                }
                return [rx, s];
            };
        }, all: function () {
            var px = arguments, _ = _;
            return _.each(_.optional(px));
        }, sequence: function (px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            if (px.length == 1) {
                return px[0];
            }
            return function (s) {
                var r = null, q = null;
                var rx = [];
                for (var i = 0; i < px.length; i++) {
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        break;
                    }
                    rx.push(r[0]);
                    try {
                        q = d.call(this, r[1]);
                    } catch (ex) {
                        q = null;
                        break;
                    }
                    s = q[1];
                }
                if (!r) {
                    throw new $P.Exception(s);
                }
                if (q) {
                    throw new $P.Exception(q[1]);
                }
                if (c) {
                    try {
                        r = c.call(this, r[1]);
                    } catch (ey) {
                        throw new $P.Exception(r[1]);
                    }
                }
                return [rx, (r ? r[1] : s)];
            };
        }, between: function (d1, p, d2) {
            d2 = d2 || d1;
            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
            return function (s) {
                var rx = _fn.call(this, s);
                return [[rx[0][0], r[0][2]], rx[1]];
            };
        }, list: function (p, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return (p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));
        }, set: function (px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return function (s) {
                var r = null, p = null, q = null, rx = null, best = [[], s], last = false;
                for (var i = 0; i < px.length; i++) {
                    q = null;
                    p = null;
                    r = null;
                    last = (px.length == 1);
                    try {
                        r = px[i].call(this, s);
                    } catch (e) {
                        continue;
                    }
                    rx = [[r[0]], r[1]];
                    if (r[1].length > 0 && !last) {
                        try {
                            q = d.call(this, r[1]);
                        } catch (ex) {
                            last = true;
                        }
                    } else {
                        last = true;
                    }
                    if (!last && q[1].length === 0) {
                        last = true;
                    }
                    if (!last) {
                        var qx = [];
                        for (var j = 0; j < px.length; j++) {
                            if (i != j) {
                                qx.push(px[j]);
                            }
                        }
                        p = _.set(qx, d).call(this, q[1]);
                        if (p[0].length > 0) {
                            rx[0] = rx[0].concat(p[0]);
                            rx[1] = p[1];
                        }
                    }
                    if (rx[1].length < best[1].length) {
                        best = rx;
                    }
                    if (best[1].length === 0) {
                        break;
                    }
                }
                if (best[0].length === 0) {
                    return best;
                }
                if (c) {
                    try {
                        q = c.call(this, best[1]);
                    } catch (ey) {
                        throw new $P.Exception(best[1]);
                    }
                    best[1] = q[1];
                }
                return best;
            };
        }, forward: function (gr, fname) {
            return function (s) {
                return gr[fname].call(this, s);
            };
        }, replace: function (rule, repl) {
            return function (s) {
                var r = rule.call(this, s);
                return [repl, r[1]];
            };
        }, process: function (rule, fn) {
            return function (s) {
                var r = rule.call(this, s);
                return [fn.call(this, r[0]), r[1]];
            };
        }, min: function (min, rule) {
            return function (s) {
                var rx = rule.call(this, s);
                if (rx[0].length < min) {
                    throw new $P.Exception(s);
                }
                return rx;
            };
        }
    };
    var _generator = function (op) {
        return function () {
            var args = null, rx = [];
            if (arguments.length > 1) {
                args = Array.prototype.slice.call(arguments);
            } else if (arguments[0]instanceof Array) {
                args = arguments[0];
            }
            if (args) {
                for (var i = 0, px = args.shift(); i < px.length; i++) {
                    args.unshift(px[i]);
                    rx.push(op.apply(null, args));
                    args.shift();
                    return rx;
                }
            } else {
                return op.apply(null, arguments);
            }
        };
    };
    var gx = "optional not ignore cache".split(/\s/);
    for (var i = 0; i < gx.length; i++) {
        _[gx[i]] = _generator(_[gx[i]]);
    }
    var _vector = function (op) {
        return function () {
            if (arguments[0]instanceof Array) {
                return op.apply(null, arguments[0]);
            } else {
                return op.apply(null, arguments);
            }
        };
    };
    var vx = "each any all".split(/\s/);
    for (var j = 0; j < vx.length; j++) {
        _[vx[j]] = _vector(_[vx[j]]);
    }
}());
(function () {
    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo;
    var flattenAndCompact = function (ax) {
        var rx = [];
        for (var i = 0; i < ax.length; i++) {
            if (ax[i]instanceof Array) {
                rx = rx.concat(flattenAndCompact(ax[i]));
            } else {
                if (ax[i]) {
                    rx.push(ax[i]);
                }
            }
        }
        return rx;
    };
    $D.Grammar = {};
    $D.Translator = {
        hour: function (s) {
            return function () {
                this.hour = Number(s);
            };
        }, minute: function (s) {
            return function () {
                this.minute = Number(s);
            };
        }, second: function (s) {
            return function () {
                this.second = Number(s);
            };
        }, meridian: function (s) {
            return function () {
                this.meridian = s.slice(0, 1).toLowerCase();
            };
        }, timezone: function (s) {
            return function () {
                var n = s.replace(/[^\d\+\-]/g, "");
                if (n.length) {
                    this.timezoneOffset = Number(n);
                } else {
                    this.timezone = s.toLowerCase();
                }
            };
        }, day: function (x) {
            var s = x[0];
            return function () {
                this.day = Number(s.match(/\d+/)[0]);
            };
        }, month: function (s) {
            return function () {
                this.month = (s.length == 3) ? "jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s) / 4 : Number(s) - 1;
            };
        }, year: function (s) {
            return function () {
                var n = Number(s);
                this.year = ((s.length > 2) ? n : (n + (((n + 2000) < $C.twoDigitYearMax) ? 2000 : 1900)));
            };
        }, rday: function (s) {
            return function () {
                switch (s) {
                    case"yesterday":
                        this.days = -1;
                        break;
                    case"tomorrow":
                        this.days = 1;
                        break;
                    case"today":
                        this.days = 0;
                        break;
                    case"now":
                        this.days = 0;
                        this.now = true;
                        break;
                }
            };
        }, finishExact: function (x) {
            x = (x instanceof Array) ? x : [x];
            for (var i = 0; i < x.length; i++) {
                if (x[i]) {
                    x[i].call(this);
                }
            }
            var now = new Date();
            if ((this.hour || this.minute) && (!this.month && !this.year && !this.day)) {
                this.day = now.getDate();
            }
            if (!this.year) {
                this.year = now.getFullYear();
            }
            if (!this.month && this.month !== 0) {
                this.month = now.getMonth();
            }
            if (!this.day) {
                this.day = 1;
            }
            if (!this.hour) {
                this.hour = 0;
            }
            if (!this.minute) {
                this.minute = 0;
            }
            if (!this.second) {
                this.second = 0;
            }
            if (this.meridian && this.hour) {
                if (this.meridian == "p" && this.hour < 12) {
                    this.hour = this.hour + 12;
                } else if (this.meridian == "a" && this.hour == 12) {
                    this.hour = 0;
                }
            }
            if (this.day > $D.getDaysInMonth(this.year, this.month)) {
                throw new RangeError(this.day + " is not a valid value for days.");
            }
            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);
            if (this.timezone) {
                r.set({timezone: this.timezone});
            } else if (this.timezoneOffset) {
                r.set({timezoneOffset: this.timezoneOffset});
            }
            return r;
        }, finish: function (x) {
            x = (x instanceof Array) ? flattenAndCompact(x) : [x];
            if (x.length === 0) {
                return null;
            }
            for (var i = 0; i < x.length; i++) {
                if (typeof x[i] == "function") {
                    x[i].call(this);
                }
            }
            var today = $D.today();
            if (this.now && !this.unit && !this.operator) {
                return new Date();
            } else if (this.now) {
                today = new Date();
            }
            var expression = !!(this.days && this.days !== null || this.orient || this.operator);
            var gap, mod, orient;
            orient = ((this.orient == "past" || this.operator == "subtract") ? -1 : 1);
            if (!this.now && "hour minute second".indexOf(this.unit) != -1) {
                today.setTimeToNow();
            }
            if (this.month || this.month === 0) {
                if ("year day hour minute second".indexOf(this.unit) != -1) {
                    this.value = this.month + 1;
                    this.month = null;
                    expression = true;
                }
            }
            if (!expression && this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (!this.month) {
                    this.month = temp.getMonth();
                }
                this.year = temp.getFullYear();
            }
            if (expression && this.weekday && this.unit != "month") {
                this.unit = "day";
                gap = ($D.getDayNumberFromName(this.weekday) - today.getDay());
                mod = 7;
                this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
            }
            if (this.month && this.unit == "day" && this.operator) {
                this.value = (this.month + 1);
                this.month = null;
            }
            if (this.value != null && this.month != null && this.year != null) {
                this.day = this.value * 1;
            }
            if (this.month && !this.day && this.value) {
                today.set({day: this.value * 1});
                if (!expression) {
                    this.day = this.value * 1;
                }
            }
            if (!this.month && this.value && this.unit == "month" && !this.now) {
                this.month = this.value;
                expression = true;
            }
            if (expression && (this.month || this.month === 0) && this.unit != "year") {
                this.unit = "month";
                gap = (this.month - today.getMonth());
                mod = 12;
                this.months = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
                this.month = null;
            }
            if (!this.unit) {
                this.unit = "day";
            }
            if (!this.value && this.operator && this.operator !== null && this[this.unit + "s"] && this[this.unit + "s"] !== null) {
                this[this.unit + "s"] = this[this.unit + "s"] + ((this.operator == "add") ? 1 : -1) + (this.value || 0) * orient;
            } else if (this[this.unit + "s"] == null || this.operator != null) {
                if (!this.value) {
                    this.value = 1;
                }
                this[this.unit + "s"] = this.value * orient;
            }
            if (this.meridian && this.hour) {
                if (this.meridian == "p" && this.hour < 12) {
                    this.hour = this.hour + 12;
                } else if (this.meridian == "a" && this.hour == 12) {
                    this.hour = 0;
                }
            }
            if (this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (temp.getMonth() !== today.getMonth()) {
                    this.month = temp.getMonth();
                }
            }
            if ((this.month || this.month === 0) && !this.day) {
                this.day = 1;
            }
            if (!this.orient && !this.operator && this.unit == "week" && this.value && !this.day && !this.month) {
                return Date.today().setWeek(this.value);
            }
            if (expression && this.timezone && this.day && this.days) {
                this.day = this.days;
            }
            return (expression) ? today.add(this) : today.set(this);
        }
    };
    var _ = $D.Parsing.Operators, g = $D.Grammar, t = $D.Translator, _fn;
    g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/);
    g.timePartDelimiter = _.stoken(":");
    g.whiteSpace = _.rtoken(/^\s*/);
    g.generalDelimiter = _.rtoken(/^(([\s\,]|at|@|on)+)/);
    var _C = {};
    g.ctoken = function (keys) {
        var fn = _C[keys];
        if (!fn) {
            var c = $C.regexPatterns;
            var kx = keys.split(/\s+/), px = [];
            for (var i = 0; i < kx.length; i++) {
                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
            }
            fn = _C[keys] = _.any.apply(null, px);
        }
        return fn;
    };
    g.ctoken2 = function (key) {
        return _.rtoken($C.regexPatterns[key]);
    };
    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
    g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter));
    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
    g.z = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));
    g.zz = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));
    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));
    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), function (s) {
        return function () {
            this.weekday = s;
        };
    }));
    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
    g.MMM = g.MMMM = _.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year));
    g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));
    _fn = function () {
        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")));
    };
    g.day = _fn(g.d, g.dd);
    g.month = _fn(g.M, g.MMM);
    g.year = _fn(g.yyyy, g.yy);
    g.orientation = _.process(g.ctoken("past future"), function (s) {
        return function () {
            this.orient = s;
        };
    });
    g.operator = _.process(g.ctoken("add subtract"), function (s) {
        return function () {
            this.operator = s;
        };
    });
    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
    g.unit = _.process(g.ctoken("second minute hour day week month year"), function (s) {
        return function () {
            this.unit = s;
        };
    });
    g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/), function (s) {
        return function () {
            this.value = s.replace(/\D/g, "");
        };
    });
    g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM]);
    _fn = function () {
        return _.set(arguments, g.datePartDelimiter);
    };
    g.mdy = _fn(g.ddd, g.month, g.day, g.year);
    g.ymd = _fn(g.ddd, g.year, g.month, g.day);
    g.dmy = _fn(g.ddd, g.day, g.month, g.year);
    g.date = function (s) {
        return ((g[$C.dateElementOrder] || g.mdy).call(this, s));
    };
    g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function (fmt) {
        if (g[fmt]) {
            return g[fmt];
        } else {
            throw $D.Parsing.Exception(fmt);
        }
    }), _.process(_.rtoken(/^[^dMyhHmstz]+/), function (s) {
        return _.ignore(_.stoken(s));
    }))), function (rules) {
        return _.process(_.each.apply(null, rules), t.finishExact);
    });
    var _F = {};
    var _get = function (f) {
        return _F[f] = (_F[f] || g.format(f)[0]);
    };
    g.formats = function (fx) {
        if (fx instanceof Array) {
            var rx = [];
            for (var i = 0; i < fx.length; i++) {
                rx.push(_get(fx[i]));
            }
            return _.any.apply(null, rx);
        } else {
            return _get(fx);
        }
    };
    g._formats = g.formats(["\"yyyy-MM-ddTHH:mm:ssZ\"", "yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-ddTHH:mm:ssz", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mmZ", "yyyy-MM-ddTHH:mmz", "yyyy-MM-ddTHH:mm", "ddd, MMM dd, yyyy H:mm:ss tt", "ddd MMM d yyyy HH:mm:ss zzz", "MMddyyyy", "ddMMyyyy", "Mddyyyy", "ddMyyyy", "Mdyyyy", "dMyyyy", "yyyy", "Mdyy", "dMyy", "d"]);
    g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish);
    g.start = function (s) {
        try {
            var r = g._formats.call({}, s);
            if (r[1].length === 0) {
                return r;
            }
        } catch (e) {
        }
        return g._start.call({}, s);
    };
    $D._parse = $D.parse;
    $D.parse = function (s) {
        var r = null;
        if (!s) {
            return null;
        }
        if (s instanceof Date) {
            return s;
        }
        try {
            r = $D.Grammar.start.call({}, s.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1"));
        } catch (e) {
            return null;
        }
        return ((r[1].length === 0) ? r[0] : null);
    };
    $D.getParseFunction = function (fx) {
        var fn = $D.Grammar.formats(fx);
        return function (s) {
            var r = null;
            try {
                r = fn.call({}, s);
            } catch (e) {
                return null;
            }
            return ((r[1].length === 0) ? r[0] : null);
        };
    };
    $D.parseExact = function (s, fx) {
        return $D.getParseFunction(fx)(s);
    };
}());
/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function ($) {

    var types = ['DOMMouseScroll', 'mousewheel'];

    if ($.event.fixHooks) {
        for (var i = types.length; i;) {
            $.event.fixHooks[types[--i]] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function () {
            if (this.addEventListener) {
                for (var i = types.length; i;) {
                    this.addEventListener(types[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function () {
            if (this.removeEventListener) {
                for (var i = types.length; i;) {
                    this.removeEventListener(types[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function (fn) {
            return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
        },

        unmousewheel: function (fn) {
            return this.unbind("mousewheel", fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
        event = $.event.fix(orgEvent);
        event.type = "mousewheel";

        // Old school scrollwheel delta
        if (orgEvent.wheelDelta) {
            delta = orgEvent.wheelDelta / 120;
        }
        if (orgEvent.detail) {
            delta = -orgEvent.detail / 3;
        }

        // New school multidimensional scroll (touchpads) deltas
        deltaY = delta;

        // Gecko
        if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaY = 0;
            deltaX = -1 * delta;
        }

        // Webkit
        if (orgEvent.wheelDeltaY !== undefined) {
            deltaY = orgEvent.wheelDeltaY / 120;
        }
        if (orgEvent.wheelDeltaX !== undefined) {
            deltaX = -1 * orgEvent.wheelDeltaX / 120;
        }

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

})(jQuery);
(function (a) {
    "use strict";
    var b = function (a, c, d) {
        var e = document.createElement("img"), f, g;
        return e.onerror = c, e.onload = function () {
            g && (!d || !d.noRevoke) && b.revokeObjectURL(g), c(b.scale(e, d))
        }, window.Blob && a instanceof Blob || window.File && a instanceof File ? (f = g = b.createObjectURL(a), e._type = a.type) : f = a, f ? (e.src = f, e) : b.readFile(a, function (a) {
            var b = a.target;
            b && b.result ? e.src = b.result : c(a)
        })
    }, c = window.createObjectURL && window || window.URL && URL.revokeObjectURL && URL || window.webkitURL && webkitURL;
    b.detectSubsampling = function (a) {
        var b = a.width, c = a.height, d, e;
        return b * c > 1048576 ? (d = document.createElement("canvas"), d.width = d.height = 1, e = d.getContext("2d"), e.drawImage(a, -b + 1, 0), e.getImageData(0, 0, 1, 1).data[3] === 0) : !1
    }, b.detectVerticalSquash = function (a, b) {
        var c = document.createElement("canvas"), d = c.getContext("2d"), e, f, g, h, i;
        c.width = 1, c.height = b, d.drawImage(a, 0, 0), e = d.getImageData(0, 0, 1, b).data, f = 0, g = b, h = b;
        while (h > f)i = e[(h - 1) * 4 + 3], i === 0 ? g = h : f = h, h = g + f >> 1;
        return h / b
    }, b.renderImageToCanvas = function (a, c, d, e) {
        var f = a.width, g = a.height, h = c.getContext("2d"), i, j = 1024, k = document.createElement("canvas"), l, m, n, o, p;
        h.save(), b.detectSubsampling(a) && (f /= 2, g /= 2), i = b.detectVerticalSquash(a, g), k.width = k.height = j, l = k.getContext("2d"), m = 0;
        while (m < g) {
            n = m + j > g ? g - m : j, o = 0;
            while (o < f)p = o + j > f ? f - o : j, l.clearRect(0, 0, j, j), l.drawImage(a, -o, -m), h.drawImage(k, 0, 0, p, n, Math.floor(o * d / f), Math.floor(m * e / g / i), Math.ceil(p * d / f), Math.ceil(n * e / g / i)), o += j;
            m += j
        }
        h.restore(), k = l = null
    }, b.scale = function (a, c) {
        c = c || {};
        var d = document.createElement("canvas"), e = a.width, f = a.height, g = Math.max((c.minWidth || e) / e, (c.minHeight || f) / f);
        return g > 1 && (e = parseInt(e * g, 10), f = parseInt(f * g, 10)), g = Math.min((c.maxWidth || e) / e, (c.maxHeight || f) / f), g < 1 && (e = parseInt(e * g, 10), f = parseInt(f * g, 10)), a.getContext || c.canvas && d.getContext ? (d.width = e, d.height = f, a._type === "image/jpeg" ? b.renderImageToCanvas(a, d, e, f) : d.getContext("2d").drawImage(a, 0, 0, e, f), d) : (a.width = e, a.height = f, a)
    }, b.createObjectURL = function (a) {
        return c ? c.createObjectURL(a) : !1
    }, b.revokeObjectURL = function (a) {
        return c ? c.revokeObjectURL(a) : !1
    }, b.readFile = function (a, b) {
        if (window.FileReader && FileReader.prototype.readAsDataURL) {
            var c = new FileReader;
            return c.onload = c.onerror = b, c.readAsDataURL(a), c
        }
        return !1
    }, typeof define == "function" && define.amd ? define(function () {
        return b
    }) : a.loadImage = b
})(this);
/* ===================================================
 * bootstrap-transition.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#transitions
 * ===================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* CSS TRANSITION SUPPORT (http://www.modernizr.com/)
     * ======================================================= */

    $(function () {

        $.support.transition = (function () {

            var transitionEnd = (function () {

                var el = document.createElement('bootstrap')
                    , transEndEventNames = {
                        'WebkitTransition': 'webkitTransitionEnd'
                        , 'MozTransition': 'transitionend'
                        , 'OTransition': 'oTransitionEnd otransitionend'
                        , 'transition': 'transitionend'
                    }
                    , name

                for (name in transEndEventNames) {
                    if (el.style[name] !== undefined) {
                        return transEndEventNames[name]
                    }
                }

            }())

            return transitionEnd && {
                    end: transitionEnd
                }

        })()

    })

}(window.jQuery);
/* ==========================================================
 * bootstrap-alert.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#alerts
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* ALERT CLASS DEFINITION
     * ====================== */

    var dismiss = '[data-dismiss="alert"]'
        , Alert = function (el) {
            $(el).on('click', dismiss, this.close)
        }

    Alert.prototype.close = function (e) {
        var $this = $(this)
            , selector = $this.attr('data-target')
            , $parent

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
        }

        $parent = $(selector)

        e && e.preventDefault()

        $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())

        $parent.trigger(e = $.Event('close'))

        if (e.isDefaultPrevented()) return

        $parent.removeClass('in')

        function removeElement() {
            $parent
                .trigger('closed')
                .remove()
        }

        $.support.transition && $parent.hasClass('fade') ?
            $parent.on($.support.transition.end, removeElement) :
            removeElement()
    }


    /* ALERT PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.alert

    $.fn.alert = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('alert')
            if (!data) $this.data('alert', (data = new Alert(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    $.fn.alert.Constructor = Alert


    /* ALERT NO CONFLICT
     * ================= */

    $.fn.alert.noConflict = function () {
        $.fn.alert = old
        return this
    }


    /* ALERT DATA-API
     * ============== */

    $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)

}(window.jQuery);
/* ============================================================
 * bootstrap-button.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#buttons
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* BUTTON PUBLIC CLASS DEFINITION
     * ============================== */

    var Button = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, $.fn.button.defaults, options)
    }

    Button.prototype.setState = function (state) {
        var d = 'disabled'
            , $el = this.$element
            , data = $el.data()
            , val = $el.is('input') ? 'val' : 'html'

        state = state + 'Text'
        data.resetText || $el.data('resetText', $el[val]())

        $el[val](data[state] || this.options[state])

        // push to event loop to allow forms to submit
        setTimeout(function () {
            state == 'loadingText' ?
                $el.addClass(d).attr(d, d) :
                $el.removeClass(d).removeAttr(d)
        }, 0)
    }

    Button.prototype.toggle = function () {
        var $parent = this.$element.closest('[data-toggle="buttons-radio"]')

        $parent && $parent
            .find('.active')
            .removeClass('active')

        this.$element.toggleClass('active')
    }


    /* BUTTON PLUGIN DEFINITION
     * ======================== */

    var old = $.fn.button

    $.fn.button = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('button')
                , options = typeof option == 'object' && option
            if (!data) $this.data('button', (data = new Button(this, options)))
            if (option == 'toggle') data.toggle()
            else if (option) data.setState(option)
        })
    }

    $.fn.button.defaults = {
        loadingText: 'loading...'
    }

    $.fn.button.Constructor = Button


    /* BUTTON NO CONFLICT
     * ================== */

    $.fn.button.noConflict = function () {
        $.fn.button = old
        return this
    }


    /* BUTTON DATA-API
     * =============== */

    $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {
        var $btn = $(e.target)
        if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
        $btn.button('toggle')
    })

}(window.jQuery);
/* ==========================================================
 * bootstrap-carousel.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#carousel
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* CAROUSEL CLASS DEFINITION
     * ========================= */

    var Carousel = function (element, options) {
        this.$element = $(element)
        this.options = options
        this.options.pause == 'hover' && this.$element
            .on('mouseenter', $.proxy(this.pause, this))
            .on('mouseleave', $.proxy(this.cycle, this))
    }

    Carousel.prototype = {

        cycle: function (e) {
            if (!e) this.paused = false
            this.options.interval
            && !this.paused
            && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
            return this
        }

        , to: function (pos) {
            var $active = this.$element.find('.item.active')
                , children = $active.parent().children()
                , activePos = children.index($active)
                , that = this

            if (pos > (children.length - 1) || pos < 0) return

            if (this.sliding) {
                return this.$element.one('slid', function () {
                    that.to(pos)
                })
            }

            if (activePos == pos) {
                return this.pause().cycle()
            }

            return this.slide(pos > activePos ? 'next' : 'prev', $(children[pos]))
        }

        , pause: function (e) {
            if (!e) this.paused = true
            if (this.$element.find('.next, .prev').length && $.support.transition.end) {
                this.$element.trigger($.support.transition.end)
                this.cycle()
            }
            clearInterval(this.interval)
            this.interval = null
            return this
        }

        , next: function () {
            if (this.sliding) return
            return this.slide('next')
        }

        , prev: function () {
            if (this.sliding) return
            return this.slide('prev')
        }

        , slide: function (type, next) {
            var $active = this.$element.find('.item.active')
                , $next = next || $active[type]()
                , isCycling = this.interval
                , direction = type == 'next' ? 'left' : 'right'
                , fallback = type == 'next' ? 'first' : 'last'
                , that = this
                , e

            this.sliding = true

            isCycling && this.pause()

            $next = $next.length ? $next : this.$element.find('.item')[fallback]()

            e = $.Event('slide', {
                relatedTarget: $next[0]
            })

            if ($next.hasClass('active')) return

            if ($.support.transition && this.$element.hasClass('slide')) {
                this.$element.trigger(e)
                if (e.isDefaultPrevented()) return
                $next.addClass(type)
                $next[0].offsetWidth // force reflow
                $active.addClass(direction)
                $next.addClass(direction)
                this.$element.one($.support.transition.end, function () {
                    $next.removeClass([type, direction].join(' ')).addClass('active')
                    $active.removeClass(['active', direction].join(' '))
                    that.sliding = false
                    setTimeout(function () {
                        that.$element.trigger('slid')
                    }, 0)
                })
            } else {
                this.$element.trigger(e)
                if (e.isDefaultPrevented()) return
                $active.removeClass('active')
                $next.addClass('active')
                this.sliding = false
                this.$element.trigger('slid')
            }

            isCycling && this.cycle()

            return this
        }

    }


    /* CAROUSEL PLUGIN DEFINITION
     * ========================== */

    var old = $.fn.carousel

    $.fn.carousel = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('carousel')
                , options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option)
                , action = typeof option == 'string' ? option : options.slide
            if (!data) $this.data('carousel', (data = new Carousel(this, options)))
            if (typeof option == 'number') data.to(option)
            else if (action) data[action]()
            else if (options.interval) data.cycle()
        })
    }

    $.fn.carousel.defaults = {
        interval: 5000
        , pause: 'hover'
    }

    $.fn.carousel.Constructor = Carousel


    /* CAROUSEL NO CONFLICT
     * ==================== */

    $.fn.carousel.noConflict = function () {
        $.fn.carousel = old
        return this
    }

    /* CAROUSEL DATA-API
     * ================= */

    $(document).on('click.carousel.data-api', '[data-slide]', function (e) {
        var $this = $(this), href
            , $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
            , options = $.extend({}, $target.data(), $this.data())
        $target.carousel(options)
        e.preventDefault()
    })

}(window.jQuery);
/* =============================================================
 * bootstrap-collapse.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#collapse
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* COLLAPSE PUBLIC CLASS DEFINITION
     * ================================ */

    var Collapse = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, $.fn.collapse.defaults, options)

        if (this.options.parent) {
            this.$parent = $(this.options.parent)
        }

        this.options.toggle && this.toggle()
    }

    Collapse.prototype = {

        constructor: Collapse

        , dimension: function () {
            var hasWidth = this.$element.hasClass('width')
            return hasWidth ? 'width' : 'height'
        }

        , show: function () {
            var dimension
                , scroll
                , actives
                , hasData

            if (this.transitioning) return

            dimension = this.dimension()
            scroll = $.camelCase(['scroll', dimension].join('-'))
            actives = this.$parent && this.$parent.find('> .accordion-group > .in')

            if (actives && actives.length) {
                hasData = actives.data('collapse')
                if (hasData && hasData.transitioning) return
                actives.collapse('hide')
                hasData || actives.data('collapse', null)
            }

            this.$element[dimension](0)
            this.transition('addClass', $.Event('show'), 'shown')
            $.support.transition && this.$element[dimension](this.$element[0][scroll])
        }

        , hide: function () {
            var dimension
            if (this.transitioning) return
            dimension = this.dimension()
            this.reset(this.$element[dimension]())
            this.transition('removeClass', $.Event('hide'), 'hidden')
            this.$element[dimension](0)
        }

        , reset: function (size) {
            var dimension = this.dimension()

            this.$element
                .removeClass('collapse')
                [dimension](size || 'auto')
                [0].offsetWidth

            this.$element[size !== null ? 'addClass' : 'removeClass']('collapse')

            return this
        }

        , transition: function (method, startEvent, completeEvent) {
            var that = this
                , complete = function () {
                    if (startEvent.type == 'show') that.reset()
                    that.transitioning = 0
                    that.$element.trigger(completeEvent)
                }

            this.$element.trigger(startEvent)

            if (startEvent.isDefaultPrevented()) return

            this.transitioning = 1

            this.$element[method]('in')

            $.support.transition && this.$element.hasClass('collapse') ?
                this.$element.one($.support.transition.end, complete) :
                complete()
        }

        , toggle: function () {
            this[this.$element.hasClass('in') ? 'hide' : 'show']()
        }

    }


    /* COLLAPSE PLUGIN DEFINITION
     * ========================== */

    var old = $.fn.collapse

    $.fn.collapse = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('collapse')
                , options = typeof option == 'object' && option
            if (!data) $this.data('collapse', (data = new Collapse(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.collapse.defaults = {
        toggle: true
    }

    $.fn.collapse.Constructor = Collapse


    /* COLLAPSE NO CONFLICT
     * ==================== */

    $.fn.collapse.noConflict = function () {
        $.fn.collapse = old
        return this
    }


    /* COLLAPSE DATA-API
     * ================= */

    $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
        var $this = $(this), href
            , target = $this.attr('data-target')
                || e.preventDefault()
                || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
            , option = $(target).data('collapse') ? 'toggle' : $this.data()
        $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
        $(target).collapse(option)
    })

}(window.jQuery);
/* ============================================================
 * bootstrap-dropdown.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#dropdowns
 * ============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* DROPDOWN CLASS DEFINITION
     * ========================= */

    var toggle = '[data-toggle=dropdown]'
        , Dropdown = function (element) {
            var $el = $(element).on('click.dropdown.data-api', this.toggle)
            $('html').on('click.dropdown.data-api', function () {
                $el.parent().removeClass('open')
            })
        }

    Dropdown.prototype = {

        constructor: Dropdown

        , toggle: function (e) {
            var $this = $(this)
                , $parent
                , isActive

            if ($this.is('.disabled, :disabled')) return

            $parent = getParent($this)

            isActive = $parent.hasClass('open')

            clearMenus()

            if (!isActive) {
                $parent.toggleClass('open')
            }

            $this.focus()

            return false
        }

        , keydown: function (e) {
            var $this
                , $items
                , $active
                , $parent
                , isActive
                , index

            if (!/(38|40|27)/.test(e.keyCode)) return

            $this = $(this)

            e.preventDefault()
            e.stopPropagation()

            if ($this.is('.disabled, :disabled')) return

            $parent = getParent($this)

            isActive = $parent.hasClass('open')

            if (!isActive || (isActive && e.keyCode == 27)) return $this.click()

            $items = $('[role=menu] li:not(.divider):visible a', $parent)

            if (!$items.length) return

            index = $items.index($items.filter(':focus'))

            if (e.keyCode == 38 && index > 0) index--                                        // up
            if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
            if (!~index) index = 0

            $items
                .eq(index)
                .focus()
        }

    }

    function clearMenus() {
        $(toggle).each(function () {
            getParent($(this)).removeClass('open')
        })
    }

    function getParent($this) {
        var selector = $this.attr('data-target')
            , $parent

        if (!selector) {
            selector = $this.attr('href')
            selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
        }

        $parent = $(selector)
        $parent.length || ($parent = $this.parent())

        return $parent
    }


    /* DROPDOWN PLUGIN DEFINITION
     * ========================== */

    var old = $.fn.dropdown

    $.fn.dropdown = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('dropdown')
            if (!data) $this.data('dropdown', (data = new Dropdown(this)))
            if (typeof option == 'string') data[option].call($this)
        })
    }

    $.fn.dropdown.Constructor = Dropdown


    /* DROPDOWN NO CONFLICT
     * ==================== */

    $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old
        return this
    }


    /* APPLY TO STANDARD DROPDOWN ELEMENTS
     * =================================== */

    $(document)
        .on('click.dropdown.data-api touchstart.dropdown.data-api', clearMenus)
        .on('click.dropdown touchstart.dropdown.data-api', '.dropdown form', function (e) {
            e.stopPropagation()
        })
        .on('touchstart.dropdown.data-api', '.dropdown-menu', function (e) {
            e.stopPropagation()
        })
        .on('click.dropdown.data-api touchstart.dropdown.data-api', toggle, Dropdown.prototype.toggle)
        .on('keydown.dropdown.data-api touchstart.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown)

}(window.jQuery);


/* =========================================================
 * bootstrap-modal.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#modals
 * =========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * ========================================================= 
 * !!! This plugin was replaced by a plugin - plugins/bootstrap modal !!!
 * ========================================================= */




/* ===========================================================
 * bootstrap-tooltip.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* TOOLTIP PUBLIC CLASS DEFINITION
     * =============================== */

    var Tooltip = function (element, options) {
        this.init('tooltip', element, options)
    }

    Tooltip.prototype = {

        constructor: Tooltip

        , init: function (type, element, options) {
            var eventIn
                , eventOut

            this.type = type
            this.$element = $(element)
            this.options = this.getOptions(options)
            this.enabled = true

            if (this.options.trigger == 'click') {
                this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
            } else if (this.options.trigger != 'manual') {
                eventIn = this.options.trigger == 'hover' ? 'mouseenter' : 'focus'
                eventOut = this.options.trigger == 'hover' ? 'mouseleave' : 'blur'
                this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
                this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
            }

            this.options.selector ?
                (this._options = $.extend({}, this.options, {trigger: 'manual', selector: ''})) :
                this.fixTitle()
        }

        , getOptions: function (options) {
            options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data())

            if (options.delay && typeof options.delay == 'number') {
                options.delay = {
                    show: options.delay
                    , hide: options.delay
                }
            }

            return options
        }

        , enter: function (e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type)

            if (!self.options.delay || !self.options.delay.show) return self.show()

            clearTimeout(this.timeout)
            self.hoverState = 'in'
            this.timeout = setTimeout(function () {
                if (self.hoverState == 'in') self.show()
            }, self.options.delay.show)
        }

        , leave: function (e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type)

            if (this.timeout) clearTimeout(this.timeout)
            if (!self.options.delay || !self.options.delay.hide) return self.hide()

            self.hoverState = 'out'
            this.timeout = setTimeout(function () {
                if (self.hoverState == 'out') self.hide()
            }, self.options.delay.hide)
        }

        , show: function () {
            var $tip
                , inside
                , pos
                , actualWidth
                , actualHeight
                , placement
                , tp

            if (this.hasContent() && this.enabled) {
                $tip = this.tip()
                this.setContent()

                if (this.options.animation) {
                    $tip.addClass('fade')
                }

                placement = typeof this.options.placement == 'function' ?
                    this.options.placement.call(this, $tip[0], this.$element[0]) :
                    this.options.placement

                inside = /in/.test(placement)

                $tip
                    .detach()
                    .css({top: 0, left: 0, display: 'block'})
                    .insertAfter(this.$element)

                pos = this.getPosition(inside)

                actualWidth = $tip[0].offsetWidth
                actualHeight = $tip[0].offsetHeight

                switch (inside ? placement.split(' ')[1] : placement) {
                    case 'bottom':
                        tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
                        break
                    case 'top':
                        tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
                        break
                    case 'left':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
                        break
                    case 'right':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
                        break
                }

                $tip
                    .offset(tp)
                    .addClass(placement)
                    .addClass('in')
            }
        }

        , setContent: function () {
            var $tip = this.tip()
                , title = this.getTitle()

            $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
            $tip.removeClass('fade in top bottom left right')
        }

        , hide: function () {
            var that = this
                , $tip = this.tip()

            $tip.removeClass('in')

            function removeWithAnimation() {
                var timeout = setTimeout(function () {
                    $tip.off($.support.transition.end).detach()
                }, 500)

                $tip.one($.support.transition.end, function () {
                    clearTimeout(timeout)
                    $tip.detach()
                })
            }

            $.support.transition && this.$tip.hasClass('fade') ?
                removeWithAnimation() :
                $tip.detach()

            return this
        }

        , fixTitle: function () {
            var $e = this.$element
            if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
                $e.attr('data-original-title', $e.attr('title') || '').removeAttr('title')
            }
        }

        , hasContent: function () {
            return this.getTitle()
        }

        , getPosition: function (inside) {
            return $.extend({}, (inside ? {top: 0, left: 0} : this.$element.offset()), {
                width: this.$element[0].offsetWidth
                , height: this.$element[0].offsetHeight
            })
        }

        , getTitle: function () {
            var title
                , $e = this.$element
                , o = this.options

            title = $e.attr('data-original-title')
                || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)

            return title
        }

        , tip: function () {
            return this.$tip = this.$tip || $(this.options.template)
        }

        , validate: function () {
            if (!this.$element[0].parentNode) {
                this.hide()
                this.$element = null
                this.options = null
            }
        }

        , enable: function () {
            this.enabled = true
        }

        , disable: function () {
            this.enabled = false
        }

        , toggleEnabled: function () {
            this.enabled = !this.enabled
        }

        , toggle: function (e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type)
            self[self.tip().hasClass('in') ? 'hide' : 'show']()
        }

        , destroy: function () {
            this.hide().$element.off('.' + this.type).removeData(this.type)
        }

    }


    /* TOOLTIP PLUGIN DEFINITION
     * ========================= */

    var old = $.fn.tooltip

    $.fn.tooltip = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('tooltip')
                , options = typeof option == 'object' && option
            if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.tooltip.Constructor = Tooltip

    $.fn.tooltip.defaults = {
        animation: true
        , placement: 'top'
        , selector: false
        , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
        , trigger: 'hover'
        , title: ''
        , delay: 0
        , html: false
    }


    /* TOOLTIP NO CONFLICT
     * =================== */

    $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old
        return this
    }

}(window.jQuery);
/* ===========================================================
 * bootstrap-popover.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* POPOVER PUBLIC CLASS DEFINITION
     * =============================== */

    var Popover = function (element, options) {
        this.init('popover', element, options)
    }


    /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */

    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {

        constructor: Popover

        , setContent: function () {
            var $tip = this.tip()
                , title = this.getTitle()
                , content = this.getContent()

            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
            $tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

            $tip.removeClass('fade top bottom left right in')
        }

        , hasContent: function () {
            return this.getTitle() || this.getContent()
        }

        , getContent: function () {
            var content
                , $e = this.$element
                , o = this.options

            content = $e.attr('data-content')
                || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content)

            return content
        }

        , tip: function () {
            if (!this.$tip) {
                this.$tip = $(this.options.template)
            }
            return this.$tip
        }

        , destroy: function () {
            this.hide().$element.off('.' + this.type).removeData(this.type)
        }

    })


    /* POPOVER PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.popover

    $.fn.popover = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('popover')
                , options = typeof option == 'object' && option
            if (!data) $this.data('popover', (data = new Popover(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.popover.Constructor = Popover

    $.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
        placement: 'right'
        ,
        trigger: 'click'
        ,
        content: ''
        ,
        template: '<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"></div></div></div>'
    })


    /* POPOVER NO CONFLICT
     * =================== */

    $.fn.popover.noConflict = function () {
        $.fn.popover = old
        return this
    }

}(window.jQuery);
/* =============================================================
 * bootstrap-scrollspy.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#scrollspy
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* SCROLLSPY CLASS DEFINITION
     * ========================== */

    function ScrollSpy(element, options) {
        var process = $.proxy(this.process, this)
            , $element = $(element).is('body') ? $(window) : $(element)
            , href
        this.options = $.extend({}, $.fn.scrollspy.defaults, options)
        this.$scrollElement = $element.on('scroll.scroll-spy.data-api', process)
        this.selector = (this.options.target
            || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
            || '') + ' .nav li > a'
        this.$body = $('body')
        this.refresh()
        this.process()
    }

    ScrollSpy.prototype = {

        constructor: ScrollSpy

        , refresh: function () {
            var self = this
                , $targets

            this.offsets = $([])
            this.targets = $([])

            $targets = this.$body
                .find(this.selector)
                .map(function () {
                    var $el = $(this)
                        , href = $el.data('target') || $el.attr('href')
                        , $href = /^#\w/.test(href) && $(href)
                    return ( $href
                        && $href.length
                        && [[$href.position().top + self.$scrollElement.scrollTop(), href]] ) || null
                })
                .sort(function (a, b) {
                    return a[0] - b[0]
                })
                .each(function () {
                    self.offsets.push(this[0])
                    self.targets.push(this[1])
                })
        }

        , process: function () {
            var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
                , scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
                , maxScroll = scrollHeight - this.$scrollElement.height()
                , offsets = this.offsets
                , targets = this.targets
                , activeTarget = this.activeTarget
                , i

            if (scrollTop >= maxScroll) {
                return activeTarget != (i = targets.last()[0])
                    && this.activate(i)
            }

            for (i = offsets.length; i--;) {
                activeTarget != targets[i]
                && scrollTop >= offsets[i]
                && (!offsets[i + 1] || scrollTop <= offsets[i + 1])
                && this.activate(targets[i])
            }
        }

        , activate: function (target) {
            var active
                , selector

            this.activeTarget = target

            $(this.selector)
                .parent('.active')
                .removeClass('active')

            selector = this.selector
                + '[data-target="' + target + '"],'
                + this.selector + '[href="' + target + '"]'

            active = $(selector)
                .parent('li')
                .addClass('active')

            if (active.parent('.dropdown-menu').length) {
                active = active.closest('li.dropdown').addClass('active')
            }

            active.trigger('activate')
        }

    }


    /* SCROLLSPY PLUGIN DEFINITION
     * =========================== */

    var old = $.fn.scrollspy

    $.fn.scrollspy = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('scrollspy')
                , options = typeof option == 'object' && option
            if (!data) $this.data('scrollspy', (data = new ScrollSpy(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.scrollspy.Constructor = ScrollSpy

    $.fn.scrollspy.defaults = {
        offset: 10
    }


    /* SCROLLSPY NO CONFLICT
     * ===================== */

    $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old
        return this
    }


    /* SCROLLSPY DATA-API
     * ================== */

    $(window).on('load', function () {
        $('[data-spy="scroll"]').each(function () {
            var $spy = $(this)
            $spy.scrollspy($spy.data())
        })
    })

}(window.jQuery);
/* ========================================================
 * bootstrap-tab.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#tabs
 * ========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* TAB CLASS DEFINITION
     * ==================== */

    var Tab = function (element) {
        this.element = $(element)
    }

    Tab.prototype = {

        constructor: Tab

        , show: function () {
            var $this = this.element
                , $ul = $this.closest('ul:not(.dropdown-menu)')
                , selector = $this.attr('data-target')
                , previous
                , $target
                , e

            if (!selector) {
                selector = $this.attr('href')
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
            }

            if ($this.parent('li').hasClass('active')) return

            previous = $ul.find('.active:last a')[0]

            e = $.Event('show', {
                relatedTarget: previous
            })

            $this.trigger(e)

            if (e.isDefaultPrevented()) return

            $target = $(selector)

            this.activate($this.parent('li'), $ul)
            this.activate($target, $target.parent(), function () {
                $this.trigger({
                    type: 'shown'
                    , relatedTarget: previous
                })
            })
        }

        , activate: function (element, container, callback) {
            var $active = container.find('> .active')
                , transition = callback
                    && $.support.transition
                    && $active.hasClass('fade')

            function next() {
                $active
                    .removeClass('active')
                    .find('> .dropdown-menu > .active')
                    .removeClass('active')

                element.addClass('active')

                if (transition) {
                    element[0].offsetWidth // reflow for transition
                    element.addClass('in')
                } else {
                    element.removeClass('fade')
                }

                if (element.parent('.dropdown-menu')) {
                    element.closest('li.dropdown').addClass('active')
                }

                callback && callback()
            }

            transition ?
                $active.one($.support.transition.end, next) :
                next()

            $active.removeClass('in')
        }
    }


    /* TAB PLUGIN DEFINITION
     * ===================== */

    var old = $.fn.tab

    $.fn.tab = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('tab')
            if (!data) $this.data('tab', (data = new Tab(this)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.tab.Constructor = Tab


    /* TAB NO CONFLICT
     * =============== */

    $.fn.tab.noConflict = function () {
        $.fn.tab = old
        return this
    }


    /* TAB DATA-API
     * ============ */

    $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
        e.preventDefault()
        $(this).tab('show')
    })

}(window.jQuery);
/* =============================================================
 * bootstrap-typeahead.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#typeahead
 * =============================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

    "use strict"; // jshint ;_;


    /* TYPEAHEAD PUBLIC CLASS DEFINITION
     * ================================= */

    var Typeahead = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, $.fn.typeahead.defaults, options)
        this.matcher = this.options.matcher || this.matcher
        this.sorter = this.options.sorter || this.sorter
        this.highlighter = this.options.highlighter || this.highlighter
        this.updater = this.options.updater || this.updater
        this.source = this.options.source
        this.$menu = $(this.options.menu)
        this.shown = false
        this.listen()
    }

    Typeahead.prototype = {

        constructor: Typeahead

        , select: function () {
            var val = this.$menu.find('.active').attr('data-value')
            this.$element
                .val(this.updater(val))
                .change()
            return this.hide()
        }

        , updater: function (item) {
            return item
        }

        , show: function () {
            var pos = $.extend({}, this.$element.position(), {
                height: this.$element[0].offsetHeight
            })

            this.$menu
                .insertAfter(this.$element)
                .css({
                    top: pos.top + pos.height
                    , left: pos.left
                })
                .show()

            this.shown = true
            return this
        }

        , hide: function () {
            this.$menu.hide()
            this.shown = false
            return this
        }

        , lookup: function (event) {
            var items

            this.query = this.$element.val()

            if (!this.query || this.query.length < this.options.minLength) {
                return this.shown ? this.hide() : this
            }

            items = $.isFunction(this.source) ? this.source(this.query, $.proxy(this.process, this)) : this.source

            return items ? this.process(items) : this
        }

        , process: function (items) {
            var that = this

            items = $.grep(items, function (item) {
                return that.matcher(item)
            })

            items = this.sorter(items)

            if (!items.length) {
                return this.shown ? this.hide() : this
            }

            return this.render(items.slice(0, this.options.items)).show()
        }

        , matcher: function (item) {
            return ~item.toLowerCase().indexOf(this.query.toLowerCase())
        }

        , sorter: function (items) {
            var beginswith = []
                , caseSensitive = []
                , caseInsensitive = []
                , item

            while (item = items.shift()) {
                if (!item.toLowerCase().indexOf(this.query.toLowerCase())) beginswith.push(item)
                else if (~item.indexOf(this.query)) caseSensitive.push(item)
                else caseInsensitive.push(item)
            }

            return beginswith.concat(caseSensitive, caseInsensitive)
        }

        , highlighter: function (item) {
            var query = this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
            return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
                return '<strong>' + match + '</strong>'
            })
        }

        , render: function (items) {
            var that = this

            items = $(items).map(function (i, item) {
                i = $(that.options.item).attr('data-value', item)
                i.find('a').html(that.highlighter(item))
                return i[0]
            })

            items.first().addClass('active')
            this.$menu.html(items)
            return this
        }

        , next: function (event) {
            var active = this.$menu.find('.active').removeClass('active')
                , next = active.next()

            if (!next.length) {
                next = $(this.$menu.find('li')[0])
            }

            next.addClass('active')
        }

        , prev: function (event) {
            var active = this.$menu.find('.active').removeClass('active')
                , prev = active.prev()

            if (!prev.length) {
                prev = this.$menu.find('li').last()
            }

            prev.addClass('active')
        }

        , listen: function () {
            this.$element
                .on('blur', $.proxy(this.blur, this))
                .on('keypress', $.proxy(this.keypress, this))
                .on('keyup', $.proxy(this.keyup, this))

            if (this.eventSupported('keydown')) {
                this.$element.on('keydown', $.proxy(this.keydown, this))
            }

            this.$menu
                .on('click', $.proxy(this.click, this))
                .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
        }

        , eventSupported: function (eventName) {
            var isSupported = eventName in this.$element
            if (!isSupported) {
                this.$element.setAttribute(eventName, 'return;')
                isSupported = typeof this.$element[eventName] === 'function'
            }
            return isSupported
        }

        , move: function (e) {
            if (!this.shown) return

            switch (e.keyCode) {
                case 9: // tab
                case 13: // enter
                case 27: // escape
                    e.preventDefault()
                    break

                case 38: // up arrow
                    e.preventDefault()
                    this.prev()
                    break

                case 40: // down arrow
                    e.preventDefault()
                    this.next()
                    break
            }

            e.stopPropagation()
        }

        , keydown: function (e) {
            this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40, 38, 9, 13, 27])
            this.move(e)
        }

        , keypress: function (e) {
            if (this.suppressKeyPressRepeat) return
            this.move(e)
        }

        , keyup: function (e) {
            switch (e.keyCode) {
                case 40: // down arrow
                case 38: // up arrow
                case 16: // shift
                case 17: // ctrl
                case 18: // alt
                    break

                case 9: // tab
                case 13: // enter
                    if (!this.shown) return
                    this.select()
                    break

                case 27: // escape
                    if (!this.shown) return
                    this.hide()
                    break

                default:
                    this.lookup()
            }

            e.stopPropagation()
            e.preventDefault()
        }

        , blur: function (e) {
            var that = this
            setTimeout(function () {
                that.hide()
            }, 150)
        }

        , click: function (e) {
            e.stopPropagation()
            e.preventDefault()
            this.select()
        }

        , mouseenter: function (e) {
            this.$menu.find('.active').removeClass('active')
            $(e.currentTarget).addClass('active')
        }

    }


    /* TYPEAHEAD PLUGIN DEFINITION
     * =========================== */

    var old = $.fn.typeahead

    $.fn.typeahead = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('typeahead')
                , options = typeof option == 'object' && option
            if (!data) $this.data('typeahead', (data = new Typeahead(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.typeahead.defaults = {
        source: []
        , items: 8
        , menu: '<ul class="typeahead dropdown-menu"></ul>'
        , item: '<li><a href="#"></a></li>'
        , minLength: 1
    }

    $.fn.typeahead.Constructor = Typeahead


    /* TYPEAHEAD NO CONFLICT
     * =================== */

    $.fn.typeahead.noConflict = function () {
        $.fn.typeahead = old
        return this
    }


    /* TYPEAHEAD DATA-API
     * ================== */

    $(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
        var $this = $(this)
        if ($this.data('typeahead')) return
        e.preventDefault()
        $this.typeahead($this.data())
    })

}(window.jQuery);
/* ==========================================================
 * bootstrap-affix.js v2.2.2
 * http://twitter.github.com/bootstrap/javascript.html#affix
 * ==========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;


    /* AFFIX CLASS DEFINITION
     * ====================== */

    var Affix = function (element, options) {
        this.options = $.extend({}, $.fn.affix.defaults, options)
        this.$window = $(window)
            .on('scroll.affix.data-api', $.proxy(this.checkPosition, this))
            .on('click.affix.data-api', $.proxy(function () {
                setTimeout($.proxy(this.checkPosition, this), 1)
            }, this))
        this.$element = $(element)
        this.checkPosition()
    }

    Affix.prototype.checkPosition = function () {
        if (!this.$element.is(':visible')) return

        var scrollHeight = $(document).height()
            , scrollTop = this.$window.scrollTop()
            , position = this.$element.offset()
            , offset = this.options.offset
            , offsetBottom = offset.bottom
            , offsetTop = offset.top
            , reset = 'affix affix-top affix-bottom'
            , affix

        if (typeof offset != 'object') offsetBottom = offsetTop = offset
        if (typeof offsetTop == 'function') offsetTop = offset.top()
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

        affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ?
            false : offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ?
            'bottom' : offsetTop != null && scrollTop <= offsetTop ?
            'top' : false

        if (this.affixed === affix) return

        this.affixed = affix
        this.unpin = affix == 'bottom' ? position.top - scrollTop : null

        this.$element.removeClass(reset).addClass('affix' + (affix ? '-' + affix : ''))
    }


    /* AFFIX PLUGIN DEFINITION
     * ======================= */

    var old = $.fn.affix

    $.fn.affix = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('affix')
                , options = typeof option == 'object' && option
            if (!data) $this.data('affix', (data = new Affix(this, options)))
            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.affix.Constructor = Affix

    $.fn.affix.defaults = {
        offset: 0
    }


    /* AFFIX NO CONFLICT
     * ================= */

    $.fn.affix.noConflict = function () {
        $.fn.affix = old
        return this
    }


    /* AFFIX DATA-API
     * ============== */

    $(window).on('load', function () {
        $('[data-spy="affix"]').each(function () {
            var $spy = $(this)
                , data = $spy.data()

            data.offset = data.offset || {}

            data.offsetBottom && (data.offset.bottom = data.offsetBottom)
            data.offsetTop && (data.offset.top = data.offsetTop)

            $spy.affix(data)
        })
    })


}(window.jQuery);
/*
 wysihtml5 v0.3.0
 https://github.com/xing/wysihtml5

 Author: Christopher Blum (https://github.com/tiff)

 Copyright (C) 2012 XING AG
 Licensed under the MIT license (MIT)

 Rangy, a cross-browser JavaScript range and selection library
 http://code.google.com/p/rangy/

 Copyright 2011, Tim Down
 Licensed under the MIT license.
 Version: 1.2.2
 Build date: 13 November 2011
 */
var wysihtml5 = {
    version: "0.3.0",
    commands: {},
    dom: {},
    quirks: {},
    toolbar: {},
    lang: {},
    selection: {},
    views: {},
    INVISIBLE_SPACE: "\ufeff",
    EMPTY_FUNCTION: function () {
    },
    ELEMENT_NODE: 1,
    TEXT_NODE: 3,
    BACKSPACE_KEY: 8,
    ENTER_KEY: 13,
    ESCAPE_KEY: 27,
    SPACE_KEY: 32,
    DELETE_KEY: 46
};
window.rangy = function () {
    function b(a, b) {
        var c = typeof a[b];
        return c == k || !!(c == h && a[b]) || "unknown" == c
    }

    function c(a, b) {
        return !!(typeof a[b] == h && a[b])
    }

    function a(a, b) {
        return typeof a[b] != j
    }

    function d(a) {
        return function (b, c) {
            for (var d = c.length; d--;)if (!a(b, c[d]))return !1;
            return !0
        }
    }

    function e(a) {
        return a && m(a, r) && x(a, q)
    }

    function f(a) {
        window.alert("Rangy not supported in your browser. Reason: " + a);
        o.initialized = !0;
        o.supported = !1
    }

    function g() {
        if (!o.initialized) {
            var a, d = !1, h = !1;
            b(document, "createRange") &&
            (a = document.createRange(), m(a, p) && x(a, n) && (d = !0), a.detach());
            if ((a = c(document, "body") ? document.body : document.getElementsByTagName("body")[0]) && b(a, "createTextRange"))a = a.createTextRange(), e(a) && (h = !0);
            !d && !h && f("Neither Range nor TextRange are implemented");
            o.initialized = !0;
            o.features = {implementsDomRange: d, implementsTextRange: h};
            d = w.concat(z);
            h = 0;
            for (a = d.length; h < a; ++h)try {
                d[h](o)
            } catch (j) {
                c(window, "console") && b(window.console, "log") && window.console.log("Init listener threw an exception. Continuing.",
                    j)
            }
        }
    }

    function i(a) {
        this.name = a;
        this.supported = this.initialized = !1
    }

    var h = "object", k = "function", j = "undefined", n = "startContainer startOffset endContainer endOffset collapsed commonAncestorContainer START_TO_START START_TO_END END_TO_START END_TO_END".split(" "), p = "setStart setStartBefore setStartAfter setEnd setEndBefore setEndAfter collapse selectNode selectNodeContents compareBoundaryPoints deleteContents extractContents cloneContents insertNode surroundContents cloneRange toString detach".split(" "),
        q = "boundingHeight boundingLeft boundingTop boundingWidth htmlText text".split(" "), r = "collapse compareEndPoints duplicate getBookmark moveToBookmark moveToElementText parentElement pasteHTML select setEndPoint getBoundingClientRect".split(" "), m = d(b), s = d(c), x = d(a), o = {
            version: "1.2.2",
            initialized: !1,
            supported: !0,
            util: {
                isHostMethod: b,
                isHostObject: c,
                isHostProperty: a,
                areHostMethods: m,
                areHostObjects: s,
                areHostProperties: x,
                isTextRange: e
            },
            features: {},
            modules: {},
            config: {alertOnWarn: !1, preferTextRange: !1}
        };
    o.fail = f;
    o.warn = function (a) {
        a = "Rangy warning: " + a;
        o.config.alertOnWarn ? window.alert(a) : typeof window.console != j && typeof window.console.log != j && window.console.log(a)
    };
    ({}).hasOwnProperty ? o.util.extend = function (a, b) {
        for (var c in b)b.hasOwnProperty(c) && (a[c] = b[c])
    } : f("hasOwnProperty not supported");
    var z = [], w = [];
    o.init = g;
    o.addInitListener = function (a) {
        o.initialized ? a(o) : z.push(a)
    };
    var y = [];
    o.addCreateMissingNativeApiListener = function (a) {
        y.push(a)
    };
    o.createMissingNativeApi = function (a) {
        a = a || window;
        g();
        for (var b = 0, c = y.length; b < c; ++b)y[b](a)
    };
    i.prototype.fail = function (a) {
        this.initialized = !0;
        this.supported = !1;
        throw Error("Module '" + this.name + "' failed to load: " + a);
    };
    i.prototype.warn = function (a) {
        o.warn("Module " + this.name + ": " + a)
    };
    i.prototype.createError = function (a) {
        return Error("Error in Rangy " + this.name + " module: " + a)
    };
    o.createModule = function (a, b) {
        var c = new i(a);
        o.modules[a] = c;
        w.push(function (a) {
            b(a, c);
            c.initialized = !0;
            c.supported = !0
        })
    };
    o.requireModules = function (a) {
        for (var b = 0, c = a.length, d, h; b <
        c; ++b) {
            h = a[b];
            d = o.modules[h];
            if (!d || !(d instanceof i))throw Error("Module '" + h + "' not found");
            if (!d.supported)throw Error("Module '" + h + "' not supported");
        }
    };
    var A = !1, s = function () {
        A || (A = !0, o.initialized || g())
    };
    if (typeof window == j)f("No window found"); else if (typeof document == j)f("No document found"); else return b(document, "addEventListener") && document.addEventListener("DOMContentLoaded", s, !1), b(window, "addEventListener") ? window.addEventListener("load", s, !1) : b(window, "attachEvent") ? window.attachEvent("onload",
        s) : f("Window does not have required addEventListener or attachEvent method"), o
}();
rangy.createModule("DomUtil", function (b, c) {
    function a(a) {
        for (var b = 0; a = a.previousSibling;)b++;
        return b
    }

    function d(a, b) {
        var c = [], d;
        for (d = a; d; d = d.parentNode)c.push(d);
        for (d = b; d; d = d.parentNode)if (m(c, d))return d;
        return null
    }

    function e(a, b, c) {
        for (c = c ? a : a.parentNode; c;) {
            a = c.parentNode;
            if (a === b)return c;
            c = a
        }
        return null
    }

    function f(a) {
        a = a.nodeType;
        return 3 == a || 4 == a || 8 == a
    }

    function g(a, b) {
        var c = b.nextSibling, d = b.parentNode;
        c ? d.insertBefore(a, c) : d.appendChild(a);
        return a
    }

    function i(a) {
        if (9 == a.nodeType)return a;
        if (typeof a.ownerDocument != p)return a.ownerDocument;
        if (typeof a.document != p)return a.document;
        if (a.parentNode)return i(a.parentNode);
        throw Error("getDocument: no document found for node");
    }

    function h(a) {
        return !a ? "[No node]" : f(a) ? '"' + a.data + '"' : 1 == a.nodeType ? "<" + a.nodeName + (a.id ? ' id="' + a.id + '"' : "") + ">[" + a.childNodes.length + "]" : a.nodeName
    }

    function k(a) {
        this._next = this.root = a
    }

    function j(a, b) {
        this.node = a;
        this.offset = b
    }

    function n(a) {
        this.code = this[a];
        this.codeName = a;
        this.message = "DOMException: " + this.codeName
    }

    var p = "undefined", q = b.util;
    q.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"]) || c.fail("document missing a Node creation method");
    q.isHostMethod(document, "getElementsByTagName") || c.fail("document missing getElementsByTagName method");
    var r = document.createElement("div");
    q.areHostMethods(r, ["insertBefore", "appendChild", "cloneNode"]) || c.fail("Incomplete Element implementation");
    q.isHostProperty(r, "innerHTML") || c.fail("Element is missing innerHTML property");
    r = document.createTextNode("test");
    q.areHostMethods(r, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"]) || c.fail("Incomplete Text Node implementation");
    var m = function (a, b) {
        for (var c = a.length; c--;)if (a[c] === b)return !0;
        return !1
    };
    k.prototype = {
        _current: null, hasNext: function () {
            return !!this._next
        }, next: function () {
            var a = this._current = this._next, b;
            if (this._current) {
                b = a.firstChild;
                if (!b)for (b = null; a !== this.root && !(b = a.nextSibling);)a = a.parentNode;
                this._next = b
            }
            return this._current
        }, detach: function () {
            this._current = this._next = this.root =
                null
        }
    };
    j.prototype = {
        equals: function (a) {
            return this.node === a.node & this.offset == a.offset
        }, inspect: function () {
            return "[DomPosition(" + h(this.node) + ":" + this.offset + ")]"
        }
    };
    n.prototype = {
        INDEX_SIZE_ERR: 1,
        HIERARCHY_REQUEST_ERR: 3,
        WRONG_DOCUMENT_ERR: 4,
        NO_MODIFICATION_ALLOWED_ERR: 7,
        NOT_FOUND_ERR: 8,
        NOT_SUPPORTED_ERR: 9,
        INVALID_STATE_ERR: 11
    };
    n.prototype.toString = function () {
        return this.message
    };
    b.dom = {
        arrayContains: m, isHtmlNamespace: function (a) {
            var b;
            return typeof a.namespaceURI == p || null === (b = a.namespaceURI) || "http://www.w3.org/1999/xhtml" ==
                b
        }, parentElement: function (a) {
            a = a.parentNode;
            return 1 == a.nodeType ? a : null
        }, getNodeIndex: a, getNodeLength: function (a) {
            var b;
            return f(a) ? a.length : (b = a.childNodes) ? b.length : 0
        }, getCommonAncestor: d, isAncestorOf: function (a, b, c) {
            for (b = c ? b : b.parentNode; b;) {
                if (b === a)return !0;
                b = b.parentNode
            }
            return !1
        }, getClosestAncestorIn: e, isCharacterDataNode: f, insertAfter: g, splitDataNode: function (a, b) {
            var c = a.cloneNode(!1);
            c.deleteData(0, b);
            a.deleteData(b, a.length - b);
            g(c, a);
            return c
        }, getDocument: i, getWindow: function (a) {
            a = i(a);
            if (typeof a.defaultView != p)return a.defaultView;
            if (typeof a.parentWindow != p)return a.parentWindow;
            throw Error("Cannot get a window object for node");
        }, getIframeWindow: function (a) {
            if (typeof a.contentWindow != p)return a.contentWindow;
            if (typeof a.contentDocument != p)return a.contentDocument.defaultView;
            throw Error("getIframeWindow: No Window object found for iframe element");
        }, getIframeDocument: function (a) {
            if (typeof a.contentDocument != p)return a.contentDocument;
            if (typeof a.contentWindow != p)return a.contentWindow.document;
            throw Error("getIframeWindow: No Document object found for iframe element");
        }, getBody: function (a) {
            return q.isHostObject(a, "body") ? a.body : a.getElementsByTagName("body")[0]
        }, getRootContainer: function (a) {
            for (var b; b = a.parentNode;)a = b;
            return a
        }, comparePoints: function (b, c, h, j) {
            var k;
            if (b == h)return c === j ? 0 : c < j ? -1 : 1;
            if (k = e(h, b, !0))return c <= a(k) ? -1 : 1;
            if (k = e(b, h, !0))return a(k) < j ? -1 : 1;
            c = d(b, h);
            b = b === c ? c : e(b, c, !0);
            h = h === c ? c : e(h, c, !0);
            if (b === h)throw Error("comparePoints got to case 4 and childA and childB are the same!");
            for (c = c.firstChild; c;) {
                if (c === b)return -1;
                if (c === h)return 1;
                c = c.nextSibling
            }
            throw Error("Should not be here!");
        }, inspectNode: h, fragmentFromNodeChildren: function (a) {
            for (var b = i(a).createDocumentFragment(), c; c = a.firstChild;)b.appendChild(c);
            return b
        }, createIterator: function (a) {
            return new k(a)
        }, DomPosition: j
    };
    b.DOMException = n
});
rangy.createModule("DomRange", function (b) {
    function c(a, b) {
        return 3 != a.nodeType && (l.isAncestorOf(a, b.startContainer, !0) || l.isAncestorOf(a, b.endContainer, !0))
    }

    function a(a) {
        return l.getDocument(a.startContainer)
    }

    function d(a, b, c) {
        if (b = a._listeners[b])for (var d = 0, h = b.length; d < h; ++d)b[d].call(a, {target: a, args: c})
    }

    function e(a) {
        return new u(a.parentNode, l.getNodeIndex(a))
    }

    function f(a) {
        return new u(a.parentNode, l.getNodeIndex(a) + 1)
    }

    function g(a, b, c) {
        var d = 11 == a.nodeType ? a.firstChild : a;
        l.isCharacterDataNode(b) ?
            c == b.length ? l.insertAfter(a, b) : b.parentNode.insertBefore(a, 0 == c ? b : l.splitDataNode(b, c)) : c >= b.childNodes.length ? b.appendChild(a) : b.insertBefore(a, b.childNodes[c]);
        return d
    }

    function i(b) {
        for (var c, d, h = a(b.range).createDocumentFragment(); d = b.next();) {
            c = b.isPartiallySelectedSubtree();
            d = d.cloneNode(!c);
            c && (c = b.getSubtreeIterator(), d.appendChild(i(c)), c.detach(!0));
            if (10 == d.nodeType)throw new B("HIERARCHY_REQUEST_ERR");
            h.appendChild(d)
        }
        return h
    }

    function h(a, b, c) {
        for (var d, e, c = c || {stop: !1}; d = a.next();)if (a.isPartiallySelectedSubtree())if (!1 ===
            b(d)) {
            c.stop = !0;
            break
        } else {
            if (d = a.getSubtreeIterator(), h(d, b, c), d.detach(!0), c.stop)break
        } else for (d = l.createIterator(d); e = d.next();)if (!1 === b(e)) {
            c.stop = !0;
            return
        }
    }

    function k(a) {
        for (var b; a.next();)a.isPartiallySelectedSubtree() ? (b = a.getSubtreeIterator(), k(b), b.detach(!0)) : a.remove()
    }

    function j(b) {
        for (var c, d = a(b.range).createDocumentFragment(), h; c = b.next();) {
            b.isPartiallySelectedSubtree() ? (c = c.cloneNode(!1), h = b.getSubtreeIterator(), c.appendChild(j(h)), h.detach(!0)) : b.remove();
            if (10 == c.nodeType)throw new B("HIERARCHY_REQUEST_ERR");
            d.appendChild(c)
        }
        return d
    }

    function n(a, b, c) {
        var d = !(!b || !b.length), e, j = !!c;
        d && (e = RegExp("^(" + b.join("|") + ")$"));
        var k = [];
        h(new q(a, !1), function (a) {
            (!d || e.test(a.nodeType)) && (!j || c(a)) && k.push(a)
        });
        return k
    }

    function p(a) {
        return "[" + ("undefined" == typeof a.getName ? "Range" : a.getName()) + "(" + l.inspectNode(a.startContainer) + ":" + a.startOffset + ", " + l.inspectNode(a.endContainer) + ":" + a.endOffset + ")]"
    }

    function q(a, b) {
        this.range = a;
        this.clonePartiallySelectedTextNodes = b;
        if (!a.collapsed) {
            this.sc = a.startContainer;
            this.so = a.startOffset;
            this.ec = a.endContainer;
            this.eo = a.endOffset;
            var c = a.commonAncestorContainer;
            this.sc === this.ec && l.isCharacterDataNode(this.sc) ? (this.isSingleCharacterDataNode = !0, this._first = this._last = this._next = this.sc) : (this._first = this._next = this.sc === c && !l.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : l.getClosestAncestorIn(this.sc, c, !0), this._last = this.ec === c && !l.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : l.getClosestAncestorIn(this.ec, c, !0))
        }
    }

    function r(a) {
        this.code =
            this[a];
        this.codeName = a;
        this.message = "RangeException: " + this.codeName
    }

    function m(a, b, c) {
        this.nodes = n(a, b, c);
        this._next = this.nodes[0];
        this._position = 0
    }

    function s(a) {
        return function (b, c) {
            for (var d, h = c ? b : b.parentNode; h;) {
                d = h.nodeType;
                if (l.arrayContains(a, d))return h;
                h = h.parentNode
            }
            return null
        }
    }

    function x(a, b) {
        if ($(a, b))throw new r("INVALID_NODE_TYPE_ERR");
    }

    function o(a) {
        if (!a.startContainer)throw new B("INVALID_STATE_ERR");
    }

    function z(a, b) {
        if (!l.arrayContains(b, a.nodeType))throw new r("INVALID_NODE_TYPE_ERR");
    }

    function w(a, b) {
        if (0 > b || b > (l.isCharacterDataNode(a) ? a.length : a.childNodes.length))throw new B("INDEX_SIZE_ERR");
    }

    function y(a, b) {
        if (O(a, !0) !== O(b, !0))throw new B("WRONG_DOCUMENT_ERR");
    }

    function A(a) {
        if (aa(a, !0))throw new B("NO_MODIFICATION_ALLOWED_ERR");
    }

    function t(a, b) {
        if (!a)throw new B(b);
    }

    function v(a) {
        o(a);
        if (!l.arrayContains(G, a.startContainer.nodeType) && !O(a.startContainer, !0) || !l.arrayContains(G, a.endContainer.nodeType) && !O(a.endContainer, !0) || !(a.startOffset <= (l.isCharacterDataNode(a.startContainer) ?
                a.startContainer.length : a.startContainer.childNodes.length)) || !(a.endOffset <= (l.isCharacterDataNode(a.endContainer) ? a.endContainer.length : a.endContainer.childNodes.length)))throw Error("Range error: Range is no longer valid after DOM mutation (" + a.inspect() + ")");
    }

    function D() {
    }

    function K(a) {
        a.START_TO_START = Q;
        a.START_TO_END = U;
        a.END_TO_END = ba;
        a.END_TO_START = V;
        a.NODE_BEFORE = W;
        a.NODE_AFTER = X;
        a.NODE_BEFORE_AND_AFTER = Y;
        a.NODE_INSIDE = R
    }

    function F(a) {
        K(a);
        K(a.prototype)
    }

    function E(a, b) {
        return function () {
            v(this);
            var c = this.startContainer, d = this.startOffset, e = this.commonAncestorContainer, j = new q(this, !0);
            c !== e && (c = l.getClosestAncestorIn(c, e, !0), d = f(c), c = d.node, d = d.offset);
            h(j, A);
            j.reset();
            e = a(j);
            j.detach();
            b(this, c, d, c, d);
            return e
        }
    }

    function I(a, d, h) {
        function g(a, b) {
            return function (c) {
                o(this);
                z(c, L);
                z(M(c), G);
                c = (a ? e : f)(c);
                (b ? i : n)(this, c.node, c.offset)
            }
        }

        function i(a, b, c) {
            var h = a.endContainer, e = a.endOffset;
            if (b !== a.startContainer || c !== a.startOffset) {
                if (M(b) != M(h) || 1 == l.comparePoints(b, c, h, e))h = b, e = c;
                d(a, b, c,
                    h, e)
            }
        }

        function n(a, b, c) {
            var h = a.startContainer, e = a.startOffset;
            if (b !== a.endContainer || c !== a.endOffset) {
                if (M(b) != M(h) || -1 == l.comparePoints(b, c, h, e))h = b, e = c;
                d(a, h, e, b, c)
            }
        }

        a.prototype = new D;
        b.util.extend(a.prototype, {
            setStart: function (a, b) {
                o(this);
                x(a, !0);
                w(a, b);
                i(this, a, b)
            },
            setEnd: function (a, b) {
                o(this);
                x(a, !0);
                w(a, b);
                n(this, a, b)
            },
            setStartBefore: g(!0, !0),
            setStartAfter: g(!1, !0),
            setEndBefore: g(!0, !1),
            setEndAfter: g(!1, !1),
            collapse: function (a) {
                v(this);
                a ? d(this, this.startContainer, this.startOffset, this.startContainer,
                    this.startOffset) : d(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset)
            },
            selectNodeContents: function (a) {
                o(this);
                x(a, !0);
                d(this, a, 0, a, l.getNodeLength(a))
            },
            selectNode: function (a) {
                o(this);
                x(a, !1);
                z(a, L);
                var b = e(a), a = f(a);
                d(this, b.node, b.offset, a.node, a.offset)
            },
            extractContents: E(j, d),
            deleteContents: E(k, d),
            canSurroundContents: function () {
                v(this);
                A(this.startContainer);
                A(this.endContainer);
                var a = new q(this, !0), b = a._first && c(a._first, this) || a._last && c(a._last, this);
                a.detach();
                return !b
            },
            detach: function () {
                h(this)
            },
            splitBoundaries: function () {
                v(this);
                var a = this.startContainer, b = this.startOffset, c = this.endContainer, h = this.endOffset, e = a === c;
                l.isCharacterDataNode(c) && (0 < h && h < c.length) && l.splitDataNode(c, h);
                l.isCharacterDataNode(a) && (0 < b && b < a.length) && (a = l.splitDataNode(a, b), e ? (h -= b, c = a) : c == a.parentNode && h >= l.getNodeIndex(a) && h++, b = 0);
                d(this, a, b, c, h)
            },
            normalizeBoundaries: function () {
                v(this);
                var a = this.startContainer, b = this.startOffset, c = this.endContainer, h = this.endOffset, e = function (a) {
                    var b =
                        a.nextSibling;
                    b && b.nodeType == a.nodeType && (c = a, h = a.length, a.appendData(b.data), b.parentNode.removeChild(b))
                }, j = function (d) {
                    var e = d.previousSibling;
                    if (e && e.nodeType == d.nodeType) {
                        a = d;
                        var j = d.length;
                        b = e.length;
                        d.insertData(0, e.data);
                        e.parentNode.removeChild(e);
                        a == c ? (h += b, c = a) : c == d.parentNode && (e = l.getNodeIndex(d), h == e ? (c = d, h = j) : h > e && h--)
                    }
                }, k = !0;
                l.isCharacterDataNode(c) ? c.length == h && e(c) : (0 < h && (k = c.childNodes[h - 1]) && l.isCharacterDataNode(k) && e(k), k = !this.collapsed);
                k ? l.isCharacterDataNode(a) ? 0 == b && j(a) :
                b < a.childNodes.length && (e = a.childNodes[b]) && l.isCharacterDataNode(e) && j(e) : (a = c, b = h);
                d(this, a, b, c, h)
            },
            collapseToPoint: function (a, b) {
                o(this);
                x(a, !0);
                w(a, b);
                (a !== this.startContainer || b !== this.startOffset || a !== this.endContainer || b !== this.endOffset) && d(this, a, b, a, b)
            }
        });
        F(a)
    }

    function N(a) {
        a.collapsed = a.startContainer === a.endContainer && a.startOffset === a.endOffset;
        a.commonAncestorContainer = a.collapsed ? a.startContainer : l.getCommonAncestor(a.startContainer, a.endContainer)
    }

    function J(a, b, c, h, e) {
        var j = a.startContainer !==
            b || a.startOffset !== c, k = a.endContainer !== h || a.endOffset !== e;
        a.startContainer = b;
        a.startOffset = c;
        a.endContainer = h;
        a.endOffset = e;
        N(a);
        d(a, "boundarychange", {startMoved: j, endMoved: k})
    }

    function C(a) {
        this.startContainer = a;
        this.startOffset = 0;
        this.endContainer = a;
        this.endOffset = 0;
        this._listeners = {boundarychange: [], detach: []};
        N(this)
    }

    b.requireModules(["DomUtil"]);
    var l = b.dom, u = l.DomPosition, B = b.DOMException;
    q.prototype = {
        _current: null, _next: null, _first: null, _last: null, isSingleCharacterDataNode: !1, reset: function () {
            this._current =
                null;
            this._next = this._first
        }, hasNext: function () {
            return !!this._next
        }, next: function () {
            var a = this._current = this._next;
            a && (this._next = a !== this._last ? a.nextSibling : null, l.isCharacterDataNode(a) && this.clonePartiallySelectedTextNodes && (a === this.ec && (a = a.cloneNode(!0)).deleteData(this.eo, a.length - this.eo), this._current === this.sc && (a = a.cloneNode(!0)).deleteData(0, this.so)));
            return a
        }, remove: function () {
            var a = this._current, b, c;
            l.isCharacterDataNode(a) && (a === this.sc || a === this.ec) ? (b = a === this.sc ? this.so : 0, c = a ===
            this.ec ? this.eo : a.length, b != c && a.deleteData(b, c - b)) : a.parentNode && a.parentNode.removeChild(a)
        }, isPartiallySelectedSubtree: function () {
            return c(this._current, this.range)
        }, getSubtreeIterator: function () {
            var b;
            if (this.isSingleCharacterDataNode)b = this.range.cloneRange(), b.collapse(); else {
                b = new C(a(this.range));
                var c = this._current, d = c, h = 0, e = c, j = l.getNodeLength(c);
                l.isAncestorOf(c, this.sc, !0) && (d = this.sc, h = this.so);
                l.isAncestorOf(c, this.ec, !0) && (e = this.ec, j = this.eo);
                J(b, d, h, e, j)
            }
            return new q(b, this.clonePartiallySelectedTextNodes)
        },
        detach: function (a) {
            a && this.range.detach();
            this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null
        }
    };
    r.prototype = {BAD_BOUNDARYPOINTS_ERR: 1, INVALID_NODE_TYPE_ERR: 2};
    r.prototype.toString = function () {
        return this.message
    };
    m.prototype = {
        _current: null, hasNext: function () {
            return !!this._next
        }, next: function () {
            this._current = this._next;
            this._next = this.nodes[++this._position];
            return this._current
        }, detach: function () {
            this._current = this._next = this.nodes = null
        }
    };
    var L = [1, 3, 4, 5,
        7, 8, 10], G = [2, 9, 11], P = [1, 3, 4, 5, 7, 8, 10, 11], H = [1, 3, 4, 5, 7, 8], M = l.getRootContainer, O = s([9, 11]), aa = s([5, 6, 10, 12]), $ = s([6, 10, 12]), Z = document.createElement("style"), S = !1;
    try {
        Z.innerHTML = "<b>x</b>", S = 3 == Z.firstChild.nodeType
    } catch (ca) {
    }
    b.features.htmlParsingConforms = S;
    var T = "startContainer startOffset endContainer endOffset collapsed commonAncestorContainer".split(" "), Q = 0, U = 1, ba = 2, V = 3, W = 0, X = 1, Y = 2, R = 3;
    D.prototype = {
        attachListener: function (a, b) {
            this._listeners[a].push(b)
        }, compareBoundaryPoints: function (a, b) {
            v(this);
            y(this.startContainer, b.startContainer);
            var c = a == V || a == Q ? "start" : "end", d = a == U || a == Q ? "start" : "end";
            return l.comparePoints(this[c + "Container"], this[c + "Offset"], b[d + "Container"], b[d + "Offset"])
        }, insertNode: function (a) {
            v(this);
            z(a, P);
            A(this.startContainer);
            if (l.isAncestorOf(a, this.startContainer, !0))throw new B("HIERARCHY_REQUEST_ERR");
            this.setStartBefore(g(a, this.startContainer, this.startOffset))
        }, cloneContents: function () {
            v(this);
            var b, c;
            if (this.collapsed)return a(this).createDocumentFragment();
            if (this.startContainer ===
                this.endContainer && l.isCharacterDataNode(this.startContainer))return b = this.startContainer.cloneNode(!0), b.data = b.data.slice(this.startOffset, this.endOffset), c = a(this).createDocumentFragment(), c.appendChild(b), c;
            c = new q(this, !0);
            b = i(c);
            c.detach();
            return b
        }, canSurroundContents: function () {
            v(this);
            A(this.startContainer);
            A(this.endContainer);
            var a = new q(this, !0), b = a._first && c(a._first, this) || a._last && c(a._last, this);
            a.detach();
            return !b
        }, surroundContents: function (a) {
            z(a, H);
            if (!this.canSurroundContents())throw new r("BAD_BOUNDARYPOINTS_ERR");
            var b = this.extractContents();
            if (a.hasChildNodes())for (; a.lastChild;)a.removeChild(a.lastChild);
            g(a, this.startContainer, this.startOffset);
            a.appendChild(b);
            this.selectNode(a)
        }, cloneRange: function () {
            v(this);
            for (var b = new C(a(this)), c = T.length, d; c--;)d = T[c], b[d] = this[d];
            return b
        }, toString: function () {
            v(this);
            var a = this.startContainer;
            if (a === this.endContainer && l.isCharacterDataNode(a))return 3 == a.nodeType || 4 == a.nodeType ? a.data.slice(this.startOffset, this.endOffset) : "";
            var b = [], a = new q(this, !0);
            h(a, function (a) {
                (3 ==
                a.nodeType || 4 == a.nodeType) && b.push(a.data)
            });
            a.detach();
            return b.join("")
        }, compareNode: function (a) {
            v(this);
            var b = a.parentNode, c = l.getNodeIndex(a);
            if (!b)throw new B("NOT_FOUND_ERR");
            a = this.comparePoint(b, c);
            b = this.comparePoint(b, c + 1);
            return 0 > a ? 0 < b ? Y : W : 0 < b ? X : R
        }, comparePoint: function (a, b) {
            v(this);
            t(a, "HIERARCHY_REQUEST_ERR");
            y(a, this.startContainer);
            return 0 > l.comparePoints(a, b, this.startContainer, this.startOffset) ? -1 : 0 < l.comparePoints(a, b, this.endContainer, this.endOffset) ? 1 : 0
        }, createContextualFragment: S ?
            function (a) {
                var b = this.startContainer, c = l.getDocument(b);
                if (!b)throw new B("INVALID_STATE_ERR");
                var d = null;
                1 == b.nodeType ? d = b : l.isCharacterDataNode(b) && (d = l.parentElement(b));
                d = null === d || "HTML" == d.nodeName && l.isHtmlNamespace(l.getDocument(d).documentElement) && l.isHtmlNamespace(d) ? c.createElement("body") : d.cloneNode(!1);
                d.innerHTML = a;
                return l.fragmentFromNodeChildren(d)
            } : function (b) {
            o(this);
            var c = a(this).createElement("body");
            c.innerHTML = b;
            return l.fragmentFromNodeChildren(c)
        }, toHtml: function () {
            v(this);
            var b = a(this).createElement("div");
            b.appendChild(this.cloneContents());
            return b.innerHTML
        }, intersectsNode: function (b, c) {
            v(this);
            t(b, "NOT_FOUND_ERR");
            if (l.getDocument(b) !== a(this))return !1;
            var d = b.parentNode, h = l.getNodeIndex(b);
            t(d, "NOT_FOUND_ERR");
            var e = l.comparePoints(d, h, this.endContainer, this.endOffset), d = l.comparePoints(d, h + 1, this.startContainer, this.startOffset);
            return c ? 0 >= e && 0 <= d : 0 > e && 0 < d
        }, isPointInRange: function (a, b) {
            v(this);
            t(a, "HIERARCHY_REQUEST_ERR");
            y(a, this.startContainer);
            return 0 <=
                l.comparePoints(a, b, this.startContainer, this.startOffset) && 0 >= l.comparePoints(a, b, this.endContainer, this.endOffset)
        }, intersectsRange: function (b, c) {
            v(this);
            if (a(b) != a(this))throw new B("WRONG_DOCUMENT_ERR");
            var d = l.comparePoints(this.startContainer, this.startOffset, b.endContainer, b.endOffset), h = l.comparePoints(this.endContainer, this.endOffset, b.startContainer, b.startOffset);
            return c ? 0 >= d && 0 <= h : 0 > d && 0 < h
        }, intersection: function (a) {
            if (this.intersectsRange(a)) {
                var b = l.comparePoints(this.startContainer,
                    this.startOffset, a.startContainer, a.startOffset), c = l.comparePoints(this.endContainer, this.endOffset, a.endContainer, a.endOffset), d = this.cloneRange();
                -1 == b && d.setStart(a.startContainer, a.startOffset);
                1 == c && d.setEnd(a.endContainer, a.endOffset);
                return d
            }
            return null
        }, union: function (a) {
            if (this.intersectsRange(a, !0)) {
                var b = this.cloneRange();
                -1 == l.comparePoints(a.startContainer, a.startOffset, this.startContainer, this.startOffset) && b.setStart(a.startContainer, a.startOffset);
                1 == l.comparePoints(a.endContainer,
                    a.endOffset, this.endContainer, this.endOffset) && b.setEnd(a.endContainer, a.endOffset);
                return b
            }
            throw new r("Ranges do not intersect");
        }, containsNode: function (a, b) {
            return b ? this.intersectsNode(a, !1) : this.compareNode(a) == R
        }, containsNodeContents: function (a) {
            return 0 <= this.comparePoint(a, 0) && 0 >= this.comparePoint(a, l.getNodeLength(a))
        }, containsRange: function (a) {
            return this.intersection(a).equals(a)
        }, containsNodeText: function (a) {
            var b = this.cloneRange();
            b.selectNode(a);
            var c = b.getNodes([3]);
            return 0 < c.length ?
                (b.setStart(c[0], 0), a = c.pop(), b.setEnd(a, a.length), a = this.containsRange(b), b.detach(), a) : this.containsNodeContents(a)
        }, createNodeIterator: function (a, b) {
            v(this);
            return new m(this, a, b)
        }, getNodes: function (a, b) {
            v(this);
            return n(this, a, b)
        }, getDocument: function () {
            return a(this)
        }, collapseBefore: function (a) {
            o(this);
            this.setEndBefore(a);
            this.collapse(!1)
        }, collapseAfter: function (a) {
            o(this);
            this.setStartAfter(a);
            this.collapse(!0)
        }, getName: function () {
            return "DomRange"
        }, equals: function (a) {
            return C.rangesEqual(this,
                a)
        }, inspect: function () {
            return p(this)
        }
    };
    I(C, J, function (a) {
        o(a);
        a.startContainer = a.startOffset = a.endContainer = a.endOffset = null;
        a.collapsed = a.commonAncestorContainer = null;
        d(a, "detach", null);
        a._listeners = null
    });
    b.rangePrototype = D.prototype;
    C.rangeProperties = T;
    C.RangeIterator = q;
    C.copyComparisonConstants = F;
    C.createPrototypeRange = I;
    C.inspect = p;
    C.getRangeDocument = a;
    C.rangesEqual = function (a, b) {
        return a.startContainer === b.startContainer && a.startOffset === b.startOffset && a.endContainer === b.endContainer && a.endOffset ===
            b.endOffset
    };
    b.DomRange = C;
    b.RangeException = r
});
rangy.createModule("WrappedRange", function (b) {
    function c(a, b, c, d) {
        var g = a.duplicate();
        g.collapse(c);
        var i = g.parentElement();
        e.isAncestorOf(b, i, !0) || (i = b);
        if (!i.canHaveHTML)return new f(i.parentNode, e.getNodeIndex(i));
        var b = e.getDocument(i).createElement("span"), r, m = c ? "StartToStart" : "StartToEnd";
        do i.insertBefore(b, b.previousSibling), g.moveToElementText(b); while (0 < (r = g.compareEndPoints(m, a)) && b.previousSibling);
        m = b.nextSibling;
        if (-1 == r && m && e.isCharacterDataNode(m)) {
            g.setEndPoint(c ? "EndToStart" : "EndToEnd",
                a);
            if (/[\r\n]/.test(m.data)) {
                i = g.duplicate();
                c = i.text.replace(/\r\n/g, "\r").length;
                for (c = i.moveStart("character", c); -1 == i.compareEndPoints("StartToEnd", i);)c++, i.moveStart("character", 1)
            } else c = g.text.length;
            i = new f(m, c)
        } else m = (d || !c) && b.previousSibling, i = (c = (d || c) && b.nextSibling) && e.isCharacterDataNode(c) ? new f(c, 0) : m && e.isCharacterDataNode(m) ? new f(m, m.length) : new f(i, e.getNodeIndex(b));
        b.parentNode.removeChild(b);
        return i
    }

    function a(a, b) {
        var c, d, f = a.offset, g = e.getDocument(a.node), i = g.body.createTextRange(),
            m = e.isCharacterDataNode(a.node);
        m ? (c = a.node, d = c.parentNode) : (c = a.node.childNodes, c = f < c.length ? c[f] : null, d = a.node);
        g = g.createElement("span");
        g.innerHTML = "&#feff;";
        c ? d.insertBefore(g, c) : d.appendChild(g);
        i.moveToElementText(g);
        i.collapse(!b);
        d.removeChild(g);
        if (m)i[b ? "moveStart" : "moveEnd"]("character", f);
        return i
    }

    b.requireModules(["DomUtil", "DomRange"]);
    var d, e = b.dom, f = e.DomPosition, g = b.DomRange;
    if (b.features.implementsDomRange && (!b.features.implementsTextRange || !b.config.preferTextRange))(function () {
        function a(b) {
            for (var c =
                j.length, d; c--;)d = j[c], b[d] = b.nativeRange[d]
        }

        var c, j = g.rangeProperties, f;
        d = function (b) {
            if (!b)throw Error("Range must be specified");
            this.nativeRange = b;
            a(this)
        };
        g.createPrototypeRange(d, function (a, b, c, d, h) {
            var e = a.endContainer !== d || a.endOffset != h;
            if (a.startContainer !== b || a.startOffset != c || e)a.setEnd(d, h), a.setStart(b, c)
        }, function (a) {
            a.nativeRange.detach();
            a.detached = !0;
            for (var b = j.length, c; b--;)c = j[b], a[c] = null
        });
        c = d.prototype;
        c.selectNode = function (b) {
            this.nativeRange.selectNode(b);
            a(this)
        };
        c.deleteContents =
            function () {
                this.nativeRange.deleteContents();
                a(this)
            };
        c.extractContents = function () {
            var b = this.nativeRange.extractContents();
            a(this);
            return b
        };
        c.cloneContents = function () {
            return this.nativeRange.cloneContents()
        };
        c.surroundContents = function (b) {
            this.nativeRange.surroundContents(b);
            a(this)
        };
        c.collapse = function (b) {
            this.nativeRange.collapse(b);
            a(this)
        };
        c.cloneRange = function () {
            return new d(this.nativeRange.cloneRange())
        };
        c.refresh = function () {
            a(this)
        };
        c.toString = function () {
            return this.nativeRange.toString()
        };
        var i = document.createTextNode("test");
        e.getBody(document).appendChild(i);
        var q = document.createRange();
        q.setStart(i, 0);
        q.setEnd(i, 0);
        try {
            q.setStart(i, 1), c.setStart = function (b, c) {
                this.nativeRange.setStart(b, c);
                a(this)
            }, c.setEnd = function (b, c) {
                this.nativeRange.setEnd(b, c);
                a(this)
            }, f = function (b) {
                return function (c) {
                    this.nativeRange[b](c);
                    a(this)
                }
            }
        } catch (r) {
            c.setStart = function (b, c) {
                try {
                    this.nativeRange.setStart(b, c)
                } catch (d) {
                    this.nativeRange.setEnd(b, c), this.nativeRange.setStart(b, c)
                }
                a(this)
            }, c.setEnd = function (b,
                                    c) {
                try {
                    this.nativeRange.setEnd(b, c)
                } catch (d) {
                    this.nativeRange.setStart(b, c), this.nativeRange.setEnd(b, c)
                }
                a(this)
            }, f = function (b, c) {
                return function (d) {
                    try {
                        this.nativeRange[b](d)
                    } catch (e) {
                        this.nativeRange[c](d), this.nativeRange[b](d)
                    }
                    a(this)
                }
            }
        }
        c.setStartBefore = f("setStartBefore", "setEndBefore");
        c.setStartAfter = f("setStartAfter", "setEndAfter");
        c.setEndBefore = f("setEndBefore", "setStartBefore");
        c.setEndAfter = f("setEndAfter", "setStartAfter");
        q.selectNodeContents(i);
        c.selectNodeContents = q.startContainer ==
        i && q.endContainer == i && 0 == q.startOffset && q.endOffset == i.length ? function (b) {
            this.nativeRange.selectNodeContents(b);
            a(this)
        } : function (a) {
            this.setStart(a, 0);
            this.setEnd(a, g.getEndOffset(a))
        };
        q.selectNodeContents(i);
        q.setEnd(i, 3);
        f = document.createRange();
        f.selectNodeContents(i);
        f.setEnd(i, 4);
        f.setStart(i, 2);
        c.compareBoundaryPoints = -1 == q.compareBoundaryPoints(q.START_TO_END, f) & 1 == q.compareBoundaryPoints(q.END_TO_START, f) ? function (a, b) {
            b = b.nativeRange || b;
            a == b.START_TO_END ? a = b.END_TO_START : a == b.END_TO_START &&
            (a = b.START_TO_END);
            return this.nativeRange.compareBoundaryPoints(a, b)
        } : function (a, b) {
            return this.nativeRange.compareBoundaryPoints(a, b.nativeRange || b)
        };
        b.util.isHostMethod(q, "createContextualFragment") && (c.createContextualFragment = function (a) {
            return this.nativeRange.createContextualFragment(a)
        });
        e.getBody(document).removeChild(i);
        q.detach();
        f.detach()
    })(), b.createNativeRange = function (a) {
        a = a || document;
        return a.createRange()
    }; else if (b.features.implementsTextRange) {
        d = function (a) {
            this.textRange = a;
            this.refresh()
        };
        d.prototype = new g(document);
        d.prototype.refresh = function () {
            var a, b, d = this.textRange;
            a = d.parentElement();
            var f = d.duplicate();
            f.collapse(!0);
            b = f.parentElement();
            f = d.duplicate();
            f.collapse(!1);
            d = f.parentElement();
            b = b == d ? b : e.getCommonAncestor(b, d);
            b = b == a ? b : e.getCommonAncestor(a, b);
            0 == this.textRange.compareEndPoints("StartToEnd", this.textRange) ? b = a = c(this.textRange, b, !0, !0) : (a = c(this.textRange, b, !0, !1), b = c(this.textRange, b, !1, !1));
            this.setStart(a.node, a.offset);
            this.setEnd(b.node, b.offset)
        };
        g.copyComparisonConstants(d);
        var i = function () {
            return this
        }();
        "undefined" == typeof i.Range && (i.Range = d);
        b.createNativeRange = function (a) {
            a = a || document;
            return a.body.createTextRange()
        }
    }
    b.features.implementsTextRange && (d.rangeToTextRange = function (b) {
        if (b.collapsed)return a(new f(b.startContainer, b.startOffset), !0);
        var c = a(new f(b.startContainer, b.startOffset), !0), d = a(new f(b.endContainer, b.endOffset), !1), b = e.getDocument(b.startContainer).body.createTextRange();
        b.setEndPoint("StartToStart", c);
        b.setEndPoint("EndToEnd", d);
        return b
    });
    d.prototype.getName = function () {
        return "WrappedRange"
    };
    b.WrappedRange = d;
    b.createRange = function (a) {
        a = a || document;
        return new d(b.createNativeRange(a))
    };
    b.createRangyRange = function (a) {
        a = a || document;
        return new g(a)
    };
    b.createIframeRange = function (a) {
        return b.createRange(e.getIframeDocument(a))
    };
    b.createIframeRangyRange = function (a) {
        return b.createRangyRange(e.getIframeDocument(a))
    };
    b.addCreateMissingNativeApiListener(function (a) {
        a = a.document;
        if (typeof a.createRange == "undefined")a.createRange = function () {
            return b.createRange(this)
        };
        a = a = null
    })
});
rangy.createModule("WrappedSelection", function (b, c) {
    function a(a) {
        return (a || window).getSelection()
    }

    function d(a) {
        return (a || window).document.selection
    }

    function e(a, b, c) {
        var d = c ? "end" : "start", c = c ? "start" : "end";
        a.anchorNode = b[d + "Container"];
        a.anchorOffset = b[d + "Offset"];
        a.focusNode = b[c + "Container"];
        a.focusOffset = b[c + "Offset"]
    }

    function f(a) {
        a.anchorNode = a.focusNode = null;
        a.anchorOffset = a.focusOffset = 0;
        a.rangeCount = 0;
        a.isCollapsed = !0;
        a._ranges.length = 0
    }

    function g(a) {
        var c;
        a instanceof x ? (c = a._selectionNativeRange,
        c || (c = b.createNativeRange(m.getDocument(a.startContainer)), c.setEnd(a.endContainer, a.endOffset), c.setStart(a.startContainer, a.startOffset), a._selectionNativeRange = c, a.attachListener("detach", function () {
            this._selectionNativeRange = null
        }))) : a instanceof o ? c = a.nativeRange : b.features.implementsDomRange && a instanceof m.getWindow(a.startContainer).Range && (c = a);
        return c
    }

    function i(a) {
        var b = a.getNodes(), c;
        a:if (!b.length || 1 != b[0].nodeType)c = !1; else {
            c = 1;
            for (var d = b.length; c < d; ++c)if (!m.isAncestorOf(b[0], b[c])) {
                c = !1;
                break a
            }
            c = !0
        }
        if (!c)throw Error("getSingleElementFromRange: range " + a.inspect() + " did not consist of a single element");
        return b[0]
    }

    function h(a, b) {
        var c = new o(b);
        a._ranges = [c];
        e(a, c, !1);
        a.rangeCount = 1;
        a.isCollapsed = c.collapsed
    }

    function k(a) {
        a._ranges.length = 0;
        if ("None" == a.docSelection.type)f(a); else {
            var c = a.docSelection.createRange();
            if (c && "undefined" != typeof c.text)h(a, c); else {
                a.rangeCount = c.length;
                for (var d, j = m.getDocument(c.item(0)), k = 0; k < a.rangeCount; ++k)d = b.createRange(j), d.selectNode(c.item(k)),
                    a._ranges.push(d);
                a.isCollapsed = 1 == a.rangeCount && a._ranges[0].collapsed;
                e(a, a._ranges[a.rangeCount - 1], !1)
            }
        }
    }

    function j(a, b) {
        for (var c = a.docSelection.createRange(), d = i(b), e = m.getDocument(c.item(0)), e = m.getBody(e).createControlRange(), h = 0, j = c.length; h < j; ++h)e.add(c.item(h));
        try {
            e.add(d)
        } catch (f) {
            throw Error("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
        }
        e.select();
        k(a)
    }

    function n(a, b, c) {
        this.nativeSelection = a;
        this.docSelection = b;
        this._ranges =
            [];
        this.win = c;
        this.refresh()
    }

    function p(a, b) {
        for (var c = m.getDocument(b[0].startContainer), c = m.getBody(c).createControlRange(), d = 0, e; d < rangeCount; ++d) {
            e = i(b[d]);
            try {
                c.add(e)
            } catch (h) {
                throw Error("setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)");
            }
        }
        c.select();
        k(a)
    }

    function q(a, b) {
        if (a.anchorNode && m.getDocument(a.anchorNode) !== m.getDocument(b))throw new z("WRONG_DOCUMENT_ERR");
    }

    function r(a) {
        var b = [], c = new w(a.anchorNode, a.anchorOffset),
            d = new w(a.focusNode, a.focusOffset), e = "function" == typeof a.getName ? a.getName() : "Selection";
        if ("undefined" != typeof a.rangeCount)for (var h = 0, j = a.rangeCount; h < j; ++h)b[h] = x.inspect(a.getRangeAt(h));
        return "[" + e + "(Ranges: " + b.join(", ") + ")(anchor: " + c.inspect() + ", focus: " + d.inspect() + "]"
    }

    b.requireModules(["DomUtil", "DomRange", "WrappedRange"]);
    b.config.checkSelectionRanges = !0;
    var m = b.dom, s = b.util, x = b.DomRange, o = b.WrappedRange, z = b.DOMException, w = m.DomPosition, y, A, t = b.util.isHostMethod(window, "getSelection"),
        v = b.util.isHostObject(document, "selection"), D = v && (!t || b.config.preferTextRange);
    D ? (y = d, b.isSelectionValid = function (a) {
        var a = (a || window).document, b = a.selection;
        return "None" != b.type || m.getDocument(b.createRange().parentElement()) == a
    }) : t ? (y = a, b.isSelectionValid = function () {
        return !0
    }) : c.fail("Neither document.selection or window.getSelection() detected.");
    b.getNativeSelection = y;
    var t = y(), K = b.createNativeRange(document), F = m.getBody(document), E = s.areHostObjects(t, s.areHostProperties(t, ["anchorOffset", "focusOffset"]));
    b.features.selectionHasAnchorAndFocus = E;
    var I = s.isHostMethod(t, "extend");
    b.features.selectionHasExtend = I;
    var N = "number" == typeof t.rangeCount;
    b.features.selectionHasRangeCount = N;
    var J = !1, C = !0;
    s.areHostMethods(t, ["addRange", "getRangeAt", "removeAllRanges"]) && ("number" == typeof t.rangeCount && b.features.implementsDomRange) && function () {
        var a = document.createElement("iframe");
        F.appendChild(a);
        var b = m.getIframeDocument(a);
        b.open();
        b.write("<html><head></head><body>12</body></html>");
        b.close();
        var c = m.getIframeWindow(a).getSelection(),
            d = b.documentElement.lastChild.firstChild, b = b.createRange();
        b.setStart(d, 1);
        b.collapse(true);
        c.addRange(b);
        C = c.rangeCount == 1;
        c.removeAllRanges();
        var e = b.cloneRange();
        b.setStart(d, 0);
        e.setEnd(d, 2);
        c.addRange(b);
        c.addRange(e);
        J = c.rangeCount == 2;
        b.detach();
        e.detach();
        F.removeChild(a)
    }();
    b.features.selectionSupportsMultipleRanges = J;
    b.features.collapsedNonEditableSelectionsSupported = C;
    var l = !1, u;
    F && s.isHostMethod(F, "createControlRange") && (u = F.createControlRange(), s.areHostProperties(u, ["item", "add"]) && (l = !0));
    b.features.implementsControlRange = l;
    A = E ? function (a) {
        return a.anchorNode === a.focusNode && a.anchorOffset === a.focusOffset
    } : function (a) {
        return a.rangeCount ? a.getRangeAt(a.rangeCount - 1).collapsed : false
    };
    var B;
    s.isHostMethod(t, "getRangeAt") ? B = function (a, b) {
        try {
            return a.getRangeAt(b)
        } catch (c) {
            return null
        }
    } : E && (B = function (a) {
        var c = m.getDocument(a.anchorNode), c = b.createRange(c);
        c.setStart(a.anchorNode, a.anchorOffset);
        c.setEnd(a.focusNode, a.focusOffset);
        if (c.collapsed !== this.isCollapsed) {
            c.setStart(a.focusNode,
                a.focusOffset);
            c.setEnd(a.anchorNode, a.anchorOffset)
        }
        return c
    });
    b.getSelection = function (a) {
        var a = a || window, b = a._rangySelection, c = y(a), e = v ? d(a) : null;
        if (b) {
            b.nativeSelection = c;
            b.docSelection = e;
            b.refresh(a)
        } else {
            b = new n(c, e, a);
            a._rangySelection = b
        }
        return b
    };
    b.getIframeSelection = function (a) {
        return b.getSelection(m.getIframeWindow(a))
    };
    u = n.prototype;
    if (!D && E && s.areHostMethods(t, ["removeAllRanges", "addRange"])) {
        u.removeAllRanges = function () {
            this.nativeSelection.removeAllRanges();
            f(this)
        };
        var L = function (a,
                          c) {
            var d = x.getRangeDocument(c), d = b.createRange(d);
            d.collapseToPoint(c.endContainer, c.endOffset);
            a.nativeSelection.addRange(g(d));
            a.nativeSelection.extend(c.startContainer, c.startOffset);
            a.refresh()
        };
        u.addRange = N ? function (a, c) {
            if (l && v && this.docSelection.type == "Control")j(this, a); else if (c && I)L(this, a); else {
                var d;
                if (J)d = this.rangeCount; else {
                    this.removeAllRanges();
                    d = 0
                }
                this.nativeSelection.addRange(g(a));
                this.rangeCount = this.nativeSelection.rangeCount;
                if (this.rangeCount == d + 1) {
                    if (b.config.checkSelectionRanges)(d =
                        B(this.nativeSelection, this.rangeCount - 1)) && !x.rangesEqual(d, a) && (a = new o(d));
                    this._ranges[this.rangeCount - 1] = a;
                    e(this, a, H(this.nativeSelection));
                    this.isCollapsed = A(this)
                } else this.refresh()
            }
        } : function (a, b) {
            if (b && I)L(this, a); else {
                this.nativeSelection.addRange(g(a));
                this.refresh()
            }
        };
        u.setRanges = function (a) {
            if (l && a.length > 1)p(this, a); else {
                this.removeAllRanges();
                for (var b = 0, c = a.length; b < c; ++b)this.addRange(a[b])
            }
        }
    } else if (s.isHostMethod(t, "empty") && s.isHostMethod(K, "select") && l && D)u.removeAllRanges =
        function () {
            try {
                this.docSelection.empty();
                if (this.docSelection.type != "None") {
                    var a;
                    if (this.anchorNode)a = m.getDocument(this.anchorNode); else if (this.docSelection.type == "Control") {
                        var b = this.docSelection.createRange();
                        b.length && (a = m.getDocument(b.item(0)).body.createTextRange())
                    }
                    if (a) {
                        a.body.createTextRange().select();
                        this.docSelection.empty()
                    }
                }
            } catch (c) {
            }
            f(this)
        }, u.addRange = function (a) {
        if (this.docSelection.type == "Control")j(this, a); else {
            o.rangeToTextRange(a).select();
            this._ranges[0] = a;
            this.rangeCount =
                1;
            this.isCollapsed = this._ranges[0].collapsed;
            e(this, a, false)
        }
    }, u.setRanges = function (a) {
        this.removeAllRanges();
        var b = a.length;
        b > 1 ? p(this, a) : b && this.addRange(a[0])
    }; else return c.fail("No means of selecting a Range or TextRange was found"), !1;
    u.getRangeAt = function (a) {
        if (a < 0 || a >= this.rangeCount)throw new z("INDEX_SIZE_ERR");
        return this._ranges[a]
    };
    var G;
    if (D)G = function (a) {
        var c;
        if (b.isSelectionValid(a.win))c = a.docSelection.createRange(); else {
            c = m.getBody(a.win.document).createTextRange();
            c.collapse(true)
        }
        a.docSelection.type ==
        "Control" ? k(a) : c && typeof c.text != "undefined" ? h(a, c) : f(a)
    }; else if (s.isHostMethod(t, "getRangeAt") && "number" == typeof t.rangeCount)G = function (a) {
        if (l && v && a.docSelection.type == "Control")k(a); else {
            a._ranges.length = a.rangeCount = a.nativeSelection.rangeCount;
            if (a.rangeCount) {
                for (var c = 0, d = a.rangeCount; c < d; ++c)a._ranges[c] = new b.WrappedRange(a.nativeSelection.getRangeAt(c));
                e(a, a._ranges[a.rangeCount - 1], H(a.nativeSelection));
                a.isCollapsed = A(a)
            } else f(a)
        }
    }; else if (E && "boolean" == typeof t.isCollapsed && "boolean" == typeof K.collapsed && b.features.implementsDomRange)G = function (a) {
        var b;
        b = a.nativeSelection;
        if (b.anchorNode) {
            b = B(b, 0);
            a._ranges = [b];
            a.rangeCount = 1;
            b = a.nativeSelection;
            a.anchorNode = b.anchorNode;
            a.anchorOffset = b.anchorOffset;
            a.focusNode = b.focusNode;
            a.focusOffset = b.focusOffset;
            a.isCollapsed = A(a)
        } else f(a)
    }; else return c.fail("No means of obtaining a Range or TextRange from the user's selection was found"), !1;
    u.refresh = function (a) {
        var b = a ? this._ranges.slice(0) : null;
        G(this);
        if (a) {
            a = b.length;
            if (a != this._ranges.length)return false;
            for (; a--;)if (!x.rangesEqual(b[a], this._ranges[a]))return false;
            return true
        }
    };
    var P = function (a, b) {
        var c = a.getAllRanges(), d = false;
        a.removeAllRanges();
        for (var e = 0, h = c.length; e < h; ++e)d || b !== c[e] ? a.addRange(c[e]) : d = true;
        a.rangeCount || f(a)
    };
    u.removeRange = l ? function (a) {
        if (this.docSelection.type == "Control") {
            for (var b = this.docSelection.createRange(), a = i(a), c = m.getDocument(b.item(0)), c = m.getBody(c).createControlRange(), d, e = false, h = 0, j = b.length; h < j; ++h) {
                d = b.item(h);
                d !== a || e ? c.add(b.item(h)) : e = true
            }
            c.select();
            k(this)
        } else P(this, a)
    } : function (a) {
        P(this, a)
    };
    var H;
    !D && E && b.features.implementsDomRange ? (H = function (a) {
        var b = false;
        a.anchorNode && (b = m.comparePoints(a.anchorNode, a.anchorOffset, a.focusNode, a.focusOffset) == 1);
        return b
    }, u.isBackwards = function () {
        return H(this)
    }) : H = u.isBackwards = function () {
        return false
    };
    u.toString = function () {
        for (var a = [], b = 0, c = this.rangeCount; b < c; ++b)a[b] = "" + this._ranges[b];
        return a.join("")
    };
    u.collapse = function (a, c) {
        q(this, a);
        var d = b.createRange(m.getDocument(a));
        d.collapseToPoint(a,
            c);
        this.removeAllRanges();
        this.addRange(d);
        this.isCollapsed = true
    };
    u.collapseToStart = function () {
        if (this.rangeCount) {
            var a = this._ranges[0];
            this.collapse(a.startContainer, a.startOffset)
        } else throw new z("INVALID_STATE_ERR");
    };
    u.collapseToEnd = function () {
        if (this.rangeCount) {
            var a = this._ranges[this.rangeCount - 1];
            this.collapse(a.endContainer, a.endOffset)
        } else throw new z("INVALID_STATE_ERR");
    };
    u.selectAllChildren = function (a) {
        q(this, a);
        var c = b.createRange(m.getDocument(a));
        c.selectNodeContents(a);
        this.removeAllRanges();
        this.addRange(c)
    };
    u.deleteFromDocument = function () {
        if (l && v && this.docSelection.type == "Control") {
            for (var a = this.docSelection.createRange(), b; a.length;) {
                b = a.item(0);
                a.remove(b);
                b.parentNode.removeChild(b)
            }
            this.refresh()
        } else if (this.rangeCount) {
            a = this.getAllRanges();
            this.removeAllRanges();
            b = 0;
            for (var c = a.length; b < c; ++b)a[b].deleteContents();
            this.addRange(a[c - 1])
        }
    };
    u.getAllRanges = function () {
        return this._ranges.slice(0)
    };
    u.setSingleRange = function (a) {
        this.setRanges([a])
    };
    u.containsNode = function (a, b) {
        for (var c =
            0, d = this._ranges.length; c < d; ++c)if (this._ranges[c].containsNode(a, b))return true;
        return false
    };
    u.toHtml = function () {
        var a = "";
        if (this.rangeCount) {
            for (var a = x.getRangeDocument(this._ranges[0]).createElement("div"), b = 0, c = this._ranges.length; b < c; ++b)a.appendChild(this._ranges[b].cloneContents());
            a = a.innerHTML
        }
        return a
    };
    u.getName = function () {
        return "WrappedSelection"
    };
    u.inspect = function () {
        return r(this)
    };
    u.detach = function () {
        this.win = this.anchorNode = this.focusNode = this.win._rangySelection = null
    };
    n.inspect =
        r;
    b.Selection = n;
    b.selectionPrototype = u;
    b.addCreateMissingNativeApiListener(function (a) {
        if (typeof a.getSelection == "undefined")a.getSelection = function () {
            return b.getSelection(this)
        };
        a = null
    })
});
var Base = function () {
};
Base.extend = function (b, c) {
    var a = Base.prototype.extend;
    Base._prototyping = !0;
    var d = new this;
    a.call(d, b);
    d.base = function () {
    };
    delete Base._prototyping;
    var e = d.constructor, f = d.constructor = function () {
        if (!Base._prototyping)if (this._constructing || this.constructor == f)this._constructing = !0, e.apply(this, arguments), delete this._constructing; else if (null != arguments[0])return (arguments[0].extend || a).call(arguments[0], d)
    };
    f.ancestor = this;
    f.extend = this.extend;
    f.forEach = this.forEach;
    f.implement = this.implement;
    f.prototype =
        d;
    f.toString = this.toString;
    f.valueOf = function (a) {
        return "object" == a ? f : e.valueOf()
    };
    a.call(f, c);
    "function" == typeof f.init && f.init();
    return f
};
Base.prototype = {
    extend: function (b, c) {
        if (1 < arguments.length) {
            var a = this[b];
            if (a && "function" == typeof c && (!a.valueOf || a.valueOf() != c.valueOf()) && /\bbase\b/.test(c)) {
                var d = c.valueOf(), c = function () {
                    var b = this.base || Base.prototype.base;
                    this.base = a;
                    var c = d.apply(this, arguments);
                    this.base = b;
                    return c
                };
                c.valueOf = function (a) {
                    return "object" == a ? c : d
                };
                c.toString = Base.toString
            }
            this[b] = c
        } else if (b) {
            var e = Base.prototype.extend;
            !Base._prototyping && "function" != typeof this && (e = this.extend || e);
            for (var f = {toSource: null},
                     g = ["constructor", "toString", "valueOf"], i = Base._prototyping ? 0 : 1; h = g[i++];)b[h] != f[h] && e.call(this, h, b[h]);
            for (var h in b)f[h] || e.call(this, h, b[h])
        }
        return this
    }
};
Base = Base.extend({
    constructor: function (b) {
        this.extend(b)
    }
}, {
    ancestor: Object, version: "1.1", forEach: function (b, c, a) {
        for (var d in b)void 0 === this.prototype[d] && c.call(a, b[d], d, b)
    }, implement: function () {
        for (var b = 0; b < arguments.length; b++)if ("function" == typeof arguments[b])arguments[b](this.prototype); else this.prototype.extend(arguments[b]);
        return this
    }, toString: function () {
        return "" + this.valueOf()
    }
});
wysihtml5.browser = function () {
    var b = navigator.userAgent, c = document.createElement("div"), a = -1 !== b.indexOf("MSIE") && -1 === b.indexOf("Opera"), d = -1 !== b.indexOf("Gecko") && -1 === b.indexOf("KHTML"), e = -1 !== b.indexOf("AppleWebKit/"), f = -1 !== b.indexOf("Chrome/"), g = -1 !== b.indexOf("Opera/");
    return {
        USER_AGENT: b, supported: function () {
            var a = this.USER_AGENT.toLowerCase(), b = "contentEditable"in c, d = document.execCommand && document.queryCommandSupported && document.queryCommandState, e = document.querySelector && document.querySelectorAll,
                a = this.isIos() && 5 > (/ipad|iphone|ipod/.test(a) && a.match(/ os (\d+).+? like mac os x/) || [, 0])[1] || -1 !== a.indexOf("opera mobi") || -1 !== a.indexOf("hpwos/");
            return b && d && e && !a
        }, isTouchDevice: function () {
            return this.supportsEvent("touchmove")
        }, isIos: function () {
            var a = this.USER_AGENT.toLowerCase();
            return -1 !== a.indexOf("webkit") && -1 !== a.indexOf("mobile")
        }, supportsSandboxedIframes: function () {
            return a
        }, throwsMixedContentWarningWhenIframeSrcIsEmpty: function () {
            return !("querySelector"in document)
        }, displaysCaretInEmptyContentEditableCorrectly: function () {
            return !d
        },
        hasCurrentStyleProperty: function () {
            return "currentStyle"in c
        }, insertsLineBreaksOnReturn: function () {
            return d
        }, supportsPlaceholderAttributeOn: function (a) {
            return "placeholder"in a
        }, supportsEvent: function (a) {
            var b;
            if (!(b = "on" + a in c))c.setAttribute("on" + a, "return;"), b = "function" === typeof c["on" + a];
            return b
        }, supportsEventsInIframeCorrectly: function () {
            return !g
        }, firesOnDropOnlyWhenOnDragOverIsCancelled: function () {
            return e || d
        }, supportsDataTransfer: function () {
            try {
                return e && (window.Clipboard || window.DataTransfer).prototype.getData
            } catch (a) {
                return !1
            }
        },
        supportsHTML5Tags: function (a) {
            a = a.createElement("div");
            a.innerHTML = "<article>foo</article>";
            return "<article>foo</article>" === a.innerHTML.toLowerCase()
        }, supportsCommand: function () {
            var b = {
                formatBlock: a,
                insertUnorderedList: a || g || e,
                insertOrderedList: a || g || e
            }, c = {insertHTML: d};
            return function (a, d) {
                if (!b[d]) {
                    try {
                        return a.queryCommandSupported(d)
                    } catch (e) {
                    }
                    try {
                        return a.queryCommandEnabled(d)
                    } catch (f) {
                        return !!c[d]
                    }
                }
                return !1
            }
        }(), doesAutoLinkingInContentEditable: function () {
            return a
        }, canDisableAutoLinking: function () {
            return this.supportsCommand(document,
                "AutoUrlDetect")
        }, clearsContentEditableCorrectly: function () {
            return d || g || e
        }, supportsGetAttributeCorrectly: function () {
            return "1" != document.createElement("td").getAttribute("rowspan")
        }, canSelectImagesInContentEditable: function () {
            return d || a || g
        }, clearsListsInContentEditableCorrectly: function () {
            return d || a || e
        }, autoScrollsToCaret: function () {
            return !e
        }, autoClosesUnclosedTags: function () {
            var a = c.cloneNode(!1), b;
            a.innerHTML = "<p><div></div>";
            a = a.innerHTML.toLowerCase();
            b = "<p></p><div></div>" === a || "<p><div></div></p>" ===
                a;
            this.autoClosesUnclosedTags = function () {
                return b
            };
            return b
        }, supportsNativeGetElementsByClassName: function () {
            return -1 !== ("" + document.getElementsByClassName).indexOf("[native code]")
        }, supportsSelectionModify: function () {
            return "getSelection"in window && "modify"in window.getSelection()
        }, supportsClassList: function () {
            return "classList"in c
        }, needsSpaceAfterLineBreak: function () {
            return g
        }, supportsSpeechApiOn: function (a) {
            return 11 <= (b.match(/Chrome\/(\d+)/) || [, 0])[1] && ("onwebkitspeechchange"in a || "speech"in a)
        },
        crashesWhenDefineProperty: function (b) {
            return a && ("XMLHttpRequest" === b || "XDomainRequest" === b)
        }, doesAsyncFocus: function () {
            return a
        }, hasProblemsSettingCaretAfterImg: function () {
            return a
        }, hasUndoInContextMenu: function () {
            return d || f || g
        }
    }
}();
wysihtml5.lang.array = function (b) {
    return {
        contains: function (c) {
            if (b.indexOf)return -1 !== b.indexOf(c);
            for (var a = 0, d = b.length; a < d; a++)if (b[a] === c)return !0;
            return !1
        }, without: function (c) {
            for (var c = wysihtml5.lang.array(c), a = [], d = 0, e = b.length; d < e; d++)c.contains(b[d]) || a.push(b[d]);
            return a
        }, get: function () {
            for (var c = 0, a = b.length, d = []; c < a; c++)d.push(b[c]);
            return d
        }
    }
};
wysihtml5.lang.Dispatcher = Base.extend({
    observe: function (b, c) {
        this.events = this.events || {};
        this.events[b] = this.events[b] || [];
        this.events[b].push(c);
        return this
    }, on: function () {
        return this.observe.apply(this, wysihtml5.lang.array(arguments).get())
    }, fire: function (b, c) {
        this.events = this.events || {};
        for (var a = this.events[b] || [], d = 0; d < a.length; d++)a[d].call(this, c);
        return this
    }, stopObserving: function (b, c) {
        this.events = this.events || {};
        var a = 0, d, e;
        if (b) {
            d = this.events[b] || [];
            for (e = []; a < d.length; a++)d[a] !== c && c &&
            e.push(d[a]);
            this.events[b] = e
        } else this.events = {};
        return this
    }
});
wysihtml5.lang.object = function (b) {
    return {
        merge: function (c) {
            for (var a in c)b[a] = c[a];
            return this
        }, get: function () {
            return b
        }, clone: function () {
            var c = {}, a;
            for (a in b)c[a] = b[a];
            return c
        }, isArray: function () {
            return "[object Array]" === Object.prototype.toString.call(b)
        }
    }
};
(function () {
    var b = /^\s+/, c = /\s+$/;
    wysihtml5.lang.string = function (a) {
        a = "" + a;
        return {
            trim: function () {
                return a.replace(b, "").replace(c, "")
            }, interpolate: function (b) {
                for (var c in b)a = this.replace("#{" + c + "}").by(b[c]);
                return a
            }, replace: function (b) {
                return {
                    by: function (c) {
                        return a.split(b).join(c)
                    }
                }
            }
        }
    }
})();
(function (b) {
    function c(a) {
        return a.replace(e, function (a, b) {
            var c = (b.match(f) || [])[1] || "", d = i[c], b = b.replace(f, "");
            b.split(d).length > b.split(c).length && (b += c, c = "");
            var e = d = b;
            b.length > g && (e = e.substr(0, g) + "...");
            "www." === d.substr(0, 4) && (d = "http://" + d);
            return '<a href="' + d + '">' + e + "</a>" + c
        })
    }

    function a(h) {
        if (!d.contains(h.nodeName))if (h.nodeType === b.TEXT_NODE && h.data.match(e)) {
            var f = h.parentNode, j;
            j = f.ownerDocument;
            var g = j._wysihtml5_tempElement;
            g || (g = j._wysihtml5_tempElement = j.createElement("div"));
            j =
                g;
            j.innerHTML = "<span></span>" + c(h.data);
            for (j.removeChild(j.firstChild); j.firstChild;)f.insertBefore(j.firstChild, h);
            f.removeChild(h)
        } else {
            f = b.lang.array(h.childNodes).get();
            j = f.length;
            for (g = 0; g < j; g++)a(f[g]);
            return h
        }
    }

    var d = b.lang.array("CODE PRE A SCRIPT HEAD TITLE STYLE".split(" ")), e = /((https?:\/\/|www\.)[^\s<]{3,})/gi, f = /([^\w\/\-](,?))$/i, g = 100, i = {
        ")": "(",
        "]": "[",
        "}": "{"
    };
    b.dom.autoLink = function (b) {
        var c;
        a:{
            c = b;
            for (var e; c.parentNode;) {
                c = c.parentNode;
                e = c.nodeName;
                if (d.contains(e)) {
                    c = !0;
                    break a
                }
                if ("body" ===
                    e)break
            }
            c = !1
        }
        if (c)return b;
        b === b.ownerDocument.documentElement && (b = b.ownerDocument.body);
        return a(b)
    };
    b.dom.autoLink.URL_REG_EXP = e
})(wysihtml5);
(function (b) {
    var c = b.browser.supportsClassList(), a = b.dom;
    a.addClass = function (b, e) {
        if (c)return b.classList.add(e);
        a.hasClass(b, e) || (b.className += " " + e)
    };
    a.removeClass = function (a, b) {
        if (c)return a.classList.remove(b);
        a.className = a.className.replace(RegExp("(^|\\s+)" + b + "(\\s+|$)"), " ")
    };
    a.hasClass = function (a, b) {
        if (c)return a.classList.contains(b);
        var f = a.className;
        return 0 < f.length && (f == b || RegExp("(^|\\s)" + b + "(\\s|$)").test(f))
    }
})(wysihtml5);
wysihtml5.dom.contains = function () {
    var b = document.documentElement;
    if (b.contains)return function (b, a) {
        a.nodeType !== wysihtml5.ELEMENT_NODE && (a = a.parentNode);
        return b !== a && b.contains(a)
    };
    if (b.compareDocumentPosition)return function (b, a) {
        return !!(b.compareDocumentPosition(a) & 16)
    }
}();
wysihtml5.dom.convertToList = function () {
    function b(b, a) {
        var d = b.createElement("li");
        a.appendChild(d);
        return d
    }

    return function (c, a) {
        if ("UL" === c.nodeName || "OL" === c.nodeName || "MENU" === c.nodeName)return c;
        var d = c.ownerDocument, e = d.createElement(a), f = c.querySelectorAll("br"), g = f.length, i, h, k, j, n;
        for (n = 0; n < g; n++)for (i = f[n]; (h = i.parentNode) && h !== c && h.lastChild === i;) {
            if ("block" === wysihtml5.dom.getStyle("display").from(h)) {
                h.removeChild(i);
                break
            }
            wysihtml5.dom.insert(i).after(i.parentNode)
        }
        f = wysihtml5.lang.array(c.childNodes).get();
        g = f.length;
        for (n = 0; n < g; n++)j = j || b(d, e), i = f[n], h = "block" === wysihtml5.dom.getStyle("display").from(i), k = "BR" === i.nodeName, h ? (j = j.firstChild ? b(d, e) : j, j.appendChild(i), j = null) : k ? j = j.firstChild ? null : j : j.appendChild(i);
        c.parentNode.replaceChild(e, c);
        return e
    }
}();
wysihtml5.dom.copyAttributes = function (b) {
    return {
        from: function (c) {
            return {
                to: function (a) {
                    for (var d, e = 0, f = b.length; e < f; e++)d = b[e], "undefined" !== typeof c[d] && "" !== c[d] && (a[d] = c[d]);
                    return {andTo: arguments.callee}
                }
            }
        }
    }
};
(function (b) {
    var c = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"], a = function (a) {
        var e;
        a:for (var f = 0, g = c.length; f < g; f++)if ("border-box" === b.getStyle(c[f]).from(a)) {
            e = c[f];
            break a
        }
        return e ? parseInt(b.getStyle("width").from(a), 10) < a.offsetWidth : !1
    };
    b.copyStyles = function (d) {
        return {
            from: function (e) {
                a(e) && (d = wysihtml5.lang.array(d).without(c));
                for (var f = "", g = d.length, i = 0, h; i < g; i++)h = d[i], f += h + ":" + b.getStyle(h).from(e) + ";";
                return {
                    to: function (a) {
                        b.setStyles(f).on(a);
                        return {andTo: arguments.callee}
                    }
                }
            }
        }
    }
})(wysihtml5.dom);
(function (b) {
    b.dom.delegate = function (c, a, d, e) {
        return b.dom.observe(c, d, function (d) {
            for (var g = d.target, i = b.lang.array(c.querySelectorAll(a)); g && g !== c;) {
                if (i.contains(g)) {
                    e.call(g, d);
                    break
                }
                g = g.parentNode
            }
        })
    }
})(wysihtml5);
wysihtml5.dom.getAsDom = function () {
    var b = "abbr article aside audio bdi canvas command datalist details figcaption figure footer header hgroup keygen mark meter nav output progress rp rt ruby svg section source summary time track video wbr".split(" ");
    return function (c, a) {
        var a = a || document, d;
        if ("object" === typeof c && c.nodeType)d = a.createElement("div"), d.appendChild(c); else if (wysihtml5.browser.supportsHTML5Tags(a))d = a.createElement("div"), d.innerHTML = c; else {
            d = a;
            if (!d._wysihtml5_supportsHTML5Tags) {
                for (var e =
                    0, f = b.length; e < f; e++)d.createElement(b[e]);
                d._wysihtml5_supportsHTML5Tags = !0
            }
            d = a;
            e = d.createElement("div");
            e.style.display = "none";
            d.body.appendChild(e);
            try {
                e.innerHTML = c
            } catch (g) {
            }
            d.body.removeChild(e);
            d = e
        }
        return d
    }
}();
wysihtml5.dom.getParentElement = function () {
    function b(b, a) {
        return !a || !a.length ? !0 : "string" === typeof a ? b === a : wysihtml5.lang.array(a).contains(b)
    }

    return function (c, a, d) {
        d = d || 50;
        if (a.className || a.classRegExp) {
            a:{
                for (var e = a.nodeName, f = a.className, a = a.classRegExp; d-- && c && "BODY" !== c.nodeName;) {
                    var g;
                    if (g = c.nodeType === wysihtml5.ELEMENT_NODE)if (g = b(c.nodeName, e)) {
                        g = f;
                        var i = (c.className || "").match(a) || [];
                        g = !g ? !!i.length : i[i.length - 1] === g
                    }
                    if (g)break a;
                    c = c.parentNode
                }
                c = null
            }
            return c
        }
        a:{
            e = a.nodeName;
            for (f = d; f-- &&
            c && "BODY" !== c.nodeName;) {
                if (b(c.nodeName, e))break a;
                c = c.parentNode
            }
            c = null
        }
        return c
    }
}();
wysihtml5.dom.getStyle = function () {
    function b(b) {
        return b.replace(a, function (a) {
            return a.charAt(1).toUpperCase()
        })
    }

    var c = {"float": "styleFloat"in document.createElement("div").style ? "styleFloat" : "cssFloat"}, a = /\-[a-z]/g;
    return function (a) {
        return {
            from: function (e) {
                if (e.nodeType === wysihtml5.ELEMENT_NODE) {
                    var f = e.ownerDocument, g = c[a] || b(a), i = e.style, h = e.currentStyle, k = i[g];
                    if (k)return k;
                    if (h)try {
                        return h[g]
                    } catch (j) {
                    }
                    var g = f.defaultView || f.parentWindow, f = ("height" === a || "width" === a) && "TEXTAREA" === e.nodeName,
                        n;
                    if (g.getComputedStyle)return f && (n = i.overflow, i.overflow = "hidden"), e = g.getComputedStyle(e, null).getPropertyValue(a), f && (i.overflow = n || ""), e
                }
            }
        }
    }
}();
wysihtml5.dom.hasElementWithTagName = function () {
    var b = {}, c = 1;
    return function (a, d) {
        var e = (a._wysihtml5_identifier || (a._wysihtml5_identifier = c++)) + ":" + d, f = b[e];
        f || (f = b[e] = a.getElementsByTagName(d));
        return 0 < f.length
    }
}();
(function (b) {
    var c = {}, a = 1;
    b.dom.hasElementWithClassName = function (d, e) {
        if (!b.browser.supportsNativeGetElementsByClassName())return !!d.querySelector("." + e);
        var f = (d._wysihtml5_identifier || (d._wysihtml5_identifier = a++)) + ":" + e, g = c[f];
        g || (g = c[f] = d.getElementsByClassName(e));
        return 0 < g.length
    }
})(wysihtml5);
wysihtml5.dom.insert = function (b) {
    return {
        after: function (c) {
            c.parentNode.insertBefore(b, c.nextSibling)
        }, before: function (c) {
            c.parentNode.insertBefore(b, c)
        }, into: function (c) {
            c.appendChild(b)
        }
    }
};
wysihtml5.dom.insertCSS = function (b) {
    b = b.join("\n");
    return {
        into: function (c) {
            var a = c.head || c.getElementsByTagName("head")[0], d = c.createElement("style");
            d.type = "text/css";
            d.styleSheet ? d.styleSheet.cssText = b : d.appendChild(c.createTextNode(b));
            a && a.appendChild(d)
        }
    }
};
wysihtml5.dom.observe = function (b, c, a) {
    for (var c = "string" === typeof c ? [c] : c, d, e, f = 0, g = c.length; f < g; f++)e = c[f], b.addEventListener ? b.addEventListener(e, a, !1) : (d = function (c) {
        "target"in c || (c.target = c.srcElement);
        c.preventDefault = c.preventDefault || function () {
                this.returnValue = false
            };
        c.stopPropagation = c.stopPropagation || function () {
                this.cancelBubble = true
            };
        a.call(b, c)
    }, b.attachEvent("on" + e, d));
    return {
        stop: function () {
            for (var e, h = 0, f = c.length; h < f; h++)e = c[h], b.removeEventListener ? b.removeEventListener(e, a, !1) :
                b.detachEvent("on" + e, d)
        }
    }
};
wysihtml5.dom.parse = function () {
    function b(c, e) {
        var h = c.childNodes, f = h.length, g;
        g = a[c.nodeType];
        var k = 0;
        g = g && g(c);
        if (!g)return null;
        for (k = 0; k < f; k++)(newChild = b(h[k], e)) && g.appendChild(newChild);
        return e && 1 >= g.childNodes.length && g.nodeName.toLowerCase() === d && !g.attributes.length ? g.firstChild : g
    }

    function c(a, b) {
        var b = b.toLowerCase(), c;
        if (c = "IMG" == a.nodeName)if (c = "src" == b) {
            var d;
            try {
                d = a.complete && !a.mozMatchesSelector(":-moz-broken")
            } catch (e) {
                a.complete && "complete" === a.readyState && (d = !0)
            }
            c = !0 === d
        }
        return c ?
            a.src : i && "outerHTML"in a ? -1 != a.outerHTML.toLowerCase().indexOf(" " + b + "=") ? a.getAttribute(b) : null : a.getAttribute(b)
    }

    var a = {
            1: function (a) {
                var b, f, i = g.tags;
                f = a.nodeName.toLowerCase();
                b = a.scopeName;
                if (a._wysihtml5)return null;
                a._wysihtml5 = 1;
                if ("wysihtml5-temp" === a.className)return null;
                b && "HTML" != b && (f = b + ":" + f);
                "outerHTML"in a && !wysihtml5.browser.autoClosesUnclosedTags() && ("P" === a.nodeName && "</p>" !== a.outerHTML.slice(-4).toLowerCase()) && (f = "div");
                if (f in i) {
                    b = i[f];
                    if (!b || b.remove)return null;
                    b = "string" === typeof b ? {rename_tag: b} : b
                } else if (a.firstChild)b = {rename_tag: d}; else return null;
                f = a.ownerDocument.createElement(b.rename_tag || f);
                var i = {}, r = b.set_class, m = b.add_class, s = b.set_attributes, x = b.check_attributes, o = g.classes, z = 0, w = [];
                b = [];
                var y = [], A = [], t;
                s && (i = wysihtml5.lang.object(s).clone());
                if (x)for (t in x)if (s = h[x[t]])s = s(c(a, t)), "string" === typeof s && (i[t] = s);
                r && w.push(r);
                if (m)for (t in m)if (s = k[m[t]])r = s(c(a, t)), "string" === typeof r && w.push(r);
                o["_wysihtml5-temp-placeholder"] = 1;
                (A = a.getAttribute("class")) &&
                (w = w.concat(A.split(e)));
                for (m = w.length; z < m; z++)a = w[z], o[a] && b.push(a);
                for (o = b.length; o--;)a = b[o], wysihtml5.lang.array(y).contains(a) || y.unshift(a);
                y.length && (i["class"] = y.join(" "));
                for (t in i)try {
                    f.setAttribute(t, i[t])
                } catch (v) {
                }
                i.src && ("undefined" !== typeof i.width && f.setAttribute("width", i.width), "undefined" !== typeof i.height && f.setAttribute("height", i.height));
                return f
            }, 3: function (a) {
                return a.ownerDocument.createTextNode(a.data)
            }
        }, d = "span", e = /\s+/, f = {
            tags: {},
            classes: {}
        }, g = {}, i = !wysihtml5.browser.supportsGetAttributeCorrectly(),
        h = {
            url: function () {
                var a = /^https?:\/\//i;
                return function (b) {
                    return !b || !b.match(a) ? null : b.replace(a, function (a) {
                        return a.toLowerCase()
                    })
                }
            }(), alt: function () {
                var a = /[^ a-z0-9_\-]/gi;
                return function (b) {
                    return !b ? "" : b.replace(a, "")
                }
            }(), numbers: function () {
                var a = /\D/g;
                return function (b) {
                    return (b = (b || "").replace(a, "")) || null
                }
            }()
        }, k = {
            align_img: function () {
                var a = {left: "wysiwyg-float-left", right: "wysiwyg-float-right"};
                return function (b) {
                    return a[("" + b).toLowerCase()]
                }
            }(), align_text: function () {
                var a = {
                    left: "wysiwyg-text-align-left",
                    right: "wysiwyg-text-align-right",
                    center: "wysiwyg-text-align-center",
                    justify: "wysiwyg-text-align-justify"
                };
                return function (b) {
                    return a[("" + b).toLowerCase()]
                }
            }(), clear_br: function () {
                var a = {
                    left: "wysiwyg-clear-left",
                    right: "wysiwyg-clear-right",
                    both: "wysiwyg-clear-both",
                    all: "wysiwyg-clear-both"
                };
                return function (b) {
                    return a[("" + b).toLowerCase()]
                }
            }(), size_font: function () {
                var a = {
                    1: "wysiwyg-font-size-xx-small",
                    2: "wysiwyg-font-size-small",
                    3: "wysiwyg-font-size-medium",
                    4: "wysiwyg-font-size-large",
                    5: "wysiwyg-font-size-x-large",
                    6: "wysiwyg-font-size-xx-large",
                    7: "wysiwyg-font-size-xx-large",
                    "-": "wysiwyg-font-size-smaller",
                    "+": "wysiwyg-font-size-larger"
                };
                return function (b) {
                    return a[("" + b).charAt(0)]
                }
            }()
        };
    return function (a, c, d, e) {
        wysihtml5.lang.object(g).merge(f).merge(c).get();
        for (var d = d || a.ownerDocument || document, c = d.createDocumentFragment(), h = "string" === typeof a, a = h ? wysihtml5.dom.getAsDom(a, d) : a; a.firstChild;)d = a.firstChild, a.removeChild(d), (d = b(d, e)) && c.appendChild(d);
        a.innerHTML = "";
        a.appendChild(c);
        return h ? wysihtml5.quirks.getCorrectInnerHTML(a) :
            a
    }
}();
wysihtml5.dom.removeEmptyTextNodes = function (b) {
    for (var c = wysihtml5.lang.array(b.childNodes).get(), a = c.length, d = 0; d < a; d++)b = c[d], b.nodeType === wysihtml5.TEXT_NODE && "" === b.data && b.parentNode.removeChild(b)
};
wysihtml5.dom.renameElement = function (b, c) {
    for (var a = b.ownerDocument.createElement(c), d; d = b.firstChild;)a.appendChild(d);
    wysihtml5.dom.copyAttributes(["align", "className"]).from(b).to(a);
    b.parentNode.replaceChild(a, b);
    return a
};
wysihtml5.dom.replaceWithChildNodes = function (b) {
    if (b.parentNode)if (b.firstChild) {
        for (var c = b.ownerDocument.createDocumentFragment(); b.firstChild;)c.appendChild(b.firstChild);
        b.parentNode.replaceChild(c, b)
    } else b.parentNode.removeChild(b)
};
(function (b) {
    function c(a) {
        var b = a.ownerDocument.createElement("br");
        a.appendChild(b)
    }

    b.resolveList = function (a) {
        if (!("MENU" !== a.nodeName && "UL" !== a.nodeName && "OL" !== a.nodeName)) {
            var d = a.ownerDocument.createDocumentFragment(), e = a.previousElementSibling || a.previousSibling, f, g, i;
            for (e && "block" !== b.getStyle("display").from(e) && c(d); i = a.firstChild;) {
                for (f = i.lastChild; e = i.firstChild;)g = (g = e === f) && "block" !== b.getStyle("display").from(e) && "BR" !== e.nodeName, d.appendChild(e), g && c(d);
                i.parentNode.removeChild(i)
            }
            a.parentNode.replaceChild(d,
                a)
        }
    }
})(wysihtml5.dom);
(function (b) {
    var c = document, a = "parent top opener frameElement frames localStorage globalStorage sessionStorage indexedDB".split(" "), d = "open close openDialog showModalDialog alert confirm prompt openDatabase postMessage XMLHttpRequest XDomainRequest".split(" "), e = ["referrer", "write", "open", "close"];
    b.dom.Sandbox = Base.extend({
        constructor: function (a, c) {
            this.callback = a || b.EMPTY_FUNCTION;
            this.config = b.lang.object({}).merge(c).get();
            this.iframe = this._createIframe()
        }, insertInto: function (a) {
            "string" === typeof a &&
            (a = c.getElementById(a));
            a.appendChild(this.iframe)
        }, getIframe: function () {
            return this.iframe
        }, getWindow: function () {
            this._readyError()
        }, getDocument: function () {
            this._readyError()
        }, destroy: function () {
            var a = this.getIframe();
            a.parentNode.removeChild(a)
        }, _readyError: function () {
            throw Error("wysihtml5.Sandbox: Sandbox iframe isn't loaded yet");
        }, _createIframe: function () {
            var a = this, d = c.createElement("iframe");
            d.className = "wysihtml5-sandbox";
            b.dom.setAttributes({
                security: "restricted", allowtransparency: "true",
                frameborder: 0, width: 0, height: 0, marginwidth: 0, marginheight: 0
            }).on(d);
            b.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty() && (d.src = "javascript:'<html></html>'");
            d.onload = function () {
                d.onreadystatechange = d.onload = null;
                a._onLoadIframe(d)
            };
            d.onreadystatechange = function () {
                if (/loaded|complete/.test(d.readyState)) {
                    d.onreadystatechange = d.onload = null;
                    a._onLoadIframe(d)
                }
            };
            return d
        }, _onLoadIframe: function (f) {
            if (b.dom.contains(c.documentElement, f)) {
                var g = this, i = f.contentWindow, h = f.contentWindow.document, k =
                    this._getHtml({
                        charset: c.characterSet || c.charset || "utf-8",
                        stylesheets: this.config.stylesheets
                    });
                h.open("text/html", "replace");
                h.write(k);
                h.close();
                this.getWindow = function () {
                    return f.contentWindow
                };
                this.getDocument = function () {
                    return f.contentWindow.document
                };
                i.onerror = function (a, b, c) {
                    throw Error("wysihtml5.Sandbox: " + a, b, c);
                };
                if (!b.browser.supportsSandboxedIframes()) {
                    var j, k = 0;
                    for (j = a.length; k < j; k++)this._unset(i, a[k]);
                    k = 0;
                    for (j = d.length; k < j; k++)this._unset(i, d[k], b.EMPTY_FUNCTION);
                    k = 0;
                    for (j = e.length; k <
                    j; k++)this._unset(h, e[k]);
                    this._unset(h, "cookie", "", !0)
                }
                this.loaded = !0;
                setTimeout(function () {
                    g.callback(g)
                }, 0)
            }
        }, _getHtml: function (a) {
            var c = a.stylesheets, d = "", e = 0, k;
            if (c = "string" === typeof c ? [c] : c)for (k = c.length; e < k; e++)d += '<link rel="stylesheet" href="' + c[e] + '">';
            a.stylesheets = d;
            return b.lang.string('<!DOCTYPE html><html><head><meta charset="#{charset}">#{stylesheets}</head><body></body></html>').interpolate(a)
        }, _unset: function (a, c, d, e) {
            try {
                a[c] = d
            } catch (k) {
            }
            try {
                a.__defineGetter__(c, function () {
                    return d
                })
            } catch (j) {
            }
            if (e)try {
                a.__defineSetter__(c,
                    function () {
                    })
            } catch (n) {
            }
            if (!b.browser.crashesWhenDefineProperty(c))try {
                var p = {
                    get: function () {
                        return d
                    }
                };
                e && (p.set = function () {
                });
                Object.defineProperty(a, c, p)
            } catch (q) {
            }
        }
    })
})(wysihtml5);
(function () {
    var b = {className: "class"};
    wysihtml5.dom.setAttributes = function (c) {
        return {
            on: function (a) {
                for (var d in c)a.setAttribute(b[d] || d, c[d])
            }
        }
    }
})();
wysihtml5.dom.setStyles = function (b) {
    return {
        on: function (c) {
            c = c.style;
            if ("string" === typeof b)c.cssText += ";" + b; else for (var a in b)"float" === a ? (c.cssFloat = b[a], c.styleFloat = b[a]) : c[a] = b[a]
        }
    }
};
(function (b) {
    b.simulatePlaceholder = function (c, a, d) {
        var e = function () {
            a.hasPlaceholderSet() && a.clear();
            b.removeClass(a.element, "placeholder")
        }, f = function () {
            a.isEmpty() && (a.setValue(d), b.addClass(a.element, "placeholder"))
        };
        c.observe("set_placeholder", f).observe("unset_placeholder", e).observe("focus:composer", e).observe("paste:composer", e).observe("blur:composer", f);
        f()
    }
})(wysihtml5.dom);
(function (b) {
    var c = document.documentElement;
    "textContent"in c ? (b.setTextContent = function (a, b) {
        a.textContent = b
    }, b.getTextContent = function (a) {
        return a.textContent
    }) : "innerText"in c ? (b.setTextContent = function (a, b) {
        a.innerText = b
    }, b.getTextContent = function (a) {
        return a.innerText
    }) : (b.setTextContent = function (a, b) {
        a.nodeValue = b
    }, b.getTextContent = function (a) {
        return a.nodeValue
    })
})(wysihtml5.dom);
wysihtml5.quirks.cleanPastedHTML = function () {
    var b = {"a u": wysihtml5.dom.replaceWithChildNodes};
    return function (c, a, d) {
        var a = a || b, d = d || c.ownerDocument || document, e = "string" === typeof c, f, g, i, h = 0, c = e ? wysihtml5.dom.getAsDom(c, d) : c;
        for (i in a) {
            f = c.querySelectorAll(i);
            d = a[i];
            for (g = f.length; h < g; h++)d(f[h])
        }
        return e ? c.innerHTML : c
    }
}();
(function (b) {
    var c = b.dom;
    b.quirks.ensureProperClearing = function () {
        var a = function () {
            var a = this;
            setTimeout(function () {
                var b = a.innerHTML.toLowerCase();
                if ("<p>&nbsp;</p>" == b || "<p>&nbsp;</p><p>&nbsp;</p>" == b)a.innerHTML = ""
            }, 0)
        };
        return function (b) {
            c.observe(b.element, ["cut", "keydown"], a)
        }
    }();
    b.quirks.ensureProperClearingOfLists = function () {
        var a = ["OL", "UL", "MENU"];
        return function (d) {
            c.observe(d.element, "keydown", function (e) {
                if (e.keyCode === b.BACKSPACE_KEY) {
                    var f = d.selection.getSelectedNode(), e = d.element;
                    e.firstChild && b.lang.array(a).contains(e.firstChild.nodeName) && (f = c.getParentElement(f, {nodeName: a})) && f == e.firstChild && 1 >= f.childNodes.length && (f.firstChild ? "" === f.firstChild.innerHTML : 1) && f.parentNode.removeChild(f)
                }
            })
        }
    }()
})(wysihtml5);
(function (b) {
    b.quirks.getCorrectInnerHTML = function (c) {
        var a = c.innerHTML;
        if (-1 === a.indexOf("%7E"))return a;
        var c = c.querySelectorAll("[href*='~'], [src*='~']"), d, e, f, g;
        g = 0;
        for (f = c.length; g < f; g++)d = c[g].href || c[g].src, e = b.lang.string(d).replace("~").by("%7E"), a = b.lang.string(a).replace(e).by(d);
        return a
    }
})(wysihtml5);
(function (b) {
    var c = b.dom, a = "LI P H1 H2 H3 H4 H5 H6".split(" "), d = ["UL", "OL", "MENU"];
    b.quirks.insertLineBreakOnReturn = function (e) {
        function f(a) {
            if (a = c.getParentElement(a, {nodeName: ["P", "DIV"]}, 2)) {
                var d = document.createTextNode(b.INVISIBLE_SPACE);
                c.insert(d).before(a);
                c.replaceWithChildNodes(a);
                e.selection.selectNode(d)
            }
        }

        c.observe(e.element.ownerDocument, "keydown", function (g) {
            var i = g.keyCode;
            if (!(g.shiftKey || i !== b.ENTER_KEY && i !== b.BACKSPACE_KEY)) {
                var h = e.selection.getSelectedNode();
                (h = c.getParentElement(h,
                    {nodeName: a}, 4)) ? "LI" === h.nodeName && (i === b.ENTER_KEY || i === b.BACKSPACE_KEY) ? setTimeout(function () {
                    var a = e.selection.getSelectedNode(), b;
                    a && ((b = c.getParentElement(a, {nodeName: d}, 2)) || f(a))
                }, 0) : h.nodeName.match(/H[1-6]/) && i === b.ENTER_KEY && setTimeout(function () {
                    f(e.selection.getSelectedNode())
                }, 0) : i === b.ENTER_KEY && !b.browser.insertsLineBreaksOnReturn() && (e.commands.exec("insertLineBreak"), g.preventDefault())
            }
        })
    }
})(wysihtml5);
(function (b) {
    b.quirks.redraw = function (c) {
        b.dom.addClass(c, "wysihtml5-quirks-redraw");
        b.dom.removeClass(c, "wysihtml5-quirks-redraw");
        try {
            var a = c.ownerDocument;
            a.execCommand("italic", !1, null);
            a.execCommand("italic", !1, null)
        } catch (d) {
        }
    }
})(wysihtml5);
(function (b) {
    var c = b.dom;
    b.Selection = Base.extend({
        constructor: function (a) {
            window.rangy.init();
            this.editor = a;
            this.composer = a.composer;
            this.doc = this.composer.doc
        }, getBookmark: function () {
            var a = this.getRange();
            return a && a.cloneRange()
        }, setBookmark: function (a) {
            a && this.setSelection(a)
        }, setBefore: function (a) {
            var b = rangy.createRange(this.doc);
            b.setStartBefore(a);
            b.setEndBefore(a);
            return this.setSelection(b)
        }, setAfter: function (a) {
            var b = rangy.createRange(this.doc);
            b.setStartAfter(a);
            b.setEndAfter(a);
            return this.setSelection(b)
        },
        selectNode: function (a) {
            var d = rangy.createRange(this.doc), e = a.nodeType === b.ELEMENT_NODE, f = "canHaveHTML"in a ? a.canHaveHTML : "IMG" !== a.nodeName, g = e ? a.innerHTML : a.data, g = "" === g || g === b.INVISIBLE_SPACE, i = c.getStyle("display").from(a), i = "block" === i || "list-item" === i;
            if (g && e && f)try {
                a.innerHTML = b.INVISIBLE_SPACE
            } catch (h) {
            }
            f ? d.selectNodeContents(a) : d.selectNode(a);
            f && g && e ? d.collapse(i) : f && g && (d.setStartAfter(a), d.setEndAfter(a));
            this.setSelection(d)
        }, getSelectedNode: function (a) {
            if (a && this.doc.selection && "Control" ===
                this.doc.selection.type && (a = this.doc.selection.createRange()) && a.length)return a.item(0);
            a = this.getSelection(this.doc);
            return a.focusNode === a.anchorNode ? a.focusNode : (a = this.getRange(this.doc)) ? a.commonAncestorContainer : this.doc.body
        }, executeAndRestore: function (a, c) {
            var e = this.doc.body, f = c && e.scrollTop, g = c && e.scrollLeft, i = '<span class="_wysihtml5-temp-placeholder">' + b.INVISIBLE_SPACE + "</span>", h = this.getRange(this.doc);
            if (h) {
                i = h.createContextualFragment(i);
                h.insertNode(i);
                try {
                    a(h.startContainer, h.endContainer)
                } catch (k) {
                    setTimeout(function () {
                        throw k;
                    }, 0)
                }
                (caretPlaceholder = this.doc.querySelector("._wysihtml5-temp-placeholder")) ? (h = rangy.createRange(this.doc), h.selectNode(caretPlaceholder), h.deleteContents(), this.setSelection(h)) : e.focus();
                c && (e.scrollTop = f, e.scrollLeft = g);
                try {
                    caretPlaceholder.parentNode.removeChild(caretPlaceholder)
                } catch (j) {
                }
            } else a(e, e)
        }, executeAndRestoreSimple: function (a) {
            var b, c, f = this.getRange(), g = this.doc.body, i;
            if (f) {
                b = f.getNodes([3]);
                g = b[0] || f.startContainer;
                i = b[b.length - 1] || f.endContainer;
                b = g === f.startContainer ? f.startOffset :
                    0;
                c = i === f.endContainer ? f.endOffset : i.length;
                try {
                    a(f.startContainer, f.endContainer)
                } catch (h) {
                    setTimeout(function () {
                        throw h;
                    }, 0)
                }
                a = rangy.createRange(this.doc);
                try {
                    a.setStart(g, b)
                } catch (k) {
                }
                try {
                    a.setEnd(i, c)
                } catch (j) {
                }
                try {
                    this.setSelection(a)
                } catch (n) {
                }
            } else a(g, g)
        }, insertHTML: function (a) {
            var a = rangy.createRange(this.doc).createContextualFragment(a), b = a.lastChild;
            this.insertNode(a);
            b && this.setAfter(b)
        }, insertNode: function (a) {
            var b = this.getRange();
            b && b.insertNode(a)
        }, surround: function (a) {
            var b = this.getRange();
            if (b)try {
                b.surroundContents(a), this.selectNode(a)
            } catch (c) {
                a.appendChild(b.extractContents()), b.insertNode(a)
            }
        }, scrollIntoView: function () {
            var a = this.doc, c = a.documentElement.scrollHeight > a.documentElement.offsetHeight, e;
            if (!(e = a._wysihtml5ScrollIntoViewElement))e = a.createElement("span"), e.innerHTML = b.INVISIBLE_SPACE;
            e = a._wysihtml5ScrollIntoViewElement = e;
            if (c) {
                this.insertNode(e);
                var c = e, f = 0;
                if (c.parentNode) {
                    do f += c.offsetTop || 0, c = c.offsetParent; while (c)
                }
                c = f;
                e.parentNode.removeChild(e);
                c > a.body.scrollTop &&
                (a.body.scrollTop = c)
            }
        }, selectLine: function () {
            b.browser.supportsSelectionModify() ? this._selectLine_W3C() : this.doc.selection && this._selectLine_MSIE()
        }, _selectLine_W3C: function () {
            var a = this.doc.defaultView.getSelection();
            a.modify("extend", "left", "lineboundary");
            a.modify("extend", "right", "lineboundary")
        }, _selectLine_MSIE: function () {
            var a = this.doc.selection.createRange(), b = a.boundingTop, c = this.doc.body.scrollWidth, f;
            if (a.moveToPoint) {
                0 === b && (f = this.doc.createElement("span"), this.insertNode(f), b = f.offsetTop,
                    f.parentNode.removeChild(f));
                b += 1;
                for (f = -10; f < c; f += 2)try {
                    a.moveToPoint(f, b);
                    break
                } catch (g) {
                }
                for (f = this.doc.selection.createRange(); 0 <= c; c--)try {
                    f.moveToPoint(c, b);
                    break
                } catch (i) {
                }
                a.setEndPoint("EndToEnd", f);
                a.select()
            }
        }, getText: function () {
            var a = this.getSelection();
            return a ? a.toString() : ""
        }, getNodes: function (a, b) {
            var c = this.getRange();
            return c ? c.getNodes([a], b) : []
        }, getRange: function () {
            var a = this.getSelection();
            return a && a.rangeCount && a.getRangeAt(0)
        }, getSelection: function () {
            return rangy.getSelection(this.doc.defaultView ||
                this.doc.parentWindow)
        }, setSelection: function (a) {
            return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow).setSingleRange(a)
        }
    })
})(wysihtml5);
(function (b, c) {
    function a(a, b) {
        return c.dom.isCharacterDataNode(a) ? 0 == b ? !!a.previousSibling : b == a.length ? !!a.nextSibling : !0 : 0 < b && b < a.childNodes.length
    }

    function d(a, b, e) {
        var f;
        c.dom.isCharacterDataNode(b) && (0 == e ? (e = c.dom.getNodeIndex(b), b = b.parentNode) : e == b.length ? (e = c.dom.getNodeIndex(b) + 1, b = b.parentNode) : f = c.dom.splitDataNode(b, e));
        if (!f) {
            f = b.cloneNode(!1);
            f.id && f.removeAttribute("id");
            for (var g; g = b.childNodes[e];)f.appendChild(g);
            c.dom.insertAfter(f, b)
        }
        return b == a ? f : d(a, f.parentNode, c.dom.getNodeIndex(f))
    }

    function e(a) {
        this.firstTextNode = (this.isElementMerge = a.nodeType == b.ELEMENT_NODE) ? a.lastChild : a;
        this.textNodes = [this.firstTextNode]
    }

    function f(a, b, c, d) {
        this.tagNames = a || [g];
        this.cssClass = b || "";
        this.similarClassRegExp = c;
        this.normalize = d;
        this.applyToAnyTagName = !1
    }

    var g = "span", i = /\s+/g;
    e.prototype = {
        doMerge: function () {
            for (var a = [], b, c, d = 0, e = this.textNodes.length; d < e; ++d)b = this.textNodes[d], c = b.parentNode, a[d] = b.data, d && (c.removeChild(b), c.hasChildNodes() || c.parentNode.removeChild(c));
            return this.firstTextNode.data =
                a = a.join("")
        }, getLength: function () {
            for (var a = this.textNodes.length, b = 0; a--;)b += this.textNodes[a].length;
            return b
        }, toString: function () {
            for (var a = [], b = 0, c = this.textNodes.length; b < c; ++b)a[b] = "'" + this.textNodes[b].data + "'";
            return "[Merge(" + a.join(",") + ")]"
        }
    };
    f.prototype = {
        getAncestorWithClass: function (a) {
            for (var d; a;) {
                if (this.cssClass)if (d = this.cssClass, a.className) {
                    var e = a.className.match(this.similarClassRegExp) || [];
                    d = e[e.length - 1] === d
                } else d = !1; else d = !0;
                if (a.nodeType == b.ELEMENT_NODE && c.dom.arrayContains(this.tagNames,
                        a.tagName.toLowerCase()) && d)return a;
                a = a.parentNode
            }
            return !1
        }, postApply: function (a, b) {
            for (var c = a[0], d = a[a.length - 1], f = [], g, i = c, m = d, s = 0, x = d.length, o, z, w = 0, y = a.length; w < y; ++w)if (o = a[w], z = this.getAdjacentMergeableTextNode(o.parentNode, !1)) {
                if (g || (g = new e(z), f.push(g)), g.textNodes.push(o), o === c && (i = g.firstTextNode, s = i.length), o === d)m = g.firstTextNode, x = g.getLength()
            } else g = null;
            if (c = this.getAdjacentMergeableTextNode(d.parentNode, !0))g || (g = new e(d), f.push(g)), g.textNodes.push(c);
            if (f.length) {
                w = 0;
                for (y =
                         f.length; w < y; ++w)f[w].doMerge();
                b.setStart(i, s);
                b.setEnd(m, x)
            }
        }, getAdjacentMergeableTextNode: function (a, c) {
            var d = a.nodeType == b.TEXT_NODE, e = d ? a.parentNode : a, f = c ? "nextSibling" : "previousSibling";
            if (d) {
                if ((d = a[f]) && d.nodeType == b.TEXT_NODE)return d
            } else if ((d = e[f]) && this.areElementsMergeable(a, d))return d[c ? "firstChild" : "lastChild"];
            return null
        }, areElementsMergeable: function (a, b) {
            var d;
            if (d = c.dom.arrayContains(this.tagNames, (a.tagName || "").toLowerCase()))if (d = c.dom.arrayContains(this.tagNames, (b.tagName ||
                "").toLowerCase()))if (d = a.className.replace(i, " ") == b.className.replace(i, " "))a:if (a.attributes.length != b.attributes.length)d = !1; else {
                d = 0;
                for (var e = a.attributes.length, f, g; d < e; ++d)if (f = a.attributes[d], g = f.name, "class" != g && (g = b.attributes.getNamedItem(g), f.specified != g.specified || f.specified && f.nodeValue !== g.nodeValue)) {
                    d = !1;
                    break a
                }
                d = !0
            }
            return d
        }, createContainer: function (a) {
            a = a.createElement(this.tagNames[0]);
            this.cssClass && (a.className = this.cssClass);
            return a
        }, applyToTextNode: function (a) {
            var b =
                a.parentNode;
            1 == b.childNodes.length && c.dom.arrayContains(this.tagNames, b.tagName.toLowerCase()) ? this.cssClass && (a = this.cssClass, b.className ? (b.className && (b.className = b.className.replace(this.similarClassRegExp, "")), b.className += " " + a) : b.className = a) : (b = this.createContainer(c.dom.getDocument(a)), a.parentNode.insertBefore(b, a), b.appendChild(a))
        }, isRemovable: function (a) {
            return c.dom.arrayContains(this.tagNames, a.tagName.toLowerCase()) && b.lang.string(a.className).trim() == this.cssClass
        }, undoToTextNode: function (b,
                                     c, e) {
            c.containsNode(e) || (b = c.cloneRange(), b.selectNode(e), b.isPointInRange(c.endContainer, c.endOffset) && a(c.endContainer, c.endOffset) && (d(e, c.endContainer, c.endOffset), c.setEndAfter(e)), b.isPointInRange(c.startContainer, c.startOffset) && a(c.startContainer, c.startOffset) && (e = d(e, c.startContainer, c.startOffset)));
            this.similarClassRegExp && e.className && (e.className = e.className.replace(this.similarClassRegExp, ""));
            if (this.isRemovable(e)) {
                c = e;
                for (e = c.parentNode; c.firstChild;)e.insertBefore(c.firstChild,
                    c);
                e.removeChild(c)
            }
        }, applyToRange: function (a) {
            var c = a.getNodes([b.TEXT_NODE]);
            if (!c.length)try {
                var d = this.createContainer(a.endContainer.ownerDocument);
                a.surroundContents(d);
                this.selectNode(a, d);
                return
            } catch (e) {
            }
            a.splitBoundaries();
            c = a.getNodes([b.TEXT_NODE]);
            if (c.length) {
                for (var f = 0, g = c.length; f < g; ++f)d = c[f], this.getAncestorWithClass(d) || this.applyToTextNode(d);
                a.setStart(c[0], 0);
                d = c[c.length - 1];
                a.setEnd(d, d.length);
                this.normalize && this.postApply(c, a)
            }
        }, undoToRange: function (a) {
            var c = a.getNodes([b.TEXT_NODE]),
                d, e;
            c.length ? (a.splitBoundaries(), c = a.getNodes([b.TEXT_NODE])) : (c = a.endContainer.ownerDocument.createTextNode(b.INVISIBLE_SPACE), a.insertNode(c), a.selectNode(c), c = [c]);
            for (var f = 0, g = c.length; f < g; ++f)d = c[f], (e = this.getAncestorWithClass(d)) && this.undoToTextNode(d, a, e);
            1 == g ? this.selectNode(a, c[0]) : (a.setStart(c[0], 0), d = c[c.length - 1], a.setEnd(d, d.length), this.normalize && this.postApply(c, a))
        }, selectNode: function (a, c) {
            var d = c.nodeType === b.ELEMENT_NODE, e = "canHaveHTML"in c ? c.canHaveHTML : !0, f = d ? c.innerHTML :
                c.data;
            if ((f = "" === f || f === b.INVISIBLE_SPACE) && d && e)try {
                c.innerHTML = b.INVISIBLE_SPACE
            } catch (g) {
            }
            a.selectNodeContents(c);
            f && d ? a.collapse(!1) : f && (a.setStartAfter(c), a.setEndAfter(c))
        }, getTextSelectedByRange: function (a, b) {
            var c = b.cloneRange();
            c.selectNodeContents(a);
            var d = c.intersection(b), d = d ? d.toString() : "";
            c.detach();
            return d
        }, isAppliedToRange: function (a) {
            var c = [], d, e = a.getNodes([b.TEXT_NODE]);
            if (!e.length)return (d = this.getAncestorWithClass(a.startContainer)) ? [d] : !1;
            for (var f = 0, g = e.length, i; f < g; ++f) {
                i =
                    this.getTextSelectedByRange(e[f], a);
                d = this.getAncestorWithClass(e[f]);
                if ("" != i && !d)return !1;
                c.push(d)
            }
            return c
        }, toggleRange: function (a) {
            this.isAppliedToRange(a) ? this.undoToRange(a) : this.applyToRange(a)
        }
    };
    b.selection.HTMLApplier = f
})(wysihtml5, rangy);
wysihtml5.Commands = Base.extend({
    constructor: function (b) {
        this.editor = b;
        this.composer = b.composer;
        this.doc = this.composer.doc
    }, support: function (b) {
        return wysihtml5.browser.supportsCommand(this.doc, b)
    }, exec: function (b, c) {
        var a = wysihtml5.commands[b], d = wysihtml5.lang.array(arguments).get(), e = a && a.exec, f = null;
        this.editor.fire("beforecommand:composer");
        if (e)d.unshift(this.composer), f = e.apply(a, d); else try {
            f = this.doc.execCommand(b, !1, c)
        } catch (g) {
        }
        this.editor.fire("aftercommand:composer");
        return f
    }, state: function (b,
                        c) {
        var a = wysihtml5.commands[b], d = wysihtml5.lang.array(arguments).get(), e = a && a.state;
        if (e)return d.unshift(this.composer), e.apply(a, d);
        try {
            return this.doc.queryCommandState(b)
        } catch (f) {
            return !1
        }
    }, value: function (b) {
        var c = wysihtml5.commands[b], a = c && c.value;
        if (a)return a.call(c, this.composer, b);
        try {
            return this.doc.queryCommandValue(b)
        } catch (d) {
            return null
        }
    }
});
(function (b) {
    b.commands.bold = {
        exec: function (c, a) {
            return b.commands.formatInline.exec(c, a, "b")
        }, state: function (c, a) {
            return b.commands.formatInline.state(c, a, "b")
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    function c(c, g) {
        var i = c.doc, h = "_wysihtml5-temp-" + +new Date, k = 0, j, n, p;
        b.commands.formatInline.exec(c, a, d, h, /non-matching-class/g);
        j = i.querySelectorAll(d + "." + h);
        for (h = j.length; k < h; k++)for (p in n = j[k], n.removeAttribute("class"), g)n.setAttribute(p, g[p]);
        k = n;
        1 === h && (p = e.getTextContent(n), h = !!n.querySelector("*"), p = "" === p || p === b.INVISIBLE_SPACE, !h && p && (e.setTextContent(n, g.text || n.href), i = i.createTextNode(" "), c.selection.setAfter(n), c.selection.insertNode(i), k = i));
        c.selection.setAfter(k)
    }

    var a, d = "A", e = b.dom;
    b.commands.createLink = {
        exec: function (a, b, d) {
            var h = this.state(a, b);
            h ? a.selection.executeAndRestore(function () {
                for (var a = h.length, b = 0, c, d, f; b < a; b++)c = h[b], d = e.getParentElement(c, {nodeName: "code"}), f = e.getTextContent(c), f.match(e.autoLink.URL_REG_EXP) && !d ? e.renameElement(c, "code") : e.replaceWithChildNodes(c)
            }) : (d = "object" === typeof d ? d : {href: d}, c(a, d))
        }, state: function (a, c) {
            return b.commands.formatInline.state(a, c, "A")
        }, value: function () {
            return a
        }
    }
})(wysihtml5);
(function (b) {
    var c = /wysiwyg-font-size-[a-z\-]+/g;
    b.commands.fontSize = {
        exec: function (a, d, e) {
            return b.commands.formatInline.exec(a, d, "span", "wysiwyg-font-size-" + e, c)
        }, state: function (a, d, e) {
            return b.commands.formatInline.state(a, d, "span", "wysiwyg-font-size-" + e, c)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    var c = /wysiwyg-color-[a-z]+/g;
    b.commands.foreColor = {
        exec: function (a, d, e) {
            return b.commands.formatInline.exec(a, d, "span", "wysiwyg-color-" + e, c)
        }, state: function (a, d, e) {
            return b.commands.formatInline.state(a, d, "span", "wysiwyg-color-" + e, c)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    function c(a) {
        for (a = a.previousSibling; a && a.nodeType === b.TEXT_NODE && !b.lang.string(a.data).trim();)a = a.previousSibling;
        return a
    }

    function a(a) {
        for (a = a.nextSibling; a && a.nodeType === b.TEXT_NODE && !b.lang.string(a.data).trim();)a = a.nextSibling;
        return a
    }

    function d(a) {
        return "BR" === a.nodeName || "block" === g.getStyle("display").from(a) ? !0 : !1
    }

    function e(a, c, d, e) {
        if (e)var f = g.observe(a, "DOMNodeInserted", function (a) {
            var a = a.target, c;
            a.nodeType === b.ELEMENT_NODE && (c = g.getStyle("display").from(a), "inline" !==
            c.substr(0, 6) && (a.className += " " + e))
        });
        a.execCommand(c, !1, d);
        f && f.stop()
    }

    function f(b, d) {
        b.selection.selectLine();
        b.selection.surround(d);
        var e = a(d), f = c(d);
        e && "BR" === e.nodeName && e.parentNode.removeChild(e);
        f && "BR" === f.nodeName && f.parentNode.removeChild(f);
        (e = d.lastChild) && "BR" === e.nodeName && e.parentNode.removeChild(e);
        b.selection.selectNode(d)
    }

    var g = b.dom, i = "H1 H2 H3 H4 H5 H6 P BLOCKQUOTE DIV".split(" ");
    b.commands.formatBlock = {
        exec: function (h, k, j, n, p) {
            var q = h.doc, r = this.state(h, k, j, n, p), m, j = "string" === typeof j ? j.toUpperCase() : j;
            if (r)h.selection.executeAndRestoreSimple(function () {
                p && (r.className = r.className.replace(p, ""));
                var e = !!b.lang.string(r.className).trim();
                if (!e && r.nodeName === (j || "DIV")) {
                    var e = r, f = e.ownerDocument, h = a(e), i = c(e);
                    h && !d(h) && e.parentNode.insertBefore(f.createElement("br"), h);
                    i && !d(i) && e.parentNode.insertBefore(f.createElement("br"), e);
                    g.replaceWithChildNodes(r)
                } else e && g.renameElement(r, "DIV")
            }); else {
                if (null === j || b.lang.array(i).contains(j))if (m = h.selection.getSelectedNode(),
                        r = g.getParentElement(m, {nodeName: i})) {
                    h.selection.executeAndRestoreSimple(function () {
                        j && (r = g.renameElement(r, j));
                        if (n) {
                            var a = r;
                            a.className ? (a.className = a.className.replace(p, ""), a.className += " " + n) : a.className = n
                        }
                    });
                    return
                }
                h.commands.support(k) ? e(q, k, j || "DIV", n) : (r = q.createElement(j || "DIV"), n && (r.className = n), f(h, r))
            }
        }, state: function (a, b, c, d, e) {
            c = "string" === typeof c ? c.toUpperCase() : c;
            a = a.selection.getSelectedNode();
            return g.getParentElement(a, {nodeName: c, className: d, classRegExp: e})
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    function c(c, f, g) {
        var i = c + ":" + f;
        if (!d[i]) {
            var h = d, k = b.selection.HTMLApplier, j = a[c], c = j ? [c.toLowerCase(), j.toLowerCase()] : [c.toLowerCase()];
            h[i] = new k(c, f, g, !0)
        }
        return d[i]
    }

    var a = {strong: "b", em: "i", b: "strong", i: "em"}, d = {};
    b.commands.formatInline = {
        exec: function (a, b, d, i, h) {
            b = a.selection.getRange();
            if (!b)return !1;
            c(d, i, h).toggleRange(b);
            a.selection.setSelection(b)
        }, state: function (d, f, g, i, h) {
            var f = d.doc, k = a[g] || g;
            if (!b.dom.hasElementWithTagName(f, g) && !b.dom.hasElementWithTagName(f, k) || i && !b.dom.hasElementWithClassName(f, i))return !1;
            d = d.selection.getRange();
            return !d ? !1 : c(g, i, h).isAppliedToRange(d)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.insertHTML = {
        exec: function (b, a, d) {
            b.commands.support(a) ? b.doc.execCommand(a, !1, d) : b.selection.insertHTML(d)
        }, state: function () {
            return !1
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.insertImage = {
        exec: function (c, a, d) {
            var d = "object" === typeof d ? d : {src: d}, e = c.doc, a = this.state(c), f;
            if (a)c.selection.setBefore(a), d = a.parentNode, d.removeChild(a), b.dom.removeEmptyTextNodes(d), "A" === d.nodeName && !d.firstChild && (c.selection.setAfter(d), d.parentNode.removeChild(d)), b.quirks.redraw(c.element); else {
                a = e.createElement("IMG");
                for (f in d)a[f] = d[f];
                c.selection.insertNode(a);
                b.browser.hasProblemsSettingCaretAfterImg() ? (d = e.createTextNode(b.INVISIBLE_SPACE), c.selection.insertNode(d),
                    c.selection.setAfter(d)) : c.selection.setAfter(a)
            }
        }, state: function (c) {
            var a;
            if (!b.dom.hasElementWithTagName(c.doc, "IMG"))return !1;
            a = c.selection.getSelectedNode();
            if (!a)return !1;
            if ("IMG" === a.nodeName)return a;
            if (a.nodeType !== b.ELEMENT_NODE)return !1;
            a = c.selection.getText();
            if (a = b.lang.string(a).trim())return !1;
            c = c.selection.getNodes(b.ELEMENT_NODE, function (a) {
                return "IMG" === a.nodeName
            });
            return 1 !== c.length ? !1 : c[0]
        }, value: function (b) {
            return (b = this.state(b)) && b.src
        }
    }
})(wysihtml5);
(function (b) {
    var c = "<br>" + (b.browser.needsSpaceAfterLineBreak() ? " " : "");
    b.commands.insertLineBreak = {
        exec: function (a, d) {
            a.commands.support(d) ? (a.doc.execCommand(d, !1, null), b.browser.autoScrollsToCaret() || a.selection.scrollIntoView()) : a.commands.exec("insertHTML", c)
        }, state: function () {
            return !1
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.insertOrderedList = {
        exec: function (c, a) {
            var d = c.doc, e = c.selection.getSelectedNode(), f = b.dom.getParentElement(e, {nodeName: "OL"}), g = b.dom.getParentElement(e, {nodeName: "UL"}), e = "_wysihtml5-temp-" + (new Date).getTime(), i;
            c.commands.support(a) ? d.execCommand(a, !1, null) : f ? c.selection.executeAndRestoreSimple(function () {
                b.dom.resolveList(f)
            }) : g ? c.selection.executeAndRestoreSimple(function () {
                b.dom.renameElement(g, "ol")
            }) : (c.commands.exec("formatBlock", "div", e), i = d.querySelector("." + e),
                d = "" === i.innerHTML || i.innerHTML === b.INVISIBLE_SPACE, c.selection.executeAndRestoreSimple(function () {
                f = b.dom.convertToList(i, "ol")
            }), d && c.selection.selectNode(f.querySelector("li")))
        }, state: function (c) {
            c = c.selection.getSelectedNode();
            return b.dom.getParentElement(c, {nodeName: "OL"})
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.insertUnorderedList = {
        exec: function (c, a) {
            var d = c.doc, e = c.selection.getSelectedNode(), f = b.dom.getParentElement(e, {nodeName: "UL"}), g = b.dom.getParentElement(e, {nodeName: "OL"}), e = "_wysihtml5-temp-" + (new Date).getTime(), i;
            c.commands.support(a) ? d.execCommand(a, !1, null) : f ? c.selection.executeAndRestoreSimple(function () {
                b.dom.resolveList(f)
            }) : g ? c.selection.executeAndRestoreSimple(function () {
                b.dom.renameElement(g, "ul")
            }) : (c.commands.exec("formatBlock", "div", e), i = d.querySelector("." + e),
                d = "" === i.innerHTML || i.innerHTML === b.INVISIBLE_SPACE, c.selection.executeAndRestoreSimple(function () {
                f = b.dom.convertToList(i, "ul")
            }), d && c.selection.selectNode(f.querySelector("li")))
        }, state: function (c) {
            c = c.selection.getSelectedNode();
            return b.dom.getParentElement(c, {nodeName: "UL"})
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.italic = {
        exec: function (c, a) {
            return b.commands.formatInline.exec(c, a, "i")
        }, state: function (c, a) {
            return b.commands.formatInline.state(c, a, "i")
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    var c = /wysiwyg-text-align-[a-z]+/g;
    b.commands.justifyCenter = {
        exec: function (a) {
            return b.commands.formatBlock.exec(a, "formatBlock", null, "wysiwyg-text-align-center", c)
        }, state: function (a) {
            return b.commands.formatBlock.state(a, "formatBlock", null, "wysiwyg-text-align-center", c)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    var c = /wysiwyg-text-align-[a-z]+/g;
    b.commands.justifyLeft = {
        exec: function (a) {
            return b.commands.formatBlock.exec(a, "formatBlock", null, "wysiwyg-text-align-left", c)
        }, state: function (a) {
            return b.commands.formatBlock.state(a, "formatBlock", null, "wysiwyg-text-align-left", c)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    var c = /wysiwyg-text-align-[a-z]+/g;
    b.commands.justifyRight = {
        exec: function (a) {
            return b.commands.formatBlock.exec(a, "formatBlock", null, "wysiwyg-text-align-right", c)
        }, state: function (a) {
            return b.commands.formatBlock.state(a, "formatBlock", null, "wysiwyg-text-align-right", c)
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    b.commands.underline = {
        exec: function (c, a) {
            return b.commands.formatInline.exec(c, a, "u")
        }, state: function (c, a) {
            return b.commands.formatInline.state(c, a, "u")
        }, value: function () {
        }
    }
})(wysihtml5);
(function (b) {
    var c = '<span id="_wysihtml5-undo" class="_wysihtml5-temp">' + b.INVISIBLE_SPACE + "</span>", a = '<span id="_wysihtml5-redo" class="_wysihtml5-temp">' + b.INVISIBLE_SPACE + "</span>", d = b.dom;
    b.UndoManager = b.lang.Dispatcher.extend({
        constructor: function (a) {
            this.editor = a;
            this.composer = a.composer;
            this.element = this.composer.element;
            this.history = [this.composer.getValue()];
            this.position = 1;
            this.composer.commands.support("insertHTML") && this._observe()
        }, _observe: function () {
            var e = this, f = this.composer.sandbox.getDocument(),
                g;
            d.observe(this.element, "keydown", function (a) {
                if (!(a.altKey || !a.ctrlKey && !a.metaKey)) {
                    var b = a.keyCode, c = 90 === b && a.shiftKey || 89 === b;
                    90 === b && !a.shiftKey ? (e.undo(), a.preventDefault()) : c && (e.redo(), a.preventDefault())
                }
            });
            d.observe(this.element, "keydown", function (a) {
                a = a.keyCode;
                a !== g && (g = a, (8 === a || 46 === a) && e.transact())
            });
            if (b.browser.hasUndoInContextMenu()) {
                var i, h, k = function () {
                    for (var a; a = f.querySelector("._wysihtml5-temp");)a.parentNode.removeChild(a);
                    clearInterval(i)
                };
                d.observe(this.element, "contextmenu",
                    function () {
                        k();
                        e.composer.selection.executeAndRestoreSimple(function () {
                            e.element.lastChild && e.composer.selection.setAfter(e.element.lastChild);
                            f.execCommand("insertHTML", !1, c);
                            f.execCommand("insertHTML", !1, a);
                            f.execCommand("undo", !1, null)
                        });
                        i = setInterval(function () {
                            f.getElementById("_wysihtml5-redo") ? (k(), e.redo()) : f.getElementById("_wysihtml5-undo") || (k(), e.undo())
                        }, 400);
                        h || (h = !0, d.observe(document, "mousedown", k), d.observe(f, ["mousedown", "paste", "cut", "copy"], k))
                    })
            }
            this.editor.observe("newword:composer",
                function () {
                    e.transact()
                }).observe("beforecommand:composer", function () {
                    e.transact()
                })
        }, transact: function () {
            var a = this.history[this.position - 1], b = this.composer.getValue();
            if (b != a) {
                if (40 < (this.history.length = this.position))this.history.shift(), this.position--;
                this.position++;
                this.history.push(b)
            }
        }, undo: function () {
            this.transact();
            1 >= this.position || (this.set(this.history[--this.position - 1]), this.editor.fire("undo:composer"))
        }, redo: function () {
            this.position >= this.history.length || (this.set(this.history[++this.position -
            1]), this.editor.fire("redo:composer"))
        }, set: function (a) {
            this.composer.setValue(a);
            this.editor.focus(!0)
        }
    })
})(wysihtml5);
wysihtml5.views.View = Base.extend({
    constructor: function (b, c, a) {
        this.parent = b;
        this.element = c;
        this.config = a;
        this._observeViewChange()
    }, _observeViewChange: function () {
        var b = this;
        this.parent.observe("beforeload", function () {
            b.parent.observe("change_view", function (c) {
                c === b.name ? (b.parent.currentView = b, b.show(), setTimeout(function () {
                    b.focus()
                }, 0)) : b.hide()
            })
        })
    }, focus: function () {
        if (this.element.ownerDocument.querySelector(":focus") !== this.element)try {
            this.element.focus()
        } catch (b) {
        }
    }, hide: function () {
        this.element.style.display =
            "none"
    }, show: function () {
        this.element.style.display = ""
    }, disable: function () {
        this.element.setAttribute("disabled", "disabled")
    }, enable: function () {
        this.element.removeAttribute("disabled")
    }
});
(function (b) {
    var c = b.dom, a = b.browser;
    b.views.Composer = b.views.View.extend({
        name: "composer", CARET_HACK: "<br>", constructor: function (a, b, c) {
            this.base(a, b, c);
            this.textarea = this.parent.textarea;
            this._initSandbox()
        }, clear: function () {
            this.element.innerHTML = a.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK
        }, getValue: function (a) {
            var c = this.isEmpty() ? "" : b.quirks.getCorrectInnerHTML(this.element);
            a && (c = this.parent.parse(c));
            return c = b.lang.string(c).replace(b.INVISIBLE_SPACE).by("")
        }, setValue: function (a,
                               b) {
            b && (a = this.parent.parse(a));
            this.element.innerHTML = a
        }, show: function () {
            this.iframe.style.display = this._displayStyle || "";
            this.disable();
            this.enable()
        }, hide: function () {
            this._displayStyle = c.getStyle("display").from(this.iframe);
            "none" === this._displayStyle && (this._displayStyle = null);
            this.iframe.style.display = "none"
        }, disable: function () {
            this.element.removeAttribute("contentEditable");
            this.base()
        }, enable: function () {
            this.element.setAttribute("contentEditable", "true");
            this.base()
        }, focus: function (a) {
            b.browser.doesAsyncFocus() &&
            this.hasPlaceholderSet() && this.clear();
            this.base();
            var c = this.element.lastChild;
            a && c && ("BR" === c.nodeName ? this.selection.setBefore(this.element.lastChild) : this.selection.setAfter(this.element.lastChild))
        }, getTextContent: function () {
            return c.getTextContent(this.element)
        }, hasPlaceholderSet: function () {
            return this.getTextContent() == this.textarea.element.getAttribute("placeholder")
        }, isEmpty: function () {
            var a = this.element.innerHTML;
            return "" === a || a === this.CARET_HACK || this.hasPlaceholderSet() || "" === this.getTextContent() && !this.element.querySelector("blockquote, ul, ol, img, embed, object, table, iframe, svg, video, audio, button, input, select, textarea")
        }, _initSandbox: function () {
            var a = this;
            this.sandbox = new c.Sandbox(function () {
                a._create()
            }, {stylesheets: this.config.stylesheets});
            this.iframe = this.sandbox.getIframe();
            var b = document.createElement("input");
            b.type = "hidden";
            b.name = "_wysihtml5_mode";
            b.value = 1;
            var f = this.textarea.element;
            c.insert(this.iframe).after(f);
            c.insert(b).after(f)
        }, _create: function () {
            var d = this;
            this.doc =
                this.sandbox.getDocument();
            this.element = this.doc.body;
            this.textarea = this.parent.textarea;
            this.element.innerHTML = this.textarea.getValue(!0);
            this.enable();
            this.selection = new b.Selection(this.parent);
            this.commands = new b.Commands(this.parent);
            c.copyAttributes("className spellcheck title lang dir accessKey".split(" ")).from(this.textarea.element).to(this.element);
            c.addClass(this.element, this.config.composerClassName);
            this.config.style && this.style();
            this.observe();
            var e = this.config.name;
            e && (c.addClass(this.element,
                e), c.addClass(this.iframe, e));
            (e = "string" === typeof this.config.placeholder ? this.config.placeholder : this.textarea.element.getAttribute("placeholder")) && c.simulatePlaceholder(this.parent, this, e);
            this.commands.exec("styleWithCSS", !1);
            this._initAutoLinking();
            this._initObjectResizing();
            this._initUndoManager();
            (this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) && setTimeout(function () {
                d.focus()
            }, 100);
            b.quirks.insertLineBreakOnReturn(this);
            a.clearsContentEditableCorrectly() ||
            b.quirks.ensureProperClearing(this);
            a.clearsListsInContentEditableCorrectly() || b.quirks.ensureProperClearingOfLists(this);
            this.initSync && this.config.sync && this.initSync();
            this.textarea.hide();
            this.parent.fire("beforeload").fire("load")
        }, _initAutoLinking: function () {
            var d = this, e = a.canDisableAutoLinking(), f = a.doesAutoLinkingInContentEditable();
            e && this.commands.exec("autoUrlDetect", !1);
            if (this.config.autoLink) {
                (!f || f && e) && this.parent.observe("newword:composer", function () {
                    d.selection.executeAndRestore(function (a,
                                                            b) {
                        c.autoLink(b.parentNode)
                    })
                });
                var g = this.sandbox.getDocument().getElementsByTagName("a"), i = c.autoLink.URL_REG_EXP, h = function (a) {
                    a = b.lang.string(c.getTextContent(a)).trim();
                    "www." === a.substr(0, 4) && (a = "http://" + a);
                    return a
                };
                c.observe(this.element, "keydown", function (a) {
                    if (g.length) {
                        var a = d.selection.getSelectedNode(a.target.ownerDocument), b = c.getParentElement(a, {nodeName: "A"}, 4), e;
                        b && (e = h(b), setTimeout(function () {
                            var a = h(b);
                            a !== e && a.match(i) && b.setAttribute("href", a)
                        }, 0))
                    }
                })
            }
        }, _initObjectResizing: function () {
            var d =
                ["width", "height"], e = d.length, f = this.element;
            this.commands.exec("enableObjectResizing", this.config.allowObjectResizing);
            this.config.allowObjectResizing ? a.supportsEvent("resizeend") && c.observe(f, "resizeend", function (a) {
                for (var a = a.target || a.srcElement, c = a.style, h = 0, k; h < e; h++)k = d[h], c[k] && (a.setAttribute(k, parseInt(c[k], 10)), c[k] = "");
                b.quirks.redraw(f)
            }) : a.supportsEvent("resizestart") && c.observe(f, "resizestart", function (a) {
                a.preventDefault()
            })
        }, _initUndoManager: function () {
            new b.UndoManager(this.parent)
        }
    })
})(wysihtml5);
(function (b) {
    var c = b.dom, a = document, d = window, e = a.createElement("div"), f = "background-color color cursor font-family font-size font-style font-variant font-weight line-height letter-spacing text-align text-decoration text-indent text-rendering word-break word-wrap word-spacing".split(" "), g = "background-color border-collapse border-bottom-color border-bottom-style border-bottom-width border-left-color border-left-style border-left-width border-right-color border-right-style border-right-width border-top-color border-top-style border-top-width clear display float margin-bottom margin-left margin-right margin-top outline-color outline-offset outline-width outline-style padding-left padding-right padding-top padding-bottom position top left right bottom z-index vertical-align text-align -webkit-box-sizing -moz-box-sizing -ms-box-sizing box-sizing -webkit-box-shadow -moz-box-shadow -ms-box-shadow box-shadow -webkit-border-top-right-radius -moz-border-radius-topright border-top-right-radius -webkit-border-bottom-right-radius -moz-border-radius-bottomright border-bottom-right-radius -webkit-border-bottom-left-radius -moz-border-radius-bottomleft border-bottom-left-radius -webkit-border-top-left-radius -moz-border-radius-topleft border-top-left-radius width height".split(" "),
        i = "width height top left right bottom".split(" "), h = ["html             { height: 100%; }", "body             { min-height: 100%; padding: 0; margin: 0; margin-top: -1px; padding-top: 1px; }", "._wysihtml5-temp { display: none; }", b.browser.isGecko ? "body.placeholder { color: graytext !important; }" : "body.placeholder { color: #a9a9a9 !important; }", "body[disabled]   { background-color: #eee !important; color: #999 !important; cursor: default !important; }", "img:-moz-broken  { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"],
        k = function (b) {
            if (b.setActive)try {
                b.setActive()
            } catch (e) {
            } else {
                var f = b.style, h = a.documentElement.scrollTop || a.body.scrollTop, g = a.documentElement.scrollLeft || a.body.scrollLeft, f = {
                    position: f.position,
                    top: f.top,
                    left: f.left,
                    WebkitUserSelect: f.WebkitUserSelect
                };
                c.setStyles({position: "absolute", top: "-99999px", left: "-99999px", WebkitUserSelect: "none"}).on(b);
                b.focus();
                c.setStyles(f).on(b);
                d.scrollTo && d.scrollTo(g, h)
            }
        };
    b.views.Composer.prototype.style = function () {
        var j = this, n = a.querySelector(":focus"), p = this.textarea.element,
            q = p.hasAttribute("placeholder"), r = q && p.getAttribute("placeholder");
        this.focusStylesHost = this.focusStylesHost || e.cloneNode(!1);
        this.blurStylesHost = this.blurStylesHost || e.cloneNode(!1);
        q && p.removeAttribute("placeholder");
        p === n && p.blur();
        c.copyStyles(g).from(p).to(this.iframe).andTo(this.blurStylesHost);
        c.copyStyles(f).from(p).to(this.element).andTo(this.blurStylesHost);
        c.insertCSS(h).into(this.element.ownerDocument);
        k(p);
        c.copyStyles(g).from(p).to(this.focusStylesHost);
        c.copyStyles(f).from(p).to(this.focusStylesHost);
        var m = b.lang.array(g).without(["display"]);
        n ? n.focus() : p.blur();
        q && p.setAttribute("placeholder", r);
        if (!b.browser.hasCurrentStyleProperty())var s = c.observe(d, "resize", function () {
            if (c.contains(document.documentElement, j.iframe)) {
                var a = c.getStyle("display").from(p), b = c.getStyle("display").from(j.iframe);
                p.style.display = "";
                j.iframe.style.display = "none";
                c.copyStyles(i).from(p).to(j.iframe).andTo(j.focusStylesHost).andTo(j.blurStylesHost);
                j.iframe.style.display = b;
                p.style.display = a
            } else s.stop()
        });
        this.parent.observe("focus:composer",
            function () {
                c.copyStyles(m).from(j.focusStylesHost).to(j.iframe);
                c.copyStyles(f).from(j.focusStylesHost).to(j.element)
            });
        this.parent.observe("blur:composer", function () {
            c.copyStyles(m).from(j.blurStylesHost).to(j.iframe);
            c.copyStyles(f).from(j.blurStylesHost).to(j.element)
        });
        return this
    }
})(wysihtml5);
(function (b) {
    var c = b.dom, a = b.browser, d = {66: "bold", 73: "italic", 85: "underline"};
    b.views.Composer.prototype.observe = function () {
        var e = this, f = this.getValue(), g = this.sandbox.getIframe(), i = this.element, h = a.supportsEventsInIframeCorrectly() ? i : this.sandbox.getWindow(), k = a.supportsEvent("drop") ? ["drop", "paste"] : ["dragdrop", "paste"];
        c.observe(g, "DOMNodeRemoved", function () {
            clearInterval(j);
            e.parent.fire("destroy:composer")
        });
        var j = setInterval(function () {
            c.contains(document.documentElement, g) || (clearInterval(j),
                e.parent.fire("destroy:composer"))
        }, 250);
        c.observe(h, "focus", function () {
            e.parent.fire("focus").fire("focus:composer");
            setTimeout(function () {
                f = e.getValue()
            }, 0)
        });
        c.observe(h, "blur", function () {
            f !== e.getValue() && e.parent.fire("change").fire("change:composer");
            e.parent.fire("blur").fire("blur:composer")
        });
        b.browser.isIos() && c.observe(i, "blur", function () {
            var a = i.ownerDocument.createElement("input"), b = document.documentElement.scrollTop || document.body.scrollTop, c = document.documentElement.scrollLeft || document.body.scrollLeft;
            try {
                e.selection.insertNode(a)
            } catch (d) {
                i.appendChild(a)
            }
            a.focus();
            a.parentNode.removeChild(a);
            window.scrollTo(c, b)
        });
        c.observe(i, "dragenter", function () {
            e.parent.fire("unset_placeholder")
        });
        a.firesOnDropOnlyWhenOnDragOverIsCancelled() && c.observe(i, ["dragover", "dragenter"], function (a) {
            a.preventDefault()
        });
        c.observe(i, k, function (b) {
            var c = b.dataTransfer, d;
            c && a.supportsDataTransfer() && (d = c.getData("text/html") || c.getData("text/plain"));
            d ? (i.focus(), e.commands.exec("insertHTML", d), e.parent.fire("paste").fire("paste:composer"),
                b.stopPropagation(), b.preventDefault()) : setTimeout(function () {
                e.parent.fire("paste").fire("paste:composer")
            }, 0)
        });
        c.observe(i, "keyup", function (a) {
            a = a.keyCode;
            (a === b.SPACE_KEY || a === b.ENTER_KEY) && e.parent.fire("newword:composer")
        });
        this.parent.observe("paste:composer", function () {
            setTimeout(function () {
                e.parent.fire("newword:composer")
            }, 0)
        });
        a.canSelectImagesInContentEditable() || c.observe(i, "mousedown", function (a) {
            var b = a.target;
            "IMG" === b.nodeName && (e.selection.selectNode(b), a.preventDefault())
        });
        c.observe(i,
            "keydown", function (a) {
                var b = d[a.keyCode];
                if ((a.ctrlKey || a.metaKey) && !a.altKey && b)e.commands.exec(b), a.preventDefault()
            });
        c.observe(i, "keydown", function (a) {
            var c = e.selection.getSelectedNode(!0), d = a.keyCode;
            if (c && "IMG" === c.nodeName && (d === b.BACKSPACE_KEY || d === b.DELETE_KEY))d = c.parentNode, d.removeChild(c), "A" === d.nodeName && !d.firstChild && d.parentNode.removeChild(d), setTimeout(function () {
                b.quirks.redraw(i)
            }, 0), a.preventDefault()
        });
        var n = {IMG: "Image: ", A: "Link: "};
        c.observe(i, "mouseover", function (a) {
            var a =
                a.target, b = a.nodeName;
            !("A" !== b && "IMG" !== b) && !a.hasAttribute("title") && (b = n[b] + (a.getAttribute("href") || a.getAttribute("src")), a.setAttribute("title", b))
        })
    }
})(wysihtml5);
(function (b) {
    b.views.Synchronizer = Base.extend({
        constructor: function (b, a, d) {
            this.editor = b;
            this.textarea = a;
            this.composer = d;
            this._observe()
        }, fromComposerToTextarea: function (c) {
            this.textarea.setValue(b.lang.string(this.composer.getValue()).trim(), c)
        }, fromTextareaToComposer: function (b) {
            var a = this.textarea.getValue();
            a ? this.composer.setValue(a, b) : (this.composer.clear(), this.editor.fire("set_placeholder"))
        }, sync: function (b) {
            "textarea" === this.editor.currentView.name ? this.fromTextareaToComposer(b) : this.fromComposerToTextarea(b)
        },
        _observe: function () {
            var c, a = this, d = this.textarea.element.form, e = function () {
                c = setInterval(function () {
                    a.fromComposerToTextarea()
                }, 400)
            }, f = function () {
                clearInterval(c);
                c = null
            };
            e();
            d && (b.dom.observe(d, "submit", function () {
                a.sync(!0)
            }), b.dom.observe(d, "reset", function () {
                setTimeout(function () {
                    a.fromTextareaToComposer()
                }, 0)
            }));
            this.editor.observe("change_view", function (b) {
                if (b === "composer" && !c) {
                    a.fromTextareaToComposer(true);
                    e()
                } else if (b === "textarea") {
                    a.fromComposerToTextarea(true);
                    f()
                }
            });
            this.editor.observe("destroy:composer",
                f)
        }
    })
})(wysihtml5);
wysihtml5.views.Textarea = wysihtml5.views.View.extend({
    name: "textarea", constructor: function (b, c, a) {
        this.base(b, c, a);
        this._observe()
    }, clear: function () {
        this.element.value = ""
    }, getValue: function (b) {
        var c = this.isEmpty() ? "" : this.element.value;
        b && (c = this.parent.parse(c));
        return c
    }, setValue: function (b, c) {
        c && (b = this.parent.parse(b));
        this.element.value = b
    }, hasPlaceholderSet: function () {
        var b = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element), c = this.element.getAttribute("placeholder") || null, a = this.element.value;
        return b && !a || a === c
    }, isEmpty: function () {
        return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet()
    }, _observe: function () {
        var b = this.element, c = this.parent, a = {
            focusin: "focus",
            focusout: "blur"
        }, d = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];
        c.observe("beforeload", function () {
            wysihtml5.dom.observe(b, d, function (b) {
                b = a[b.type] || b.type;
                c.fire(b).fire(b + ":textarea")
            });
            wysihtml5.dom.observe(b, ["paste", "drop"], function () {
                setTimeout(function () {
                        c.fire("paste").fire("paste:textarea")
                    },
                    0)
            })
        })
    }
});
(function (b) {
    var c = b.dom;
    b.toolbar.Dialog = b.lang.Dispatcher.extend({
        constructor: function (a, b) {
            this.link = a;
            this.container = b
        }, _observe: function () {
            if (!this._observed) {
                var a = this, d = function (b) {
                    var c = a._serialize();
                    c == a.elementToChange ? a.fire("edit", c) : a.fire("save", c);
                    a.hide();
                    b.preventDefault();
                    b.stopPropagation()
                };
                c.observe(a.link, "click", function () {
                    c.hasClass(a.link, "wysihtml5-command-dialog-opened") && setTimeout(function () {
                        a.hide()
                    }, 0)
                });
                c.observe(this.container, "keydown", function (c) {
                    var e = c.keyCode;
                    e === b.ENTER_KEY && d(c);
                    e === b.ESCAPE_KEY && a.hide()
                });
                c.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", d);
                c.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function (b) {
                    a.fire("cancel");
                    a.hide();
                    b.preventDefault();
                    b.stopPropagation()
                });
                for (var e = this.container.querySelectorAll("input, select, textarea"), f = 0, g = e.length, i = function () {
                    clearInterval(a.interval)
                }; f < g; f++)c.observe(e[f], "change", i);
                this._observed = !0
            }
        }, _serialize: function () {
            for (var a = this.elementToChange ||
                {}, b = this.container.querySelectorAll("[data-wysihtml5-dialog-field]"), c = b.length, f = 0; f < c; f++)a[b[f].getAttribute("data-wysihtml5-dialog-field")] = b[f].value;
            return a
        }, _interpolate: function (a) {
            for (var b, c, f = document.querySelector(":focus"), g = this.container.querySelectorAll("[data-wysihtml5-dialog-field]"), i = g.length, h = 0; h < i; h++)b = g[h], b !== f && !(a && "hidden" === b.type) && (c = b.getAttribute("data-wysihtml5-dialog-field"), c = this.elementToChange ? this.elementToChange[c] || "" : b.defaultValue, b.value = c)
        }, show: function (a) {
            var b =
                this, e = this.container.querySelector("input, select, textarea");
            this.elementToChange = a;
            this._observe();
            this._interpolate();
            a && (this.interval = setInterval(function () {
                b._interpolate(!0)
            }, 500));
            c.addClass(this.link, "wysihtml5-command-dialog-opened");
            this.container.style.display = "";
            this.fire("show");
            if (e && !a)try {
                e.focus()
            } catch (f) {
            }
        }, hide: function () {
            clearInterval(this.interval);
            this.elementToChange = null;
            c.removeClass(this.link, "wysihtml5-command-dialog-opened");
            this.container.style.display = "none";
            this.fire("hide")
        }
    })
})(wysihtml5);
(function (b) {
    var c = b.dom, a = {position: "relative"}, d = {
        left: 0,
        margin: 0,
        opacity: 0,
        overflow: "hidden",
        padding: 0,
        position: "absolute",
        top: 0,
        zIndex: 1
    }, e = {
        cursor: "inherit",
        fontSize: "50px",
        height: "50px",
        marginTop: "-25px",
        outline: 0,
        padding: 0,
        position: "absolute",
        right: "-4px",
        top: "50%"
    }, f = {"x-webkit-speech": "", speech: ""};
    b.toolbar.Speech = function (g, i) {
        var h = document.createElement("input");
        if (b.browser.supportsSpeechApiOn(h)) {
            var k = document.createElement("div");
            b.lang.object(d).merge({
                width: i.offsetWidth + "px", height: i.offsetHeight +
                "px"
            });
            c.insert(h).into(k);
            c.insert(k).into(i);
            c.setStyles(e).on(h);
            c.setAttributes(f).on(h);
            c.setStyles(d).on(k);
            c.setStyles(a).on(i);
            c.observe(h, "onwebkitspeechchange"in h ? "webkitspeechchange" : "speechchange", function () {
                g.execCommand("insertText", h.value);
                h.value = ""
            });
            c.observe(h, "click", function (a) {
                c.hasClass(i, "wysihtml5-command-disabled") && a.preventDefault();
                a.stopPropagation()
            })
        } else i.style.display = "none"
    }
})(wysihtml5);
(function (b) {
    var c = b.dom;
    b.toolbar.Toolbar = Base.extend({
        constructor: function (a, c) {
            this.editor = a;
            this.container = "string" === typeof c ? document.getElementById(c) : c;
            this.composer = a.composer;
            this._getLinks("command");
            this._getLinks("action");
            this._observe();
            this.show();
            for (var e = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"), f = e.length, g = 0; g < f; g++)new b.toolbar.Speech(this, e[g])
        }, _getLinks: function (a) {
            for (var c = this[a + "Links"] = b.lang.array(this.container.querySelectorAll("[data-wysihtml5-" +
                a + "]")).get(), e = c.length, f = 0, g = this[a + "Mapping"] = {}, i, h, k, j, n; f < e; f++)i = c[f], k = i.getAttribute("data-wysihtml5-" + a), j = i.getAttribute("data-wysihtml5-" + a + "-value"), h = this.container.querySelector("[data-wysihtml5-" + a + "-group='" + k + "']"), n = this._getDialog(i, k), g[k + ":" + j] = {
                link: i,
                group: h,
                name: k,
                value: j,
                dialog: n,
                state: !1
            }
        }, _getDialog: function (a, c) {
            var e = this, f = this.container.querySelector("[data-wysihtml5-dialog='" + c + "']"), g, i;
            f && (g = new b.toolbar.Dialog(a, f), g.observe("show", function () {
                i = e.composer.selection.getBookmark();
                e.editor.fire("show:dialog", {command: c, dialogContainer: f, commandLink: a})
            }), g.observe("save", function (b) {
                i && e.composer.selection.setBookmark(i);
                e._execCommand(c, b);
                e.editor.fire("save:dialog", {command: c, dialogContainer: f, commandLink: a})
            }), g.observe("cancel", function () {
                e.editor.focus(!1);
                e.editor.fire("cancel:dialog", {command: c, dialogContainer: f, commandLink: a})
            }));
            return g
        }, execCommand: function (a, b) {
            if (!this.commandsDisabled) {
                var c = this.commandMapping[a + ":" + b];
                c && c.dialog && !c.state ? c.dialog.show() :
                    this._execCommand(a, b)
            }
        }, _execCommand: function (a, b) {
            this.editor.focus(!1);
            this.composer.commands.exec(a, b);
            this._updateLinkStates()
        }, execAction: function (a) {
            var b = this.editor;
            switch (a) {
                case "change_view":
                    b.currentView === b.textarea ? b.fire("change_view", "composer") : b.fire("change_view", "textarea")
            }
        }, _observe: function () {
            for (var a = this, b = this.editor, e = this.container, f = this.commandLinks.concat(this.actionLinks), g = f.length, i = 0; i < g; i++)c.setAttributes({
                href: "javascript:;",
                unselectable: "on"
            }).on(f[i]);
            c.delegate(e,
                "[data-wysihtml5-command]", "mousedown", function (a) {
                    a.preventDefault()
                });
            c.delegate(e, "[data-wysihtml5-command]", "click", function (b) {
                var c = this.getAttribute("data-wysihtml5-command"), d = this.getAttribute("data-wysihtml5-command-value");
                a.execCommand(c, d);
                b.preventDefault()
            });
            c.delegate(e, "[data-wysihtml5-action]", "click", function (b) {
                var c = this.getAttribute("data-wysihtml5-action");
                a.execAction(c);
                b.preventDefault()
            });
            b.observe("focus:composer", function () {
                a.bookmark = null;
                clearInterval(a.interval);
                a.interval =
                    setInterval(function () {
                        a._updateLinkStates()
                    }, 500)
            });
            b.observe("blur:composer", function () {
                clearInterval(a.interval)
            });
            b.observe("destroy:composer", function () {
                clearInterval(a.interval)
            });
            b.observe("change_view", function (b) {
                setTimeout(function () {
                    a.commandsDisabled = "composer" !== b;
                    a._updateLinkStates();
                    a.commandsDisabled ? c.addClass(e, "wysihtml5-commands-disabled") : c.removeClass(e, "wysihtml5-commands-disabled")
                }, 0)
            })
        }, _updateLinkStates: function () {
            var a = this.commandMapping, d = this.actionMapping, e, f, g;
            for (e in a)if (g =
                    a[e], this.commandsDisabled ? (f = !1, c.removeClass(g.link, "wysihtml5-command-active"), g.group && c.removeClass(g.group, "wysihtml5-command-active"), g.dialog && g.dialog.hide()) : (f = this.composer.commands.state(g.name, g.value), b.lang.object(f).isArray() && (f = 1 === f.length ? f[0] : !0), c.removeClass(g.link, "wysihtml5-command-disabled"), g.group && c.removeClass(g.group, "wysihtml5-command-disabled")), g.state !== f)(g.state = f) ? (c.addClass(g.link, "wysihtml5-command-active"), g.group && c.addClass(g.group, "wysihtml5-command-active"),
            g.dialog && ("object" === typeof f ? g.dialog.show(f) : g.dialog.hide())) : (c.removeClass(g.link, "wysihtml5-command-active"), g.group && c.removeClass(g.group, "wysihtml5-command-active"), g.dialog && g.dialog.hide());
            for (e in d)a = d[e], "change_view" === a.name && (a.state = this.editor.currentView === this.editor.textarea, a.state ? c.addClass(a.link, "wysihtml5-action-active") : c.removeClass(a.link, "wysihtml5-action-active"))
        }, show: function () {
            this.container.style.display = ""
        }, hide: function () {
            this.container.style.display = "none"
        }
    })
})(wysihtml5);
(function (b) {
    var c = {
        name: void 0,
        style: !0,
        toolbar: void 0,
        autoLink: !0,
        parserRules: {tags: {br: {}, span: {}, div: {}, p: {}}, classes: {}},
        parser: b.dom.parse,
        composerClassName: "wysihtml5-editor",
        bodyClassName: "wysihtml5-supported",
        stylesheets: [],
        placeholderText: void 0,
        allowObjectResizing: !0,
        supportTouchDevices: !0
    };
    b.Editor = b.lang.Dispatcher.extend({
        constructor: function (a, d) {
            this.textareaElement = "string" === typeof a ? document.getElementById(a) : a;
            this.config = b.lang.object({}).merge(c).merge(d).get();
            this.currentView =
                this.textarea = new b.views.Textarea(this, this.textareaElement, this.config);
            this._isCompatible = b.browser.supported();
            if (!this._isCompatible || !this.config.supportTouchDevices && b.browser.isTouchDevice()) {
                var e = this;
                setTimeout(function () {
                    e.fire("beforeload").fire("load")
                }, 0)
            } else {
                b.dom.addClass(document.body, this.config.bodyClassName);
                this.currentView = this.composer = new b.views.Composer(this, this.textareaElement, this.config);
                "function" === typeof this.config.parser && this._initParser();
                this.observe("beforeload",
                    function () {
                        this.synchronizer = new b.views.Synchronizer(this, this.textarea, this.composer);
                        this.config.toolbar && (this.toolbar = new b.toolbar.Toolbar(this, this.config.toolbar))
                    });
                try {
                    console.log("Heya! This page is using wysihtml5 for rich text editing. Check out https://github.com/xing/wysihtml5")
                } catch (f) {
                }
            }
        }, isCompatible: function () {
            return this._isCompatible
        }, clear: function () {
            this.currentView.clear();
            return this
        }, getValue: function (a) {
            return this.currentView.getValue(a)
        }, setValue: function (a, b) {
            if (!a)return this.clear();
            this.currentView.setValue(a, b);
            return this
        }, focus: function (a) {
            this.currentView.focus(a);
            return this
        }, disable: function () {
            this.currentView.disable();
            return this
        }, enable: function () {
            this.currentView.enable();
            return this
        }, isEmpty: function () {
            return this.currentView.isEmpty()
        }, hasPlaceholderSet: function () {
            return this.currentView.hasPlaceholderSet()
        }, parse: function (a) {
            var c = this.config.parser(a, this.config.parserRules, this.composer.sandbox.getDocument(), !0);
            "object" === typeof a && b.quirks.redraw(a);
            return c
        },
        _initParser: function () {
            this.observe("paste:composer", function () {
                var a = this;
                a.composer.selection.executeAndRestore(function () {
                    b.quirks.cleanPastedHTML(a.composer.element);
                    a.parse(a.composer.element)
                }, !0)
            });
            this.observe("paste:textarea", function () {
                this.textarea.setValue(this.parse(this.textarea.getValue()))
            })
        }
    })
})(wysihtml5);
!function ($, wysi) {
    "use strict";

    var tpl = {
        "font-styles": function (locale) {
            return "<li class='dropdown'>" +
                "<a class='btn dropdown-toggle' data-toggle='dropdown' href='#'>" +
                "<i class='icon-font'></i>&nbsp;<span class='current-font'>" + locale.font_styles.normal + "</span>&nbsp;<b class='caret'></b>" +
                "</a>" +
                "<ul class='dropdown-menu'>" +
                "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='div'>" + locale.font_styles.normal + "</a></li>" +
                "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h1'>" + locale.font_styles.h1 + "</a></li>" +
                "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h2'>" + locale.font_styles.h2 + "</a></li>" +
                "<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h3'>" + locale.font_styles.h3 + "</a></li>" +
                "</ul>" +
                "</li>";
        },

        "emphasis": function (locale) {
            return "<li>" +
                "<div class='btn-group'>" +
                "<a class='btn' data-wysihtml5-command='bold' title='CTRL+B'>" + locale.emphasis.bold + "</a>" +
                "<a class='btn' data-wysihtml5-command='italic' title='CTRL+I'>" + locale.emphasis.italic + "</a>" +
                "<a class='btn' data-wysihtml5-command='underline' title='CTRL+U'>" + locale.emphasis.underline + "</a>" +
                "</div>" +
                "</li>";
        },

        "lists": function (locale) {
            return "<li>" +
                "<div class='btn-group'>" +
                "<a class='btn' data-wysihtml5-command='insertUnorderedList' title='" + locale.lists.unordered + "'><i class='icon-list'></i></a>" +
                "<a class='btn' data-wysihtml5-command='insertOrderedList' title='" + locale.lists.ordered + "'><i class='icon-th-list'></i></a>" +
                "<a class='btn' data-wysihtml5-command='Outdent' title='" + locale.lists.outdent + "'><i class='icon-indent-right'></i></a>" +
                "<a class='btn' data-wysihtml5-command='Indent' title='" + locale.lists.indent + "'><i class='icon-indent-left'></i></a>" +
                "</div>" +
                "</li>";
        },

        "link": function (locale) {
            return "<li>" +
                "<div class='bootstrap-wysihtml5-insert-link-modal modal hide fade'>" +
                "<div class='modal-header'>" +
                "<a class='close' data-dismiss='modal'>&times;</a>" +
                "<h3>" + locale.link.insert + "</h3>" +
                "</div>" +
                "<div class='modal-body'>" +
                "<input value='http://' class='bootstrap-wysihtml5-insert-link-url input-xlarge'>" +
                "</div>" +
                "<div class='modal-footer'>" +
                "<a href='#' class='btn' data-dismiss='modal'>" + locale.link.cancel + "</a>" +
                "<a href='#' class='btn btn-primary' data-dismiss='modal'>" + locale.link.insert + "</a>" +
                "</div>" +
                "</div>" +
                "<a class='btn' data-wysihtml5-command='createLink' title='" + locale.link.insert + "'><i class='icon-share'></i></a>" +
                "</li>";
        },

        "image": function (locale) {
            return "<li>" +
                "<div class='bootstrap-wysihtml5-insert-image-modal modal hide fade'>" +
                "<div class='modal-header'>" +
                "<a class='close' data-dismiss='modal'>&times;</a>" +
                "<h3>" + locale.image.insert + "</h3>" +
                "</div>" +
                "<div class='modal-body'>" +
                "<input value='http://' class='bootstrap-wysihtml5-insert-image-url input-xlarge'>" +
                "</div>" +
                "<div class='modal-footer'>" +
                "<a href='#' class='btn' data-dismiss='modal'>" + locale.image.cancel + "</a>" +
                "<a href='#' class='btn btn-primary' data-dismiss='modal'>" + locale.image.insert + "</a>" +
                "</div>" +
                "</div>" +
                "<a class='btn' data-wysihtml5-command='insertImage' title='" + locale.image.insert + "'><i class='icon-picture'></i></a>" +
                "</li>";
        },

        "html": function (locale) {
            return "<li>" +
                "<div class='btn-group'>" +
                "<a class='btn' data-wysihtml5-action='change_view' title='" + locale.html.edit + "'><i class='icon-pencil'></i></a>" +
                "</div>" +
                "</li>";
        },

        "color": function (locale) {
            return "<li class='dropdown'>" +
                "<a class='btn dropdown-toggle' data-toggle='dropdown' href='#'>" +
                "<span class='current-color'>" + locale.colours.black + "</span>&nbsp;<b class='caret'></b>" +
                "</a>" +
                "<ul class='dropdown-menu'>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='black'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='black'>" + locale.colours.black + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='silver'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='silver'>" + locale.colours.silver + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='gray'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='gray'>" + locale.colours.gray + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='maroon'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='maroon'>" + locale.colours.maroon + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='red'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='red'>" + locale.colours.red + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='purple'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='purple'>" + locale.colours.purple + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='green'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='green'>" + locale.colours.green + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='olive'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='olive'>" + locale.colours.olive + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='navy'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='navy'>" + locale.colours.navy + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='blue'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='blue'>" + locale.colours.blue + "</a></li>" +
                "<li><div class='wysihtml5-colors' data-wysihtml5-command-value='orange'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='orange'>" + locale.colours.orange + "</a></li>" +
                "</ul>" +
                "</li>";
        }
    };

    var templates = function (key, locale) {
        return tpl[key](locale);
    };


    var Wysihtml5 = function (el, options) {
        this.el = el;
        var toolbarOpts = options || defaultOptions;
        for (var t in toolbarOpts.customTemplates) {
            tpl[t] = toolbarOpts.customTemplates[t];
        }
        this.toolbar = this.createToolbar(el, toolbarOpts);
        this.editor = this.createEditor(options);

        window.editor = this.editor;

        $('iframe.wysihtml5-sandbox').each(function (i, el) {
            $(el.contentWindow).off('focus.wysihtml5').on({
                'focus.wysihtml5': function () {
                    $('li.dropdown').removeClass('open');
                }
            });
        });
    };

    Wysihtml5.prototype = {

        constructor: Wysihtml5,

        createEditor: function (options) {
            options = options || {};
            options.toolbar = this.toolbar[0];

            var editor = new wysi.Editor(this.el[0], options);

            if (options && options.events) {
                for (var eventName in options.events) {
                    editor.on(eventName, options.events[eventName]);
                }
            }
            return editor;
        },

        createToolbar: function (el, options) {
            var self = this;
            var toolbar = $("<ul/>", {
                'class': "wysihtml5-toolbar",
                'style': "display:none"
            });
            var culture = options.locale || defaultOptions.locale || "en";
            for (var key in defaultOptions) {
                var value = false;

                if (options[key] !== undefined) {
                    if (options[key] === true) {
                        value = true;
                    }
                } else {
                    value = defaultOptions[key];
                }

                if (value === true) {
                    toolbar.append(templates(key, locale[culture]));

                    if (key === "html") {
                        this.initHtml(toolbar);
                    }

                    if (key === "link") {
                        this.initInsertLink(toolbar);
                    }

                    if (key === "image") {
                        this.initInsertImage(toolbar);
                    }
                }
            }

            if (options.toolbar) {
                for (key in options.toolbar) {
                    toolbar.append(options.toolbar[key]);
                }
            }

            toolbar.find("a[data-wysihtml5-command='formatBlock']").click(function (e) {
                var target = e.target || e.srcElement;
                var el = $(target);
                self.toolbar.find('.current-font').text(el.html());
            });

            toolbar.find("a[data-wysihtml5-command='foreColor']").click(function (e) {
                var target = e.target || e.srcElement;
                var el = $(target);
                self.toolbar.find('.current-color').text(el.html());
            });

            this.el.before(toolbar);

            return toolbar;
        },

        initHtml: function (toolbar) {
            var changeViewSelector = "a[data-wysihtml5-action='change_view']";
            toolbar.find(changeViewSelector).click(function (e) {
                toolbar.find('a.btn').not(changeViewSelector).toggleClass('disabled');
            });
        },

        initInsertImage: function (toolbar) {
            var self = this;
            var insertImageModal = toolbar.find('.bootstrap-wysihtml5-insert-image-modal');
            var urlInput = insertImageModal.find('.bootstrap-wysihtml5-insert-image-url');
            var insertButton = insertImageModal.find('a.btn-primary');
            var initialValue = urlInput.val();

            var insertImage = function () {
                var url = urlInput.val();
                urlInput.val(initialValue);
                self.editor.currentView.element.focus();
                self.editor.composer.commands.exec("insertImage", url);
            };

            urlInput.keypress(function (e) {
                if (e.which == 13) {
                    insertImage();
                    insertImageModal.modal('hide');
                }
            });

            insertButton.click(insertImage);

            insertImageModal.on('shown', function () {
                urlInput.focus();
            });

            insertImageModal.on('hide', function () {
                self.editor.currentView.element.focus();
            });

            toolbar.find('a[data-wysihtml5-command=insertImage]').click(function () {
                var activeButton = $(this).hasClass("wysihtml5-command-active");

                if (!activeButton) {
                    insertImageModal.modal('show');
                    insertImageModal.on('click.dismiss.modal', '[data-dismiss="modal"]', function (e) {
                        e.stopPropagation();
                    });
                    return false;
                }
                else {
                    return true;
                }
            });
        },

        initInsertLink: function (toolbar) {
            var self = this;
            var insertLinkModal = toolbar.find('.bootstrap-wysihtml5-insert-link-modal');
            var urlInput = insertLinkModal.find('.bootstrap-wysihtml5-insert-link-url');
            var insertButton = insertLinkModal.find('a.btn-primary');
            var initialValue = urlInput.val();

            var insertLink = function () {
                var url = urlInput.val();
                urlInput.val(initialValue);
                self.editor.currentView.element.focus();
                self.editor.composer.commands.exec("createLink", {
                    href: url,
                    target: "_blank",
                    rel: "nofollow"
                });
            };
            var pressedEnter = false;

            urlInput.keypress(function (e) {
                if (e.which == 13) {
                    insertLink();
                    insertLinkModal.modal('hide');
                }
            });

            insertButton.click(insertLink);

            insertLinkModal.on('shown', function () {
                urlInput.focus();
            });

            insertLinkModal.on('hide', function () {
                self.editor.currentView.element.focus();
            });

            toolbar.find('a[data-wysihtml5-command=createLink]').click(function () {
                var activeButton = $(this).hasClass("wysihtml5-command-active");

                if (!activeButton) {
                    insertLinkModal.appendTo('body').modal('show');
                    insertLinkModal.on('click.dismiss.modal', '[data-dismiss="modal"]', function (e) {
                        e.stopPropagation();
                    });
                    return false;
                }
                else {
                    return true;
                }
            });
        }
    };

    // these define our public api
    var methods = {
        resetDefaults: function () {
            $.fn.wysihtml5.defaultOptions = $.extend(true, {}, $.fn.wysihtml5.defaultOptionsCache);
        },
        bypassDefaults: function (options) {
            return this.each(function () {
                var $this = $(this);
                $this.data('wysihtml5', new Wysihtml5($this, options));
            });
        },
        shallowExtend: function (options) {
            var settings = $.extend({}, $.fn.wysihtml5.defaultOptions, options || {});
            var that = this;
            return methods.bypassDefaults.apply(that, [settings]);
        },
        deepExtend: function (options) {
            var settings = $.extend(true, {}, $.fn.wysihtml5.defaultOptions, options || {});
            var that = this;
            return methods.bypassDefaults.apply(that, [settings]);
        },
        init: function (options) {
            var that = this;
            return methods.shallowExtend.apply(that, [options]);
        }
    };

    $.fn.wysihtml5 = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.wysihtml5');
        }
    };

    $.fn.wysihtml5.Constructor = Wysihtml5;

    var defaultOptions = $.fn.wysihtml5.defaultOptions = {
        "font-styles": true,
        "color": false,
        "emphasis": true,
        "lists": true,
        "html": false,
        "link": true,
        "image": true,
        events: {},
        parserRules: {
            classes: {
                // (path_to_project/lib/css/wysiwyg-color.css)
                "wysiwyg-color-silver": 1,
                "wysiwyg-color-gray": 1,
                "wysiwyg-color-white": 1,
                "wysiwyg-color-maroon": 1,
                "wysiwyg-color-red": 1,
                "wysiwyg-color-purple": 1,
                "wysiwyg-color-fuchsia": 1,
                "wysiwyg-color-green": 1,
                "wysiwyg-color-lime": 1,
                "wysiwyg-color-olive": 1,
                "wysiwyg-color-yellow": 1,
                "wysiwyg-color-navy": 1,
                "wysiwyg-color-blue": 1,
                "wysiwyg-color-teal": 1,
                "wysiwyg-color-aqua": 1,
                "wysiwyg-color-orange": 1,
            },
            tags: {
                "b": {},
                "i": {},
                "br": {},
                "ol": {},
                "ul": {},
                "li": {},
                "h1": {},
                "h2": {},
                "h3": {},
                "blockquote": {},
                "u": 1,
                "img": {
                    "check_attributes": {
                        "width": "numbers",
                        "alt": "alt",
                        "src": "url",
                        "height": "numbers"
                    }
                },
                "a": {
                    set_attributes: {
                        target: "_blank",
                        rel: "nofollow"
                    },
                    check_attributes: {
                        href: "url" // important to avoid XSS
                    }
                },
                "span": 1,
                "div": 1
            }
        },
        stylesheets: ["./lib/css/wysiwyg-color.css"], // (path_to_project/lib/css/wysiwyg-color.css)
        locale: "en"
    };

    if (typeof $.fn.wysihtml5.defaultOptionsCache === 'undefined') {
        $.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, $.fn.wysihtml5.defaultOptions);
    }

    var locale = $.fn.wysihtml5.locale = {
        en: {
            font_styles: {
                normal: "Normal text",
                h1: "Heading 1",
                h2: "Heading 2",
                h3: "Heading 3"
            },
            emphasis: {
                bold: "Bold",
                italic: "Italic",
                underline: "Underline"
            },
            lists: {
                unordered: "Unordered list",
                ordered: "Ordered list",
                outdent: "Outdent",
                indent: "Indent"
            },
            link: {
                insert: "Insert link",
                cancel: "Cancel"
            },
            image: {
                insert: "Insert image",
                cancel: "Cancel"
            },
            html: {
                edit: "Edit HTML"
            },
            colours: {
                black: "Black",
                silver: "Silver",
                gray: "Grey",
                maroon: "Maroon",
                red: "Red",
                purple: "Purple",
                green: "Green",
                olive: "Olive",
                navy: "Navy",
                blue: "Blue",
                orange: "Orange"
            }
        }
    };

}(window.jQuery, window.wysihtml5);
/* ===========================================================================================
 * Fuel UX - v2.1.1 - 2012-11-10
 * https://github.com/ExactTarget/fuelux
 * ---------------------------------------------------------
 *
 * Copyright (c) 2012 ExactTarget
 * Licensed under the MIT license.
 * =========================================================================================== */
!function (b) {
    var a = function (d, c) {
        this.$element = b(d);
        this.options = b.extend({}, b.fn.combobox.defaults, c);
        this.$element.on("click", "a", b.proxy(this.itemclicked, this));
        this.$input = this.$element.find("input")
    };
    a.prototype = {
        constructor: a, select: function (c) {
            this.$input.val(c).change();
            return this
        }, itemclicked: function (c) {
            this.select(b(c.target).text());
            b("body").click();
            c.preventDefault()
        }
    };
    b.fn.combobox = function (c) {
        return this.each(function () {
            var f = b(this);
            var e = f.data("combobox");
            var d = typeof c === "object" && c;
            if (!e) {
                f.data("combobox", (e = new a(this, d)))
            }
            if (typeof c === "string") {
                e[c]()
            }
        })
    };
    b.fn.combobox.defaults = {};
    b.fn.combobox.Constructor = a;
    b(function () {
        b("body").on("mousedown.combobox.data-api", ".combobox", function (d) {
            var c = b(this);
            if (c.data("combobox")) {
                return
            }
            c.combobox(c.data())
        })
    })
}(window.jQuery);
!function (b) {
    var a = function (d, c) {
        this.$element = b(d);
        this.$thead = this.$element.find("thead");
        this.$footer = this.$element.find("tfoot th");
        this.$footerchildren = this.$footer.children();
        this.$topheader = this.$element.find("thead th");
        this.$searchcontrol = this.$element.find(".search");
        this.$pagesize = this.$element.find(".grid-pagesize");
        this.$pageinput = this.$element.find(".grid-pager input");
        this.$pagedropdown = this.$element.find(".grid-pager .dropdown-menu");
        this.$prevpagebtn = this.$element.find(".grid-prevpage");
        this.$nextpagebtn = this.$element.find(".grid-nextpage");
        this.$pageslabel = this.$element.find(".grid-pages");
        this.$countlabel = this.$element.find(".grid-count");
        this.$startlabel = this.$element.find(".grid-start");
        this.$endlabel = this.$element.find(".grid-end");
        this.$tbody = b("<tbody>").insertAfter(this.$thead);
        this.$colheader = b("<tr>").appendTo(this.$thead);
        this.options = b.extend({}, b.fn.datagrid.defaults, c);
        this.options.dataOptions.pageSize = parseInt(this.$pagesize.val(), 10);
        this.columns = this.options.dataSource.columns();
        this.$nextpagebtn.on("click", b.proxy(this.next, this));
        this.$prevpagebtn.on("click", b.proxy(this.previous, this));
        this.$searchcontrol.on("searched cleared", b.proxy(this.searchChanged, this));
        this.$colheader.on("click", "th", b.proxy(this.headerClicked, this));
        this.$pagesize.on("change", b.proxy(this.pagesizeChanged, this));
        this.$pageinput.on("change", b.proxy(this.pageChanged, this));
        this.renderColumns();
        this.renderData()
    };
    a.prototype = {
        constructor: a, renderColumns: function () {
            var c = this;
            this.$footer.attr("colspan", this.columns.length);
            this.$topheader.attr("colspan", this.columns.length);
            var d = "";
            b.each(this.columns, function (e, f) {
                d += '<th data-property="' + f.property + '"';
                if (f.sortable) {
                    d += ' class="sortable"'
                }
                d += ">" + f.label + "</th>"
            });
            c.$colheader.append(d)
        }, updateColumns: function (c, e) {
            var d = (e === "asc") ? "icon-chevron-up" : "icon-chevron-down";
            this.$colheader.find("i").remove();
            this.$colheader.find("th").removeClass("sorted");
            b("<i>").addClass(d).appendTo(c);
            c.addClass("sorted")
        }, updatePageDropdown: function (d) {
            var e = "";
            for (var c = 1; c <= d.pages; c++) {
                e += "<li><a>" + c + "</a></li>"
            }
            this.$pagedropdown.html(e)
        }, updatePageButtons: function (c) {
            if (c.page === 1) {
                this.$prevpagebtn.attr("disabled", "disabled")
            } else {
                this.$prevpagebtn.removeAttr("disabled")
            }
            if (c.page === c.pages) {
                this.$nextpagebtn.attr("disabled", "disabled")
            } else {
                this.$nextpagebtn.removeAttr("disabled")
            }
        }, renderData: function () {
            var c = this;
            this.$tbody.html(this.placeholderRowHTML(this.options.loadingHTML));
            this.$footerchildren.hide();
            this.options.dataSource.data(this.options.dataOptions, function (f) {
                var e = (f.count === 1) ? c.options.itemText : c.options.itemsText;
                var d = "";
                c.$footerchildren.toggle(f.count > 0);
                c.$pageinput.val(f.page);
                c.$pageslabel.text(f.pages);
                c.$countlabel.text(f.count + " " + e);
                c.$startlabel.text(f.start);
                c.$endlabel.text(f.end);
                c.updatePageDropdown(f);
                c.updatePageButtons(f);
                b.each(f.data, function (g, h) {
                    d += "<tr>";
                    b.each(c.columns, function (i, j) {
                        d += "<td>" + h[j.property] + "</td>"
                    });
                    d += "</tr>"
                });
                if (!d) {
                    d = c.placeholderRowHTML("0 " + c.options.itemsText)
                }
                c.$tbody.html(d);
                c.$element.trigger("loaded")
            })
        }, placeholderRowHTML: function (c) {
            return '<tr><td style="text-align:center;padding:20px;" colspan="' + this.columns.length + '">' + c + "</td></tr>"
        }, headerClicked: function (h) {
            var c = b(h.target);
            if (!c.hasClass("sortable")) {
                return
            }
            var g = this.options.dataOptions.sortDirection;
            var d = this.options.dataOptions.sortProperty;
            var f = c.data("property");
            if (d === f) {
                this.options.dataOptions.sortDirection = (g === "asc") ? "desc" : "asc"
            } else {
                this.options.dataOptions.sortDirection = "asc";
                this.options.dataOptions.sortProperty = f
            }
            this.options.dataOptions.pageIndex = 0;
            this.updateColumns(c, this.options.dataOptions.sortDirection);
            this.renderData()
        }, pagesizeChanged: function (c) {
            this.options.dataOptions.pageSize = parseInt(b(c.target).val(), 10);
            this.options.dataOptions.pageIndex = 0;
            this.renderData()
        }, pageChanged: function (c) {
            this.options.dataOptions.pageIndex = parseInt(b(c.target).val(), 10) - 1;
            this.renderData()
        }, searchChanged: function (d, c) {
            this.options.dataOptions.search = c;
            this.options.dataOptions.pageIndex = 0;
            this.renderData()
        }, previous: function () {
            this.options.dataOptions.pageIndex--;
            this.renderData()
        }, next: function () {
            this.options.dataOptions.pageIndex++;
            this.renderData()
        }
    };
    b.fn.datagrid = function (c) {
        return this.each(function () {
            var f = b(this);
            var e = f.data("datagrid");
            var d = typeof c === "object" && c;
            if (!e) {
                f.data("datagrid", (e = new a(this, d)))
            }
            if (typeof c === "string") {
                e[c]()
            }
        })
    };
    b.fn.datagrid.defaults = {
        dataOptions: {pageIndex: 0, pageSize: 10},
        loadingHTML: '<div class="progress progress-striped active" style="width:50%;margin:auto;"><div class="bar" style="width:100%;"></div></div>',
        itemsText: "items",
        itemText: "item"
    };
    b.fn.datagrid.Constructor = a
}(window.jQuery);
!function (b) {
    var a = function (d, c) {
        this.$element = b(d);
        this.options = b.extend({}, b.fn.pillbox.defaults, c);
        this.$element.on("click", "li", b.proxy(this.itemclicked, this))
    };
    a.prototype = {
        constructor: a, items: function () {
            return this.$element.find("li").map(function () {
                var c = b(this);
                return b.extend({text: c.text()}, c.data())
            }).get()
        }, itemclicked: function (c) {
            b(c.currentTarget).remove();
            c.preventDefault()
        }
    };
    b.fn.pillbox = function (d) {
        var e;
        var c = this.each(function () {
            var h = b(this);
            var g = h.data("pillbox");
            var f = typeof d === "object" && d;
            if (!g) {
                h.data("pillbox", (g = new a(this, f)))
            }
            if (typeof d === "string") {
                e = g[d]()
            }
        });
        return (e === undefined) ? c : e
    };
    b.fn.pillbox.defaults = {};
    b.fn.pillbox.Constructor = a;
    b(function () {
        b("body").on("mousedown.pillbox.data-api", ".pillbox", function (d) {
            var c = b(this);
            if (c.data("pillbox")) {
                return
            }
            c.pillbox(c.data())
        })
    })
}(window.jQuery);
!function (b) {
    var a = function (d, c) {
        this.$element = b(d);
        this.options = b.extend({}, b.fn.search.defaults, c);
        this.$element.find("button").on("click", b.proxy(this.buttonclicked, this));
        this.$input = this.$element.find("input").on("keydown", b.proxy(this.keypress, this));
        this.$input = this.$element.find("input").on("keyup", b.proxy(this.keypressed, this));
        this.$icon = this.$element.find("i");
        this.activeSearch = ""
    };
    a.prototype = {
        constructor: a, search: function (c) {
            this.$icon.attr("class", "fontello-icon-cancel-1");
            this.activeSearch = c;
            this.$element.trigger("searched", c)
        }, clear: function () {
            this.$icon.attr("class", "icon-search");
            this.activeSearch = "";
            this.$input.val("");
            this.$element.trigger("cleared")
        }, action: function () {
            var d = this.$input.val();
            var c = d === "" || d === this.activeSearch;
            if (this.activeSearch && c) {
                this.clear()
            } else {
                if (d) {
                    this.search(d)
                }
            }
        }, buttonclicked: function (c) {
            c.preventDefault();
            if (b(c.currentTarget).is(".disabled, :disabled")) {
                return
            }
            this.action()
        }, keypress: function (c) {
            if (c.which === 13) {
                c.preventDefault()
            }
        }, keypressed: function (d) {
            var f, c;
            if (d.which === 13) {
                d.preventDefault();
                this.action()
            } else {
                f = this.$input.val();
                c = f && (f === this.activeSearch);
                this.$icon.attr("class", c ? "fontello-icon-cancel-1" : "icon-search")
            }
        }
    };
    b.fn.search = function (c) {
        return this.each(function () {
            var f = b(this);
            var e = f.data("search");
            var d = typeof c === "object" && c;
            if (!e) {
                f.data("search", (e = new a(this, d)))
            }
            if (typeof c === "string") {
                e[c]()
            }
        })
    };
    b.fn.search.defaults = {};
    b.fn.search.Constructor = a;
    b(function () {
        b("body").on("mousedown.search.data-api", ".search", function () {
            var c = b(this);
            if (c.data("search")) {
                return
            }
            c.search(c.data())
        })
    })
}(window.jQuery);
!function (b) {
    var a = function (d, c) {
        this.$element = b(d);
        this.options = b.extend({}, b.fn.spinner.defaults, c);
        this.$input = this.$element.find(".spinner-input");
        this.$element.on("keyup", this.$input, b.proxy(this.change, this));
        if (this.options.hold) {
            this.$element.on("mousedown", ".spinner-up", b.proxy(function () {
                this.startSpin(true)
            }, this));
            this.$element.on("mouseup", ".spinner-up, .spinner-down", b.proxy(this.stopSpin, this));
            this.$element.on("mouseout", ".spinner-up, .spinner-down", b.proxy(this.stopSpin, this));
            this.$element.on("mousedown", ".spinner-down", b.proxy(function () {
                this.startSpin(false)
            }, this))
        } else {
            this.$element.on("click", ".spinner-up", b.proxy(function () {
                this.step(true)
            }, this));
            this.$element.on("click", ".spinner-down", b.proxy(function () {
                this.step(false)
            }, this))
        }
        this.switches = {count: 1, enabled: true};
        if (this.options.speed === "medium") {
            this.switches.speed = 300
        } else {
            if (this.options.speed === "fast") {
                this.switches.speed = 100
            } else {
                this.switches.speed = 500
            }
        }
        this.render();
        if (this.options.disabled) {
            this.disable()
        }
    };
    a.prototype = {
        constructor: a, render: function () {
            this.$input.val(this.options.value);
            this.$input.attr("maxlength", (this.options.max + "").split("").length)
        }, change: function () {
            var c = this.$input.val();
            if (c / 1) {
                this.options.value = c / 1
            } else {
                c = c.replace(/[^0-9]/g, "");
                this.$input.val(c);
                this.options.value = c / 1
            }
            this.$element.trigger("change")
        }, stopSpin: function () {
            clearTimeout(this.switches.timeout);
            this.switches.count = 1;
            this.$element.trigger("change")
        }, startSpin: function (c) {
            if (!this.options.disabled) {
                var d = this.switches.count;
                if (d === 1) {
                    this.step(c);
                    d = 1
                } else {
                    if (d < 3) {
                        d = 1.5
                    } else {
                        if (d < 8) {
                            d = 2.5
                        } else {
                            d = 4
                        }
                    }
                }
                this.switches.timeout = setTimeout(b.proxy(function () {
                    this.iterator(c)
                }, this), this.switches.speed / d);
                this.switches.count++
            }
        }, iterator: function (c) {
            this.step(c);
            this.startSpin(c)
        }, step: function (d) {
            var f = this.options.value;
            var e = d ? this.options.max : this.options.min;
            if ((d ? f < e : f > e)) {
                var c = f + (d ? 1 : -1) * this.options.step;
                if (d ? c > e : c < e) {
                    this.value(e)
                } else {
                    this.value(c)
                }
            }
        }, value: function (c) {
            if (typeof c !== "undefined") {
                this.options.value = c;
                this.$input.val(c);
                return this
            } else {
                return this.options.value
            }
        }, disable: function () {
            this.options.disabled = true;
            this.$input.attr("disabled", "");
            this.$element.find("button").addClass("disabled")
        }, enable: function () {
            this.options.disabled = false;
            this.$input.removeAttr("disabled");
            this.$element.find("button").removeClass("disabled")
        }
    };
    b.fn.spinner = function (d, f) {
        var e;
        var c = this.each(function () {
            var i = b(this);
            var h = i.data("spinner");
            var g = typeof d === "object" && d;
            if (!h) {
                i.data("spinner", (h = new a(this, g)))
            }
            if (typeof d === "string") {
                e = h[d](f)
            }
        });
        return (e === undefined) ? c : e
    };
    b.fn.spinner.defaults = {value: 1, min: 1, max: 999, step: 1, hold: true, speed: "medium", disabled: false};
    b.fn.spinner.Constructor = a;
    b(function () {
        b("body").on("mousedown.spinner.data-api", ".spinner", function (d) {
            var c = b(this);
            if (c.data(".spinner")) {
                return
            }
            c.spinner(c.data())
        })
    })
}(window.jQuery);
/* =========================================================
 * bootstrap-datepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 * Improvements by Andrew Rowls
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

!function ($) {

    function UTCDate() {
        return new Date(Date.UTC.apply(Date, arguments));
    }

    // Picker object

    var Datepicker = function (element, options) {
        var that = this;

        this.element = $(element);
        this.language = options.language || this.element.data('date-language') || "en";
        this.language = this.language in dates ? this.language : "en";
        this.format = DPGlobal.parseFormat(options.format || this.element.data('date-format') || 'mm/dd/yyyy');
        this.isInline = false;
        this.isInput = this.element.is('input');
        this.component = this.element.is('.date') ? this.element.find('.add-on') : false;
        this.hasInput = this.component && this.element.find('input').length;
        if (this.component && this.component.length === 0)
            this.component = false;

        if (this.isInput) {   //single input
            this.element.on({
                focus: $.proxy(this.show, this),
                keyup: $.proxy(this.update, this),
                keydown: $.proxy(this.keydown, this)
            });
        } else if (this.component && this.hasInput) {  //component: input + button
            // For components that are not readonly, allow keyboard nav
            this.element.find('input').on({
                focus: $.proxy(this.show, this),
                keyup: $.proxy(this.update, this),
                keydown: $.proxy(this.keydown, this)
            });

            this.component.on('click', $.proxy(this.show, this));
        } else if (this.element.is('div')) {  //inline datepicker
            this.isInline = true;
        } else {
            this.element.on('click', $.proxy(this.show, this));
        }

        this.picker = $(DPGlobal.template)
            .appendTo(this.isInline ? this.element : 'body')
            .on({
                click: $.proxy(this.click, this),
                mousedown: $.proxy(this.mousedown, this)
            });

        if (this.isInline) {
            this.picker.addClass('datepicker-inline');
        } else {
            this.picker.addClass('dropdown-menu');
        }

        $(document).on('mousedown', function (e) {
            // Clicked outside the datepicker, hide it
            if ($(e.target).closest('.datepicker').length == 0) {
                that.hide();
            }
        });

        this.autoclose = false;
        if ('autoclose' in options) {
            this.autoclose = options.autoclose;
        } else if ('dateAutoclose' in this.element.data()) {
            this.autoclose = this.element.data('date-autoclose');
        }

        this.keyboardNavigation = true;
        if ('keyboardNavigation' in options) {
            this.keyboardNavigation = options.keyboardNavigation;
        } else if ('dateKeyboardNavigation' in this.element.data()) {
            this.keyboardNavigation = this.element.data('date-keyboard-navigation');
        }

        switch (options.startView || this.element.data('date-start-view')) {
            case 2:
            case 'decade':
                this.viewMode = this.startViewMode = 2;
                break;
            case 1:
            case 'year':
                this.viewMode = this.startViewMode = 1;
                break;
            case 0:
            case 'month':
            default:
                this.viewMode = this.startViewMode = 0;
                break;
        }

        this.weekStart = ((options.weekStart || this.element.data('date-weekstart') || dates[this.language].weekStart || 0) % 7);
        this.weekEnd = ((this.weekStart + 6) % 7);
        this.startDate = -Infinity;
        this.endDate = Infinity;
        this.setStartDate(options.startDate || this.element.data('date-startdate'));
        this.setEndDate(options.endDate || this.element.data('date-enddate'));
        this.fillDow();
        this.fillMonths();
        this.update();
        this.showMode();

        if (this.isInline) {
            this.show();
        }
    };

    Datepicker.prototype = {
        constructor: Datepicker,

        show: function (e) {
            this.picker.show();
            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
            this.update();
            this.place();
            $(window).on('resize', $.proxy(this.place, this));
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            this.element.trigger({
                type: 'show',
                date: this.date
            });
        },

        hide: function (e) {
            if (this.isInline) return;
            this.picker.hide();
            $(window).off('resize', this.place);
            this.viewMode = this.startViewMode;
            this.showMode();
            if (!this.isInput) {
                $(document).off('mousedown', this.hide);
            }
            if (e && e.currentTarget.value)
                this.setValue();
            this.element.trigger({
                type: 'hide',
                date: this.date
            });
        },

        setValue: function () {
            var formatted = this.getFormattedDate();
            if (!this.isInput) {
                if (this.component) {
                    this.element.find('input').prop('value', formatted);
                }
                this.element.data('date', formatted);
            } else {
                this.element.prop('value', formatted);
            }
        },

        getFormattedDate: function (format) {
            if (format == undefined) format = this.format;
            return DPGlobal.formatDate(this.date, format, this.language);
        },

        setStartDate: function (startDate) {
            this.startDate = startDate || -Infinity;
            if (this.startDate !== -Infinity) {
                this.startDate = DPGlobal.parseDate(this.startDate, this.format, this.language);
            }
            this.update();
            this.updateNavArrows();
        },

        setEndDate: function (endDate) {
            this.endDate = endDate || Infinity;
            if (this.endDate !== Infinity) {
                this.endDate = DPGlobal.parseDate(this.endDate, this.format, this.language);
            }
            this.update();
            this.updateNavArrows();
        },

        place: function () {
            if (this.isInline) return;
            var zIndex = parseInt(this.element.parents().filter(function () {
                    return $(this).css('z-index') != 'auto';
                }).first().css('z-index')) + 10;
            var offset = this.component ? this.component.offset() : this.element.offset();
            this.picker.css({
                top: offset.top + this.height,
                left: offset.left,
                zIndex: zIndex
            });
        },

        update: function () {
            var date, fromArgs = false;
            if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {
                date = arguments[0];
                fromArgs = true;
            } else {
                date = this.isInput ? this.element.prop('value') : this.element.data('date') || this.element.find('input').prop('value');
            }

            this.date = DPGlobal.parseDate(date, this.format, this.language);

            if (fromArgs) this.setValue();

            if (this.date < this.startDate) {
                this.viewDate = new Date(this.startDate);
            } else if (this.date > this.endDate) {
                this.viewDate = new Date(this.endDate);
            } else {
                this.viewDate = new Date(this.date);
            }
            this.fill();
        },

        fillDow: function () {
            var dowCnt = this.weekStart;
            var html = '<tr>';
            while (dowCnt < this.weekStart + 7) {
                html += '<th class="dow">' + dates[this.language].daysMin[(dowCnt++) % 7] + '</th>';
            }
            html += '</tr>';
            this.picker.find('.datepicker-days thead').append(html);
        },

        fillMonths: function () {
            var html = '';
            var i = 0
            while (i < 12) {
                html += '<span class="month">' + dates[this.language].monthsShort[i++] + '</span>';
            }
            this.picker.find('.datepicker-months td').html(html);
        },

        fill: function () {
            var d = new Date(this.viewDate),
                year = d.getUTCFullYear(),
                month = d.getUTCMonth(),
                startYear = this.startDate !== -Infinity ? this.startDate.getUTCFullYear() : -Infinity,
                startMonth = this.startDate !== -Infinity ? this.startDate.getUTCMonth() : -Infinity,
                endYear = this.endDate !== Infinity ? this.endDate.getUTCFullYear() : Infinity,
                endMonth = this.endDate !== Infinity ? this.endDate.getUTCMonth() : Infinity,
                currentDate = this.date.valueOf();
            this.picker.find('.datepicker-days th:eq(1)')
                .text(dates[this.language].months[month] + ' ' + year);
            this.updateNavArrows();
            this.fillMonths();
            var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),
                day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
            prevMonth.setUTCDate(day);
            prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.weekStart + 7) % 7);
            var nextMonth = new Date(prevMonth);
            nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
            nextMonth = nextMonth.valueOf();
            var html = [];
            var clsName;
            while (prevMonth.valueOf() < nextMonth) {
                if (prevMonth.getUTCDay() == this.weekStart) {
                    html.push('<tr>');
                }
                clsName = '';
                if (prevMonth.getUTCFullYear() < year || (prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() < month)) {
                    clsName += ' old';
                } else if (prevMonth.getUTCFullYear() > year || (prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() > month)) {
                    clsName += ' new';
                }
                if (prevMonth.valueOf() == currentDate) {
                    clsName += ' active';
                }
                if (prevMonth.valueOf() < this.startDate || prevMonth.valueOf() > this.endDate) {
                    clsName += ' disabled';
                }
                html.push('<td class="day' + clsName + '">' + prevMonth.getUTCDate() + '</td>');
                if (prevMonth.getUTCDay() == this.weekEnd) {
                    html.push('</tr>');
                }
                prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
            }
            this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
            var currentYear = this.date.getUTCFullYear();

            var months = this.picker.find('.datepicker-months')
                .find('th:eq(1)')
                .text(year)
                .end()
                .find('span').removeClass('active');
            if (currentYear == year) {
                months.eq(this.date.getUTCMonth()).addClass('active');
            }
            if (year < startYear || year > endYear) {
                months.addClass('disabled');
            }
            if (year == startYear) {
                months.slice(0, startMonth).addClass('disabled');
            }
            if (year == endYear) {
                months.slice(endMonth + 1).addClass('disabled');
            }

            html = '';
            year = parseInt(year / 10, 10) * 10;
            var yearCont = this.picker.find('.datepicker-years')
                .find('th:eq(1)')
                .text(year + '-' + (year + 9))
                .end()
                .find('td');
            year -= 1;
            for (var i = -1; i < 11; i++) {
                html += '<span class="year' + (i == -1 || i == 10 ? ' old' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        updateNavArrows: function () {
            var d = new Date(this.viewDate),
                year = d.getUTCFullYear(),
                month = d.getUTCMonth();
            switch (this.viewMode) {
                case 0:
                    if (this.startDate !== -Infinity && year <= this.startDate.getUTCFullYear() && month <= this.startDate.getUTCMonth()) {
                        this.picker.find('.prev').css({visibility: 'hidden'});
                    } else {
                        this.picker.find('.prev').css({visibility: 'visible'});
                    }
                    if (this.endDate !== Infinity && year >= this.endDate.getUTCFullYear() && month >= this.endDate.getUTCMonth()) {
                        this.picker.find('.next').css({visibility: 'hidden'});
                    } else {
                        this.picker.find('.next').css({visibility: 'visible'});
                    }
                    break;
                case 1:
                case 2:
                    if (this.startDate !== -Infinity && year <= this.startDate.getUTCFullYear()) {
                        this.picker.find('.prev').css({visibility: 'hidden'});
                    } else {
                        this.picker.find('.prev').css({visibility: 'visible'});
                    }
                    if (this.endDate !== Infinity && year >= this.endDate.getUTCFullYear()) {
                        this.picker.find('.next').css({visibility: 'hidden'});
                    } else {
                        this.picker.find('.next').css({visibility: 'visible'});
                    }
                    break;
            }
        },

        click: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var target = $(e.target).closest('span, td, th');
            if (target.length == 1) {
                switch (target[0].nodeName.toLowerCase()) {
                    case 'th':
                        switch (target[0].className) {
                            case 'switch':
                                this.showMode(1);
                                break;
                            case 'prev':
                            case 'next':
                                var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
                                switch (this.viewMode) {
                                    case 0:
                                        this.viewDate = this.moveMonth(this.viewDate, dir);
                                        break;
                                    case 1:
                                    case 2:
                                        this.viewDate = this.moveYear(this.viewDate, dir);
                                        break;
                                }
                                this.fill();
                                break;
                        }
                        break;
                    case 'span':
                        if (!target.is('.disabled')) {
                            this.viewDate.setUTCDate(1);
                            if (target.is('.month')) {
                                var month = target.parent().find('span').index(target);
                                this.viewDate.setUTCMonth(month);
                                this.element.trigger({
                                    type: 'changeMonth',
                                    date: this.viewDate
                                });
                            } else {
                                var year = parseInt(target.text(), 10) || 0;
                                this.viewDate.setUTCFullYear(year);
                                this.element.trigger({
                                    type: 'changeYear',
                                    date: this.viewDate
                                });
                            }
                            this.showMode(-1);
                            this.fill();
                        }
                        break;
                    case 'td':
                        if (target.is('.day') && !target.is('.disabled')) {
                            var day = parseInt(target.text(), 10) || 1;
                            var year = this.viewDate.getUTCFullYear(),
                                month = this.viewDate.getUTCMonth();
                            if (target.is('.old')) {
                                if (month == 0) {
                                    month = 11;
                                    year -= 1;
                                } else {
                                    month -= 1;
                                }
                            } else if (target.is('.new')) {
                                if (month == 11) {
                                    month = 0;
                                    year += 1;
                                } else {
                                    month += 1;
                                }
                            }
                            this.date = UTCDate(year, month, day, 0, 0, 0, 0);
                            this.viewDate = UTCDate(year, month, day, 0, 0, 0, 0);
                            this.fill();
                            this.setValue();
                            this.element.trigger({
                                type: 'changeDate',
                                date: this.date
                            });
                            var element;
                            if (this.isInput) {
                                element = this.element;
                            } else if (this.component) {
                                element = this.element.find('input');
                            }
                            if (element) {
                                element.change();
                                if (this.autoclose) {
                                    this.hide();
                                }
                            }
                        }
                        break;
                }
            }
        },

        moveMonth: function (date, dir) {
            if (!dir) return date;
            var new_date = new Date(date.valueOf()),
                day = new_date.getUTCDate(),
                month = new_date.getUTCMonth(),
                mag = Math.abs(dir),
                new_month, test;
            dir = dir > 0 ? 1 : -1;
            if (mag == 1) {
                test = dir == -1
                    // If going back one month, make sure month is not current month
                    // (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
                    ? function () {
                    return new_date.getUTCMonth() == month;
                }
                    // If going forward one month, make sure month is as expected
                    // (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
                    : function () {
                    return new_date.getUTCMonth() != new_month;
                };
                new_month = month + dir;
                new_date.setUTCMonth(new_month);
                // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
                if (new_month < 0 || new_month > 11)
                    new_month = (new_month + 12) % 12;
            } else {
                // For magnitudes >1, move one month at a time...
                for (var i = 0; i < mag; i++)
                    // ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
                    new_date = this.moveMonth(new_date, dir);
                // ...then reset the day, keeping it in the new month
                new_month = new_date.getUTCMonth();
                new_date.setUTCDate(day);
                test = function () {
                    return new_month != new_date.getUTCMonth();
                };
            }
            // Common date-resetting loop -- if date is beyond end of month, make it
            // end of month
            while (test()) {
                new_date.setUTCDate(--day);
                new_date.setUTCMonth(new_month);
            }
            return new_date;
        },

        moveYear: function (date, dir) {
            return this.moveMonth(date, dir * 12);
        },

        dateWithinRange: function (date) {
            return date >= this.startDate && date <= this.endDate;
        },

        keydown: function (e) {
            if (this.picker.is(':not(:visible)')) {
                if (e.keyCode == 27) // allow escape to hide and re-show picker
                    this.show();
                return;
            }
            var dateChanged = false,
                dir, day, month,
                newDate, newViewDate;
            switch (e.keyCode) {
                case 27: // escape
                    this.hide();
                    e.preventDefault();
                    break;
                case 37: // left
                case 39: // right
                    if (!this.keyboardNavigation) break;
                    dir = e.keyCode == 37 ? -1 : 1;
                    if (e.ctrlKey) {
                        newDate = this.moveYear(this.date, dir);
                        newViewDate = this.moveYear(this.viewDate, dir);
                    } else if (e.shiftKey) {
                        newDate = this.moveMonth(this.date, dir);
                        newViewDate = this.moveMonth(this.viewDate, dir);
                    } else {
                        newDate = new Date(this.date);
                        newDate.setUTCDate(this.date.getUTCDate() + dir);
                        newViewDate = new Date(this.viewDate);
                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);
                    }
                    if (this.dateWithinRange(newDate)) {
                        this.date = newDate;
                        this.viewDate = newViewDate;
                        this.setValue();
                        this.update();
                        e.preventDefault();
                        dateChanged = true;
                    }
                    break;
                case 38: // up
                case 40: // down
                    if (!this.keyboardNavigation) break;
                    dir = e.keyCode == 38 ? -1 : 1;
                    if (e.ctrlKey) {
                        newDate = this.moveYear(this.date, dir);
                        newViewDate = this.moveYear(this.viewDate, dir);
                    } else if (e.shiftKey) {
                        newDate = this.moveMonth(this.date, dir);
                        newViewDate = this.moveMonth(this.viewDate, dir);
                    } else {
                        newDate = new Date(this.date);
                        newDate.setUTCDate(this.date.getUTCDate() + dir * 7);
                        newViewDate = new Date(this.viewDate);
                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);
                    }
                    if (this.dateWithinRange(newDate)) {
                        this.date = newDate;
                        this.viewDate = newViewDate;
                        this.setValue();
                        this.update();
                        e.preventDefault();
                        dateChanged = true;
                    }
                    break;
                case 13: // enter
                    this.hide();
                    e.preventDefault();
                    break;
                case 9: // tab
                    this.hide();
                    break;
            }
            if (dateChanged) {
                this.element.trigger({
                    type: 'changeDate',
                    date: this.date
                });
                var element;
                if (this.isInput) {
                    element = this.element;
                } else if (this.component) {
                    element = this.element.find('input');
                }
                if (element) {
                    element.change();
                }
            }
        },

        showMode: function (dir) {
            if (dir) {
                this.viewMode = Math.max(0, Math.min(2, this.viewMode + dir));
            }
            this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).show();
            this.updateNavArrows();
        }
    };

    $.fn.datepicker = function (option) {
        var args = Array.apply(null, arguments);
        args.shift();
        return this.each(function () {
            var $this = $(this),
                data = $this.data('datepicker'),
                options = typeof option == 'object' && option;
            if (!data) {
                $this.data('datepicker', (data = new Datepicker(this, $.extend({}, $.fn.datepicker.defaults, options))));
            }
            if (typeof option == 'string' && typeof data[option] == 'function') {
                data[option].apply(data, args);
            }
        });
    };

    $.fn.datepicker.defaults = {};
    $.fn.datepicker.Constructor = Datepicker;
    var dates = $.fn.datepicker.dates = {
        en: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
            daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        }
    }

    var DPGlobal = {
        modes: [
            {
                clsName: 'days',
                navFnc: 'Month',
                navStep: 1
            },
            {
                clsName: 'months',
                navFnc: 'FullYear',
                navStep: 1
            },
            {
                clsName: 'years',
                navFnc: 'FullYear',
                navStep: 10
            }],
        isLeapYear: function (year) {
            return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0))
        },
        getDaysInMonth: function (year, month) {
            return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
        },
        validParts: /dd?|mm?|MM?|yy(?:yy)?/g,
        nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\r]+/g,
        parseFormat: function (format) {
            // IE treats \0 as a string end in inputs (truncating the value),
            // so it's a bad format delimiter, anyway
            var separators = format.replace(this.validParts, '\0').split('\0'),
                parts = format.match(this.validParts);
            if (!separators || !separators.length || !parts || parts.length == 0) {
                throw new Error("Invalid date format.");
            }
            return {separators: separators, parts: parts};
        },
        parseDate: function (date, format, language) {
            if (date instanceof Date) return date;
            if (/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(date)) {
                var part_re = /([-+]\d+)([dmwy])/,
                    parts = date.match(/([-+]\d+)([dmwy])/g),
                    part, dir;
                date = new Date();
                for (var i = 0; i < parts.length; i++) {
                    part = part_re.exec(parts[i]);
                    dir = parseInt(part[1]);
                    switch (part[2]) {
                        case 'd':
                            date.setUTCDate(date.getUTCDate() + dir);
                            break;
                        case 'm':
                            date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
                            break;
                        case 'w':
                            date.setUTCDate(date.getUTCDate() + dir * 7);
                            break;
                        case 'y':
                            date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
                            break;
                    }
                }
                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
            }
            var parts = date && date.match(this.nonpunctuation) || [],
                date = new Date(),
                parsed = {},
                setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
                setters_map = {
                    yyyy: function (d, v) {
                        return d.setUTCFullYear(v);
                    },
                    yy: function (d, v) {
                        return d.setUTCFullYear(2000 + v);
                    },
                    m: function (d, v) {
                        v -= 1;
                        while (v < 0) v += 12;
                        v %= 12;
                        d.setUTCMonth(v);
                        while (d.getUTCMonth() != v)
                            d.setUTCDate(d.getUTCDate() - 1);
                        return d;
                    },
                    d: function (d, v) {
                        return d.setUTCDate(v);
                    }
                },
                val, filtered, part;
            setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
            setters_map['dd'] = setters_map['d'];
            date = UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
            if (parts.length == format.parts.length) {
                for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
                    val = parseInt(parts[i], 10);
                    part = format.parts[i];
                    if (isNaN(val)) {
                        switch (part) {
                            case 'MM':
                                filtered = $(dates[language].months).filter(function () {
                                    var m = this.slice(0, parts[i].length),
                                        p = parts[i].slice(0, m.length);
                                    return m == p;
                                });
                                val = $.inArray(filtered[0], dates[language].months) + 1;
                                break;
                            case 'M':
                                filtered = $(dates[language].monthsShort).filter(function () {
                                    var m = this.slice(0, parts[i].length),
                                        p = parts[i].slice(0, m.length);
                                    return m == p;
                                });
                                val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
                                break;
                        }
                    }
                    parsed[part] = val;
                }
                for (var i = 0, s; i < setters_order.length; i++) {
                    s = setters_order[i];
                    if (s in parsed)
                        setters_map[s](date, parsed[s])
                }
            }
            return date;
        },
        formatDate: function (date, format, language) {
            var val = {
                d: date.getUTCDate(),
                m: date.getUTCMonth() + 1,
                M: dates[language].monthsShort[date.getUTCMonth()],
                MM: dates[language].months[date.getUTCMonth()],
                yy: date.getUTCFullYear().toString().substring(2),
                yyyy: date.getUTCFullYear()
            };
            val.dd = (val.d < 10 ? '0' : '') + val.d;
            val.mm = (val.m < 10 ? '0' : '') + val.m;
            var date = [],
                seps = $.extend([], format.separators);
            for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
                if (seps.length)
                    date.push(seps.shift())
                date.push(val[format.parts[i]]);
            }
            return date.join('');
        },
        headTemplate: '<thead>' +
        '<tr>' +
        '<th class="prev"><i class="fontello-icon-left-open"></th>' +
        '<th colspan="5" class="switch"></th>' +
        '<th class="next"><i class="fontello-icon-right-open"></th>' +
        '</tr>' +
        '</thead>',
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
    };
    DPGlobal.template = '<div class="datepicker">' +
        '<div class="datepicker-days">' +
        '<table class=" table-condensed">' +
        DPGlobal.headTemplate +
        '<tbody></tbody>' +
        '</table>' +
        '</div>' +
        '<div class="datepicker-months">' +
        '<table class="table-condensed">' +
        DPGlobal.headTemplate +
        DPGlobal.contTemplate +
        '</table>' +
        '</div>' +
        '<div class="datepicker-years">' +
        '<table class="table-condensed">' +
        DPGlobal.headTemplate +
        DPGlobal.contTemplate +
        '</table>' +
        '</div>' +
        '</div>';

    $.fn.datepicker.DPGlobal = DPGlobal;

}(window.jQuery);
/* =========================================================
 * bootstrap-timepicker.js
 * http://www.github.com/jdewit/bootstrap-timepicker
 * =========================================================
 * Copyright 2012
 *
 * Created By:
 * Joris de Wit @joris_dewit
 *
 * Contributions By:
 * Gilbert @mindeavor
 * Koen Punt info@koenpunt.nl
 * Nek
 * Chris Martin
 * Dominic Barnes contact@dominicbarnes.us
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

!function ($) {

    "use strict"; // jshint ;_;

    /* TIMEPICKER PUBLIC CLASS DEFINITION
     * ================================== */
    var Timepicker = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.timepicker.defaults, options, this.$element.data());
        this.minuteStep = this.options.minuteStep || this.minuteStep;
        this.secondStep = this.options.secondStep || this.secondStep;
        this.showMeridian = this.options.showMeridian || this.showMeridian;
        this.showSeconds = this.options.showSeconds || this.showSeconds;
        this.showInputs = this.options.showInputs || this.showInputs;
        this.disableFocus = this.options.disableFocus || this.disableFocus;
        this.template = this.options.template || this.template;
        this.modalBackdrop = this.options.modalBackdrop || this.modalBackdrop;
        this.defaultTime = this.options.defaultTime || this.defaultTime;
        this.open = false;
        this.init();
    };

    Timepicker.prototype = {

        constructor: Timepicker

        , init: function () {
            if (this.$element.parent().hasClass('input-append')) {
                this.$element.parent('.input-append').find('.add-on').on('click', $.proxy(this.showWidget, this));
                this.$element.on({
                    focus: $.proxy(this.highlightUnit, this),
                    click: $.proxy(this.highlightUnit, this),
                    keypress: $.proxy(this.elementKeypress, this),
                    blur: $.proxy(this.blurElement, this)
                });

            } else {
                if (this.template) {
                    this.$element.on({
                        focus: $.proxy(this.showWidget, this),
                        click: $.proxy(this.showWidget, this),
                        blur: $.proxy(this.blurElement, this)
                    });
                } else {
                    this.$element.on({
                        focus: $.proxy(this.highlightUnit, this),
                        click: $.proxy(this.highlightUnit, this),
                        keypress: $.proxy(this.elementKeypress, this),
                        blur: $.proxy(this.blurElement, this)
                    });
                }
            }


            this.$widget = $(this.getTemplate()).appendTo('body');

            this.$widget.on('click', $.proxy(this.widgetClick, this));

            if (this.showInputs) {
                this.$widget.find('input').on({
                    click: function () {
                        this.select();
                    },
                    keypress: $.proxy(this.widgetKeypress, this),
                    change: $.proxy(this.updateFromWidgetInputs, this)
                });
            }

            this.setDefaultTime(this.defaultTime);
        }

        , showWidget: function (e) {
            e.stopPropagation();
            e.preventDefault();

            if (this.open) {
                return;
            }

            this.$element.trigger('show');

            if (this.disableFocus) {
                this.$element.blur();
            }

            var pos = $.extend({}, this.$element.offset(), {
                height: this.$element[0].offsetHeight
            });

            this.updateFromElementVal();

            $('html')
                .trigger('click.timepicker.data-api')
                .one('click.timepicker.data-api', $.proxy(this.hideWidget, this));

            if (this.template === 'modal') {
                this.$widget.modal('show').on('hidden', $.proxy(this.hideWidget, this));
            } else {
                this.$widget.css({
                    top: pos.top + pos.height
                    , left: pos.left
                })

                if (!this.open) {
                    this.$widget.addClass('open');
                }
            }

            this.open = true;
            this.$element.trigger('shown');
        }

        , hideWidget: function () {
            this.$element.trigger('hide');

            if (this.template === 'modal') {
                this.$widget.modal('hide');
            } else {
                this.$widget.removeClass('open');
            }
            this.open = false;
            this.$element.trigger('hidden');
        }

        , widgetClick: function (e) {
            e.stopPropagation();
            e.preventDefault();

            var action = $(e.target).closest('a').data('action');
            if (action) {
                this[action]();
                this.update();
            }
        }

        , widgetKeypress: function (e) {
            var input = $(e.target).closest('input').attr('name');

            switch (e.keyCode) {
                case 9: //tab
                    if (this.showMeridian) {
                        if (input == 'meridian') {
                            this.hideWidget();
                        }
                    } else {
                        if (this.showSeconds) {
                            if (input == 'second') {
                                this.hideWidget();
                            }
                        } else {
                            if (input == 'minute') {
                                this.hideWidget();
                            }
                        }
                    }
                    break;
                case 27: // escape
                    this.hideWidget();
                    break;
                case 38: // up arrow
                    switch (input) {
                        case 'hour':
                            this.incrementHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.update();
                    break;
                case 40: // down arrow
                    switch (input) {
                        case 'hour':
                            this.decrementHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.update();
                    break;
            }
        }

        , elementKeypress: function (e) {
            var input = this.$element.get(0);
            switch (e.keyCode) {
                case 0: //input
                    break;
                case 9: //tab
                    this.updateFromElementVal();
                    if (this.showMeridian) {
                        if (this.highlightedUnit != 'meridian') {
                            e.preventDefault();
                            this.highlightNextUnit();
                        }
                    } else {
                        if (this.showSeconds) {
                            if (this.highlightedUnit != 'second') {
                                e.preventDefault();
                                this.highlightNextUnit();
                            }
                        } else {
                            if (this.highlightedUnit != 'minute') {
                                e.preventDefault();
                                this.highlightNextUnit();
                            }
                        }
                    }
                    break;
                case 27: // escape
                    this.updateFromElementVal();
                    break;
                case 37: // left arrow
                    this.updateFromElementVal();
                    this.highlightPrevUnit();
                    break;
                case 38: // up arrow
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.incrementHour();
                            break;
                        case 'minute':
                            this.incrementMinute();
                            break;
                        case 'second':
                            this.incrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.updateElement();
                    break;
                case 39: // right arrow
                    this.updateFromElementVal();
                    this.highlightNextUnit();
                    break;
                case 40: // down arrow
                    switch (this.highlightedUnit) {
                        case 'hour':
                            this.decrementHour();
                            break;
                        case 'minute':
                            this.decrementMinute();
                            break;
                        case 'second':
                            this.decrementSecond();
                            break;
                        case 'meridian':
                            this.toggleMeridian();
                            break;
                    }
                    this.updateElement();
                    break;
            }

            if (e.keyCode !== 0 && e.keyCode !== 8 && e.keyCode !== 9 && e.keyCode !== 46) {
                e.preventDefault();
            }
        }

        , setValues: function (time) {
            if (this.showMeridian) {
                var arr = time.split(' ');
                var timeArray = arr[0].split(':');
                this.meridian = arr[1];
            } else {
                var timeArray = time.split(':');
            }

            this.hour = parseInt(timeArray[0], 10);
            this.minute = parseInt(timeArray[1], 10);
            this.second = parseInt(timeArray[2], 10);

            if (isNaN(this.hour)) {
                this.hour = 0;
            }
            if (isNaN(this.minute)) {
                this.minute = 0;
            }

            if (this.showMeridian) {
                if (this.hour > 12) {
                    this.hour = 12;
                } else if (this.hour < 1) {
                    this.hour = 1;
                }

                if (this.meridian == 'am' || this.meridian == 'a') {
                    this.meridian = 'AM';
                } else if (this.meridian == 'pm' || this.meridian == 'p') {
                    this.meridian = 'PM';
                }

                if (this.meridian != 'AM' && this.meridian != 'PM') {
                    this.meridian = 'AM';
                }
            } else {
                if (this.hour >= 24) {
                    this.hour = 23;
                } else if (this.hour < 0) {
                    this.hour = 0;
                }
            }

            if (this.minute < 0) {
                this.minute = 0;
            } else if (this.minute >= 60) {
                this.minute = 59;
            }

            if (this.showSeconds) {
                if (isNaN(this.second)) {
                    this.second = 0;
                } else if (this.second < 0) {
                    this.second = 0;
                } else if (this.second >= 60) {
                    this.second = 59;
                }
            }

            this.updateElement();
            this.updateWidget();
        }

        , setMeridian: function (meridian) {
            if (meridian == 'a' || meridian == 'am' || meridian == 'AM') {
                this.meridian = 'AM';
            } else if (meridian == 'p' || meridian == 'pm' || meridian == 'PM') {
                this.meridian = 'PM';
            } else {
                this.updateWidget();
            }

            this.updateElement();
        }

        , setDefaultTime: function (defaultTime) {
            if (defaultTime) {
                if (defaultTime === 'current') {
                    var dTime = new Date();
                    var hours = dTime.getHours();
                    var minutes = Math.floor(dTime.getMinutes() / this.minuteStep) * this.minuteStep;
                    var seconds = Math.floor(dTime.getSeconds() / this.secondStep) * this.secondStep;
                    var meridian = "AM";
                    if (this.showMeridian) {
                        if (hours === 0) {
                            hours = 12;
                        } else if (hours >= 12) {
                            if (hours > 12) {
                                hours = hours - 12;
                            }
                            meridian = "PM";
                        } else {
                            meridian = "AM";
                        }
                    }
                    this.hour = hours;
                    this.minute = minutes;
                    this.second = seconds;
                    this.meridian = meridian;
                } else if (defaultTime === 'value') {
                    this.setValues(this.$element.val());
                } else {
                    this.setValues(defaultTime);
                }
                this.update();
            } else {
                this.hour = 0;
                this.minute = 0;
                this.second = 0;
            }
        }

        , formatTime: function (hour, minute, second, meridian) {
            hour = hour < 10 ? '0' + hour : hour;
            minute = minute < 10 ? '0' + minute : minute;
            second = second < 10 ? '0' + second : second;

            return hour + ':' + minute + (this.showSeconds ? ':' + second : '') + (this.showMeridian ? ' ' + meridian : '');
        }

        , getTime: function () {
            return this.formatTime(this.hour, this.minute, this.second, this.meridian);
        }

        , setTime: function (time) {
            this.setValues(time);
            this.update();
        }

        , update: function () {
            this.updateElement();
            this.updateWidget();
        }

        , blurElement: function () {
            this.highlightedUnit = undefined;
            this.updateFromElementVal();
        }

        , updateElement: function () {
            var time = this.getTime();

            this.$element.val(time).change();

            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightHour();
                    break;
                case 'minute':
                    this.highlightMinute();
                    break;
                case 'second':
                    this.highlightSecond();
                    break;
                case 'meridian':
                    this.highlightMeridian();
                    break;
            }
        }

        , updateWidget: function () {
            if (this.showInputs) {
                this.$widget.find('input.bootstrap-timepicker-hour').val(this.hour < 10 ? '0' + this.hour : this.hour);
                this.$widget.find('input.bootstrap-timepicker-minute').val(this.minute < 10 ? '0' + this.minute : this.minute);
                if (this.showSeconds) {
                    this.$widget.find('input.bootstrap-timepicker-second').val(this.second < 10 ? '0' + this.second : this.second);
                }
                if (this.showMeridian) {
                    this.$widget.find('input.bootstrap-timepicker-meridian').val(this.meridian);
                }
            } else {
                this.$widget.find('span.bootstrap-timepicker-hour').text(this.hour);
                this.$widget.find('span.bootstrap-timepicker-minute').text(this.minute < 10 ? '0' + this.minute : this.minute);
                if (this.showSeconds) {
                    this.$widget.find('span.bootstrap-timepicker-second').text(this.second < 10 ? '0' + this.second : this.second);
                }
                if (this.showMeridian) {
                    this.$widget.find('span.bootstrap-timepicker-meridian').text(this.meridian);
                }
            }
        }

        , updateFromElementVal: function (e) {
            var time = this.$element.val();
            if (time) {
                this.setValues(time);
                this.updateWidget();
            }
        }

        , updateFromWidgetInputs: function () {
            var time = $('input.bootstrap-timepicker-hour', this.$widget).val() + ':' +
                $('input.bootstrap-timepicker-minute', this.$widget).val() +
                (this.showSeconds ?
                ':' + $('input.bootstrap-timepicker-second', this.$widget).val()
                    : '') +
                (this.showMeridian ?
                ' ' + $('input.bootstrap-timepicker-meridian', this.$widget).val()
                    : '');

            this.setValues(time);
        }

        , getCursorPosition: function () {
            var input = this.$element.get(0);

            if ('selectionStart' in input) {
                // Standard-compliant browsers
                return input.selectionStart;
            } else if (document.selection) {
                // IE fix
                input.focus();
                var sel = document.selection.createRange();
                var selLen = document.selection.createRange().text.length;
                sel.moveStart('character', -input.value.length);

                return sel.text.length - selLen;
            }
        }

        , highlightUnit: function () {
            var input = this.$element.get(0);

            this.position = this.getCursorPosition();
            if (this.position >= 0 && this.position <= 2) {
                this.highlightHour();
            } else if (this.position >= 3 && this.position <= 5) {
                this.highlightMinute();
            } else if (this.position >= 6 && this.position <= 8) {
                if (this.showSeconds) {
                    this.highlightSecond();
                } else {
                    this.highlightMeridian();
                }
            } else if (this.position >= 9 && this.position <= 11) {
                this.highlightMeridian();
            }
        }

        , highlightNextUnit: function () {
            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightMinute();
                    break;
                case 'minute':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMeridian();
                    }
                    break;
                case 'second':
                    this.highlightMeridian();
                    break;
                case 'meridian':
                    this.highlightHour();
                    break;
            }
        }

        , highlightPrevUnit: function () {
            switch (this.highlightedUnit) {
                case 'hour':
                    this.highlightMeridian();
                    break;
                case 'minute':
                    this.highlightHour();
                    break;
                case 'second':
                    this.highlightMinute();
                    break;
                case 'meridian':
                    if (this.showSeconds) {
                        this.highlightSecond();
                    } else {
                        this.highlightMinute();
                    }
                    break;
            }
        }

        , highlightHour: function () {
            this.highlightedUnit = 'hour';
            this.$element.get(0).setSelectionRange(0, 2);
        }

        , highlightMinute: function () {
            this.highlightedUnit = 'minute';
            this.$element.get(0).setSelectionRange(3, 5);
        }

        , highlightSecond: function () {
            this.highlightedUnit = 'second';
            this.$element.get(0).setSelectionRange(6, 8);
        }

        , highlightMeridian: function () {
            this.highlightedUnit = 'meridian';
            if (this.showSeconds) {
                this.$element.get(0).setSelectionRange(9, 11);
            } else {
                this.$element.get(0).setSelectionRange(6, 8);
            }
        }

        , incrementHour: function () {
            if (this.showMeridian) {
                if (this.hour === 11) {
                    this.toggleMeridian();
                } else if (this.hour === 12) {
                    return this.hour = 1;
                }
            }
            if (this.hour === 23) {
                return this.hour = 0;
            }
            this.hour = this.hour + 1;
        }

        , decrementHour: function () {
            if (this.showMeridian) {
                if (this.hour === 1) {
                    return this.hour = 12;
                }
                else if (this.hour === 12) {
                    this.toggleMeridian();
                }
            }
            if (this.hour === 0) {
                return this.hour = 23;
            }
            this.hour = this.hour - 1;
        }

        , incrementMinute: function () {
            var newVal = this.minute + this.minuteStep - (this.minute % this.minuteStep);
            if (newVal > 59) {
                this.incrementHour();
                this.minute = newVal - 60;
            } else {
                this.minute = newVal;
            }
        }

        , decrementMinute: function () {
            var newVal = this.minute - this.minuteStep;
            if (newVal < 0) {
                this.decrementHour();
                this.minute = newVal + 60;
            } else {
                this.minute = newVal;
            }
        }

        , incrementSecond: function () {
            var newVal = this.second + this.secondStep - (this.second % this.secondStep);
            if (newVal > 59) {
                this.incrementMinute();
                this.second = newVal - 60;
            } else {
                this.second = newVal;
            }
        }

        , decrementSecond: function () {
            var newVal = this.second - this.secondStep;
            if (newVal < 0) {
                this.decrementMinute();
                this.second = newVal + 60;
            } else {
                this.second = newVal;
            }
        }

        , toggleMeridian: function () {
            this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';

            this.update();
        }

        , getTemplate: function () {
            if (this.options.templates[this.options.template]) {
                return this.options.templates[this.options.template];
            }
            if (this.showInputs) {
                var hourTemplate = '<input type="text" name="hour" class="bootstrap-timepicker-hour" maxlength="2"/>';
                var minuteTemplate = '<input type="text" name="minute" class="bootstrap-timepicker-minute" maxlength="2"/>';
                var secondTemplate = '<input type="text" name="second" class="bootstrap-timepicker-second" maxlength="2"/>';
                var meridianTemplate = '<input type="text" name="meridian" class="bootstrap-timepicker-meridian" maxlength="2"/>';
            } else {
                var hourTemplate = '<span class="bootstrap-timepicker-hour"></span>';
                var minuteTemplate = '<span class="bootstrap-timepicker-minute"></span>';
                var secondTemplate = '<span class="bootstrap-timepicker-second"></span>';
                var meridianTemplate = '<span class="bootstrap-timepicker-meridian"></span>';
            }
            var templateContent = '<table class="' + (this.showSeconds ? 'show-seconds' : '') + ' ' + (this.showMeridian ? 'show-meridian' : '') + '">' +
                '<tr>' +
                '<td><a href="#" data-action="incrementHour"><i class="icon-chevron-up"></i></a></td>' +
                '<td class="separator">&nbsp;</td>' +
                '<td><a href="#" data-action="incrementMinute"><i class="icon-chevron-up"></i></a></td>' +
                (this.showSeconds ?
                '<td class="separator">&nbsp;</td>' +
                '<td><a href="#" data-action="incrementSecond"><i class="icon-chevron-up"></i></a></td>'
                    : '') +
                (this.showMeridian ?
                '<td class="separator">&nbsp;</td>' +
                '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><i class="icon-chevron-up"></i></a></td>'
                    : '') +
                '</tr>' +
                '<tr>' +
                '<td>' + hourTemplate + '</td> ' +
                '<td class="separator">:</td>' +
                '<td>' + minuteTemplate + '</td> ' +
                (this.showSeconds ?
                '<td class="separator">:</td>' +
                '<td>' + secondTemplate + '</td>'
                    : '') +
                (this.showMeridian ?
                '<td class="separator">&nbsp;</td>' +
                '<td>' + meridianTemplate + '</td>'
                    : '') +
                '</tr>' +
                '<tr>' +
                '<td><a href="#" data-action="decrementHour"><i class="icon-chevron-down"></i></a></td>' +
                '<td class="separator"></td>' +
                '<td><a href="#" data-action="decrementMinute"><i class="icon-chevron-down"></i></a></td>' +
                (this.showSeconds ?
                '<td class="separator">&nbsp;</td>' +
                '<td><a href="#" data-action="decrementSecond"><i class="icon-chevron-down"></i></a></td>'
                    : '') +
                (this.showMeridian ?
                '<td class="separator">&nbsp;</td>' +
                '<td><a href="#" data-action="toggleMeridian"><i class="icon-chevron-down"></i></a></td>'
                    : '') +
                '</tr>' +
                '</table>';

            var template;
            switch (this.options.template) {
                case 'modal':
                    template = '<div class="bootstrap-timepicker modal hide fade in" style="top: 30%; margin-top: 0; width: 200px; margin-left: -100px;" data-backdrop="' + (this.modalBackdrop ? 'true' : 'false') + '">' +
                        '<div class="modal-header">' +
                        '<a href="#" class="close" data-dismiss="modal">×</a>' +
                        '<h3>Pick a Time</h3>' +
                        '</div>' +
                        '<div class="modal-content">' +
                        templateContent +
                        '</div>' +
                        '<div class="modal-footer">' +
                        '<a href="#" class="btn btn-primary" data-dismiss="modal">Ok</a>' +
                        '</div>' +
                        '</div>';

                    break;
                case 'dropdown':
                    template = '<div class="bootstrap-timepicker dropdown-menu">' +
                        templateContent +
                        '</div>';
                    break;

            }
            return template;
        }
    };


    /* TIMEPICKER PLUGIN DEFINITION
     * =========================== */

    $.fn.timepicker = function (option) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('timepicker')
                , options = typeof option == 'object' && option;
            if (!data) {
                $this.data('timepicker', (data = new Timepicker(this, options)));
            }
            if (typeof option == 'string') {
                data[option]();
            }
        })
    }

    $.fn.timepicker.defaults = {
        minuteStep: 15
        , secondStep: 15
        , disableFocus: false
        , defaultTime: 'current'
        , showSeconds: false
        , showInputs: true
        , showMeridian: true
        , template: 'dropdown'
        , modalBackdrop: false
        , templates: {} // set custom templates
    }

    $.fn.timepicker.Constructor = Timepicker
}(window.jQuery);
/**
 * @license
 * =========================================================
 * bootstrap-datetimepicker.js
 * http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Contributions:
 *  - Andrew Rowls
 *  - Thiago de Arruda
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================
 */
(function ($) {
    var smartPhone = window.orientation != undefined;
    var DateTimePicker = function (element, options) {
        this.id = dpgId++;
        this.init(element, options)
    };
    DateTimePicker.prototype = {
        constructor: DateTimePicker, init: function (element, options) {
            var icon;
            if (!(options.pickTime || options.pickDate))throw new Error("Must choose at least one picker");
            this.options = options;
            this.$element = $(element);
            this.language = options.language in dates ? options.language : "en";
            this.pickDate = options.pickDate;
            this.pickTime = options.pickTime;
            this.isInput = this.$element.is("input");
            this.component = this.$element.is(".input-append") ? this.$element.find(".add-on") : false;
            this.format = options.format;
            if (!this.format) {
                if (this.isInput)this.format = this.$element.data("format"); else this.format = this.$element.find("input").data("format");
                if (!this.format)this.format = "MM/dd/yyyy"
            }
            this._compileFormat();
            if (this.component) {
                icon = this.component.find("i")
            }
            if (this.pickTime) {
                if (icon && icon.length)this.timeIcon = icon.data("time-icon");
                if (!this.timeIcon)this.timeIcon = "icon-time";
                icon.addClass(this.timeIcon)
            }
            if (this.pickDate) {
                if (icon && icon.length)this.dateIcon = icon.data("date-icon");
                if (!this.dateIcon)this.dateIcon = "icon-calendar";
                icon.removeClass(this.timeIcon);
                icon.addClass(this.dateIcon)
            }
            this.widget = $(getTemplate(this.timeIcon, options.pickDate, options.pickTime, options.pick12HourFormat)).appendTo("body");
            this.minViewMode = options.minViewMode || this.$element.data("date-minviewmode") || 0;
            if (typeof this.minViewMode === "string") {
                switch (this.minViewMode) {
                    case"months":
                        this.minViewMode = 1;
                        break;
                    case"years":
                        this.minViewMode = 2;
                        break;
                    default:
                        this.minViewMode = 0;
                        break
                }
            }
            this.viewMode = options.viewMode || this.$element.data("date-viewmode") || 0;
            if (typeof this.viewMode === "string") {
                switch (this.viewMode) {
                    case"months":
                        this.viewMode = 1;
                        break;
                    case"years":
                        this.viewMode = 2;
                        break;
                    default:
                        this.viewMode = 0;
                        break
                }
            }
            this.startViewMode = this.viewMode;
            this.weekStart = options.weekStart || this.$element.data("date-weekstart") || 0;
            this.weekEnd = this.weekStart === 0 ? 6 : this.weekStart - 1;
            this.fillDow();
            this.fillMonths();
            this.fillHours();
            this.fillMinutes();
            this.fillSeconds();
            this.update();
            this.showMode();
            this._attachDatePickerEvents()
        }, show: function (e) {
            this.widget.show();
            this.height = this.component ? this.component.outerHeight() : this.$element.outerHeight();
            this.place();
            this.$element.trigger({type: "show", date: this._date});
            this._attachDatePickerGlobalEvents();
            if (e) {
                e.stopPropagation();
                e.preventDefault()
            }
        }, hide: function () {
            var collapse = this.widget.find(".collapse");
            for (var i = 0; i < collapse.length; i++) {
                var collapseData = collapse.eq(i).data("collapse");
                if (collapseData && collapseData.transitioning)return
            }
            this.widget.hide();
            this.viewMode = this.startViewMode;
            this.showMode();
            this.set();
            this.$element.trigger({type: "hide", date: this._date});
            this._detachDatePickerGlobalEvents()
        }, set: function () {
            var formatted = "";
            if (!this._unset)formatted = this.formatDate(this._date);
            if (!this.isInput) {
                if (this.component) {
                    var input = this.$element.find("input");
                    input.val(formatted);
                    this._resetMaskPos(input)
                }
                this.$element.data("date", formatted)
            } else {
                this.$element.val(formatted);
                this._resetMaskPos(this.$element)
            }
        }, setValue: function (newDate) {
            if (!newDate) {
                this._unset = true
            } else {
                this._unset = false
            }
            if (typeof newDate === "string") {
                this._date = this.parseDate(newDate)
            } else {
                this._date = new Date(newDate)
            }
            this.set();
            this.viewDate = UTCDate(this._date.getUTCFullYear(), this._date.getUTCMonth(), 1, 0, 0, 0, 0);
            this.fillDate();
            this.fillTime()
        }, getDate: function () {
            if (this._unset)return null;
            return new Date(this._date.valueOf())
        }, setDate: function (date) {
            if (!date)this.setValue(null); else this.setValue(date.valueOf())
        }, getLocalDate: function () {
            if (this._unset)return null;
            var d = this._date;
            return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds())
        }, setLocalDate: function (localDate) {
            if (!localDate)this.setValue(null); else this.setValue(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()))
        }, place: function () {
            var offset = this.component ? this.component.offset() : this.$element.offset();
            this.widget.css({top: offset.top + this.height, left: offset.left})
        }, notifyChange: function () {
            this.$element.trigger({type: "changeDate", date: this.getDate(), localDate: this.getLocalDate()})
        }, update: function (newDate) {
            var dateStr = newDate;
            if (!dateStr) {
                if (this.isInput) {
                    dateStr = this.$element.val()
                } else {
                    dateStr = this.$element.find("input").val()
                }
                if (!dateStr) {
                    var tmp = new Date;
                    this._date = UTCDate(tmp.getFullYear(), tmp.getMonth(), tmp.getDate(), tmp.getHours(), tmp.getMinutes(), tmp.getSeconds(), tmp.getMilliseconds())
                } else {
                    this._date = this.parseDate(dateStr)
                }
            }
            this.viewDate = UTCDate(this._date.getUTCFullYear(), this._date.getUTCMonth(), 1, 0, 0, 0, 0);
            this.fillDate();
            this.fillTime()
        }, fillDow: function () {
            var dowCnt = this.weekStart;
            var html = "<tr>";
            while (dowCnt < this.weekStart + 7) {
                html += '<th class="dow">' + dates[this.language].daysMin[dowCnt++ % 7] + "</th>"
            }
            html += "</tr>";
            this.widget.find(".datepicker-days thead").append(html)
        }, fillMonths: function () {
            var html = "";
            var i = 0;
            while (i < 12) {
                html += '<span class="month">' + dates[this.language].monthsShort[i++] + "</span>"
            }
            this.widget.find(".datepicker-months td").append(html)
        }, fillDate: function () {
            var year = this.viewDate.getUTCFullYear();
            var month = this.viewDate.getUTCMonth();
            var currentDate = UTCDate(this._date.getUTCFullYear(), this._date.getUTCMonth(), this._date.getUTCDate(), 0, 0, 0, 0);
            this.widget.find(".datepicker-days th:eq(1)").text(dates[this.language].months[month] + " " + year);
            var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0);
            var day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
            prevMonth.setUTCDate(day);
            prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.weekStart + 7) % 7);
            var nextMonth = new Date(prevMonth.valueOf());
            nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
            nextMonth = nextMonth.valueOf();
            var html = [];
            var clsName;
            while (prevMonth.valueOf() < nextMonth) {
                if (prevMonth.getUTCDay() === this.weekStart) {
                    html.push("<tr>")
                }
                clsName = "";
                if (prevMonth.getUTCFullYear() < year || prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() < month) {
                    clsName += " old"
                } else if (prevMonth.getUTCFullYear() > year || prevMonth.getUTCFullYear() == year && prevMonth.getUTCMonth() > month) {
                    clsName += " new"
                }
                if (prevMonth.valueOf() === currentDate.valueOf()) {
                    clsName += " active"
                }
                html.push('<td class="day' + clsName + '">' + prevMonth.getUTCDate() + "</td>");
                if (prevMonth.getUTCDay() === this.weekEnd) {
                    html.push("</tr>")
                }
                prevMonth.setUTCDate(prevMonth.getUTCDate() + 1)
            }
            this.widget.find(".datepicker-days tbody").empty().append(html.join(""));
            var currentYear = this._date.getUTCFullYear();
            var months = this.widget.find(".datepicker-months").find("th:eq(1)").text(year).end().find("span").removeClass("active");
            if (currentYear === year) {
                months.eq(this._date.getUTCMonth()).addClass("active")
            }
            html = "";
            year = parseInt(year / 10, 10) * 10;
            var yearCont = this.widget.find(".datepicker-years").find("th:eq(1)").text(year + "-" + (year + 9)).end().find("td");
            year -= 1;
            for (var i = -1; i < 11; i++) {
                html += '<span class="year' + (i === -1 || i === 10 ? " old" : "") + (currentYear === year ? " active" : "") + '">' + year + "</span>";
                year += 1
            }
            yearCont.html(html)
        }, fillHours: function () {
            var table = this.widget.find(".timepicker .timepicker-hours table");
            table.parent().hide();
            var html = "";
            if (this.options.pick12HourFormat) {
                var current = 1;
                for (var i = 0; i < 3; i += 1) {
                    html += "<tr>";
                    for (var j = 0; j < 4; j += 1) {
                        var c = current.toString();
                        html += '<td class="hour">' + padLeft(c, 2, "0") + "</td>";
                        current++
                    }
                    html += "</tr>"
                }
            } else {
                var current = 0;
                for (var i = 0; i < 6; i += 1) {
                    html += "<tr>";
                    for (var j = 0; j < 4; j += 1) {
                        var c = current.toString();
                        html += '<td class="hour">' + padLeft(c, 2, "0") + "</td>";
                        current++
                    }
                    html += "</tr>"
                }
            }
            table.html(html)
        }, fillMinutes: function () {
            var table = this.widget.find(".timepicker .timepicker-minutes table");
            table.parent().hide();
            var html = "";
            var current = 0;
            for (var i = 0; i < 5; i++) {
                html += "<tr>";
                for (var j = 0; j < 4; j += 1) {
                    var c = current.toString();
                    html += '<td class="minute">' + padLeft(c, 2, "0") + "</td>";
                    current += 3
                }
                html += "</tr>"
            }
            table.html(html)
        }, fillSeconds: function () {
            var table = this.widget.find(".timepicker .timepicker-seconds table");
            table.parent().hide();
            var html = "";
            var current = 0;
            for (var i = 0; i < 5; i++) {
                html += "<tr>";
                for (var j = 0; j < 4; j += 1) {
                    var c = current.toString();
                    html += '<td class="second">' + padLeft(c, 2, "0") + "</td>";
                    current += 3
                }
                html += "</tr>"
            }
            table.html(html)
        }, fillTime: function () {
            if (!this._date)return;
            var timeComponents = this.widget.find(".timepicker span[data-time-component]");
            var table = timeComponents.closest("table");
            var is12HourFormat = this.options.pick12HourFormat;
            var hour = this._date.getUTCHours();
            var period = "AM";
            if (is12HourFormat) {
                if (hour >= 12)period = "PM";
                if (hour === 0)hour = 12; else if (hour != 12)hour = hour % 12;
                this.widget.find(".timepicker [data-action=togglePeriod]").text(period)
            }
            hour = padLeft(hour.toString(), 2, "0");
            var minute = padLeft(this._date.getUTCMinutes().toString(), 2, "0");
            var second = padLeft(this._date.getUTCSeconds().toString(), 2, "0");
            timeComponents.filter("[data-time-component=hours]").text(hour);
            timeComponents.filter("[data-time-component=minutes]").text(minute);
            timeComponents.filter("[data-time-component=seconds]").text(second)
        }, click: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var target = $(e.target).closest("span, td, th");
            if (target.length === 1) {
                switch (target[0].nodeName.toLowerCase()) {
                    case"th":
                        switch (target[0].className) {
                            case"switch":
                                this.showMode(1);
                                break;
                            case"prev":
                            case"next":
                                var vd = this.viewDate;
                                var navFnc = DPGlobal.modes[this.viewMode].navFnc;
                                var step = DPGlobal.modes[this.viewMode].navStep;
                                if (target[0].className === "prev")step = step * -1;
                                vd["set" + navFnc](vd["get" + navFnc]() + step);
                                this.fillDate();
                                this.set();
                                break
                        }
                        break;
                    case"span":
                        if (target.is(".month")) {
                            var month = target.parent().find("span").index(target);
                            this.viewDate.setUTCMonth(month)
                        } else {
                            var year = parseInt(target.text(), 10) || 0;
                            this.viewDate.setUTCFullYear(year)
                        }
                        if (this.viewMode !== 0) {
                            this._date = UTCDate(this.viewDate.getUTCFullYear(), this.viewDate.getUTCMonth(), this.viewDate.getUTCDate(), this._date.getUTCHours(), this._date.getUTCMinutes(), this._date.getUTCSeconds(), this._date.getUTCMilliseconds());
                            this.notifyChange()
                        }
                        this.showMode(-1);
                        this.fillDate();
                        this.set();
                        break;
                    case"td":
                        if (target.is(".day")) {
                            var day = parseInt(target.text(), 10) || 1;
                            var month = this.viewDate.getUTCMonth();
                            var year = this.viewDate.getUTCFullYear();
                            if (target.is(".old")) {
                                if (month === 0) {
                                    month = 11;
                                    year -= 1
                                } else {
                                    month -= 1
                                }
                            } else if (target.is(".new")) {
                                if (month == 11) {
                                    month = 0;
                                    year += 1
                                } else {
                                    month += 1
                                }
                            }
                            this._date = UTCDate(year, month, day, this._date.getUTCHours(), this._date.getUTCMinutes(), this._date.getUTCSeconds(), this._date.getUTCMilliseconds());
                            this.viewDate = UTCDate(year, month, Math.min(28, day), 0, 0, 0, 0);
                            this.fillDate();
                            this.set();
                            this.notifyChange()
                        }
                        break
                }
            }
        }, actions: {
            incrementHours: function (e) {
                this._date.setUTCHours(this._date.getUTCHours() + 1)
            }, incrementMinutes: function (e) {
                this._date.setUTCMinutes(this._date.getUTCMinutes() + 1)
            }, incrementSeconds: function (e) {
                this._date.setUTCSeconds(this._date.getUTCSeconds() + 1)
            }, decrementHours: function (e) {
                this._date.setUTCHours(this._date.getUTCHours() - 1)
            }, decrementMinutes: function (e) {
                this._date.setUTCMinutes(this._date.getUTCMinutes() - 1)
            }, decrementSeconds: function (e) {
                this._date.setUTCSeconds(this._date.getUTCSeconds() - 1)
            }, togglePeriod: function (e) {
                var hour = this._date.getUTCHours();
                if (hour >= 12)hour -= 12; else hour += 12;
                this._date.setUTCHours(hour)
            }, showPicker: function () {
                this.widget.find(".timepicker > div:not(.timepicker-picker)").hide();
                this.widget.find(".timepicker .timepicker-picker").show()
            }, showHours: function () {
                this.widget.find(".timepicker .timepicker-picker").hide();
                this.widget.find(".timepicker .timepicker-hours").show()
            }, showMinutes: function () {
                this.widget.find(".timepicker .timepicker-picker").hide();
                this.widget.find(".timepicker .timepicker-minutes").show()
            }, showSeconds: function () {
                this.widget.find(".timepicker .timepicker-picker").hide();
                this.widget.find(".timepicker .timepicker-seconds").show()
            }, selectHour: function (e) {
                var tgt = $(e.target);
                var value = parseInt(tgt.text(), 10);
                if (this.options.pick12HourFormat) {
                    var current = this._date.getUTCHours();
                    if (current >= 12) {
                        if (value != 12)value = (value + 12) % 24
                    } else {
                        if (value === 12)value = 0; else value = value % 12
                    }
                }
                this._date.setUTCHours(value);
                this.actions.showPicker.call(this)
            }, selectMinute: function (e) {
                var tgt = $(e.target);
                var value = parseInt(tgt.text(), 10);
                this._date.setUTCMinutes(value);
                this.actions.showPicker.call(this)
            }, selectSecond: function (e) {
                var tgt = $(e.target);
                var value = parseInt(tgt.text(), 10);
                this._date.setUTCSeconds(value);
                this.actions.showPicker.call(this)
            }
        }, doAction: function (e) {
            e.stopPropagation();
            e.preventDefault();
            if (!this._date)this._date = UTCDate(1970, 0, 0, 0, 0, 0, 0);
            var action = $(e.currentTarget).data("action");
            var rv = this.actions[action].apply(this, arguments);
            this.set();
            this.fillTime();
            this.notifyChange();
            return rv
        }, stopEvent: function (e) {
            e.stopPropagation();
            e.preventDefault()
        }, keydown: function (e) {
            var self = this, k = e.which, input = $(e.target);
            if (k == 8 || k == 46) {
                setTimeout(function () {
                    self._resetMaskPos(input)
                })
            }
        }, keypress: function (e) {
            var k = e.which;
            if (k == 8 || k == 46) {
                return
            }
            var input = $(e.target);
            var c = String.fromCharCode(k);
            var val = input.val() || "";
            val += c;
            var mask = this._mask[this._maskPos];
            if (!mask) {
                return false
            }
            if (mask.end != val.length) {
                return
            }
            if (!mask.pattern.test(val.slice(mask.start))) {
                val = val.slice(0, val.length - 1);
                while ((mask = this._mask[this._maskPos]) && mask.character) {
                    val += mask.character;
                    this._maskPos++
                }
                val += c;
                if (mask.end != val.length) {
                    input.val(val);
                    return false
                } else {
                    if (!mask.pattern.test(val.slice(mask.start))) {
                        input.val(val.slice(0, mask.start));
                        return false
                    } else {
                        input.val(val);
                        this._maskPos++;
                        return false
                    }
                }
            } else {
                this._maskPos++
            }
        }, change: function (e) {
            var input = $(e.target);
            var val = input.val();
            if (this._formatPattern.test(val)) {
                this.update();
                this.setValue(this._date.getTime());
                this.notifyChange();
                this.set()
            } else if (val && val.trim()) {
                this.setValue(this._date.getTime());
                if (this._date)this.set(); else input.val("")
            } else {
                if (this._date) {
                    this.setValue(null);
                    this.notifyChange()
                }
            }
            this._resetMaskPos(input)
        }, showMode: function (dir) {
            if (dir) {
                this.viewMode = Math.max(this.minViewMode, Math.min(2, this.viewMode + dir))
            }
            this.widget.find(".datepicker > div").hide().filter(".datepicker-" + DPGlobal.modes[this.viewMode].clsName).show()
        }, destroy: function () {
            this._detachDatePickerEvents();
            this._detachDatePickerGlobalEvents();
            this.widget.remove();
            this.$element.removeData("datetimepicker");
            this.component.removeData("datetimepicker")
        }, formatDate: function (d) {
            return this.format.replace(formatReplacer, function (match) {
                var methodName, property, rv, len = match.length;
                if (match === "ms")len = 1;
                property = dateFormatComponents[match].property;
                if (property === "Hours12") {
                    rv = d.getUTCHours();
                    if (rv === 0)rv = 12; else if (rv !== 12)rv = rv % 12
                } else if (property === "Period12") {
                    if (d.getUTCHours() >= 12)return "PM"; else return "AM"
                } else {
                    methodName = "get" + property;
                    rv = d[methodName]()
                }
                if (methodName === "getUTCMonth")rv = rv + 1;
                if (methodName === "getUTCYear")rv = rv + 1900 - 2e3;
                return padLeft(rv.toString(), len, "0")
            })
        }, parseDate: function (str) {
            var match, i, property, methodName, value, parsed = {};
            if (!(match = this._formatPattern.exec(str)))return null;
            for (i = 1; i < match.length; i++) {
                property = this._propertiesByIndex[i];
                if (!property)continue;
                value = match[i];
                if (/^\d+$/.test(value))value = parseInt(value, 10);
                parsed[property] = value
            }
            return this._finishParsingDate(parsed)
        }, _resetMaskPos: function (input) {
            var val = input.val();
            for (var i = 0; i < this._mask.length; i++) {
                if (this._mask[i].end > val.length) {
                    this._maskPos = i;
                    break
                } else if (this._mask[i].end === val.length) {
                    this._maskPos = i + 1;
                    break
                }
            }
        }, _finishParsingDate: function (parsed) {
            var year, month, date, hours, minutes, seconds, milliseconds;
            year = parsed.UTCFullYear;
            if (parsed.UTCYear)year = 2e3 + parsed.UTCYear;
            if (!year)year = 1970;
            if (parsed.UTCMonth)month = parsed.UTCMonth - 1; else month = 0;
            date = parsed.UTCDate || 1;
            hours = parsed.UTCHours || 0;
            minutes = parsed.UTCMinutes || 0;
            seconds = parsed.UTCSeconds || 0;
            milliseconds = parsed.UTCMilliseconds || 0;
            if (parsed.Hours12) {
                hours = parsed.Hours12
            }
            if (parsed.Period12) {
                if (/pm/i.test(parsed.Period12)) {
                    if (hours != 12)hours = (hours + 12) % 24
                } else {
                    hours = hours % 12
                }
            }
            return UTCDate(year, month, date, hours, minutes, seconds, milliseconds)
        }, _compileFormat: function () {
            var match, component, components = [], mask = [], str = this.format, propertiesByIndex = {}, i = 0, pos = 0;
            while (match = formatComponent.exec(str)) {
                component = match[0];
                if (component in dateFormatComponents) {
                    i++;
                    propertiesByIndex[i] = dateFormatComponents[component].property;
                    components.push("\\s*" + dateFormatComponents[component].getPattern(this) + "\\s*");
                    mask.push({
                        pattern: new RegExp(dateFormatComponents[component].getPattern(this)),
                        property: dateFormatComponents[component].property,
                        start: pos,
                        end: pos += component.length
                    })
                } else {
                    components.push(escapeRegExp(component));
                    mask.push({
                        pattern: new RegExp(escapeRegExp(component)),
                        character: component,
                        start: pos,
                        end: ++pos
                    })
                }
                str = str.slice(component.length)
            }
            this._mask = mask;
            this._maskPos = 0;
            this._formatPattern = new RegExp("^\\s*" + components.join("") + "\\s*$");
            this._propertiesByIndex = propertiesByIndex
        }, _attachDatePickerEvents: function () {
            var self = this;
            this.widget.on("click", ".datepicker *", $.proxy(this.click, this));
            this.widget.on("click", "[data-action]", $.proxy(this.doAction, this));
            this.widget.on("mousedown", $.proxy(this.stopEvent, this));
            if (this.pickDate && this.pickTime) {
                this.widget.on("click.togglePicker", ".accordion-toggle", function (e) {
                    e.stopPropagation();
                    var $this = $(this);
                    var $parent = $this.closest("ul");
                    var expanded = $parent.find(".collapse.in");
                    var closed = $parent.find(".collapse:not(.in)");
                    if (expanded && expanded.length) {
                        var collapseData = expanded.data("collapse");
                        if (collapseData && collapseData.transitioning)return;
                        expanded.collapse("hide");
                        closed.collapse("show");
                        $this.find("i").toggleClass(self.timeIcon + " " + self.dateIcon);
                        self.$element.find(".add-on i").toggleClass(self.timeIcon + " " + self.dateIcon)
                    }
                })
            }
            if (this.isInput) {
                this.$element.on({focus: $.proxy(this.show, this), change: $.proxy(this.change, this)});
                if (this.options.maskInput) {
                    this.$element.on({keydown: $.proxy(this.keydown, this), keypress: $.proxy(this.keypress, this)})
                }
            } else {
                this.$element.on({change: $.proxy(this.change, this)}, "input");
                if (this.options.maskInput) {
                    this.$element.on({
                        keydown: $.proxy(this.keydown, this),
                        keypress: $.proxy(this.keypress, this)
                    }, "input")
                }
                if (this.component) {
                    this.component.on("click", $.proxy(this.show, this))
                } else {
                    this.$element.on("click", $.proxy(this.show, this))
                }
            }
        }, _attachDatePickerGlobalEvents: function () {
            $(window).on("resize.datetimepicker" + this.id, $.proxy(this.place, this));
            if (!this.isInput) {
                $(document).on("mousedown.datetimepicker" + this.id, $.proxy(this.hide, this))
            }
        }, _detachDatePickerEvents: function () {
            this.widget.off("click", ".datepicker *", this.click);
            this.widget.off("click", "[data-action]");
            this.widget.off("mousedown", this.stopEvent);
            if (this.pickDate && this.pickTime) {
                this.widget.off("click.togglePicker")
            }
            if (this.isInput) {
                this.$element.off({focus: this.show, change: this.change});
                if (this.options.maskInput) {
                    this.$element.off({keydown: this.keydown, keypress: this.keypress})
                }
            } else {
                this.$element.off({change: this.change}, "input");
                if (this.options.maskInput) {
                    this.$element.off({keydown: this.keydown, keypress: this.keypress}, "input")
                }
                if (this.component) {
                    this.component.off("click", this.show)
                } else {
                    this.$element.off("click", this.show)
                }
            }
        }, _detachDatePickerGlobalEvents: function () {
            $(window).off("resize.datetimepicker" + this.id);
            if (!this.isInput) {
                $(document).off("mousedown.datetimepicker" + this.id)
            }
        }
    };
    $.fn.datetimepicker = function (option, val) {
        return this.each(function () {
            var $this = $(this), data = $this.data("datetimepicker"), options = typeof option === "object" && option;
            if (!data) {
                $this.data("datetimepicker", data = new DateTimePicker(this, $.extend({}, $.fn.datetimepicker.defaults, options)))
            }
            if (typeof option === "string")data[option](val)
        })
    };
    $.fn.datetimepicker.defaults = {maskInput: true, pickDate: true, pickTime: true, pick12HourFormat: false};
    $.fn.datetimepicker.Constructor = DateTimePicker;
    var dpgId = 0;
    var dates = $.fn.datetimepicker.dates = {
        en: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
            daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        }
    };
    var dateFormatComponents = {
        dd: {
            property: "UTCDate", getPattern: function () {
                return "(0?[1-9]|[1-2][0-9]|3[0-1])\\b"
            }
        }, MM: {
            property: "UTCMonth", getPattern: function () {
                return "(0?[1-9]|1[0-2])\\b"
            }
        }, yy: {
            property: "UTCYear", getPattern: function () {
                return "(\\d{2})\\b"
            }
        }, yyyy: {
            property: "UTCFullYear", getPattern: function () {
                return "(\\d{4})\\b"
            }
        }, hh: {
            property: "UTCHours", getPattern: function () {
                return "(0?[0-9]|1[0-9]|2[0-3])\\b"
            }
        }, mm: {
            property: "UTCMinutes", getPattern: function () {
                return "(0?[0-9]|[1-5][0-9])\\b"
            }
        }, ss: {
            property: "UTCSeconds", getPattern: function () {
                return "(0?[0-9]|[1-5][0-9])\\b"
            }
        }, ms: {
            property: "UTCMilliseconds", getPattern: function () {
                return "([0-9]{1,3})\\b"
            }
        }, HH: {
            property: "Hours12", getPattern: function () {
                return "(0?[1-9]|1[0-2])\\b"
            }
        }, PP: {
            property: "Period12", getPattern: function () {
                return "(AM|PM|am|pm|Am|aM|Pm|pM)\\b"
            }
        }
    };
    var keys = [];
    for (var k in dateFormatComponents)keys.push(k);
    keys[keys.length - 1] += "\\b";
    keys.push(".");
    var formatComponent = new RegExp(keys.join("\\b|"));
    keys.pop();
    var formatReplacer = new RegExp(keys.join("\\b|"), "g");

    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
    }

    function padLeft(s, l, c) {
        if (l < s.length)return s; else return Array(l - s.length + 1).join(c || " ") + s
    }

    function getTemplate(timeIcon, pickDate, pickTime, is12Hours) {
        if (pickDate && pickTime) {
            return '<div class="bootstrap-datetimepicker-widget dropdown-menu">' + "<ul>" + '<li class="collapse in">' + '<div class="datepicker">' + DPGlobal.template + "</div>" + "</li>" + '<li class="picker-switch"><a class="accordion-toggle"><i class="' + timeIcon + '"></i></a></li>' + '<li class="collapse">' + '<div class="timepicker">' + TPGlobal.getTemplate(is12Hours) + "</div>" + "</li>" + "</ul>" + "</div>"
        } else if (pickTime) {
            return '<div class="bootstrap-datetimepicker-widget dropdown-menu">' + '<div class="timepicker">' + TPGlobal.getTemplate(is12Hours) + "</div>" + "</div>"
        } else {
            return '<div class="bootstrap-datetimepicker-widget dropdown-menu">' + '<div class="datepicker">' + DPGlobal.template + "</div>" + "</div>"
        }
    }

    function UTCDate() {
        return new Date(Date.UTC.apply(Date, arguments))
    }

    var DPGlobal = {
        modes: [{clsName: "days", navFnc: "UTCMonth", navStep: 1}, {
            clsName: "months",
            navFnc: "UTCFullYear",
            navStep: 1
        }, {clsName: "years", navFnc: "UTCFullYear", navStep: 10}],
        isLeapYear: function (year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
        },
        getDaysInMonth: function (year, month) {
            return [31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
        },
        headTemplate: "<thead>" + "<tr>" + '<th class="prev">&lsaquo;</th>' + '<th colspan="5" class="switch"></th>' + '<th class="next">&rsaquo;</th>' + "</tr>" + "</thead>",
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>'
    };
    DPGlobal.template = '<div class="datepicker-days">' + '<table class="table-condensed">' + DPGlobal.headTemplate + "<tbody></tbody>" + "</table>" + "</div>" + '<div class="datepicker-months">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + "</table>" + "</div>" + '<div class="datepicker-years">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + "</table>" + "</div>";
    var TPGlobal = {
        hourTemplate: '<span data-action="showHours" data-time-component="hours" class="timepicker-hour"></span>',
        minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
        secondTemplate: '<span data-action="showSeconds" data-time-component="seconds" class="timepicker-second"></span>'
    };
    TPGlobal.getTemplate = function (is12Hours) {
        return '<div class="timepicker-picker">' + '<table class="table-condensed"' + (is12Hours ? ' data-hour-format="12"' : "") + ">" + "<tr>" + '<td><a href="#" class="btn" data-action="incrementHours"><i class="icon-chevron-up"></i></a></td>' + '<td class="separator"></td>' + '<td><a href="#" class="btn" data-action="incrementMinutes"><i class="icon-chevron-up"></i></a></td>' + '<td class="separator"></td>' + '<td><a href="#" class="btn" data-action="incrementSeconds"><i class="icon-chevron-up"></i></a></td>' + (is12Hours ? '<td class="separator"></td>' : "") + "</tr>" + "<tr>" + "<td>" + TPGlobal.hourTemplate + "</td> " + '<td class="separator">:</td>' + "<td>" + TPGlobal.minuteTemplate + "</td> " + '<td class="separator">:</td>' + "<td>" + TPGlobal.secondTemplate + "</td>" + (is12Hours ? '<td class="separator"></td>' + "<td>" + '<button type="button" class="btn btn-primary" data-action="togglePeriod"></button>' + "</td>" : "") + "</tr>" + "<tr>" + '<td><a href="#" class="btn" data-action="decrementHours"><i class="icon-chevron-down"></i></a></td>' + '<td class="separator"></td>' + '<td><a href="#" class="btn" data-action="decrementMinutes"><i class="icon-chevron-down"></i></a></td>' + '<td class="separator"></td>' + '<td><a href="#" class="btn" data-action="decrementSeconds"><i class="icon-chevron-down"></i></a></td>' + (is12Hours ? '<td class="separator"></td>' : "") + "</tr>" + "</table>" + "</div>" + '<div class="timepicker-hours" data-action="selectHour">' + '<table class="table-condensed">' + "</table>" + "</div>" + '<div class="timepicker-minutes" data-action="selectMinute">' + '<table class="table-condensed">' + "</table>" + "</div>" + '<div class="timepicker-seconds" data-action="selectSecond">' + '<table class="table-condensed">' + "</table>" + "</div>"
    }
})(window.jQuery);
/* =========================================================
 * bootstrap-colorpicker.js 
 * http://www.eyecon.ro/bootstrap-colorpicker
 * =========================================================
 * Copyright 2012 Stefan Petre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

!function ($) {

    // Color object

    var Color = function (val) {
        this.value = {
            h: 1,
            s: 1,
            b: 1,
            a: 1
        };
        this.setColor(val);
    };

    Color.prototype = {
        constructor: Color,

        //parse a string to HSB
        setColor: function (val) {
            val = val.toLowerCase();
            var that = this;
            $.each(CPGlobal.stringParsers, function (i, parser) {
                var match = parser.re.exec(val),
                    values = match && parser.parse(match),
                    space = parser.space || 'rgba';
                if (values) {
                    if (space === 'hsla') {
                        that.value = CPGlobal.RGBtoHSB.apply(null, CPGlobal.HSLtoRGB.apply(null, values));
                    } else {
                        that.value = CPGlobal.RGBtoHSB.apply(null, values);
                    }
                    return false;
                }
            });
        },

        setHue: function (h) {
            this.value.h = 1 - h;
        },

        setSaturation: function (s) {
            this.value.s = s;
        },

        setLightness: function (b) {
            this.value.b = 1 - b;
        },

        setAlpha: function (a) {
            this.value.a = parseInt((1 - a) * 100, 10) / 100;
        },

        // HSBtoRGB from RaphaelJS
        // https://github.com/DmitryBaranovskiy/raphael/
        toRGB: function (h, s, b, a) {
            if (!h) {
                h = this.value.h;
                s = this.value.s;
                b = this.value.b;
            }
            h *= 360;
            var R, G, B, X, C;
            h = (h % 360) / 60;
            C = b * s;
            X = C * (1 - Math.abs(h % 2 - 1));
            R = G = B = b - C;

            h = ~~h;
            R += [C, X, 0, 0, X, C][h];
            G += [X, C, C, X, 0, 0][h];
            B += [0, 0, X, C, C, X][h];
            return {
                r: Math.round(R * 255),
                g: Math.round(G * 255),
                b: Math.round(B * 255),
                a: a || this.value.a
            };
        },

        toHex: function (h, s, b, a) {
            var rgb = this.toRGB(h, s, b, a);
            return '#' + ((1 << 24) | (parseInt(rgb.r) << 16) | (parseInt(rgb.g) << 8) | parseInt(rgb.b)).toString(16).substr(1);
        },

        toHSL: function (h, s, b, a) {
            if (!h) {
                h = this.value.h;
                s = this.value.s;
                b = this.value.b;
            }
            var H = h,
                L = (2 - s) * b,
                S = s * b;
            if (L > 0 && L <= 1) {
                S /= L;
            } else {
                S /= 2 - L;
            }
            L /= 2;
            if (S > 1) {
                S = 1;
            }
            return {
                h: H,
                s: S,
                l: L,
                a: a || this.value.a
            };
        }
    };

    // Picker object

    var Colorpicker = function (element, options) {
        this.element = $(element);
        var format = options.format || this.element.data('color-format') || 'hex';
        this.format = CPGlobal.translateFormats[format];
        this.isInput = this.element.is('input');
        this.component = this.element.is('.color') ? this.element.find('.add-on') : false;

        this.picker = $(CPGlobal.template)
            .appendTo('body')
            .on('mousedown', $.proxy(this.mousedown, this));

        if (this.isInput) {
            this.element.on({
                'focus': $.proxy(this.show, this),
                'keyup': $.proxy(this.update, this)
            });
        } else if (this.component) {
            this.component.on({
                'click': $.proxy(this.show, this)
            });
        } else {
            this.element.on({
                'click': $.proxy(this.show, this)
            });
        }
        if (format === 'rgba' || format === 'hsla') {
            this.picker.addClass('alpha');
            this.alpha = this.picker.find('.colorpicker-alpha')[0].style;
        }

        if (this.component) {
            this.picker.find('.colorpicker-color').hide();
            this.preview = this.element.find('i')[0].style;
        } else {
            this.preview = this.picker.find('div:last')[0].style;
        }

        this.base = this.picker.find('div:first')[0].style;
        this.update();
    };

    Colorpicker.prototype = {
        constructor: Colorpicker,

        show: function (e) {
            this.picker.show();
            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();
            this.place();
            $(window).on('resize', $.proxy(this.place, this));
            if (!this.isInput) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            $(document).on({
                'mousedown': $.proxy(this.hide, this)
            });
            this.element.trigger({
                type: 'show',
                color: this.color
            });
        },

        update: function () {
            this.color = new Color(this.isInput ? this.element.prop('value') : this.element.data('color'));
            this.picker.find('i')
                .eq(0).css({left: this.color.value.s * 100, top: 100 - this.color.value.b * 100}).end()
                .eq(1).css('top', 100 * (1 - this.color.value.h)).end()
                .eq(2).css('top', 100 * (1 - this.color.value.a));
            this.previewColor();
        },

        setValue: function (newColor) {
            this.color = new Color(newColor);
            this.picker.find('i')
                .eq(0).css({left: this.color.value.s * 100, top: 100 - this.color.value.b * 100}).end()
                .eq(1).css('top', 100 * (1 - this.color.value.h)).end()
                .eq(2).css('top', 100 * (1 - this.color.value.a));
            this.previewColor();
            this.element.trigger({
                type: 'changeColor',
                color: this.color
            });
        },

        hide: function () {
            this.picker.hide();
            $(window).off('resize', this.place);
            if (!this.isInput) {
                $(document).off({
                    'mousedown': this.hide
                });
                if (this.component) {
                    this.element.find('input').prop('value', this.format.call(this));
                }
                this.element.data('color', this.format.call(this));
            } else {
                this.element.prop('value', this.format.call(this));
            }
            this.element.trigger({
                type: 'hide',
                color: this.color
            });
        },

        place: function () {
            var offset = this.component ? this.component.offset() : this.element.offset();
            this.picker.css({
                top: offset.top + this.height,
                left: offset.left
            });
        },

        //preview color change
        previewColor: function () {
            try {
                this.preview.backgroundColor = this.format.call(this);
            } catch (e) {
                this.preview.backgroundColor = this.color.toHex();
            }
            //set the color for brightness/saturation slider
            this.base.backgroundColor = this.color.toHex(this.color.value.h, 1, 1, 1);
            //set te color for alpha slider
            if (this.alpha) {
                this.alpha.backgroundColor = this.color.toHex();
            }
        },

        pointer: null,

        slider: null,

        mousedown: function (e) {
            e.stopPropagation();
            e.preventDefault();

            var target = $(e.target);

            //detect the slider and set the limits and callbacks
            var zone = target.closest('div');
            if (!zone.is('.colorpicker')) {
                if (zone.is('.colorpicker-saturation')) {
                    this.slider = $.extend({}, CPGlobal.sliders.saturation);
                }
                else if (zone.is('.colorpicker-hue')) {
                    this.slider = $.extend({}, CPGlobal.sliders.hue);
                }
                else if (zone.is('.colorpicker-alpha')) {
                    this.slider = $.extend({}, CPGlobal.sliders.alpha);
                } else {
                    return false;
                }
                var offset = zone.offset();
                //reference to knob's style
                this.slider.knob = zone.find('i')[0].style;
                this.slider.left = e.pageX - offset.left;
                this.slider.top = e.pageY - offset.top;
                this.pointer = {
                    left: e.pageX,
                    top: e.pageY
                };
                //trigger mousemove to move the knob to the current position
                $(document).on({
                    mousemove: $.proxy(this.mousemove, this),
                    mouseup: $.proxy(this.mouseup, this)
                }).trigger('mousemove');
            }
            return false;
        },

        mousemove: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var left = Math.max(
                0,
                Math.min(
                    this.slider.maxLeft,
                    this.slider.left + ((e.pageX || this.pointer.left) - this.pointer.left)
                )
            );
            var top = Math.max(
                0,
                Math.min(
                    this.slider.maxTop,
                    this.slider.top + ((e.pageY || this.pointer.top) - this.pointer.top)
                )
            );
            this.slider.knob.left = left + 'px';
            this.slider.knob.top = top + 'px';
            if (this.slider.callLeft) {
                this.color[this.slider.callLeft].call(this.color, left / 100);
            }
            if (this.slider.callTop) {
                this.color[this.slider.callTop].call(this.color, top / 100);
            }
            this.previewColor();
            this.element.trigger({
                type: 'changeColor',
                color: this.color
            });
            return false;
        },

        mouseup: function (e) {
            e.stopPropagation();
            e.preventDefault();
            $(document).off({
                mousemove: this.mousemove,
                mouseup: this.mouseup
            });
            return false;
        }
    }

    $.fn.colorpicker = function (option) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('colorpicker'),
                options = typeof option === 'object' && option;
            if (!data) {
                $this.data('colorpicker', (data = new Colorpicker(this, $.extend({}, $.fn.colorpicker.defaults, options))));
            }
            if (typeof option === 'string') data[option]();
        });
    };

    $.fn.colorpicker.defaults = {};

    $.fn.colorpicker.Constructor = Colorpicker;

    var CPGlobal = {

        // translate a format from Color object to a string
        translateFormats: {
            'rgb': function () {
                var rgb = this.color.toRGB();
                return 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            },

            'rgba': function () {
                var rgb = this.color.toRGB();
                return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')';
            },

            'hsl': function () {
                var hsl = this.color.toHSL();
                return 'hsl(' + Math.round(hsl.h * 360) + ',' + Math.round(hsl.s * 100) + '%,' + Math.round(hsl.l * 100) + '%)';
            },

            'hsla': function () {
                var hsl = this.color.toHSL();
                return 'hsla(' + Math.round(hsl.h * 360) + ',' + Math.round(hsl.s * 100) + '%,' + Math.round(hsl.l * 100) + '%,' + hsl.a + ')';
            },

            'hex': function () {
                return this.color.toHex();
            }
        },

        sliders: {
            saturation: {
                maxLeft: 100,
                maxTop: 100,
                callLeft: 'setSaturation',
                callTop: 'setLightness'
            },

            hue: {
                maxLeft: 0,
                maxTop: 100,
                callLeft: false,
                callTop: 'setHue'
            },

            alpha: {
                maxLeft: 0,
                maxTop: 100,
                callLeft: false,
                callTop: 'setAlpha'
            }
        },

        // HSBtoRGB from RaphaelJS
        // https://github.com/DmitryBaranovskiy/raphael/
        RGBtoHSB: function (r, g, b, a) {
            r /= 255;
            g /= 255;
            b /= 255;

            var H, S, V, C;
            V = Math.max(r, g, b);
            C = V - Math.min(r, g, b);
            H = (C === 0 ? null :
                    V == r ? (g - b) / C :
                        V == g ? (b - r) / C + 2 :
                        (r - g) / C + 4
            );
            H = ((H + 360) % 6) * 60 / 360;
            S = C === 0 ? 0 : C / V;
            return {h: H || 1, s: S, b: V, a: a || 1};
        },

        HueToRGB: function (p, q, h) {
            if (h < 0)
                h += 1;
            else if (h > 1)
                h -= 1;

            if ((h * 6) < 1)
                return p + (q - p) * h * 6;
            else if ((h * 2) < 1)
                return q;
            else if ((h * 3) < 2)
                return p + (q - p) * ((2 / 3) - h) * 6;
            else
                return p;
        },

        HSLtoRGB: function (h, s, l, a) {
            if (s < 0) {
                s = 0;
            }
            var q;
            if (l <= 0.5) {
                q = l * (1 + s);
            } else {
                q = l + s - (l * s);
            }

            var p = 2 * l - q;

            var tr = h + (1 / 3);
            var tg = h;
            var tb = h - (1 / 3);

            var r = Math.round(CPGlobal.HueToRGB(p, q, tr) * 255);
            var g = Math.round(CPGlobal.HueToRGB(p, q, tg) * 255);
            var b = Math.round(CPGlobal.HueToRGB(p, q, tb) * 255);
            return [r, g, b, a || 1];
        },

        // a set of RE's that can match strings and generate color tuples.
        // from John Resig color plugin
        // https://github.com/jquery/jquery-color/
        stringParsers: [
            {
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2],
                        execResult[3],
                        execResult[4]
                    ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        2.55 * execResult[1],
                        2.55 * execResult[2],
                        2.55 * execResult[3],
                        execResult[4]
                    ];
                }
            }, {
                re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1], 16),
                        parseInt(execResult[2], 16),
                        parseInt(execResult[3], 16)
                    ];
                }
            }, {
                re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1] + execResult[1], 16),
                        parseInt(execResult[2] + execResult[2], 16),
                        parseInt(execResult[3] + execResult[3], 16)
                    ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
                space: 'hsla',
                parse: function (execResult) {
                    return [
                        execResult[1] / 360,
                        execResult[2] / 100,
                        execResult[3] / 100,
                        execResult[4]
                    ];
                }
            }
        ],
        template: '<div class="colorpicker dropdown-menu">' +
        '<div class="colorpicker-saturation"><i><b></b></i></div>' +
        '<div class="colorpicker-hue"><i></i></div>' +
        '<div class="colorpicker-alpha"><i></i></div>' +
        '<div class="colorpicker-color"><div /></div>' +
        '</div>'
    };

}(window.jQuery);
/**
 * @version: 1.0.1
 * @author: Dan Grossman http://www.dangrossman.info/
 * @date: 2012-08-20
 * @copyright: Copyright (c) 2012 Dan Grossman. All rights reserved.
 * @license: Licensed under Apache License v2.0. See http://www.apache.org/licenses/LICENSE-2.0
 * @website: http://www.improvely.com/
 */
!function ($) {

    var DateRangePicker = function (element, options, cb) {
        var hasOptions = typeof options == 'object'
        var localeObject;

        //state
        this.startDate = Date.today();
        this.endDate = Date.today();
        this.minDate = false;
        this.maxDate = false;
        this.changed = false;
        this.ranges = {};
        this.opens = 'right';
        this.cb = function () {
        };
        this.format = 'MM/dd/yyyy';
        this.separator = ' - ';
        this.showWeekNumbers = false;
        this.buttonClasses = ['btn-success'];
        this.locale = {
            applyLabel: 'Apply',
            fromLabel: 'From',
            toLabel: 'To',
            weekLabel: 'W',
            customRangeLabel: 'Custom Range',
            daysOfWeek: Date.CultureInfo.shortestDayNames,
            monthNames: Date.CultureInfo.monthNames,
            firstDay: 0
        };

        localeObject = this.locale;

        this.leftCalendar = {
            month: Date.today().set({day: 1, month: this.startDate.getMonth(), year: this.startDate.getFullYear()}),
            calendar: Array()
        };

        this.rightCalendar = {
            month: Date.today().set({day: 1, month: this.endDate.getMonth(), year: this.endDate.getFullYear()}),
            calendar: Array()
        };

        // by default, the daterangepicker element is placed at the bottom of HTML body
        this.parentEl = 'body';

        //element that triggered the date range picker
        this.element = $(element);

        if (this.element.hasClass('pull-right'))
            this.opens = 'left';

        if (this.element.is('input')) {
            this.element.on({
                click: $.proxy(this.show, this),
                focus: $.proxy(this.show, this)
            });
        } else {
            this.element.on('click', $.proxy(this.show, this));
        }

        if (hasOptions) {
            if (typeof options.locale == 'object') {
                $.each(localeObject, function (property, value) {
                    localeObject[property] = options.locale[property] || value;
                });
            }
        }

        var DRPTemplate = '<div class="daterangepicker dropdown-menu">' +
            '<div class="calendar left"></div>' +
            '<div class="calendar right"></div>' +
            '<div class="ranges">' +
            '<div class="range_inputs">' +
            '<div style="float: left">' +
            '<label for="daterangepicker_start">' + this.locale.fromLabel + '</label>' +
            '<input class="input-mini" type="text" name="daterangepicker_start" value="" disabled="disabled" />' +
            '</div>' +
            '<div style="float: left; padding-left: 11px">' +
            '<label for="daterangepicker_end">' + this.locale.toLabel + '</label>' +
            '<input class="input-mini" type="text" name="daterangepicker_end" value="" disabled="disabled" />' +
            '</div>' +
            '<button class="btn btn-small btn-success" disabled="disabled">' + this.locale.applyLabel + '</button>' +
            '</div>' +
            '</div>' +
            '</div>';

        this.parentEl = (hasOptions && options.parentEl && $(options.parentEl)) || $(this.parentEl);
        //the date range picker
        this.container = $(DRPTemplate).appendTo(this.parentEl);

        if (hasOptions) {

            if (typeof options.format == 'string')
                this.format = options.format;

            if (typeof options.separator == 'string')
                this.separator = options.separator;

            if (typeof options.startDate == 'string')
                this.startDate = Date.parse(options.startDate, this.format);

            if (typeof options.endDate == 'string')
                this.endDate = Date.parse(options.endDate, this.format);

            if (typeof options.minDate == 'string')
                this.minDate = Date.parse(options.minDate, this.format);

            if (typeof options.maxDate == 'string')
                this.maxDate = Date.parse(options.maxDate, this.format);


            if (typeof options.startDate == 'object')
                this.startDate = options.startDate;

            if (typeof options.endDate == 'object')
                this.endDate = options.endDate;

            if (typeof options.minDate == 'object')
                this.minDate = options.minDate;

            if (typeof options.maxDate == 'object')
                this.maxDate = options.maxDate;

            if (typeof options.ranges == 'object') {
                for (var range in options.ranges) {

                    var start = options.ranges[range][0];
                    var end = options.ranges[range][1];

                    if (typeof start == 'string')
                        start = Date.parse(start);

                    if (typeof end == 'string')
                        end = Date.parse(end);

                    // If we have a min/max date set, bound this range
                    // to it, but only if it would otherwise fall
                    // outside of the min/max.
                    if (this.minDate && start < this.minDate)
                        start = this.minDate;

                    if (this.maxDate && end > this.maxDate)
                        end = this.maxDate;

                    // If the end of the range is before the minimum (if min is set) OR
                    // the start of the range is after the max (also if set) don't display this
                    // range option.
                    if ((this.minDate && end < this.minDate) || (this.maxDate && start > this.maxDate)) {
                        continue;
                    }

                    this.ranges[range] = [start, end];
                }

                var list = '<ul>';
                for (var range in this.ranges) {
                    list += '<li>' + range + '</li>';
                }
                list += '<li>' + this.locale.customRangeLabel + '</li>';
                list += '</ul>';
                this.container.find('.ranges').prepend(list);
            }

            // update day names order to firstDay
            if (typeof options.locale == 'object') {
                if (typeof options.locale.firstDay == 'number') {
                    this.locale.firstDay = options.locale.firstDay;
                    var iterator = options.locale.firstDay;
                    while (iterator > 0) {
                        this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                        iterator--;
                    }
                }
            }

            if (typeof options.opens == 'string')
                this.opens = options.opens;

            if (typeof options.showWeekNumbers == 'boolean') {
                this.showWeekNumbers = options.showWeekNumbers;
            }

            if (typeof options.buttonClasses == 'string') {
                this.buttonClasses = [options.buttonClasses];
            }

            if (typeof options.buttonClasses == 'object') {
                this.buttonClasses = options.buttonClasses;
            }

        }

        //apply CSS classes to buttons
        var c = this.container;
        $.each(this.buttonClasses, function (idx, val) {
            c.find('button').addClass(val);
        });

        if (this.opens == 'right') {
            //swap calendar positions
            var left = this.container.find('.calendar.left');
            var right = this.container.find('.calendar.right');
            left.removeClass('left').addClass('right');
            right.removeClass('right').addClass('left');
        }

        if (typeof options == 'undefined' || typeof options.ranges == 'undefined')
            this.container.find('.calendar').show();

        if (typeof cb == 'function')
            this.cb = cb;

        this.container.addClass('opens' + this.opens);

        //event listeners
        this.container.on('mousedown', $.proxy(this.mousedown, this));
        this.container.find('.calendar').on('click', '.prev', $.proxy(this.clickPrev, this));
        this.container.find('.calendar').on('click', '.next', $.proxy(this.clickNext, this));
        this.container.find('.ranges').on('click', 'button', $.proxy(this.clickApply, this));

        this.container.find('.calendar').on('click', 'td.available', $.proxy(this.clickDate, this));
        this.container.find('.calendar').on('mouseenter', 'td.available', $.proxy(this.enterDate, this));
        this.container.find('.calendar').on('mouseleave', 'td.available', $.proxy(this.updateView, this));

        this.container.find('.ranges').on('click', 'li', $.proxy(this.clickRange, this));
        this.container.find('.ranges').on('mouseenter', 'li', $.proxy(this.enterRange, this));
        this.container.find('.ranges').on('mouseleave', 'li', $.proxy(this.updateView, this));

        this.element.on('keyup', $.proxy(this.updateFromControl, this));

        this.updateView();
        this.updateCalendars();

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        mousedown: function (e) {
            e.stopPropagation();
            e.preventDefault();
        },

        updateView: function () {
            this.leftCalendar.month.set({month: this.startDate.getMonth(), year: this.startDate.getFullYear()});
            this.rightCalendar.month.set({month: this.endDate.getMonth(), year: this.endDate.getFullYear()});

            this.container.find('input[name=daterangepicker_start]').val(this.startDate.toString(this.format));
            this.container.find('input[name=daterangepicker_end]').val(this.endDate.toString(this.format));

            if (this.startDate.equals(this.endDate) || this.startDate.isBefore(this.endDate)) {
                this.container.find('button').removeAttr('disabled');
            } else {
                this.container.find('button').attr('disabled', 'disabled');
            }
        },

        updateFromControl: function () {
            if (!this.element.is('input')) return;

            var dateString = this.element.val().split(this.separator);
            var start = Date.parseExact(dateString[0], this.format);
            var end = Date.parseExact(dateString[1], this.format);

            if (start == null || end == null) return;
            if (end.isBefore(start)) return;

            this.startDate = start;
            this.endDate = end;

            this.updateView();
            this.cb(this.startDate, this.endDate);
            this.updateCalendars();
        },

        notify: function () {
            this.updateView();

            if (this.element.is('input')) {
                this.element.val(this.startDate.toString(this.format) + this.separator + this.endDate.toString(this.format));
            }
            this.cb(this.startDate, this.endDate);
        },

        move: function () {
            var parentOffset = {
                top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                left: this.parentEl.offset().left - this.parentEl.scrollLeft()
            };
            if (this.opens == 'left') {
                this.container.css({
                    top: this.element.offset().top + this.element.outerHeight() - parentOffset.top,
                    right: $(window).width() - this.element.offset().left - this.element.outerWidth() - parentOffset.left,
                    left: 'auto'
                });
            } else {
                this.container.css({
                    top: this.element.offset().top + this.element.outerHeight() - parentOffset.top,
                    left: this.element.offset().left - parentOffset.left,
                    right: 'auto'
                });
            }
        },

        show: function (e) {
            this.container.show();
            this.move();

            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }

            this.changed = false;

            $(document).on('mousedown', $.proxy(this.hide, this));
        },

        hide: function (e) {
            this.container.hide();
            $(document).off('mousedown', this.hide);

            if (this.changed) {
                this.changed = false;
                this.notify();
            }
        },

        enterRange: function (e) {
            var label = e.target.innerHTML;
            if (label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label];
                this.container.find('input[name=daterangepicker_start]').val(dates[0].toString(this.format));
                this.container.find('input[name=daterangepicker_end]').val(dates[1].toString(this.format));
            }
        },

        clickRange: function (e) {
            var label = e.target.innerHTML;
            if (label == this.locale.customRangeLabel) {
                this.container.find('.calendar').show();
            } else {
                var dates = this.ranges[label];

                this.startDate = dates[0];
                this.endDate = dates[1];

                this.leftCalendar.month.set({month: this.startDate.getMonth(), year: this.startDate.getFullYear()});
                this.rightCalendar.month.set({month: this.endDate.getMonth(), year: this.endDate.getFullYear()});
                this.updateCalendars();

                this.changed = true;

                this.container.find('.calendar').hide();
                this.hide();
            }
        },

        clickPrev: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add({months: -1});
            } else {
                this.rightCalendar.month.add({months: -1});
            }
            this.updateCalendars();
        },

        clickNext: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add({months: 1});
            } else {
                this.rightCalendar.month.add({months: 1});
            }
            this.updateCalendars();
        },

        enterDate: function (e) {

            var title = $(e.target).attr('title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');

            if (cal.hasClass('left')) {
                this.container.find('input[name=daterangepicker_start]').val(this.leftCalendar.calendar[row][col].toString(this.format));
            } else {
                this.container.find('input[name=daterangepicker_end]').val(this.rightCalendar.calendar[row][col].toString(this.format));
            }

        },

        clickDate: function (e) {
            var title = $(e.target).attr('title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');

            if (cal.hasClass('left')) {
                startDate = this.leftCalendar.calendar[row][col];
                endDate = this.endDate;
            } else {
                startDate = this.startDate;
                endDate = this.rightCalendar.calendar[row][col];
            }

            cal.find('td').removeClass('active');

            if (startDate.equals(endDate) || startDate.isBefore(endDate)) {
                $(e.target).addClass('active');
                if (!startDate.equals(this.startDate) || !endDate.equals(this.endDate))
                    this.changed = true;
                this.startDate = startDate;
                this.endDate = endDate;
            }

            this.leftCalendar.month.set({month: this.startDate.getMonth(), year: this.startDate.getFullYear()});
            this.rightCalendar.month.set({month: this.endDate.getMonth(), year: this.endDate.getFullYear()});
            this.updateCalendars();
        },

        clickApply: function (e) {
            this.hide();
        },

        updateCalendars: function () {
            this.leftCalendar.calendar = this.buildCalendar(this.leftCalendar.month.getMonth(), this.leftCalendar.month.getFullYear());
            this.rightCalendar.calendar = this.buildCalendar(this.rightCalendar.month.getMonth(), this.rightCalendar.month.getFullYear());
            this.container.find('.calendar.left').html(this.renderCalendar(this.leftCalendar.calendar, this.startDate, this.minDate, this.endDate));
            this.container.find('.calendar.right').html(this.renderCalendar(this.rightCalendar.calendar, this.endDate, this.startDate, this.maxDate));
        },

        buildCalendar: function (month, year) {

            var firstDay = Date.today().set({day: 1, month: month, year: year});
            var lastMonth = firstDay.clone().add(-1).day().getMonth();
            var lastYear = firstDay.clone().add(-1).day().getFullYear();

            var daysInMonth = Date.getDaysInMonth(year, month);
            var daysInLastMonth = Date.getDaysInMonth(lastYear, lastMonth);

            var dayOfWeek = firstDay.getDay();

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = Array();
            for (var i = 0; i < 6; i++) {
                calendar[i] = Array();
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
            if (startDay > daysInLastMonth)
                startDay -= 7;

            if (dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = Date.today().set({day: startDay, month: lastMonth, year: lastYear});
            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = curDate.clone().add(1).day()) {
                if (i > 0 && col % 7 == 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate;
            }

            return calendar;

        },

        renderCalendar: function (calendar, selected, minDate, maxDate) {
            var html = '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if (this.showWeekNumbers)
                html += '<th></th>';

            if (!minDate || minDate < calendar[1][1]) {
                html += '<th class="prev available"><i class="fontello-icon-left-open"></i></th>';
            }
            else {
                html += '<th></th>';
            }
            html += '<th colspan="5" style="width: auto">' + this.locale.monthNames[calendar[1][1].getMonth()] + calendar[1][1].toString(" yyyy") + '</th>';
            if (!maxDate || maxDate > calendar[1][1]) {
                html += '<th class="next available"><i class="fontello-icon-right-open"></i></th>';
            }
            else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if (this.showWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel + '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            for (var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if (this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].getWeek() + '</td>';

                for (var col = 0; col < 7; col++) {
                    var cname = 'available ';
                    cname += (calendar[row][col].getMonth() == calendar[1][1].getMonth()) ? '' : 'off';

                    // Normalise the time so the comparison won't fail
                    selected.setHours(0, 0, 0, 0);

                    if ((minDate && calendar[row][col] < minDate) || (maxDate && calendar[row][col] > maxDate)) {
                        cname = 'off disabled';
                    }
                    else if (calendar[row][col].equals(selected)) {
                        cname += 'active';
                    }

                    var title = 'r' + row + 'c' + col;
                    html += '<td class="' + cname + '" title="' + title + '">' + calendar[row][col].getDate() + '</td>';
                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';

            return html;

        }

    };

    $.fn.daterangepicker = function (options, cb) {
        this.each(function () {
            var el = $(this);
            if (!el.data('daterangepicker'))
                el.data('daterangepicker', new DateRangePicker(el, options, cb));
        });
        return this;
    };

}(window.jQuery);
!function ($) {
    "use strict";
    // version: 2.8.2
    // by Mattia Larentis - follow me on twitter! @SpiritualGuru

    var addToAttribute = function (obj, array, value) {
        var i = 0
            , length = array.length;

        for (; i < length; i++) {
            obj = obj[array[i]] = obj[array[i]] || i == ( length - 1) ? value : {}
        }
    };

    $.fn.toggleButtons = function (method) {
        var $element
            , $div
            , $cb
            , transitionSpeed = 0.05
            , methods = {
                init: function (opt) {
                    this.each(function () {
                            var $spanLeft
                                , $spanRight
                                , options
                                , moving
                                , dataAttribute = {};

                            $element = $(this);
                            $element.addClass('toggle-button');

                            $.each($element.data(), function (i, el) {
                                var key
                                    , tmp = {};

                                if (i.indexOf("togglebutton") === 0) {
                                    key = i.match(/[A-Z][a-z]+/g);
                                    key = $.map(key, function (n) {
                                        return (n.toLowerCase());
                                    });

                                    addToAttribute(tmp, key, el);
                                    dataAttribute = $.extend(true, dataAttribute, tmp);
                                }
                            });

                            options = $.extend(true, {}, $.fn.toggleButtons.defaults, opt, dataAttribute);

                            $(this).data('options', options);

                            $spanLeft = $('<span></span>').addClass("labelLeft").text(options.label.enabled === undefined ? "ON" : options.label.enabled);
                            $spanRight = $('<span></span>').addClass("labelRight").text(options.label.disabled === undefined ? "OFF " : options.label.disabled);

                            // html layout
                            $cb = $element.find('input:checkbox')

                            $div = $cb.wrap($('<div></div>')).parent();
                            $div.append($spanLeft);
                            $div.append($('<label></label>').attr('for', $cb.attr('id') || ''));
                            $div.append($spanRight);

                            if ($cb.is(':checked'))
                                $element.find('>div').css('left', "0");
                            else $element.find('>div').css('left', "-50%");

                            if (options.animated) {
                                if (options.transitionspeed !== undefined)
                                    if (/^(\d*%$)/.test(options.transitionspeed))  // is a percent value?
                                        transitionSpeed = 0.05 * parseInt(options.transitionspeed) / 100;
                                    else
                                        transitionSpeed = options.transitionspeed;
                            }
                            else transitionSpeed = 0;

                            $(this).data('transitionSpeed', transitionSpeed * 1000);


                            options["width"] /= 2;

                            // width of the bootstrap-toggle-button
                            $element
                                .css('width', options.width * 2)
                                .find('>div').css('width', options.width * 3)
                                .find('>span, >label').css('width', options.width);

                            // height of the bootstrap-toggle-button
                            $element
                                .css('height', options.height)
                                .find('span, label')
                                .css('height', options.height)
                                .filter('span')
                                .css('line-height', options.height + "px");

                            if ($cb.is(':disabled'))
                                $(this).addClass('deactivate');

                            $element.find('span').css(options.font);


                            // enabled custom color
                            if (options.style.enabled === undefined) {
                                if (options.style.custom !== undefined && options.style.custom.enabled !== undefined && options.style.custom.enabled.background !== undefined) {
                                    $spanLeft.css('color', options.style.custom.enabled.color);
                                    if (options.style.custom.enabled.gradient === undefined)
                                        $spanLeft.css('background', options.style.custom.enabled.background);
                                    else $.each(["-webkit-", "-moz-", "-o-", ""], function (i, el) {
                                        $spanLeft.css('background-image', el + 'linear-gradient(top, ' + options.style.custom.enabled.background + ',' + options.style.custom.enabled.gradient + ')');
                                    });
                                }
                            }
                            else $spanLeft.addClass(options.style.enabled);

                            // disabled custom color
                            if (options.style.disabled === undefined) {
                                if (options.style.custom !== undefined && options.style.custom.disabled !== undefined && options.style.custom.disabled.background !== undefined) {
                                    $spanRight.css('color', options.style.custom.disabled.color);
                                    if (options.style.custom.disabled.gradient === undefined)
                                        $spanRight.css('background', options.style.custom.disabled.background);
                                    else $.each(["-webkit-", "-moz-", "-o-", ""], function (i, el) {
                                        $spanRight.css('background-image', el + 'linear-gradient(top, ' + options.style.custom.disabled.background + ',' + options.style.custom.disabled.gradient + ')');
                                    });
                                }
                            }
                            else $spanRight.addClass(options.style.disabled);

                            var changeStatus = function ($this) {
                                $this.siblings('label')
                                    .trigger('mousedown')
                                    .trigger('mouseup')
                                    .trigger('click');
                            };

                            $spanLeft.on('click', function (e) {
                                changeStatus($(this));
                            });
                            $spanRight.on('click', function (e) {
                                changeStatus($(this));
                            });

                            $element.find('input:checkbox').on('change', function (e, skipOnChange) {
                                var $element = $(this).parent()
                                    , active = $(this).is(':checked')
                                    , $toggleButton = $(this).closest('.toggle-button');

                                $element.stop().animate({'left': active ? '0' : '-50%'}, $toggleButton.data('transitionSpeed'));

                                options = $toggleButton.data('options');

                                if (!skipOnChange)
                                    options.onChange($element, active, e);
                            });

                            $element.find('label').on('mousedown touchstart', function (e) {
                                moving = false;
                                e.preventDefault();
                                e.stopImmediatePropagation();

                                if ($(this).closest('.toggle-button').is('.deactivate'))
                                    $(this).off('click');
                                else {
                                    $(this).on('mousemove touchmove', function (e) {
                                        var $element = $(this).closest('.toggle-button')
                                            , relativeX = (e.pageX || e.originalEvent.targetTouches[0].pageX) - $element.offset().left
                                            , percent = ((relativeX / (options.width * 2)) * 100);
                                        moving = true;

                                        e.stopImmediatePropagation();
                                        e.preventDefault();

                                        if (percent < 25)
                                            percent = 25;
                                        else if (percent > 75)
                                            percent = 75;

                                        $element.find('>div').css('left', (percent - 75) + "%");
                                    });

                                    $(this).on('click touchend', function (e) {
                                        var $target = $(e.target)
                                            , $myCheckBox = $target.siblings('input:checkbox');

                                        e.stopImmediatePropagation();
                                        e.preventDefault();
                                        $(this).off('mouseleave');

                                        if (moving)
                                            if (parseInt($(this).parent().css('left')) < -25)
                                                $myCheckBox.attr('checked', false);
                                            else $myCheckBox.attr('checked', true);
                                        else $myCheckBox.attr("checked", !$myCheckBox.is(":checked"));

                                        $myCheckBox.trigger('change');
                                    });

                                    $(this).on('mouseleave', function (e) {
                                        var $myCheckBox = $(this).siblings('input:checkbox');

                                        e.preventDefault();
                                        e.stopImmediatePropagation();

                                        $(this).off('mouseleave');
                                        $(this).trigger('mouseup');

                                        if (parseInt($(this).parent().css('left')) < -25)
                                            $myCheckBox.attr('checked', false);
                                        else $myCheckBox.attr('checked', true);

                                        $myCheckBox.trigger('change');
                                    });

                                    $(this).on('mouseup', function (e) {
                                        e.stopImmediatePropagation();
                                        e.preventDefault();
                                        $(this).off('mousemove');
                                    });
                                }
                            });
                        }
                    );
                    return this;
                },
                toggleActivation: function () {
                    $(this).toggleClass('deactivate');
                },
                toggleState: function (skipOnChange) {
                    var $input = $(this).find('input:checkbox');
                    $input.attr('checked', !$input.is(':checked')).trigger('change', skipOnChange);
                },
                setState: function (value, skipOnChange) {
                    $(this).find('input:checkbox').attr('checked', value).trigger('change', skipOnChange);
                },
                status: function () {
                    return $(this).find('input:checkbox').is(':checked');
                },
                destroy: function () {
                    var $div = $(this).find('div')
                        , $checkbox;

                    $div.find(':not(input:checkbox)').remove();

                    $checkbox = $div.children();
                    $checkbox.unwrap().unwrap();

                    $checkbox.unbind('change');

                    return $checkbox;
                }
            };

        if (methods[method])
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        else if (typeof method === 'object' || !method)
            return methods.init.apply(this, arguments);
        else
            $.error('Method ' + method + ' does not exist!');
    };

    $.fn.toggleButtons.defaults = {
        onChange: function () {
        },
        width: 100,
        height: 25,
        font: {},
        animated: true,
        transitionspeed: undefined,
        label: {
            enabled: undefined,
            disabled: undefined
        },
        style: {
            enabled: undefined,
            disabled: undefined,
            custom: {
                enabled: {
                    background: undefined,
                    gradient: undefined,
                    color: "#FFFFFF"
                },
                disabled: {
                    background: undefined,
                    gradient: undefined,
                    color: "#FFFFFF"
                }
            }
        }
    };
}($);
/* ===========================================================
 * bootstrap-fileupload.js j2
 * http://jasny.github.com/bootstrap/javascript.html#fileupload
 * ===========================================================
 * Copyright 2012 Jasny BV, Netherlands.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

!function ($) {

    "use strict"; // jshint ;_

    /* INPUTMASK PUBLIC CLASS DEFINITION
     * ================================= */

    var Fileupload = function (element, options) {
        this.$element = $(element)
        this.type = this.$element.data('uploadtype') || (this.$element.find('.thumbnail').length > 0 ? "image" : "file")

        this.$input = this.$element.find(':file')
        if (this.$input.length === 0) return

        this.name = this.$input.attr('name') || options.name

        this.$hidden = this.$element.find(':hidden[name="' + this.name + '"]')
        if (this.$hidden.length === 0) {
            this.$hidden = $('<input type="hidden" />')
            this.$element.prepend(this.$hidden)
        }

        this.$preview = this.$element.find('.fileupload-preview')
        var height = this.$preview.css('height')
        if (this.$preview.css('display') != 'inline' && height != '0px' && height != 'none') this.$preview.css('line-height', height)

        this.$remove = this.$element.find('[data-dismiss="fileupload"]')

        this.$element.find('[data-trigger="fileupload"]').on('click.fileupload', $.proxy(this.trigger, this))

        this.listen()
    }

    Fileupload.prototype = {

        listen: function () {
            this.$input.on('change.fileupload', $.proxy(this.change, this))
            if (this.$remove) this.$remove.on('click.fileupload', $.proxy(this.clear, this))
        },

        change: function (e, invoked) {
            var file = e.target.files !== undefined ? e.target.files[0] : (e.target.value ? {name: e.target.value.replace(/^.+\\/, '')} : null)
            if (invoked === 'clear') return

            if (!file) {
                this.clear()
                return
            }

            this.$hidden.val('')
            this.$hidden.attr('name', '')
            this.$input.attr('name', this.name)

            if (this.type === "image" && this.$preview.length > 0 && (typeof file.type !== "undefined" ? file.type.match('image.*') : file.name.match('\\.(gif|png|jpe?g)$')) && typeof FileReader !== "undefined") {
                var reader = new FileReader()
                var preview = this.$preview
                var element = this.$element

                reader.onload = function (e) {
                    preview.html('<img src="' + e.target.result + '" ' + (preview.css('max-height') != 'none' ? 'style="max-height: ' + preview.css('max-height') + ';"' : '') + ' />')
                    element.addClass('fileupload-exists').removeClass('fileupload-new')
                }

                reader.readAsDataURL(file)
            } else {
                this.$preview.text(file.name)
                this.$element.addClass('fileupload-exists').removeClass('fileupload-new')
            }
        },

        clear: function (e) {
            this.$hidden.val('')
            this.$hidden.attr('name', this.name)
            this.$input.attr('name', '')
            this.$input.val('') // Doesn't work in IE, which causes issues when selecting the same file twice

            this.$preview.html('')
            this.$element.addClass('fileupload-new').removeClass('fileupload-exists')

            if (e) {
                this.$input.trigger('change', ['clear'])
                e.preventDefault()
            }
        },

        trigger: function (e) {
            this.$input.trigger('click')
            e.preventDefault()
        }
    }


    /* INPUTMASK PLUGIN DEFINITION
     * =========================== */

    $.fn.fileupload = function (options) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('fileupload')
            if (!data) $this.data('fileupload', (data = new Fileupload(this, options)))
        })
    }

    $.fn.fileupload.Constructor = Fileupload


    /* INPUTMASK DATA-API
     * ================== */

    $(function () {
        $('body').on('click.fileupload.data-api', '[data-provides="fileupload"]', function (e) {
            var $this = $(this)
            if ($this.data('fileupload')) return
            $this.fileupload($this.data())

            var $target = $(e.target).parents('[data-dismiss=fileupload],[data-trigger=fileupload]').first()
            if ($target.length > 0) {
                $target.trigger('click.fileupload')
                e.preventDefault()
            }
        })
    })

}(window.jQuery);

/* ============================================================
 * bootstrap-rowlink.js j1
 * http://jasny.github.com/bootstrap/javascript.html#rowlink
 * ============================================================
 * Copyright 2012 Jasny BV, Netherlands.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */

!function ($) {

    "use strict"; // jshint ;_;

    var Rowlink = function (element, options) {
        options = $.extend({}, $.fn.rowlink.defaults, options)
        var tr = element.nodeName == 'tr' ? $(element) : $(element).find('tr:has(td)')

        tr.each(function () {
            var link = $(this).find(options.target).first()
            if (!link.length) return

            var href = link.attr('href')

            $(this).find('td').not('.nolink').click(function () {
                window.location = href;
            })

            $(this).addClass('rowlink')
            link.replaceWith(link.html())
        })
    }


    /* ROWLINK PLUGIN DEFINITION
     * =========================== */

    $.fn.rowlink = function (options) {
        return this.each(function () {
            var $this = $(this)
                , data = $this.data('rowlink')
            if (!data) $this.data('rowlink', (data = new Rowlink(this, options)))
        })
    }

    $.fn.rowlink.defaults = {
        target: "a"
    }

    $.fn.rowlink.Constructor = Rowlink


    /* ROWLINK DATA-API
     * ================== */

    $(function () {
        $('[data-provides="rowlink"]').each(function () {
            $(this).rowlink($(this).data())
        })
    })

}(window.jQuery);

/* ========================================================
 * bootstrap-progressbar v0.5.0
 * ========================================================
 * Copyright 2012 minddust.com
 *
 * bootstrap-progressbar is published under Apache License,
 * Version 2.0 (see LICENSE file).
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * ======================================================== */

(function ($) {

    "use strict";

    /* PROGRESSBAR CLASS DEFINITION
     * ============================ */

    var Progressbar = function (element, options) {
        this.element = $(element);
        this.options = $.extend({}, $.fn.progressbar.defaults, options);
    };

    Progressbar.prototype = {

        constructor: Progressbar,

        transition: function () {
            var $this = this.element,
                $parent = $this.parent(),
                $back = this.back,
                $front = this.front,
                options = this.options,
                percentage = $this.attr('data-percentage'),
                amount_part = $this.attr('data-amount-part'),
                amount_total = $this.attr('data-amount-total'),
                is_vertical,
                update,
                done,
                fail;

            is_vertical = $parent.hasClass('vertical');

            update = (options.update && typeof(options.update) === 'function') ? options.update : $.fn.progressbar.defaults.update;
            done = (options.done && typeof(options.done) === 'function') ? options.done : $.fn.progressbar.defaults.done;
            fail = (options.fail && typeof(options.fail) === 'function') ? options.fail : $.fn.progressbar.defaults.fail;

            if (options.use_percentage && !percentage) {
                fail("bootstrap-progressbar: you can't use percentage without data-percentage being set");
                return;
            }
            else if (!options.use_percentage) {
                if (!amount_part && !amount_total) {
                    fail("bootstrap-progressbar: you can't use values without data-amount-part and data-amount-total being set");
                    return;
                }
                else {
                    percentage = Math.round(100 * amount_part / amount_total);
                }
            }

            if (options.display_text === $.fn.progressbar.display_text.center && !$front && !$back) {
                this.back = $back = $('<span>').addClass('progressbar-back-text');
                this.front = $front = $('<span>').addClass('progressbar-front-text');

                $parent.prepend($back);
                $this.prepend($front);

                var parent_size;

                if (is_vertical) {
                    parent_size = $parent.css('height');
                    $back.css('height', parent_size);
                    $back.css('line-height', parent_size);
                    $front.css('height', parent_size);
                    $front.css('line-height', parent_size);

                    $(window).resize(function () {
                        parent_size = $parent.css('height');
                        $back.css('height', parent_size);
                        $back.css('line-height', parent_size);
                        $front.css('height', parent_size);
                        $front.css('line-height', parent_size);
                    }); // normal resizing would brick the structure because width is in px
                }
                else {
                    parent_size = $parent.css('width');
                    $front.css('width', parent_size);

                    $(window).resize(function () {
                        parent_size = $parent.css('width');
                        $front.css('width', parent_size);
                    }); // normal resizing would brick the structure because width is in px
                }
            }

            setTimeout(function () {
                var current_percentage,
                    current_value,
                    this_size,
                    parent_size,
                    text;

                if (is_vertical) {
                    $this.css('height', percentage + '%');
                }
                else {
                    $this.css('width', percentage + '%');
                }

                var progress = setInterval(function () {
                    if (is_vertical) {
                        this_size = $this.height();
                        parent_size = $parent.height();
                    }
                    else {
                        this_size = $this.width();
                        parent_size = $parent.width();
                    }

                    current_percentage = Math.round(100 * this_size / parent_size);
                    current_value = Math.round(this_size / parent_size * amount_total);

                    if (current_percentage >= percentage) {
                        current_percentage = percentage;
                        current_value = amount_part;
                        done();
                        clearInterval(progress);
                    }

                    if (options.display_text !== $.fn.progressbar.display_text.none) {
                        text = options.use_percentage ? (current_percentage + '%') : (current_value + ' / ' + amount_total);

                        if (options.display_text === $.fn.progressbar.display_text.filled) {
                            $this.text(text);
                        }
                        else if (options.display_text === $.fn.progressbar.display_text.center) {
                            $back.text(text);
                            $front.text(text);
                        }
                    }

                    update(current_percentage);
                }, options.refresh_speed);
            }, options.transition_delay);
        }
    };

    /* PROGRESSBAR PLUGIN DEFINITION
     * ============================= */

    $.fn.progressbar = function (option) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('progressbar'),
                options = typeof option === 'object' && option;
            if (!data) {
                $this.data('progressbar', (data = new Progressbar(this, options)));
            }
            if (typeof option === 'string') {
                data[option]();
            }
            data.transition();
        });
    };

    $.fn.progressbar.display_text = {
        none: 0,
        filled: 1,
        center: 2
    };

    $.fn.progressbar.defaults = {
        transition_delay: 300,
        refresh_speed: 50,
        display_text: $.fn.progressbar.display_text.none,
        use_percentage: true,
        update: $.noop,
        done: $.noop,
        fail: $.noop
    };

    $.fn.progressbar.Constructor = Progressbar;

})(window.jQuery);
!function ($) {
    var Selectpicker = function (element, options, e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        this.$element = $(element);
        this.$newElement = null;
        var button = null;
        this.options = $.extend({}, $.fn.selectpicker.defaults, this.$element.data(), typeof options == 'object' && options);
        this.style = this.options.style;
        this.size = this.options.size;
        this.init();
    };

    Selectpicker.prototype = {

        constructor: Selectpicker,

        init: function (e) {
            this.$element.hide();
            var classList = this.$element.attr('class') !== undefined ? this.$element.attr('class').split(/\s+/) : '';
            var template = this.getTemplate();
            var id = this.$element.attr('id');
            template = this.createLi(template);
            this.$element.after(template);
            this.$newElement = this.$element.next('.bootstrap-select');
            var select = this.$newElement;
            var menu = this.$newElement.find('.dropdown-menu');
            var menuA = this.$newElement.find('.dropdown-menu ul li > a');
            var liHeight = parseInt(menuA.css('line-height')) + menuA.outerHeight();
            var selectOffset_top = this.$newElement.offset().top;
            var size = 0;
            var menuHeight = 0;
            var selectHeight = this.$newElement.outerHeight();
            button = this.$newElement.find('> button');
            if (id !== undefined) {
                button.attr('id', id);
            }
            for (var i = 0; i < classList.length; i++) {
                if (classList[i] != 'selectpicker') {
                    this.$newElement.addClass(classList[i]);
                }
            }
            button.addClass(this.style);
            this.checkDisabled();
            this.clickListener();
            if (this.size == 'auto') {
                function getSize() {
                    var selectOffset_top_scroll = selectOffset_top - $(window).scrollTop();
                    var windowHeight = window.innerHeight;
                    var menuExtras = parseInt(menu.css('padding-top')) + parseInt(menu.css('padding-bottom')) + parseInt(menu.css('border-top-width')) + parseInt(menu.css('border-bottom-width')) + parseInt(menu.css('margin-top')) + parseInt(menu.css('margin-bottom')) + 2;
                    var selectOffset_bot = windowHeight - selectOffset_top_scroll - selectHeight - menuExtras;
                    if (!select.hasClass('dropup')) {
                        size = Math.floor(selectOffset_bot / liHeight);
                    } else {
                        size = Math.floor((selectOffset_top_scroll - menuExtras) / liHeight);
                    }
                    if (size < 4) {
                        size = 3
                    }
                    ;
                    menuHeight = liHeight * size;
                    if (menu.find('ul li').length > size) {
                        menu.find('ul').css({'max-height': menuHeight + 'px', 'overflow-y': 'scroll'});
                    } else {
                        menu.find('ul').css({'max-height': 'none', 'overflow-y': 'auto'});
                    }
                }

                getSize();
                $(window).resize(getSize);
                $(window).scroll(getSize);
            } else if (this.size && this.size != 'auto' && menu.find('ul li').length > this.size) {
                menuHeight = liHeight * this.size;
                if (this.size == 1) {
                    menuHeight = menuHeight + 8
                }
                menu.find('ul').css({'max-height': menuHeight + 'px', 'overflow-y': 'scroll'});
            }
            this.$newElement.find('ul').bind('DOMNodeInserted',
                $.proxy(this.clickListener, this));
        },

        getTemplate: function () {
            var template =
                "<div class='btn-group bootstrap-select'>" +
                "<button class='btn dropdown-toggle clearfix' data-toggle='dropdown'>" +
                "<span class='filter-option pull-left'>__SELECTED_OPTION</span>&nbsp;" +
                "<span class='caret'></span>" +
                "</button>" +
                "<div class='dropdown-menu' role='menu'>" +
                "<ul>" +
                "__ADD_LI" +
                "</ul>" +
                "</div>" +
                "</div>";

            return template;
        },

        createLi: function (template) {

            var _li = [];
            var _liHtml = '';
            var _this = this;
            var _selected_index = this.$element.find('option:selected').index() ? this.$element.find('option:selected').index() : 0;

            this.$element.find('option').each(function () {
                _li.push($(this).text());
            });

            if (_li.length > 0) {
                template = template.replace('__SELECTED_OPTION', _li[_selected_index]);
                for (var i = 0; i < _li.length; i++) {
                    _liHtml += "<li rel=" + i + "><a tabindex='-1' href='#'>" + _li[i] + "</a></li>";
                }
            }

            this.$element.find('option').eq(_selected_index).prop('selected', true);

            template = template.replace('__ADD_LI', _liHtml);

            return template;
        },

        checkDisabled: function () {
            if (this.$element.is(':disabled')) {
                button.addClass('disabled');
                button.click(function (e) {
                    e.preventDefault();
                });
            }
        },

        clickListener: function () {
            var _this = this;
            $('body').on('touchstart.dropdown', '.dropdown-menu', function (e) {
                e.stopPropagation();
            });
            this.$newElement.find('li').on('click', function (e) {
                e.preventDefault();
                var selected = $(this).index();
                var $this = $(this),
                    rel = $this.attr('rel'),
                    $select = $this.parents('.bootstrap-select');

                if (_this.$element.not(':disabled')) {
                    $select.prev('select').find('option').eq(selected).prop('selected', true);
                    $select.find('.filter-option').html($this.text());

                    // Trigger select 'change'
                    $select.prev('select').trigger('change');
                }

            });
            this.$element.on('change', function (e) {
                var selected = $(this).find('option:selected').text();
                $(this).next('.bootstrap-select').find('.filter-option').html(selected);

            });
        }

    };

    $.fn.selectpicker = function (option, event) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('selectpicker'),
                options = typeof option == 'object' && option;
            if (!data) {
                $this.data('selectpicker', (data = new Selectpicker(this, options, event)));
            }
            if (typeof option == 'string') {
                data[option]();
            }
        });
    };

    $.fn.selectpicker.defaults = {
        style: null,
        size: 'auto'
    }

}(window.jQuery);
/**
 * bootstrap-multiselect.js 1.0.0
 * https://github.com/davidstutz/bootstrap-multiselect
 *
 * Copyright 2012 David Stutz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
!function ($) {

    "use strict"; // jshint ;_;

    function Multiselect(select, options) {

        this.options = this.getOptions(options);
        this.select = $(select);
        this.container = $(this.options.container)
            .append('<button style="width:' + this.options.width + '" class="dropdown-toggle ' + this.options.button + '" data-toggle="dropdown">' + this.options.text($('option:selected', select)) + ' <b class="caret"></b></button>')
            .append('<ul class="dropdown-menu"></ul>');

        // Manually add the multiple attribute, if its not already set.
        if (!this.select.attr('multiple')) {
            this.select.attr('multiple', true);
        }

        // Build the dropdown.
        $('option', this.select).each($.proxy(function (index, element) {
            if ($(element).is(':selected')) {
                $(element).attr('selected', true);
            }

            $('ul', this.container).append('<li><a href="#" style="padding:0;"><label style="margin:0;padding: 3px 20px 3px 20px;width:100%;height:100%;cursor:pointer;"><input style="margin-bottom:5px;" type="checkbox" value="' + $(element).val() + '" /> ' + $(element).text() + '</label</a></li>');

            var selected = $(element).attr('selected') || false;
            var checkbox = $('ul li input[value="' + $(element).val() + '"]', this.container);

            checkbox.attr('checked', selected);

            if (selected) {
                checkbox.parents('li').addClass('active');
            }
        }, this));

        this.select.hide()
            .after(this.container);

        // Bind the change event on the dropdown elements.
        $('ul li input[type="checkbox"]', this.container).on('change', $.proxy(function (event) {
            var checked = $(event.target).attr('checked') || false;

            if (checked) {
                $(event.target).parents('li').addClass('active');
            }
            else {
                $(event.target).parents('li').removeClass('active');
            }

            $('option[value="' + $(event.target).val() + '"]', this.select).attr('selected', checked);

            $('button', this.container).html(this.options.text($('option:selected', this.select)) + ' <b class="caret"></b>');
        }, this));

        $('ul li a', this.container).on('click', function (event) {
            event.stopPropagation();
        });
    };

    Multiselect.prototype = {

        defaults: {
            button: 'btn',
            width: 'auto',
            // Default text function will either print 'None selected' in case no option is selected,
            // or a list of the selected options up to a length of 3 selected options.
            // If more than 3 options are selected, the number of selected options is printed.
            text: function (options) {
                if (options.length == 0) {
                    return 'None selected';
                }
                else if (options.length > 3) {
                    return options.length + ' selected';
                }
                else {
                    var selected = '';
                    options.each(function () {
                        selected += $(this).text() + ', ';
                    });
                    return selected.substr(0, selected.length - 2);
                }
            },
            container: '<div class="btn-group" />',
        },

        constructor: Multiselect,

        reset: function () {

        },

        // Destroy - unbind - the plugin.
        destroy: function () {
            this.container.remove();
            this.select.show();
        },

        // Get options by merging defaults and given options.
        getOptions: function (options) {
            return $.extend({}, this.defaults, options);
        }
    };

    $.fn.multiselect = function (option) {
        return this.each(function () {
            var data = $(this).data('multiselect'),
                options = typeof option == 'object' && option;

            if (!data) {
                $(this).data('multiselect', (data = new Multiselect(this, options)));
            }

            if (typeof option == 'string') {
                data[option]();
            }
        });
    }
}(window.jQuery);
/**
 * bootbox.js v3.0.0
 *
 * http://bootboxjs.com/license.txt
 */
var bootbox = window.bootbox || function (v, n) {
        function h(b, a) {
            null == a && (a = r);
            return "string" === typeof l[a][b] ? l[a][b] : a != s ? h(b, s) : b
        }

        var r = "en", s = "en", t = !0, q = "static", u = "", g = {}, m = {
            setLocale: function (b) {
                for (var a in l)if (a == b) {
                    r = b;
                    return
                }
                throw Error("Invalid locale: " + b);
            }, addLocale: function (b, a) {
                "undefined" === typeof l[b] && (l[b] = {});
                for (var c in a)l[b][c] = a[c]
            }, setIcons: function (b) {
                g = b;
                if ("object" !== typeof g || null == g)g = {}
            }, alert: function () {
                var b = "", a = h("OK"), c = null;
                switch (arguments.length) {
                    case 1:
                        b = arguments[0];
                        break;
                    case 2:
                        b = arguments[0];
                        "function" == typeof arguments[1] ? c = arguments[1] : a = arguments[1];
                        break;
                    case 3:
                        b = arguments[0];
                        a = arguments[1];
                        c = arguments[2];
                        break;
                    default:
                        throw Error("Incorrect number of arguments: expected 1-3");
                }
                return m.dialog(b, {label: a, icon: g.OK, callback: c}, {onEscape: c || !0})
            }, confirm: function () {
                var b = "", a = h("CANCEL"), c = h("CONFIRM"), e = null;
                switch (arguments.length) {
                    case 1:
                        b = arguments[0];
                        break;
                    case 2:
                        b = arguments[0];
                        "function" == typeof arguments[1] ? e = arguments[1] : a = arguments[1];
                        break;
                    case 3:
                        b =
                            arguments[0];
                        a = arguments[1];
                        "function" == typeof arguments[2] ? e = arguments[2] : c = arguments[2];
                        break;
                    case 4:
                        b = arguments[0];
                        a = arguments[1];
                        c = arguments[2];
                        e = arguments[3];
                        break;
                    default:
                        throw Error("Incorrect number of arguments: expected 1-4");
                }
                var j = function () {
                    "function" === typeof e && e(!1)
                };
                return m.dialog(b, [{label: a, icon: g.CANCEL, callback: j}, {
                    label: c,
                    icon: g.CONFIRM,
                    callback: function () {
                        "function" === typeof e && e(!0)
                    }
                }], {onEscape: j})
            }, prompt: function () {
                var b = "", a = h("CANCEL"), c = h("CONFIRM"), e = null, j = "";
                switch (arguments.length) {
                    case 1:
                        b =
                            arguments[0];
                        break;
                    case 2:
                        b = arguments[0];
                        "function" == typeof arguments[1] ? e = arguments[1] : a = arguments[1];
                        break;
                    case 3:
                        b = arguments[0];
                        a = arguments[1];
                        "function" == typeof arguments[2] ? e = arguments[2] : c = arguments[2];
                        break;
                    case 4:
                        b = arguments[0];
                        a = arguments[1];
                        c = arguments[2];
                        e = arguments[3];
                        break;
                    case 5:
                        b = arguments[0];
                        a = arguments[1];
                        c = arguments[2];
                        e = arguments[3];
                        j = arguments[4];
                        break;
                    default:
                        throw Error("Incorrect number of arguments: expected 1-5");
                }
                var d = n("<form></form>");
                d.append("<input autocomplete=off type=text value='" +
                    j + "' />");
                var j = function () {
                    "function" === typeof e && e(null)
                }, k = m.dialog(d, [{label: a, icon: g.CANCEL, callback: j}, {
                    label: c,
                    icon: g.CONFIRM,
                    callback: function () {
                        "function" === typeof e && e(d.find("input[type=text]").val())
                    }
                }], {header: b, show: !1, onEscape: j});
                k.on("shown", function () {
                    d.find("input[type=text]").focus();
                    d.on("submit", function (a) {
                        a.preventDefault();
                        k.find(".btn-primary").click()
                    })
                });
                k.modal("show");
                return k
            }, dialog: function (b, a, c) {
                var e = "", j = [];
                c = c || {};
                null == a ? a = [] : "undefined" == typeof a.length && (a =
                    [a]);
                for (var d = a.length; d--;) {
                    var k = null, g = null, h = null, l = "", m = null;
                    if ("undefined" == typeof a[d].label && "undefined" == typeof a[d]["class"] && "undefined" == typeof a[d].callback) {
                        var k = 0, g = null, p;
                        for (p in a[d])if (g = p, 1 < ++k)break;
                        1 == k && "function" == typeof a[d][p] && (a[d].label = g, a[d].callback = a[d][p])
                    }
                    "function" == typeof a[d].callback && (m = a[d].callback);
                    a[d]["class"] ? h = a[d]["class"] : d == a.length - 1 && 2 >= a.length && (h = "btn-primary");
                    k = a[d].label ? a[d].label : "Option " + (d + 1);
                    a[d].icon && (l = "<i class='" + a[d].icon + "'></i> ");
                    g = a[d].href ? a[d].href : "javascript:;";
                    e = "<a data-handler='" + d + "' class='btn " + h + "' href='" + g + "'>" + l + "" + k + "</a>" + e;
                    j[d] = m
                }
                d = ["<div class='bootbox modal' tabindex='-1' style='overflow:hidden;'>"];
                if (c.header) {
                    h = "";
                    if ("undefined" == typeof c.headerCloseButton || c.headerCloseButton)h = "<a href='javascript:;' class='close'>&times;</a>";
                    d.push("<div class='modal-header'>" + h + "<h3>" + c.header + "</h3></div>")
                }
                d.push("<div class='modal-body'></div>");
                e && d.push("<div class='modal-footer'>" + e + "</div>");
                d.push("</div>");
                var f = n(d.join("\n"));
                ("undefined" === typeof c.animate ? t : c.animate) && f.addClass("fade");
                (e = "undefined" === typeof c.classes ? u : c.classes) && f.addClass(e);
                f.find(".modal-body").html(b);
                f.on("hidden", function () {
                    f.remove()
                });
                f.on("keyup.dismiss.modal", function (a) {
                    if (27 == a.which && c.onEscape) {
                        if ("function" === typeof c.onEscape)c.onEscape();
                        f.modal("hide")
                    }
                });
                f.on("shown", function () {
                    f.find("a.btn-primary:first").focus()
                });
                f.on("click", ".modal-footer a, a.close", function (b) {
                    var c = n(this).data("handler"), d = j[c],
                        e = null;
                    "undefined" !== typeof c && "undefined" !== typeof a[c].href || (b.preventDefault(), "function" == typeof d && (e = d()), !1 !== e && f.modal("hide"))
                });
                n("body").append(f);
                f.modal({backdrop: "undefined" === typeof c.backdrop ? q : c.backdrop, keyboard: !1, show: !1});
                f.on("show", function () {
                    n(v).off("focusin.modal")
                });
                ("undefined" === typeof c.show || !0 === c.show) && f.modal("show");
                return f
            }, modal: function () {
                var b, a, c, e = {onEscape: null, keyboard: !0, backdrop: q};
                switch (arguments.length) {
                    case 1:
                        b = arguments[0];
                        break;
                    case 2:
                        b = arguments[0];
                        "object" == typeof arguments[1] ? c = arguments[1] : a = arguments[1];
                        break;
                    case 3:
                        b = arguments[0];
                        a = arguments[1];
                        c = arguments[2];
                        break;
                    default:
                        throw Error("Incorrect number of arguments: expected 1-3");
                }
                e.header = a;
                c = "object" == typeof c ? n.extend(e, c) : e;
                return m.dialog(b, [], c)
            }, hideAll: function () {
                n(".bootbox").modal("hide")
            }, animate: function (b) {
                t = b
            }, backdrop: function (b) {
                q = b
            }, classes: function (b) {
                u = b
            }
        }, l = {
            en: {OK: "OK", CANCEL: "Cancel", CONFIRM: "OK"},
            fr: {OK: "OK", CANCEL: "Annuler", CONFIRM: "D'accord"},
            de: {
                OK: "OK", CANCEL: "Abbrechen",
                CONFIRM: "Akzeptieren"
            },
            es: {OK: "OK", CANCEL: "Cancelar", CONFIRM: "Aceptar"},
            br: {OK: "OK", CANCEL: "Cancelar", CONFIRM: "Sim"},
            nl: {OK: "OK", CANCEL: "Annuleren", CONFIRM: "Accepteren"},
            ru: {
                OK: "OK",
                CANCEL: "\u041e\u0442\u043c\u0435\u043d\u0430",
                CONFIRM: "\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c"
            },
            it: {OK: "OK", CANCEL: "Annulla", CONFIRM: "Conferma"}
        };
        return m
    }(document, window.jQuery);
window.bootbox = bootbox;
/* ===========================================================
 * bootstrap-modalmanager.js v2.0
 * ===========================================================
 * Copyright 2012 Jordan Schroter.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */

!function ($) {

    "use strict"; // jshint ;_;

    /* MODAL MANAGER CLASS DEFINITION
     * ====================== */

    var ModalManager = function (element, options) {
        this.init(element, options);
    }

    ModalManager.prototype = {

        constructor: ModalManager,

        init: function (element, options) {
            this.$element = $(element);
            this.options = $.extend({}, $.fn.modalmanager.defaults, this.$element.data(), typeof options == 'object' && options);
            this.stack = [];
            this.backdropCount = 0;
        },

        createModal: function (element, options) {
            $(element).modal($.extend({manager: this}, options));
        },

        appendModal: function (modal) {
            this.stack.push(modal);

            var that = this;

            modal.$element.on('show.modalmanager', targetIsSelf(function (e) {
                modal.isShown = true;

                var transition = $.support.transition && modal.$element.hasClass('fade');

                that.$element
                    .toggleClass('modal-open', that.hasOpenModal())
                    .toggleClass('page-overflow', $(window).height() < that.$element.height());

                modal.$parent = modal.$element.parent();

                modal.$container = that.createContainer(modal);

                modal.$element.appendTo(modal.$container);

                var modalOverflow = $(window).height() < modal.$element.height() || modal.options.modalOverflow;

                that.backdrop(modal, function () {

                    modal.$element.show();

                    if (transition) {
                        modal.$element[0].style.display = 'run-in';
                        modal.$element[0].offsetWidth;
                        modal.$element.one($.support.transition.end, function () {
                            modal.$element[0].style.display = 'block'
                        });
                    }

                    modal.$element
                        .toggleClass('modal-overflow', modalOverflow)
                        .css('margin-top', modalOverflow ? 0 : 0 - modal.$element.height() / 2)
                        .addClass('in')
                        .attr('aria-hidden', false);

                    var complete = function () {
                        that.setFocus();
                        modal.$element.triggerHandler('shown');
                    }

                    transition ?
                        modal.$element.one($.support.transition.end, complete) :
                        complete();
                });
            }));

            modal.$element.on('hidden.modalmanager', targetIsSelf(function (e) {

                that.backdrop(modal);

                if (modal.$backdrop) {
                    $.support.transition && modal.$element.hasClass('fade') ?
                        modal.$backdrop.one($.support.transition.end, function () {
                            that.destroyModal(modal)
                        }) :
                        that.destroyModal(modal);
                } else {
                    that.destroyModal(modal);
                }

            }));

            modal.$element.on('destroy.modalmanager', targetIsSelf(function (e) {
                that.removeModal(modal);
            }));
        },

        destroyModal: function (modal) {

            modal.destroy();

            var hasOpenModal = this.hasOpenModal();

            this.$element.toggleClass('modal-open', hasOpenModal);

            if (!hasOpenModal) {
                this.$element.removeClass('page-overflow');
            }

            this.removeContainer(modal);

            this.setFocus();
        },

        hasOpenModal: function () {
            for (var i = 0; i < this.stack.length; i++) {
                if (this.stack[i].isShown) return true;
            }

            return false;
        },

        setFocus: function () {
            var topModal;

            for (var i = 0; i < this.stack.length; i++) {
                if (this.stack[i].isShown) topModal = this.stack[i];
            }

            if (!topModal) return;

            topModal.focus();

        },

        removeModal: function (modal) {
            modal.$element.off('.modalmanager');
            if (modal.$backdrop) this.removeBackdrop.call(modal);
            this.stack.splice(this.getIndexOfModal(modal), 1);
        },

        getModalAt: function (index) {
            return this.stack[index];
        },

        getIndexOfModal: function (modal) {
            for (var i = 0; i < this.stack.length; i++) {
                if (modal === this.stack[i]) return i;
            }
        },

        removeBackdrop: function (modal) {
            modal.$backdrop.remove();
            modal.$backdrop = null;
        },

        createBackdrop: function (animate) {
            var $backdrop;

            if (!this.isLoading) {
                $backdrop = $('<div class="modal-backdrop ' + animate + '" />')
                    .appendTo(this.$element);

            } else {
                $backdrop = this.$loading;
                $backdrop.off('.modalmanager');
                this.$spinner.remove();
                this.isLoading = false;
                this.$loading = this.$spinner = null;
            }

            return $backdrop
        },

        removeContainer: function (modal) {
            modal.$container.remove();
            modal.$container = null;
        },

        createContainer: function (modal) {
            var $container;

            $container = $('<div class="modal-scrollable">')
                .css('z-index', getzIndex('modal',
                    modal ? this.getIndexOfModal(modal) : this.stack.length))
                .appendTo(this.$element);

            if (modal && modal.options.backdrop != 'static') {
                $container.on('click.modal', targetIsSelf(function (e) {
                    modal.hide();
                }));
            } else if (modal) {
                $container.on('click.modal', targetIsSelf(function (e) {
                    modal.attention();
                }));
            }

            return $container;

        },

        backdrop: function (modal, callback) {
            var animate = modal.$element.hasClass('fade') ? 'fade' : '',
                showBackdrop = modal.options.backdrop &&
                    this.backdropCount < this.options.backdropLimit;

            if (modal.isShown && showBackdrop) {
                var doAnimate = $.support.transition && animate && !this.isLoading;


                modal.$backdrop = this.createBackdrop(animate);

                modal.$backdrop.css('z-index', getzIndex('backdrop', this.getIndexOfModal(modal)))

                if (doAnimate) modal.$backdrop[0].offsetWidth // force reflow

                modal.$backdrop.addClass('in')

                this.backdropCount += 1;

                doAnimate ?
                    modal.$backdrop.one($.support.transition.end, callback) :
                    callback();

            } else if (!modal.isShown && modal.$backdrop) {
                modal.$backdrop.removeClass('in');

                this.backdropCount -= 1;

                var that = this;

                $.support.transition && modal.$element.hasClass('fade') ?
                    modal.$backdrop.one($.support.transition.end, function () {
                        that.removeBackdrop(modal)
                    }) :
                    that.removeBackdrop(modal);

            } else if (callback) {
                callback();
            }
        },

        removeLoading: function () {
            this.$loading && this.$loading.remove();
            this.$loading = null;
            this.isLoading = false;
        },

        loading: function (callback) {
            callback = callback || function () {
                };

            this.$element
                .toggleClass('modal-open', !this.isLoading || this.hasOpenModal())
                .toggleClass('page-overflow', $(window).height() < this.$element.height());

            if (!this.isLoading) {

                this.$loading = this.createBackdrop('fade');

                this.$loading[0].offsetWidth // force reflow	

                this.$loading
                    .css('z-index', getzIndex('backdrop', this.stack.length))
                    .addClass('in');

                var $spinner = $(this.options.spinner)
                    .css('z-index', getzIndex('modal', this.stack.length))
                    .appendTo(this.$element)
                    .addClass('in');

                this.$spinner = $(this.createContainer())
                    .append($spinner)
                    .on('click.modalmanager', $.proxy(this.loading, this));

                this.isLoading = true;

                $.support.transition ?
                    this.$loading.one($.support.transition.end, callback) :
                    callback();

            } else if (this.isLoading && this.$loading) {
                this.$loading.removeClass('in');

                if (this.$spinner) this.$spinner.remove();

                var that = this;
                $.support.transition ?
                    this.$loading.one($.support.transition.end, function () {
                        that.removeLoading()
                    }) :
                    that.removeLoading();

            } else if (callback) {
                callback(this.isLoading);
            }
        }
    }

    /* PRIVATE METHODS
     * ======================= */

    // computes and caches the zindexes
    var getzIndex = (function () {
        var zIndexFactor,
            baseIndex = {};

        return function (type, pos) {

            if (typeof zIndexFactor === 'undefined') {
                var $baseModal = $('<div class="modal hide" />').appendTo('body'),
                    $baseBackdrop = $('<div class="modal-backdrop hide" />').appendTo('body');

                baseIndex['modal'] = +$baseModal.css('z-index'),
                    baseIndex['backdrop'] = +$baseBackdrop.css('z-index'),
                    zIndexFactor = baseIndex['modal'] - baseIndex['backdrop'];

                $baseModal.remove();
                $baseBackdrop.remove();
                $baseBackdrop = $baseModal = null;
            }

            return baseIndex[type] + (zIndexFactor * pos);

        }
    }())

    // make sure the event target is the modal itself in order to prevent 
    // other components such as tabsfrom triggering the modal manager. 
    // if Boostsrap namespaced events, this would not be needed.
    function targetIsSelf(callback) {
        return function (e) {
            if (this === e.target) {
                return callback.apply(this, arguments);
            }
        }
    }


    /* MODAL MANAGER PLUGIN DEFINITION
     * ======================= */

    $.fn.modalmanager = function (option) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('modalmanager');

            if (!data) $this.data('modalmanager', (data = new ModalManager(this, option)))
            if (typeof option === 'string') data[option]()
        })
    }

    $.fn.modalmanager.defaults = {
        backdropLimit: 999,
        spinner: '<div class="loading-spinner fade" style="width: 200px; margin-left: -100px;"><div class="progress progress-striped active"><div class="bar" style="width: 100%;"></div></div></div>'
    }

    $.fn.modalmanager.Constructor = ModalManager

}(jQuery);
/* ===========================================================
 * bootstrap-modal.js v2.0
 * ===========================================================
 * Copyright 2012 Jordan Schroter
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

    "use strict"; // jshint ;_;

    /* MODAL CLASS DEFINITION
     * ====================== */

    var Modal = function (element, options) {
        this.init(element, options);
    }

    Modal.prototype = {

        constructor: Modal,

        init: function (element, options) {
            this.options = options;

            this.$element = $(element)
                .delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));

            this.options.remote && this.$element.find('.modal-body').load(this.options.remote);

            var manager = typeof this.options.manager === 'function' ?
                this.options.manager.call(this) : this.options.manager;

            manager = manager.appendModal ?
                manager : $(manager).modalmanager().data('modalmanager');

            manager.appendModal(this);
        },

        toggle: function () {
            return this[!this.isShown ? 'show' : 'hide']();
        },

        show: function () {
            var that = this,
                e = $.Event('show');

            if (this.isShown) return;

            this.$element.triggerHandler(e);

            if (e.isDefaultPrevented()) return;

            if (this.options.width) {
                this.$element.css('width', this.options.width);

                var that = this;
                this.$element.css('margin-left', function () {
                    if (/%/ig.test(that.options.width)) {
                        return -(parseInt(that.options.width) / 2) + '%';
                    } else {
                        return -($(this).width() / 2) + 'px';
                    }
                });
            }

            var prop = this.options.height ? 'height' : 'max-height';

            var value = this.options.height || this.options.maxHeight;

            if (value) {
                this.$element.find('.modal-body')
                    .css('overflow', 'auto')
                    .css(prop, value);
            }

            this.escape();

            this.tab();

            this.options.loading && this.loading();
        },

        hide: function (e) {
            e && e.preventDefault();

            e = $.Event('hide');

            this.$element.triggerHandler(e);

            if (!this.isShown || e.isDefaultPrevented()) return (this.isShown = false);

            this.isShown = false;

            this.escape();

            this.tab();

            this.isLoading && this.loading();

            $(document).off('focusin.modal');

            this.$element
                .removeClass('in')
                .removeClass('animated')
                .removeClass(this.options.attentionAnimation)
                .removeClass('modal-overflow')
                .attr('aria-hidden', true);

            $.support.transition && this.$element.hasClass('fade') ?
                this.hideWithTransition() :
                this.hideModal();
        },

        tab: function () {
            var that = this;

            if (this.isShown && this.options.consumeTab) {
                this.$element.on('keydown.tabindex.modal', '[data-tabindex]', function (e) {
                    if (e.keyCode && e.keyCode == 9) {
                        var $next = $(this),
                            $rollover = $(this);

                        that.$element.find('[data-tabindex]:enabled:not([readonly])').each(function (e) {
                            if (!e.shiftKey) {
                                $next = $next.data('tabindex') < $(this).data('tabindex') ?
                                    $next = $(this) :
                                    $rollover = $(this);
                            } else {
                                $next = $next.data('tabindex') > $(this).data('tabindex') ?
                                    $next = $(this) :
                                    $rollover = $(this);
                            }
                        });

                        $next[0] !== $(this)[0] ?
                            $next.focus() : $rollover.focus();

                        e.preventDefault();

                    }
                });
            } else if (!this.isShown) {
                this.$element.off('keydown.tabindex.modal');
            }
        },

        escape: function () {
            var that = this;
            if (this.isShown && this.options.keyboard) {
                if (!this.$element.attr('tabindex')) this.$element.attr('tabindex', -1);

                this.$element.on('keyup.dismiss.modal', function (e) {
                    e.which == 27 && that.hide();
                });
            } else if (!this.isShown) {
                this.$element.off('keyup.dismiss.modal')
            }
        },

        hideWithTransition: function () {
            var that = this
                , timeout = setTimeout(function () {
                    that.$element.off($.support.transition.end)
                    that.hideModal()
                }, 500);

            this.$element.one($.support.transition.end, function () {
                clearTimeout(timeout)
                that.hideModal()
            });
        },

        hideModal: function () {
            this.$element
                .hide()
                .triggerHandler('hidden');


            var prop = this.options.height ? 'height' : 'max-height';
            var value = this.options.height || this.options.maxHeight;

            if (value) {
                this.$element.find('.modal-body')
                    .css('overflow', '')
                    .css(prop, '');
            }

        },

        removeLoading: function () {
            this.$loading.remove();
            this.$loading = null;
            this.isLoading = false;
        },

        loading: function (callback) {
            callback = callback || function () {
                };

            var animate = this.$element.hasClass('fade') ? 'fade' : '';

            if (!this.isLoading) {
                var doAnimate = $.support.transition && animate;

                this.$loading = $('<div class="loading-mask ' + animate + '">')
                    .append(this.options.spinner)
                    .appendTo(this.$element);

                if (doAnimate) this.$loading[0].offsetWidth // force reflow	

                this.$loading.addClass('in')

                this.isLoading = true;

                doAnimate ?
                    this.$loading.one($.support.transition.end, callback) :
                    callback();

            } else if (this.isLoading && this.$loading) {
                this.$loading.removeClass('in');

                var that = this;
                $.support.transition && this.$element.hasClass('fade') ?
                    this.$loading.one($.support.transition.end, function () {
                        that.removeLoading()
                    }) :
                    that.removeLoading();

            } else if (callback) {
                callback(this.isLoading);
            }
        },

        focus: function () {
            var $focusElem = this.$element.find(this.options.focusOn);

            $focusElem = $focusElem.length ? $focusElem : this.$element;

            $focusElem.focus();
        },

        attention: function () {
            // NOTE: transitionEnd with keyframes causes odd behaviour

            if (this.options.attentionAnimation) {
                this.$element
                    .removeClass('animated')
                    .removeClass(this.options.attentionAnimation);

                var that = this;

                setTimeout(function () {
                    that.$element
                        .addClass('animated')
                        .addClass(that.options.attentionAnimation);
                }, 0);
            }


            this.focus();
        },


        destroy: function () {
            var e = $.Event('destroy');
            this.$element.triggerHandler(e);
            if (e.isDefaultPrevented()) return;

            this.teardown();
        },

        teardown: function () {
            if (!this.$parent.length) {
                this.$element.remove();
                this.$element = null;
                return;
            }

            if (this.$parent !== this.$element.parent()) {
                this.$element.appendTo(this.$parent);
            }

            this.$element.off('.modal');
            this.$element.removeData('modal');
            this.$element
                .removeClass('in')
                .attr('aria-hidden', true);
        }
    }


    /* MODAL PLUGIN DEFINITION
     * ======================= */

    $.fn.modal = function (option) {
        return this.each(function () {
            var $this = $(this),
                data = $this.data('modal'),
                options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);

            if (!data) $this.data('modal', (data = new Modal(this, options)))
            if (typeof option == 'string') data[option]()
            else if (options.show) data.show()
        })
    }

    $.fn.modal.defaults = {
        keyboard: true,
        backdrop: true,
        loading: false,
        show: true,
        width: null,
        height: null,
        maxHeight: null,
        modalOverflow: false,
        consumeTab: true,
        focusOn: null,
        attentionAnimation: 'shake',
        manager: 'body',
        spinner: '<div class="loading-spinner" style="width: 200px; margin-left: -100px;"><div class="progress progress-striped active"><div class="bar" style="width: 100%;"></div></div></div>'
    }

    $.fn.modal.Constructor = Modal


    /* MODAL DATA-API
     * ============== */

    $(function () {
        $(document).off('.modal').on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
            var $this = $(this),
                href = $this.attr('href'),
                $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))), //strip for ie7 
                option = $target.data('modal') ? 'toggle' : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data());

            e.preventDefault();
            $target
                .modal(option)
                .one('hide', function () {
                    $this.focus();
                })
        });
    });

}(window.jQuery);
/*!
 * jQuery twitter bootstrap wizard plugin
 * Examples and documentation at: http://github.com/VinceG/twitter-bootstrap-wizard
 * version 1.0
 * Requires jQuery v1.3.2 or later
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 * Authors: Vadim Vincent Gabriel (http://vadimg.com)
 */
(function (b) {
    var a = function (e, d) {
        var e = b(e);
        var g = this;
        var c = b.extend({}, b.fn.bootstrapWizard.defaults, d);
        var f = null;
        var h = null;
        this.fixNavigationButtons = function () {
            if (!f.length) {
                h.find("a:first").tab("show");
                f = h.find("li:first")
            }
            if (g.firstIndex() >= g.currentIndex()) {
                b("li.previous", e).addClass("disabled")
            } else {
                b("li.previous", e).removeClass("disabled")
            }
            if (g.currentIndex() >= g.navigationLength()) {
                b("li.next", e).addClass("disabled")
            } else {
                b("li.next", e).removeClass("disabled")
            }
            if (c.onTabShow && typeof c.onTabShow === "function" && c.onTabShow(f, h, g.currentIndex()) === false) {
                return false
            }
        };
        this.next = function (i) {
            if (e.hasClass("last")) {
                return false
            }
            if (c.onNext && typeof c.onNext === "function" && c.onNext(f, h, g.nextIndex()) === false) {
                return false
            }
            $index = g.nextIndex();
            if ($index > g.navigationLength()) {
            } else {
                h.find("li:eq(" + $index + ") a").tab("show")
            }
        };
        this.previous = function (i) {
            if (e.hasClass("first")) {
                return false
            }
            if (c.onPrevious && typeof c.onPrevious === "function" && c.onPrevious(f, h, g.previousIndex()) === false) {
                return false
            }
            $index = g.previousIndex();
            if ($index < 0) {
            } else {
                h.find("li:eq(" + $index + ") a").tab("show")
            }
        };
        this.first = function (i) {
            if (c.onFirst && typeof c.onFirst === "function" && c.onFirst(f, h, g.firstIndex()) === false) {
                return false
            }
            if (e.hasClass("disabled")) {
                return false
            }
            h.find("li:eq(0) a").tab("show")
        };
        this.last = function (i) {
            if (c.onLast && typeof c.onLast === "function" && c.onLast(f, h, g.lastIndex()) === false) {
                return false
            }
            if (e.hasClass("disabled")) {
                return false
            }
            h.find("li:eq(" + g.navigationLength() + ") a").tab("show")
        };
        this.currentIndex = function () {
            return h.find("li").index(f)
        };
        this.firstIndex = function () {
            return 0
        };
        this.lastIndex = function () {
            return g.navigationLength()
        };
        this.getIndex = function (i) {
            return h.find("li").index(i)
        };
        this.nextIndex = function () {
            return h.find("li").index(f) + 1
        };
        this.previousIndex = function () {
            return h.find("li").index(f) - 1
        };
        this.navigationLength = function () {
            return h.find("li").length - 1
        };
        this.activeTab = function () {
            return f
        };
        this.nextTab = function () {
            return h.find("li:eq(" + (g.currentIndex() + 1) + ")").length ? h.find("li:eq(" + (g.currentIndex() + 1) + ")") : null
        };
        this.previousTab = function () {
            if (g.currentIndex() <= 0) {
                return null
            }
            return h.find("li:eq(" + parseInt(g.currentIndex() - 1) + ")")
        };
        h = e.find("ul:first", e);
        f = h.find("li.active", e);
        if (!h.hasClass(c.tabClass)) {
            h.addClass(c.tabClass)
        }
        if (c.onInit && typeof c.onInit === "function") {
            c.onInit(f, h, 0)
        }
        b(c.nextSelector, e).bind("click", g.next);
        b(c.previousSelector, e).bind("click", g.previous);
        b(c.lastSelector, e).bind("click", g.last);
        b(c.firstSelector, e).bind("click", g.first);
        if (c.onShow && typeof c.onShow === "function") {
            c.onShow(f, h, g.nextIndex())
        }
        g.fixNavigationButtons();
        b('a[data-toggle="tab"]', e).on("click", function (i) {
            if (c.onTabClick && typeof c.onTabClick === "function" && c.onTabClick(f, h, g.currentIndex()) === false) {
                return false
            }
        });
        b('a[data-toggle="tab"]', e).on("show", function (i) {
            $element = b(i.target).parent();
            if ($element.hasClass("disabled")) {
                return false
            }
            f = $element;
            g.fixNavigationButtons()
        })
    };
    b.fn.bootstrapWizard = function (c) {
        return this.each(function (d) {
            var e = b(this);
            if (e.data("bootstrapWizard")) {
                return
            }
            var f = new a(e, c);
            e.data("bootstrapWizard", f)
        })
    };
    b.fn.bootstrapWizard.defaults = {
        tabClass: "nav nav-pills",
        nextSelector: ".wizard li.next",
        previousSelector: ".wizard li.previous",
        firstSelector: ".wizard li.first",
        lastSelector: ".wizard li.last",
        onShow: null,
        onInit: null,
        onNext: null,
        onPrevious: null,
        onLast: null,
        onFirst: null,
        onTabClick: null,
        onTabShow: null
    }
})(jQuery);
/*!
 * jQuery Cookie Plugin v1.3
 * https://github.com/carhartl/jquery-cookie
 */
/*!
 * jQuery UI Widget October 23, 2012
 * http://jqueryui.com
 * http://api.jqueryui.com/jQuery.widget/
 */
/*!
 * Bootstrap Widget plugin
 *
 * Licensed under the GPL license:
 * http://www.gnu.org/licenses/gpl.html
 *
 */
(function (a, b) {
    a.widget("bootstrap.bwizard", {
        options: {
            autoPlay: false,
            delay: 3000,
            loop: false,
            hideOption: {fade: true},
            showOption: {fade: true, duration: 400},
            ajaxOptions: null,
            cache: false,
            cookie: null,
            stepHeaderTemplate: "",
            panelTemplate: "",
            spinner: "",
            backBtnText: "&larr; Previous",
            nextBtnText: "Next &rarr;",
            add: null,
            remove: null,
            activeIndexChanged: null,
            show: null,
            load: null,
            validating: null
        },
        _defaults: {
            stepHeaderTemplate: "<li>#{title}</li>",
            panelTemplate: "<div></div>",
            spinner: "<em>Loading&#8230;</em>"
        },
        _create: function () {
            var c = this;
            c._pageLize(true)
        },
        _init: function () {
            var d = this.options, c = d.disabled;
            if (d.disabledState) {
                this.disable();
                d.disabled = c
            } else {
                if (d.autoPlay) {
                    this.play()
                }
            }
        },
        _setOption: function (c, d) {
            a.Widget.prototype._setOption.apply(this, arguments);
            switch (c) {
                case"activeIndex":
                    this.show(d);
                    break;
                case"navButtons":
                    this._createButtons();
                    break;
                default:
                    this._pageLize();
                    break
            }
        },
        play: function () {
            var d = this.options, c = this, e;
            if (!this.element.data("intId.bwizard")) {
                e = window.setInterval(function () {
                    var f = d.activeIndex + 1;
                    if (f >= c.panels.length) {
                        if (d.loop) {
                            f = 0
                        } else {
                            c.stop();
                            return
                        }
                    }
                    c.show(f)
                }, d.delay);
                this.element.data("intId.bwizard", e)
            }
        },
        stop: function () {
            var c = this.element.data("intId.bwizard");
            if (c) {
                window.clearInterval(c);
                this.element.removeData("intId.bwizard")
            }
        },
        _normalizeBlindOption: function (d) {
            if (d.blind === b) {
                d.blind = false
            }
            if (d.fade === b) {
                d.fade = false
            }
            if (d.duration === b) {
                d.duration = 200
            }
            if (typeof d.duration === "string") {
                try {
                    d.duration = parseInt(d.duration, 10)
                } catch (c) {
                    d.duration = 200
                }
            }
        },
        _createButtons: function () {
            var e = this, g = this.options, d, c = g.backBtnText, f = g.nextBtnText;
            this._removeButtons();
            if (g.navButtons === "none") {
                return
            }
            if (!this.buttons) {
                d = g.navButtons;
                this.buttons = a('<ul class="pager"/>');
                this.buttons.addClass("bwizard-buttons");
                this.backBtn = a("<li class='previous'><a href='#'>" + c + "</a></li>").appendTo(this.buttons).bind({
                    click: function () {
                        e.back();
                        return false
                    }
                }).attr("role", "button");
                this.nextBtn = a("<li class='next'><a href='#'>" + f + "</a>").appendTo(this.buttons).bind({
                    click: function () {
                        e.next();
                        return false
                    }
                }).attr("role", "button");
                this.buttons.appendTo(this.element)
            }
        },
        _removeButtons: function () {
            if (this.buttons) {
                this.buttons.remove();
                this.buttons = b
            }
        },
        _pageLize: function (f) {
            var d = this, e = this.options, h = /^#.+/;
            var g = false;
            this.list = this.element.children("ol,ul").eq(0);
            var c = this.list.length;
            if (this.list && c === 0) {
                this.list = null
            }
            if (this.list) {
                if (this.list.get(0).tagName.toLowerCase() === "ol") {
                    g = true
                }
                this.lis = a("li", this.list);
                this.lis.each(function () {
                    a(this).find(".label").remove();
                    var j = a(this).index() + 1;
                    a(this).css("z-index", d.lis.length - j);
                    a(this).contents().wrap('<span class="hidden-phone"/>');
                    a(this).prepend('<span class="label">' + j + "</span>");
                    if (!g) {
                        a(this).find(".label").addClass("visible-phone")
                    }
                })
            }
            if (f) {
                this.panels = a("> div", this.element);
                this.panels.each(function (k, l) {
                    var j = a(l).attr("src");
                    if (j && !h.test(j)) {
                        a.data(l, "load.bwizard", j.replace(/#.*$/, ""))
                    }
                });
                this.element.addClass("bwizard clearfix");
                if (this.list) {
                    this.list.addClass("bwizard-steps clearfix").attr("role", "tablist").attr("role", "tab")
                }
                this.container = a("<div/>");
                this.container.addClass("bwizard-body");
                this.container.append(this.panels);
                this.container.appendTo(this.element);
                this.panels.attr("role", "tabpanel");
                if (e.activeIndex === b) {
                    if (typeof e.activeIndex !== "number" && e.cookie) {
                        e.activeIndex = parseInt(d._cookie(), 10)
                    }
                    if (typeof e.activeIndex !== "number" && this.panels.filter(".bwizard-activated").length) {
                        e.activeIndex = this.panels.index(this.panels.filter(".bwizard-activated"))
                    }
                    e.activeIndex = e.activeIndex || (this.panels.length ? 0 : -1)
                } else {
                    if (e.activeIndex === null) {
                        e.activeIndex = -1
                    }
                }
                e.activeIndex = ((e.activeIndex >= 0 && this.panels[e.activeIndex]) || e.activeIndex < 0) ? e.activeIndex : 0;
                this.panels.addClass("hide").attr("aria-hidden", true);
                if (e.activeIndex >= 0 && this.panels.length) {
                    this.panels.eq(e.activeIndex).removeClass("hide").addClass("bwizard-activated").attr("aria-hidden", false);
                    this.load(e.activeIndex)
                }
                this._createButtons()
            } else {
                this.panels = a("> div", this.container);
                e.activeIndex = this.panels.index(this.panels.filter(".bwizard-activated"))
            }
            this._refreshStep();
            if (e.cookie) {
                this._cookie(e.activeIndex, e.cookie)
            }
            if (e.cache === false) {
                this.panels.removeData("cache.bwizard")
            }
            if (e.showOption === b || e.showOption === null) {
                e.showOption = {}
            }
            this._normalizeBlindOption(e.showOption);
            if (e.hideOption === b || e.hideOption === null) {
                e.hideOption = {}
            }
            this._normalizeBlindOption(e.hideOption);
            this.panels.unbind(".bwizard")
        },
        _refreshStep: function () {
            var c = this.options;
            if (this.lis) {
                this.lis.removeClass("current").attr("aria-selected", false).find(".label").removeClass("badge-inverse");
                if (c.activeIndex >= 0 && c.activeIndex <= this.lis.length - 1) {
                    if (this.lis) {
                        this.lis.eq(c.activeIndex).addClass("current").attr("aria-selected", true).find(".label").addClass("badge-inverse")
                    }
                }
            }
            if (this.buttons && !c.loop) {
                this.backBtn[c.activeIndex <= 0 ? "addClass" : "removeClass"]("disabled").attr("aria-disabled", c.activeIndex === 0);
                this.nextBtn[c.activeIndex >= this.panels.length - 1 ? "addClass" : "removeClass"]("disabled").attr("aria-disabled", (c.activeIndex >= this.panels.length - 1))
            }
        },
        _sanitizeSelector: function (c) {
            return c.replace(/:/g, "\\:")
        },
        _cookie: function () {
            var c = this.cookie || (this.cookie = this.options.cookie.name);
            return a.cookie.apply(null, [c].concat(a.makeArray(arguments)))
        },
        _ui: function (c) {
            return {panel: c, index: this.panels.index(c)}
        },
        _removeSpinner: function () {
            var c = this.element.data("spinner.bwizard");
            if (c) {
                this.element.removeData("spinner.bwizard");
                c.remove()
            }
        },
        _resetStyle: function (c) {
            c.css({display: ""});
            if (!a.support.opacity) {
                c[0].style.removeAttribute("filter")
            }
        },
        destroy: function () {
            var c = this.options;
            this.abort();
            this.stop();
            this._removeButtons();
            this.element.unbind(".bwizard").removeClass(["bwizard", "clearfix"].join(" ")).removeData("bwizard");
            if (this.list) {
                this.list.removeClass("bwizard-steps clearfix").removeAttr("role")
            }
            if (this.lis) {
                this.lis.removeClass("current").removeAttr("role");
                this.lis.each(function () {
                    if (a.data(this, "destroy.bwizard")) {
                        a(this).remove()
                    } else {
                        a(this).removeAttr("aria-selected")
                    }
                })
            }
            this.panels.each(function () {
                var d = a(this).unbind(".bwizard");
                a.each(["load", "cache"], function (e, f) {
                    d.removeData(f + ".bwizard")
                });
                if (a.data(this, "destroy.bwizard")) {
                    a(this).remove()
                } else {
                    a(this).removeClass(["bwizard-activated", "hide"].join(" ")).css({
                        position: "",
                        left: "",
                        top: ""
                    }).removeAttr("aria-hidden")
                }
            });
            this.container.replaceWith(this.container.contents());
            if (c.cookie) {
                this._cookie(null, c.cookie)
            }
            return this
        },
        add: function (d, g) {
            if (d === b) {
                d = this.panels.length
            }
            if (g === b) {
                g = "Step " + d
            }
            var c = this, f = this.options, e = a(f.panelTemplate || c._defaults.panelTemplate).data("destroy.bwizard", true), h;
            e.addClass("hide").attr("aria-hidden", true);
            if (d >= this.panels.length) {
                if (this.panels.length > 0) {
                    e.insertAfter(this.panels[this.panels.length - 1])
                } else {
                    e.appendTo(this.container)
                }
            } else {
                e.insertBefore(this.panels[d])
            }
            if (this.list && this.lis) {
                h = a((f.stepHeaderTemplate || c._defaults.stepHeaderTemplate).replace(/#\{title\}/g, g));
                h.addClass("ui-widget-header ui-corner-all ui-priority-secondary").data("destroy.bwizard", true);
                if (d >= this.lis.length) {
                    h.appendTo(this.list)
                } else {
                    h.insertBefore(this.lis[d])
                }
            }
            this._pageLize();
            if (this.panels.length === 1) {
                f.activeIndex = 0;
                h.addClass("ui-priority-primary");
                e.removeClass("hide").addClass("bwizard-activated").attr("aria-hidden", false);
                this.element.queue("bwizard", function () {
                    c._trigger("show", null, c._ui(c.panels[0]))
                });
                this._refreshStep();
                this.load(0)
            }
            this._trigger("add", null, this._ui(this.panels[d]));
            return this
        },
        remove: function (c) {
            var e = this.options, d = this.panels.eq(c).remove();
            this.lis.eq(c).remove();
            if (c < e.activeIndex) {
                e.activeIndex--
            }
            this._pageLize();
            if (d.hasClass("bwizard-activated") && this.panels.length >= 1) {
                this.show(c + (c < this.panels.length ? 0 : -1))
            }
            this._trigger("remove", null, this._ui(d[0]));
            return this
        },
        _showPanel: function (f) {
            var c = this, g = this.options, e = a(f), d;
            e.addClass("bwizard-activated");
            if ((g.showOption.blind || g.showOption.fade) && g.showOption.duration > 0) {
                d = {duration: g.showOption.duration};
                if (g.showOption.blind) {
                    d.height = "toggle"
                }
                if (g.showOption.fade) {
                    d.opacity = "toggle"
                }
                e.hide().removeClass("hide").animate(d, g.showOption.duration || "normal", function () {
                    c._resetStyle(e);
                    c._trigger("show", null, c._ui(e[0]));
                    c._removeSpinner();
                    e.attr("aria-hidden", false);
                    c._trigger("activeIndexChanged", null, c._ui(e[0]))
                })
            } else {
                e.removeClass("hide").attr("aria-hidden", false);
                c._trigger("show", null, c._ui(e[0]));
                c._removeSpinner();
                c._trigger("activeIndexChanged", null, c._ui(e[0]))
            }
        },
        _hidePanel: function (f) {
            var d = this, g = this.options, c = a(f), e;
            c.removeClass("bwizard-activated");
            if ((g.hideOption.blind || g.hideOption.fade) && g.hideOption.duration > 0) {
                e = {duration: g.hideOption.duration};
                if (g.hideOption.blind) {
                    e.height = "toggle"
                }
                if (g.hideOption.fade) {
                    e.opacity = "toggle"
                }
                c.animate(e, g.hideOption.duration || "normal", function () {
                    c.addClass("hide").attr("aria-hidden", true);
                    d._resetStyle(c);
                    d.element.dequeue("bwizard")
                })
            } else {
                c.addClass("hide").attr("aria-hidden", true);
                this.element.dequeue("bwizard")
            }
        },
        show: function (f) {
            if (f < 0 || f >= this.panels.length) {
                return this
            }
            if (this.element.queue("bwizard").length > 0) {
                return this
            }
            var d = this, h = this.options, e = a.extend({}, this._ui(this.panels[h.activeIndex])), c, g;
            e.nextIndex = f;
            e.nextPanel = this.panels[f];
            if (this._trigger("validating", null, e) === false) {
                return this
            }
            c = this.panels.filter(":not(.hide)");
            g = this.panels.eq(f);
            h.activeIndex = f;
            this.abort();
            if (h.cookie) {
                this._cookie(h.activeIndex, h.cookie)
            }
            this._refreshStep();
            if (g.length) {
                if (c.length) {
                    this.element.queue("bwizard", function () {
                        d._hidePanel(c)
                    })
                }
                this.element.queue("bwizard", function () {
                    d._showPanel(g)
                });
                this.load(f)
            } else {
                throw"Bootstrap Wizard: Mismatching fragment identifier."
            }
            return this
        },
        next: function () {
            var d = this.options, c = d.activeIndex + 1;
            if (d.disabled) {
                return false
            }
            if (d.loop) {
                c = c % this.panels.length
            }
            if (c < this.panels.length) {
                this.show(c);
                return true
            }
            return false
        },
        back: function () {
            var d = this.options, c = d.activeIndex - 1;
            if (d.disabled) {
                return false
            }
            if (d.loop) {
                c = c < 0 ? this.panels.length - 1 : c
            }
            if (c >= 0) {
                this.show(c);
                return true
            }
            return false
        },
        load: function (e) {
            var c = this, h = this.options, f = this.panels.eq(e)[0], d = a.data(f, "load.bwizard"), g;
            this.abort();
            if (!d || this.element.queue("bwizard").length !== 0 && a.data(f, "cache.bwizard")) {
                this.element.dequeue("bwizard");
                return
            }
            if (h.spinner) {
                g = this.element.data("spinner.bwizard");
                if (!g) {
                    g = a('<div class="modal" id="spinner" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true"/>');
                    g.html(h.spinner || c._defaults.spinner);
                    g.appendTo(document.body);
                    this.element.data("spinner.bwizard", g);
                    g.modal()
                }
            }
            this.xhr = a.ajax(a.extend({}, h.ajaxOptions, {
                url: d, dataType: "html", success: function (j, i) {
                    a(f).html(j);
                    if (h.cache) {
                        a.data(f, "cache.bwizard", true)
                    }
                    c._trigger("load", null, c._ui(c.panels[e]));
                    try {
                        if (h.ajaxOptions && h.ajaxOptions.success) {
                            h.ajaxOptions.success(j, i)
                        }
                    } catch (k) {
                    }
                }, error: function (k, i) {
                    c._trigger("load", null, c._ui(c.panels[e]));
                    try {
                        if (h.ajaxOptions && h.ajaxOptions.error) {
                            h.ajaxOptions.error(k, i, e, f)
                        }
                    } catch (j) {
                    }
                }
            }));
            c.element.dequeue("bwizard");
            return this
        },
        abort: function () {
            this.element.queue([]);
            this.panels.stop(false, true);
            this.element.queue("bwizard", this.element.queue("bwizard").splice(-2, 2));
            if (this.xhr) {
                this.xhr.abort();
                delete this.xhr
            }
            this._removeSpinner();
            return this
        },
        url: function (d, c) {
            this.panels.eq(d).removeData("cache.bwizard").data("load.bwizard", c);
            return this
        },
        count: function () {
            return this.panels.length
        }
    })
}(jQuery));
(function (a) {
    "use strict", typeof define == "function" && define.amd ? define(["jquery", "load-image", "bootstrap"], a) : a(window.jQuery, window.loadImage)
})(function (a, b) {
    "use strict", a.extend(a.fn.modal.defaults, {
        delegate: document,
        selector: null,
        filter: "*",
        index: 0,
        href: null,
        preloadRange: 2,
        offsetWidth: 100,
        offsetHeight: 200,
        canvas: !1,
        slideshow: 0,
        imageClickDivision: .5
    });
    var c = a.fn.modal.Constructor.prototype.show, d = a.fn.modal.Constructor.prototype.hide;
    a.extend(a.fn.modal.Constructor.prototype, {
        initLinks: function () {
            var b = this, c = this.options, d = c.selector || "a[data-target=" + c.target + "]";
            this.$links = a(c.delegate).find(d).filter(c.filter).each(function (a) {
                b.getUrl(this) === c.href && (c.index = a)
            }), this.$links[c.index] || (c.index = 0)
        }, getUrl: function (b) {
            return b.href || a(b).data("href")
        }, startSlideShow: function () {
            var a = this;
            this.options.slideshow && (this._slideShow = window.setTimeout(function () {
                a.next()
            }, this.options.slideshow))
        }, stopSlideShow: function () {
            window.clearTimeout(this._slideShow)
        }, toggleSlideShow: function () {
            var a = this.$element.find(".modal-slideshow");
            this.options.slideshow ? (this.options.slideshow = 0, this.stopSlideShow()) : (this.options.slideshow = a.data("slideshow") || 5e3, this.startSlideShow()), a.find("i").toggleClass("fontello-icon-play fontello-icon-pause")
        }, preloadImages: function () {
            var b = this.options, c = b.index + b.preloadRange + 1, d, e;
            for (e = b.index - b.preloadRange; e < c; e += 1)d = this.$links[e], d && e !== b.index && a("<img>").prop("src", this.getUrl(d))
        }, loadImage: function () {
            var a = this, c = this.$element, d = this.options.index, e = this.getUrl(this.$links[d]), f;
            this.abortLoad(), this.stopSlideShow(), c.trigger("beforeLoad"), this._loadingTimeout = window.setTimeout(function () {
                c.addClass("modal-loading")
            }, 100), f = c.find(".modal-image").children().removeClass("in"), window.setTimeout(function () {
                f.remove()
            }, 3e3), c.find(".modal-title").text(this.$links[d].title), c.find(".modal-download").prop("href", e), this._loadingImage = b(e, function (b) {
                a.img = b, window.clearTimeout(a._loadingTimeout), c.removeClass("modal-loading"), c.trigger("load"), a.showImage(b), a.startSlideShow()
            }, this._loadImageOptions), this.preloadImages()
        }, showImage: function (b) {
            var c = this.$element, d = a.support.transition && c.hasClass("fade"), e = d ? c.animate : c.css, f = c.find(".modal-image"), g, h;
            f.css({
                width: b.width,
                height: b.height
            }), c.find(".modal-title").css({width: Math.max(b.width, 380)}), d && (g = c.clone().hide().appendTo(document.body)), a(window).width() > 767 ? e.call(c.stop(), {
                "margin-top": -((g || c).outerHeight() / 2),
                "margin-left": -((g || c).outerWidth() / 2)
            }) : c.css({top: (a(window).height() - (g || c).outerHeight()) / 2}), g && g.remove(), f.append(b), h = b.offsetWidth, c.trigger("display"), d ? c.is(":visible") ? a(b).on(a.support.transition.end, function (d) {
                d.target === b && (a(b).off(a.support.transition.end), c.trigger("displayed"))
            }).addClass("in") : (a(b).addClass("in"), c.one("shown", function () {
                c.trigger("displayed")
            })) : (a(b).addClass("in"), c.trigger("displayed"))
        }, abortLoad: function () {
            this._loadingImage && (this._loadingImage.onload = this._loadingImage.onerror = null), window.clearTimeout(this._loadingTimeout)
        }, prev: function () {
            var a = this.options;
            a.index -= 1, a.index < 0 && (a.index = this.$links.length - 1), this.loadImage()
        }, next: function () {
            var a = this.options;
            a.index += 1, a.index > this.$links.length - 1 && (a.index = 0), this.loadImage()
        }, keyHandler: function (a) {
            switch (a.which) {
                case 37:
                case 38:
                    a.preventDefault(), this.prev();
                    break;
                case 39:
                case 40:
                    a.preventDefault(), this.next()
            }
        }, wheelHandler: function (a) {
            a.preventDefault(), a = a.originalEvent, this._wheelCounter = this._wheelCounter || 0, this._wheelCounter += a.wheelDelta || a.detail || 0;
            if (a.wheelDelta && this._wheelCounter >= 120 || !a.wheelDelta && this._wheelCounter < 0)this.prev(), this._wheelCounter = 0; else if (a.wheelDelta && this._wheelCounter <= -120 || !a.wheelDelta && this._wheelCounter > 0)this.next(), this._wheelCounter = 0
        }, initGalleryEvents: function () {
            var b = this, c = this.$element;
            c.find(".modal-image").on("click.modal-gallery", function (c) {
                var d = a(this);
                b.$links.length === 1 ? b.hide() : (c.pageX - d.offset().left) / d.width() < b.options.imageClickDivision ? b.prev(c) : b.next(c)
            }), c.find(".modal-prev").on("click.modal-gallery", function (a) {
                b.prev(a)
            }), c.find(".modal-next").on("click.modal-gallery", function (a) {
                b.next(a)
            }), c.find(".modal-slideshow").on("click.modal-gallery", function (a) {
                b.toggleSlideShow(a)
            }), a(document).on("keydown.modal-gallery", function (a) {
                b.keyHandler(a)
            }).on("mousewheel.modal-gallery, DOMMouseScroll.modal-gallery", function (a) {
                b.wheelHandler(a)
            })
        }, destroyGalleryEvents: function () {
            var b = this.$element;
            this.abortLoad(), this.stopSlideShow(), b.find(".modal-image, .modal-prev, .modal-next, .modal-slideshow").off("click.modal-gallery"), a(document).off("keydown.modal-gallery").off("mousewheel.modal-gallery, DOMMouseScroll.modal-gallery")
        }, show: function () {
            if (!this.isShown && this.$element.hasClass("modal-gallery")) {
                var b = this.$element, d = this.options, e = a(window).width(), f = a(window).height();
                b.hasClass("modal-fullscreen") ? (this._loadImageOptions = {
                    maxWidth: e,
                    maxHeight: f,
                    canvas: d.canvas
                }, b.hasClass("modal-fullscreen-stretch") && (this._loadImageOptions.minWidth = e, this._loadImageOptions.minHeight = f)) : this._loadImageOptions = {
                    maxWidth: e - d.offsetWidth,
                    maxHeight: f - d.offsetHeight,
                    canvas: d.canvas
                }, e > 767 ? b.css({
                    "margin-top": -(b.outerHeight() / 2),
                    "margin-left": -(b.outerWidth() / 2)
                }) : b.css({top: (a(window).height() - b.outerHeight()) / 2}), this.initGalleryEvents(), this.initLinks(), this.$links.length && (b.find(".modal-slideshow, .modal-prev, .modal-next").toggle(this.$links.length !== 1), b.toggleClass("modal-single", this.$links.length === 1), this.loadImage())
            }
            c.apply(this, arguments)
        }, hide: function () {
            this.isShown && this.$element.hasClass("modal-gallery") && (this.options.delegate = document, this.options.href = null, this.destroyGalleryEvents()), d.apply(this, arguments)
        }
    }), a(function () {
        a(document.body).on("click.modal-gallery.data-api", '[data-toggle="modal-gallery"]', function (b) {
            var c = a(this), d = c.data(), e = a(d.target), f = e.data("modal"), g;
            f || (d = a.extend(e.data(), d)), d.selector || (d.selector = "a[rel=gallery]"), g = a(b.target).closest(d.selector), g.length && e.length && (b.preventDefault(), d.href = g.prop("href") || g.data("href"), d.delegate = g[0] !== this ? this : document, f && a.extend(f.options, d), e.modal(d))
        })
    })
});
var q = null;
window.PR_SHOULD_USE_CONTINUATION = !0;
(function () {
    function L(a) {
        function m(a) {
            var f = a.charCodeAt(0);
            if (f !== 92)return f;
            var b = a.charAt(1);
            return (f = r[b]) ? f : "0" <= b && b <= "7" ? parseInt(a.substring(1), 8) : b === "u" || b === "x" ? parseInt(a.substring(2), 16) : a.charCodeAt(1)
        }

        function e(a) {
            if (a < 32)return (a < 16 ? "\\x0" : "\\x") + a.toString(16);
            a = String.fromCharCode(a);
            if (a === "\\" || a === "-" || a === "[" || a === "]")a = "\\" + a;
            return a
        }

        function h(a) {
            for (var f = a.substring(1, a.length - 1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g), a =
                [], b = [], o = f[0] === "^", c = o ? 1 : 0, i = f.length; c < i; ++c) {
                var j = f[c];
                if (/\\[bdsw]/i.test(j))a.push(j); else {
                    var j = m(j), d;
                    c + 2 < i && "-" === f[c + 1] ? (d = m(f[c + 2]), c += 2) : d = j;
                    b.push([j, d]);
                    d < 65 || j > 122 || (d < 65 || j > 90 || b.push([Math.max(65, j) | 32, Math.min(d, 90) | 32]), d < 97 || j > 122 || b.push([Math.max(97, j) & -33, Math.min(d, 122) & -33]))
                }
            }
            b.sort(function (a, f) {
                return a[0] - f[0] || f[1] - a[1]
            });
            f = [];
            j = [NaN, NaN];
            for (c = 0; c < b.length; ++c)i = b[c], i[0] <= j[1] + 1 ? j[1] = Math.max(j[1], i[1]) : f.push(j = i);
            b = ["["];
            o && b.push("^");
            b.push.apply(b, a);
            for (c = 0; c <
            f.length; ++c)i = f[c], b.push(e(i[0])), i[1] > i[0] && (i[1] + 1 > i[0] && b.push("-"), b.push(e(i[1])));
            b.push("]");
            return b.join("")
        }

        function y(a) {
            for (var f = a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g), b = f.length, d = [], c = 0, i = 0; c < b; ++c) {
                var j = f[c];
                j === "(" ? ++i : "\\" === j.charAt(0) && (j = +j.substring(1)) && j <= i && (d[j] = -1)
            }
            for (c = 1; c < d.length; ++c)-1 === d[c] && (d[c] = ++t);
            for (i = c = 0; c < b; ++c)j = f[c], j === "(" ? (++i, d[i] === void 0 && (f[c] = "(?:")) : "\\" === j.charAt(0) &&
            (j = +j.substring(1)) && j <= i && (f[c] = "\\" + d[i]);
            for (i = c = 0; c < b; ++c)"^" === f[c] && "^" !== f[c + 1] && (f[c] = "");
            if (a.ignoreCase && s)for (c = 0; c < b; ++c)j = f[c], a = j.charAt(0), j.length >= 2 && a === "[" ? f[c] = h(j) : a !== "\\" && (f[c] = j.replace(/[A-Za-z]/g, function (a) {
                a = a.charCodeAt(0);
                return "[" + String.fromCharCode(a & -33, a | 32) + "]"
            }));
            return f.join("")
        }

        for (var t = 0, s = !1, l = !1, p = 0, d = a.length; p < d; ++p) {
            var g = a[p];
            if (g.ignoreCase)l = !0; else if (/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi, ""))) {
                s = !0;
                l = !1;
                break
            }
        }
        for (var r =
        {b: 8, t: 9, n: 10, v: 11, f: 12, r: 13}, n = [], p = 0, d = a.length; p < d; ++p) {
            g = a[p];
            if (g.global || g.multiline)throw Error("" + g);
            n.push("(?:" + y(g) + ")")
        }
        return RegExp(n.join("|"), l ? "gi" : "g")
    }

    function M(a) {
        function m(a) {
            switch (a.nodeType) {
                case 1:
                    if (e.test(a.className))break;
                    for (var g = a.firstChild; g; g = g.nextSibling)m(g);
                    g = a.nodeName;
                    if ("BR" === g || "LI" === g)h[s] = "\n", t[s << 1] = y++, t[s++ << 1 | 1] = a;
                    break;
                case 3:
                case 4:
                    g = a.nodeValue, g.length && (g = p ? g.replace(/\r\n?/g, "\n") : g.replace(/[\t\n\r ]+/g, " "), h[s] = g, t[s << 1] = y, y += g.length,
                        t[s++ << 1 | 1] = a)
            }
        }

        var e = /(?:^|\s)nocode(?:\s|$)/, h = [], y = 0, t = [], s = 0, l;
        a.currentStyle ? l = a.currentStyle.whiteSpace : window.getComputedStyle && (l = document.defaultView.getComputedStyle(a, q).getPropertyValue("white-space"));
        var p = l && "pre" === l.substring(0, 3);
        m(a);
        return {a: h.join("").replace(/\n$/, ""), c: t}
    }

    function B(a, m, e, h) {
        m && (a = {a: m, d: a}, e(a), h.push.apply(h, a.e))
    }

    function x(a, m) {
        function e(a) {
            for (var l = a.d, p = [l, "pln"], d = 0, g = a.a.match(y) || [], r = {}, n = 0, z = g.length; n < z; ++n) {
                var f = g[n], b = r[f], o = void 0, c;
                if (typeof b ===
                    "string")c = !1; else {
                    var i = h[f.charAt(0)];
                    if (i)o = f.match(i[1]), b = i[0]; else {
                        for (c = 0; c < t; ++c)if (i = m[c], o = f.match(i[1])) {
                            b = i[0];
                            break
                        }
                        o || (b = "pln")
                    }
                    if ((c = b.length >= 5 && "lang-" === b.substring(0, 5)) && !(o && typeof o[1] === "string"))c = !1, b = "src";
                    c || (r[f] = b)
                }
                i = d;
                d += f.length;
                if (c) {
                    c = o[1];
                    var j = f.indexOf(c), k = j + c.length;
                    o[2] && (k = f.length - o[2].length, j = k - c.length);
                    b = b.substring(5);
                    B(l + i, f.substring(0, j), e, p);
                    B(l + i + j, c, C(b, c), p);
                    B(l + i + k, f.substring(k), e, p)
                } else p.push(l + i, b)
            }
            a.e = p
        }

        var h = {}, y;
        (function () {
            for (var e = a.concat(m),
                     l = [], p = {}, d = 0, g = e.length; d < g; ++d) {
                var r = e[d], n = r[3];
                if (n)for (var k = n.length; --k >= 0;)h[n.charAt(k)] = r;
                r = r[1];
                n = "" + r;
                p.hasOwnProperty(n) || (l.push(r), p[n] = q)
            }
            l.push(/[\S\s]/);
            y = L(l)
        })();
        var t = m.length;
        return e
    }

    function u(a) {
        var m = [], e = [];
        a.tripleQuotedStrings ? m.push(["str", /^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/, q, "'\""]) : a.multiLineStrings ? m.push(["str", /^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
            q, "'\"`"]) : m.push(["str", /^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/, q, "\"'"]);
        a.verbatimStrings && e.push(["str", /^@"(?:[^"]|"")*(?:"|$)/, q]);
        var h = a.hashComments;
        h && (a.cStyleComments ? (h > 1 ? m.push(["com", /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, q, "#"]) : m.push(["com", /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/, q, "#"]), e.push(["str", /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/, q])) : m.push(["com", /^#[^\n\r]*/,
            q, "#"]));
        a.cStyleComments && (e.push(["com", /^\/\/[^\n\r]*/, q]), e.push(["com", /^\/\*[\S\s]*?(?:\*\/|$)/, q]));
        a.regexLiterals && e.push(["lang-regex", /^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);
        (h = a.types) && e.push(["typ", h]);
        a = ("" + a.keywords).replace(/^ | $/g,
            "");
        a.length && e.push(["kwd", RegExp("^(?:" + a.replace(/[\s,]+/g, "|") + ")\\b"), q]);
        m.push(["pln", /^\s+/, q, " \r\n\t\xa0"]);
        e.push(["lit", /^@[$_a-z][\w$@]*/i, q], ["typ", /^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/, q], ["pln", /^[$_a-z][\w$@]*/i, q], ["lit", /^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i, q, "0123456789"], ["pln", /^\\[\S\s]?/, q], ["pun", /^.[^\s\w"-$'./@\\`]*/, q]);
        return x(m, e)
    }

    function D(a, m) {
        function e(a) {
            switch (a.nodeType) {
                case 1:
                    if (k.test(a.className))break;
                    if ("BR" === a.nodeName)h(a),
                    a.parentNode && a.parentNode.removeChild(a); else for (a = a.firstChild; a; a = a.nextSibling)e(a);
                    break;
                case 3:
                case 4:
                    if (p) {
                        var b = a.nodeValue, d = b.match(t);
                        if (d) {
                            var c = b.substring(0, d.index);
                            a.nodeValue = c;
                            (b = b.substring(d.index + d[0].length)) && a.parentNode.insertBefore(s.createTextNode(b), a.nextSibling);
                            h(a);
                            c || a.parentNode.removeChild(a)
                        }
                    }
            }
        }

        function h(a) {
            function b(a, d) {
                var e = d ? a.cloneNode(!1) : a, f = a.parentNode;
                if (f) {
                    var f = b(f, 1), g = a.nextSibling;
                    f.appendChild(e);
                    for (var h = g; h; h = g)g = h.nextSibling, f.appendChild(h)
                }
                return e
            }

            for (; !a.nextSibling;)if (a = a.parentNode, !a)return;
            for (var a = b(a.nextSibling, 0), e; (e = a.parentNode) && e.nodeType === 1;)a = e;
            d.push(a)
        }

        var k = /(?:^|\s)nocode(?:\s|$)/, t = /\r\n?|\n/, s = a.ownerDocument, l;
        a.currentStyle ? l = a.currentStyle.whiteSpace : window.getComputedStyle && (l = s.defaultView.getComputedStyle(a, q).getPropertyValue("white-space"));
        var p = l && "pre" === l.substring(0, 3);
        for (l = s.createElement("LI"); a.firstChild;)l.appendChild(a.firstChild);
        for (var d = [l], g = 0; g < d.length; ++g)e(d[g]);
        m === (m | 0) && d[0].setAttribute("value",
            m);
        var r = s.createElement("OL");
        r.className = "linenums";
        for (var n = Math.max(0, m - 1 | 0) || 0, g = 0, z = d.length; g < z; ++g)l = d[g], l.className = "L" + (g + n) % 10, l.firstChild || l.appendChild(s.createTextNode("\xa0")), r.appendChild(l);
        a.appendChild(r)
    }

    function k(a, m) {
        for (var e = m.length; --e >= 0;) {
            var h = m[e];
            A.hasOwnProperty(h) ? window.console && console.warn("cannot override language handler %s", h) : A[h] = a
        }
    }

    function C(a, m) {
        if (!a || !A.hasOwnProperty(a))a = /^\s*</.test(m) ? "default-markup" : "default-code";
        return A[a]
    }

    function E(a) {
        var m =
            a.g;
        try {
            var e = M(a.h), h = e.a;
            a.a = h;
            a.c = e.c;
            a.d = 0;
            C(m, h)(a);
            var k = /\bMSIE\b/.test(navigator.userAgent), m = /\n/g, t = a.a, s = t.length, e = 0, l = a.c, p = l.length, h = 0, d = a.e, g = d.length, a = 0;
            d[g] = s;
            var r, n;
            for (n = r = 0; n < g;)d[n] !== d[n + 2] ? (d[r++] = d[n++], d[r++] = d[n++]) : n += 2;
            g = r;
            for (n = r = 0; n < g;) {
                for (var z = d[n], f = d[n + 1], b = n + 2; b + 2 <= g && d[b + 1] === f;)b += 2;
                d[r++] = z;
                d[r++] = f;
                n = b
            }
            for (d.length = r; h < p;) {
                var o = l[h + 2] || s, c = d[a + 2] || s, b = Math.min(o, c), i = l[h + 1], j;
                if (i.nodeType !== 1 && (j = t.substring(e, b))) {
                    k && (j = j.replace(m, "\r"));
                    i.nodeValue =
                        j;
                    var u = i.ownerDocument, v = u.createElement("SPAN");
                    v.className = d[a + 1];
                    var x = i.parentNode;
                    x.replaceChild(v, i);
                    v.appendChild(i);
                    e < o && (l[h + 1] = i = u.createTextNode(t.substring(b, o)), x.insertBefore(i, v.nextSibling))
                }
                e = b;
                e >= o && (h += 2);
                e >= c && (a += 2)
            }
        } catch (w) {
            "console"in window && console.log(w && w.stack ? w.stack : w)
        }
    }

    var v = ["break,continue,do,else,for,if,return,while"], w = [[v, "auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
            "catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"], F = [w, "alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"], G = [w, "abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
        H = [G, "as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"], w = [w, "debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"], I = [v, "and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
        J = [v, "alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"], v = [v, "case,done,elif,esac,eval,fi,function,in,local,set,then,until"], K = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/, N = /\S/, O = u({
            keywords: [F, H, w, "caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END" +
            I, J, v], hashComments: !0, cStyleComments: !0, multiLineStrings: !0, regexLiterals: !0
        }), A = {};
    k(O, ["default-code"]);
    k(x([], [["pln", /^[^<?]+/], ["dec", /^<!\w[^>]*(?:>|$)/], ["com", /^<\!--[\S\s]*?(?:--\>|$)/], ["lang-", /^<\?([\S\s]+?)(?:\?>|$)/], ["lang-", /^<%([\S\s]+?)(?:%>|$)/], ["pun", /^(?:<[%?]|[%?]>)/], ["lang-", /^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i], ["lang-js", /^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i], ["lang-css", /^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i], ["lang-in.tag", /^(<\/?[a-z][^<>]*>)/i]]),
        ["default-markup", "htm", "html", "mxml", "xhtml", "xml", "xsl"]);
    k(x([["pln", /^\s+/, q, " \t\r\n"], ["atv", /^(?:"[^"]*"?|'[^']*'?)/, q, "\"'"]], [["tag", /^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i], ["atn", /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i], ["lang-uq.val", /^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/], ["pun", /^[/<->]+/], ["lang-js", /^on\w+\s*=\s*"([^"]+)"/i], ["lang-js", /^on\w+\s*=\s*'([^']+)'/i], ["lang-js", /^on\w+\s*=\s*([^\s"'>]+)/i], ["lang-css", /^style\s*=\s*"([^"]+)"/i], ["lang-css", /^style\s*=\s*'([^']+)'/i], ["lang-css",
        /^style\s*=\s*([^\s"'>]+)/i]]), ["in.tag"]);
    k(x([], [["atv", /^[\S\s]+/]]), ["uq.val"]);
    k(u({keywords: F, hashComments: !0, cStyleComments: !0, types: K}), ["c", "cc", "cpp", "cxx", "cyc", "m"]);
    k(u({keywords: "null,true,false"}), ["json"]);
    k(u({keywords: H, hashComments: !0, cStyleComments: !0, verbatimStrings: !0, types: K}), ["cs"]);
    k(u({keywords: G, cStyleComments: !0}), ["java"]);
    k(u({keywords: v, hashComments: !0, multiLineStrings: !0}), ["bsh", "csh", "sh"]);
    k(u({keywords: I, hashComments: !0, multiLineStrings: !0, tripleQuotedStrings: !0}),
        ["cv", "py"]);
    k(u({
        keywords: "caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",
        hashComments: !0,
        multiLineStrings: !0,
        regexLiterals: !0
    }), ["perl", "pl", "pm"]);
    k(u({keywords: J, hashComments: !0, multiLineStrings: !0, regexLiterals: !0}), ["rb"]);
    k(u({keywords: w, cStyleComments: !0, regexLiterals: !0}), ["js"]);
    k(u({
        keywords: "all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
        hashComments: 3, cStyleComments: !0, multilineStrings: !0, tripleQuotedStrings: !0, regexLiterals: !0
    }), ["coffee"]);
    k(x([], [["str", /^[\S\s]+/]]), ["regex"]);
    window.prettyPrintOne = function (a, m, e) {
        var h = document.createElement("PRE");
        h.innerHTML = a;
        e && D(h, e);
        E({g: m, i: e, h: h});
        return h.innerHTML
    };
    window.prettyPrint = function (a) {
        function m() {
            for (var e = window.PR_SHOULD_USE_CONTINUATION ? l.now() + 250 : Infinity; p < h.length && l.now() < e; p++) {
                var n = h[p], k = n.className;
                if (k.indexOf("prettyprint") >= 0) {
                    var k = k.match(g), f, b;
                    if (b = !k) {
                        b = n;
                        for (var o = void 0, c = b.firstChild; c; c = c.nextSibling)var i = c.nodeType, o = i === 1 ? o ? b : c : i === 3 ? N.test(c.nodeValue) ? b : o : o;
                        b = (f = o === b ? void 0 : o) && "CODE" === f.tagName
                    }
                    b && (k = f.className.match(g));
                    k && (k = k[1]);
                    b = !1;
                    for (o = n.parentNode; o; o = o.parentNode)if ((o.tagName === "pre" || o.tagName === "code" || o.tagName === "xmp") && o.className && o.className.indexOf("prettyprint") >= 0) {
                        b = !0;
                        break
                    }
                    b || ((b = (b = n.className.match(/\blinenums\b(?::(\d+))?/)) ? b[1] && b[1].length ? +b[1] : !0 : !1) && D(n, b), d = {
                        g: k,
                        h: n,
                        i: b
                    }, E(d))
                }
            }
            p < h.length ? setTimeout(m,
                250) : a && a()
        }

        for (var e = [document.getElementsByTagName("pre"), document.getElementsByTagName("code"), document.getElementsByTagName("xmp")], h = [], k = 0; k < e.length; ++k)for (var t = 0, s = e[k].length; t < s; ++t)h.push(e[k][t]);
        var e = q, l = Date;
        l.now || (l = {
            now: function () {
                return +new Date
            }
        });
        var p = 0, d, g = /\blang(?:uage)?-([\w.]+)(?!\S)/;
        m()
    };
    window.PR = {
        createSimpleLexer: x,
        registerLangHandler: k,
        sourceDecorator: u,
        PR_ATTRIB_NAME: "atn",
        PR_ATTRIB_VALUE: "atv",
        PR_COMMENT: "com",
        PR_DECLARATION: "dec",
        PR_KEYWORD: "kwd",
        PR_LITERAL: "lit",
        PR_NOCODE: "nocode",
        PR_PLAIN: "pln",
        PR_PUNCTUATION: "pun",
        PR_SOURCE: "src",
        PR_STRING: "str",
        PR_TAG: "tag",
        PR_TYPE: "typ"
    }
})();
/* jquery.nicescroll 2.9.7 InuYaksa*2012 MIT http://areaaperta.com/nicescroll */
(function (e) {
    var o = false, q = false, t = 5E3, u = 2E3, v = function () {
        var e = document.getElementsByTagName("script"), e = e[e.length - 1].src.split("?")[0];
        return e.split("/").length > 0 ? e.split("/").slice(0, -1).join("/") + "/" : ""
    }(), n = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || false, p = window.cancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame ||
        window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || false, z = function (f, d) {
        function h(c, g, d) {
            g = c.css(g);
            c = parseFloat(g);
            return isNaN(c) ? (c = m[g] || 0, d = c == 3 ? d ? b.win.outerHeight() - b.win.innerHeight() : b.win.outerWidth() - b.win.innerWidth() : 1, b.isie8 && c && (c += 1), d ? c : 0) : c
        }

        var b = this;
        this.version = "2.9.7";
        this.name = "nicescroll";
        this.me = d;
        this.opt = {
            doc: e("body"),
            win: false,
            zindex: 9E3,
            cursoropacitymin: 0,
            cursoropacitymax: 1,
            cursorcolor: "#424242",
            cursorwidth: "5px",
            cursorborder: "1px solid #fff",
            cursorborderradius: "5px",
            scrollspeed: 60,
            mousescrollstep: 40,
            touchbehavior: false,
            hwacceleration: true,
            usetransition: true,
            boxzoom: false,
            dblclickzoom: true,
            gesturezoom: true,
            grabcursorenabled: true,
            autohidemode: true,
            background: "",
            iframeautoresize: true,
            cursorminheight: 20,
            preservenativescrolling: true,
            railoffset: false,
            bouncescroll: false,
            spacebarenabled: true,
            railpadding: {top: 0, right: 0, left: 0, bottom: 0},
            disableoutline: true
        };
        if (f)for (var i in b.opt)typeof f[i] != "undefined" && (b.opt[i] = f[i]);
        this.iddoc = (this.doc =
            b.opt.doc) && this.doc[0] ? this.doc[0].id || "" : "";
        this.ispage = /BODY|HTML/.test(b.opt.win ? b.opt.win[0].nodeName : this.doc[0].nodeName);
        this.haswrapper = b.opt.win !== false;
        this.win = b.opt.win || (this.ispage ? e(window) : this.doc);
        this.docscroll = this.ispage && !this.haswrapper ? e(window) : this.win;
        this.body = e("body");
        this.iframe = false;
        this.isiframe = this.doc[0].nodeName == "IFRAME" && this.win[0].nodeName == "IFRAME";
        this.istextarea = this.win[0].nodeName == "TEXTAREA";
        this.observer = this.page = this.view = this.onclick = this.ongesturezoom =
            this.onkeypress = this.onmousewheel = this.onmousemove = this.onmouseup = this.onmousedown = false;
        this.scroll = {x: 0, y: 0};
        this.scrollratio = {x: 0, y: 0};
        this.cursorheight = 20;
        this.scrollvaluemax = 0;
        this.scrollmom = false;
        do this.id = "ascrail" + u++; while (document.getElementById(this.id));
        this.hasmousefocus = this.hasfocus = this.zoomactive = this.zoom = this.cursorfreezed = this.cursor = this.rail = false;
        this.visibility = true;
        this.nativescrollingarea = this.hidden = this.locked = false;
        this.events = [];
        this.saved = {};
        this.delaylist = {};
        this.synclist =
        {};
        this.lastdelta = 0;
        var j = document.createElement("DIV");
        this.isopera = "opera"in window;
        this.isieold = (this.isie = "all"in document && "attachEvent"in j && !this.isopera) && !("msInterpolationMode"in j.style);
        this.isie7 = this.isie && !this.isieold && (!("documentMode"in document) || document.documentMode == 7);
        this.isie8 = this.isie && "documentMode"in document && document.documentMode == 8;
        this.isie9 = this.isie && "performance"in window && document.documentMode >= 9;
        this.isie9mobile = /iemobile.9/i.test(navigator.userAgent);
        this.isie7mobile =
            !this.isie9mobile && this.isie7 && /iemobile/i.test(navigator.userAgent);
        this.ismozilla = "MozAppearance"in j.style;
        this.ischrome = "chrome"in window;
        this.cantouch = "ontouchstart"in document.documentElement;
        this.hasmstouch = window.navigator.msPointerEnabled || false;
        this.isios4 = (this.isios = this.cantouch && /iphone|ipad|ipod/i.test(navigator.platform)) && !("seal"in Object);
        if (b.opt.hwacceleration) {
            if ((this.trstyle = window.opera ? "OTransform" : document.all ? "msTransform" : j.style.webkitTransform !== void 0 ? "webkitTransform" :
                    j.style.MozTransform !== void 0 ? "MozTransform" : false) && typeof j.style[this.trstyle] == "undefined")this.trstyle = false;
            if (this.hastransform = this.trstyle != false)j.style[this.trstyle] = "translate3d(1px,2px,3px)", this.hastranslate3d = /translate3d/.test(j.style[this.trstyle]);
            this.transitionstyle = false;
            this.prefixstyle = "";
            this.transitionend = false;
            var r = "transition,webkitTransition,MozTransition,OTransition,msTransition,KhtmlTransition".split(","), x = ",-webkit-,-moz-,-o-,-ms-,-khtml-".split(","), l = "transitionend,webkitTransitionEnd,transitionend,oTransitionEnd,msTransitionEnd,KhtmlTransitionEnd".split(",");
            for (i = 0; i < r.length; i++)if (r[i]in j.style) {
                this.transitionstyle = r[i];
                this.prefixstyle = x[i];
                this.transitionend = l[i];
                break
            }
            this.hastransition = this.transitionstyle
        } else this.transitionend = this.hastransition = this.transitionstyle = this.hastranslate3d = this.hastransform = this.trstyle = false;
        this.cursorgrabvalue = "";
        if (b.opt.grabcursorenabled && b.opt.touchbehavior)this.cursorgrabvalue = function () {
            var c = ["-moz-grab", "-webkit-grab", "grab"];
            if (b.ischrome || b.isie)c = [];
            for (var g = 0; g < c.length; g++) {
                var d = c[g];
                j.style.cursor =
                    d;
                if (j.style.cursor == d)return d
            }
            return "url(http://www.google.com/intl/en_ALL/mapfiles/openhand.cur),n-resize"
        }();
        j = null;
        this.ishwscroll = b.hastransform && b.opt.hwacceleration && b.haswrapper;
        this.delayed = function (c, g, d) {
            var e = b.delaylist[c], f = (new Date).getTime();
            if (e && e.tt)return false;
            if (e && e.last + d > f && !e.tt)b.delaylist[c] = {
                last: f + d, tt: setTimeout(function () {
                    b.delaylist[c].tt = 0;
                    g.call()
                }, d)
            }; else if (!e || !e.tt)b.delaylist[c] = {last: f, tt: 0}, setTimeout(function () {
                g.call()
            }, 0)
        };
        this.requestSync = function () {
            if (!b.onsync)n(function () {
                b.onsync =
                    false;
                for (name in b.synclist) {
                    var c = b.synclist[name];
                    c && c.call(b);
                    b.synclist[name] = false
                }
            }), b.onsync = true
        };
        this.synched = function (c, g) {
            b.synclist[c] = g;
            b.requestSync()
        };
        this.css = function (c, g) {
            for (var d in g)b.saved.css.push([c, d, c.css(d)]), c.css(d, g[d])
        };
        this.scrollTop = function (c) {
            return typeof c == "undefined" ? b.getScrollTop() : b.setScrollTop(c)
        };
        BezierClass = function (b, d, e, k, f, h, y) {
            this.st = b;
            this.ed = d;
            this.spd = e;
            this.p1 = k || 0;
            this.p2 = f || 1;
            this.p3 = h || 0;
            this.p4 = y || 1;
            this.ts = (new Date).getTime();
            this.df =
                this.ed - this.st
        };
        BezierClass.prototype = {
            B2: function (b) {
                return 3 * b * b * (1 - b)
            }, B3: function (b) {
                return 3 * b * (1 - b) * (1 - b)
            }, B4: function (b) {
                return (1 - b) * (1 - b) * (1 - b)
            }, getNow: function () {
                var b = 1 - ((new Date).getTime() - this.ts) / this.spd, d = this.B2(b) + this.B3(b) + this.B4(b);
                return b < 0 ? this.ed : this.st + Math.round(this.df * d)
            }, update: function (b, d) {
                this.st = this.getNow();
                this.ed = b;
                this.spd = d;
                this.ts = (new Date).getTime();
                this.df = this.ed - this.st;
                return this
            }
        };
        this.ishwscroll ? (this.doc.translate = {x: 0, y: 0}, this.hastranslate3d &&
        this.doc.css(this.prefixstyle + "backface-visibility", "hidden"), this.getScrollTop = function (c) {
            return b.timerscroll && !c ? b.timerscroll.bz.getNow() : b.doc.translate.y
        }, this.notifyScrollEvent = document.createEvent ? function (b) {
            var d = document.createEvent("UIEvents");
            d.initUIEvent("scroll", false, true, window, 1);
            b.dispatchEvent(d)
        } : document.fireEvent ? function (b) {
            var d = document.createEventObject();
            b.fireEvent("onscroll");
            d.cancelBubble = true
        } : function () {
        }, this.setScrollTop = this.hastranslate3d ? function (c, d) {
            b.doc.css(b.trstyle,
                "translate3d(0px," + c * -1 + "px,0px)");
            b.doc.translate.y = c;
            d || b.notifyScrollEvent(b.win[0])
        } : function (c, d) {
            b.doc.css(b.trstyle, "translate(0px," + c * -1 + "px)");
            b.doc.translate.y = c;
            d || b.notifyScrollEvent(b.win[0])
        }) : (this.getScrollTop = function () {
            return b.docscroll.scrollTop()
        }, this.setScrollTop = function (c) {
            return b.docscroll.scrollTop(c)
        });
        this.getTarget = function (b) {
            return !b ? false : b.target ? b.target : b.srcElement ? b.srcElement : false
        };
        this.hasParent = function (b, d) {
            if (!b)return false;
            for (var e = b.target || b.srcElement ||
                b || false; e && e.id != d;)e = e.parentNode || false;
            return e !== false
        };
        var m = {thin: 1, medium: 3, thick: 5};
        this.updateScrollBar = function (c) {
            if (b.ishwscroll)b.rail.css({height: b.win.innerHeight()}); else {
                var d = b.win.offset();
                d.top += h(b.win, "border-top-width", true);
                d.left += b.win.outerWidth() - h(b.win, "border-right-width", false) - b.rail.width;
                var e = b.opt.railoffset;
                e && (e.top && (d.top += e.top), e.left && (d.left += e.left));
                b.rail.css({top: d.top, left: d.left, height: c ? c.h : b.win.innerHeight()});
                b.zoom && b.zoom.css({
                    top: d.top + 1,
                    left: d.left - 20
                })
            }
        };
        b.hasanimationframe = n;
        b.hascancelanimationframe = p;
        b.hasanimationframe ? b.hascancelanimationframe || (p = function () {
            b.cancelAnimationFrame = true
        }) : (n = function (b) {
            return setTimeout(b, 16)
        }, p = clearInterval);
        this.init = function () {
            b.saved.css = [];
            if (b.isie7mobile)return true;
            b.hasmstouch && b.css(b.ispage ? e("html") : b.win, {"-ms-touch-action": "none"});
            if (!b.ispage || !b.cantouch && !b.isieold && !b.isie9mobile) {
                var c = b.docscroll;
                b.ispage && (c = b.haswrapper ? b.win : b.doc);
                b.isie9mobile || b.css(c, {"overflow-y": "hidden"});
                b.ispage && b.isie7 && b.win[0].nodeName == "BODY" && b.css(e("html"), {"overflow-y": "hidden"});
                var d = e(document.createElement("div"));
                d.css({
                    position: "relative",
                    top: 0,
                    "float": "right",
                    width: b.opt.cursorwidth,
                    height: "0px",
                    "background-color": b.opt.cursorcolor,
                    border: b.opt.cursorborder,
                    "background-clip": "padding-box",
                    "-webkit-border-radius": b.opt.cursorborderradius,
                    "-moz-border-radius": b.opt.cursorborderradius,
                    "border-radius": b.opt.cursorborderradius
                });
                d.hborder = parseFloat(d.outerHeight() - d.innerHeight());
                b.cursor =
                    d;
                c = e(document.createElement("div"));
                c.attr("id", b.id);
                c.width = Math.max(parseFloat(b.opt.cursorwidth), d.outerWidth());
                c.css({
                    width: c.width + "px",
                    zIndex: b.ispage ? b.opt.zindex : b.opt.zindex + 2,
                    background: b.opt.background
                });
                var w = ["top", "bottom", "left", "right"], k;
                for (k in w) {
                    var f = b.opt.railpadding[k];
                    f && c.css("padding-" + k, f + "px")
                }
                c.append(d);
                b.rail = c;
                k = b.rail.drag = false;
                if (b.opt.boxzoom && !b.ispage && !b.isieold && (k = document.createElement("div"), b.bind(k, "click", b.doZoom), b.zoom = e(k), b.zoom.css({
                        cursor: "pointer",
                        "z-index": b.opt.zindex,
                        backgroundImage: "url(" + v + "zoomico.png)",
                        height: 18,
                        width: 18,
                        backgroundPosition: "0px 0px"
                    }), b.opt.dblclickzoom && b.bind(b.win, "dblclick", b.doZoom), b.cantouch && b.opt.gesturezoom))b.ongesturezoom = function (c) {
                    c.scale > 1.5 && b.doZoomIn(c);
                    c.scale < 0.8 && b.doZoomOut(c);
                    return b.cancelEvent(c)
                }, b.bind(b.win, "gestureend", b.ongesturezoom);
                b.ispage ? (c.css({
                    position: "fixed",
                    top: "0px",
                    right: "0px",
                    height: "100%"
                }), b.body.append(c)) : (b.ishwscroll ? (b.win.css("position") == "static" && b.css(b.win, {position: "relative"}),
                    k = b.win[0].nodeName == "HTML" ? b.body : b.win, b.zoom && (b.zoom.css({
                    position: "absolute",
                    top: 1,
                    right: 0,
                    "margin-right": c.width + 4
                }), k.append(b.zoom)), c.css({
                    position: "absolute",
                    top: 0,
                    right: 0
                }), k.append(c)) : (c.css({position: "absolute"}), b.zoom && b.zoom.css({position: "absolute"}), b.updateScrollBar(), b.body.append(c), b.zoom && b.body.append(b.zoom)), b.isios && b.css(b.win, {
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                    "-webkit-touch-callout": "none"
                }));
                if (b.opt.autohidemode === false)b.autohidedom = false; else if (b.opt.autohidemode ===
                    true)b.autohidedom = b.rail; else if (b.opt.autohidemode == "cursor")b.autohidedom = b.cursor;
                if (b.isie9mobile)b.scrollmom = {y: new s(b)}, b.onmangotouch = function () {
                    var c = b.getScrollTop();
                    if (c == b.scrollmom.y.lastscrolly)return true;
                    var d = c - b.mangotouch.sy;
                    if (d != 0) {
                        var e = d < 0 ? -1 : 1, g = (new Date).getTime();
                        b.mangotouch.lazy && clearTimeout(b.mangotouch.lazy);
                        if (g - b.mangotouch.tm > 60 || b.mangotouch.dry != e)b.scrollmom.y.stop(), b.scrollmom.y.reset(c), b.mangotouch.sy = c, b.mangotouch.ly = c, b.mangotouch.dry = e, b.mangotouch.tm =
                            g; else {
                            b.scrollmom.y.stop();
                            b.scrollmom.y.update(b.mangotouch.sy - d);
                            var f = g - b.mangotouch.tm;
                            b.mangotouch.tm = g;
                            d = Math.abs(b.mangotouch.ly - c);
                            b.mangotouch.ly = c;
                            if (d > 2)b.mangotouch.lazy = setTimeout(function () {
                                b.mangotouch.lazy = false;
                                b.mangotouch.dry = 0;
                                b.mangotouch.tm = 0;
                                b.scrollmom.y.doMomentum(f)
                            }, 80)
                        }
                    }
                }, c = b.getScrollTop(), b.mangotouch = {
                    sy: c,
                    ly: c,
                    dry: 0,
                    lazy: false,
                    tm: 0
                }, b.bind(b.docscroll, "scroll", b.onmangotouch); else {
                    if (b.cantouch || b.opt.touchbehavior || b.hasmstouch)b.scrollmom = {y: new s(b)}, b.ontouchstart =
                        function (c) {
                            if (c.pointerType && c.pointerType != 2)return false;
                            if (!b.locked) {
                                if (b.hasmstouch)for (var d = c.target ? c.target : false; d;) {
                                    var g = e(d).getNiceScroll();
                                    if (g.length > 0 && g[0].me == b.me)break;
                                    if (g.length > 0)return false;
                                    if (d.nodeName == "DIV" && d.id == b.id)break;
                                    d = d.parentNode ? d.parentNode : false
                                }
                                b.cancelScroll();
                                b.rail.drag = {
                                    x: c.clientX,
                                    y: c.clientY,
                                    sx: b.scroll.x,
                                    sy: b.scroll.y,
                                    st: b.getScrollTop(),
                                    pt: 2
                                };
                                b.hasmoving = false;
                                b.lastmouseup = false;
                                b.scrollmom.y.reset(c.clientY);
                                if (!b.cantouch && !b.hasmstouch) {
                                    d = b.getTarget(c);
                                    if (!d || !/INPUT|SELECT|TEXTAREA/i.test(d.nodeName))return b.cancelEvent(c);
                                    if (/SUBMIT|CANCEL|BUTTON/i.test(e(d).attr("type")))pc = {
                                        tg: d,
                                        click: false
                                    }, b.preventclick = pc
                                }
                            }
                        }, b.ontouchend = function (c) {
                        if (c.pointerType && c.pointerType != 2)return false;
                        if (b.rail.drag && b.rail.drag.pt == 2 && (b.scrollmom.y.doMomentum(), b.rail.drag = false, b.hasmoving && (b.hasmoving = false, b.lastmouseup = true, b.hideCursor(), !b.cantouch)))return b.cancelEvent(c)
                    }, b.ontouchmove = function (c) {
                        if (c.pointerType && c.pointerType != 2)return false;
                        if (b.rail.drag && b.rail.drag.pt == 2) {
                            if (b.cantouch && typeof c.original == "undefined")return true;
                            b.hasmoving = true;
                            if (b.preventclick && !b.preventclick.click)b.preventclick.click = b.preventclick.tg.onclick || false, b.preventclick.tg.onclick = b.onpreventclick;
                            var d = c.clientY, g = b.rail.drag.st - (d - b.rail.drag.y);
                            if (b.ishwscroll)g < 0 ? (g = Math.round(g / 2), d = 0) : g > b.page.maxh && (g = b.page.maxh + Math.round((g - b.page.maxh) / 2), d = 0); else if (g < 0 && (g = 0), g > b.page.maxh)g = b.page.maxh;
                            b.synched("touchmove", function () {
                                b.rail.drag &&
                                b.rail.drag.pt == 2 && (b.prepareTransition && b.prepareTransition(0), b.setScrollTop(g), b.showCursor(g), b.scrollmom.y.update(d))
                            });
                            return b.cancelEvent(c)
                        }
                    };
                    b.cantouch || b.opt.touchbehavior ? (b.onpreventclick = function (c) {
                        if (b.preventclick)return b.preventclick.tg.onclick = b.preventclick.click, b.preventclick = false, b.cancelEvent(c)
                    }, b.onmousedown = b.ontouchstart, b.onmouseup = b.ontouchend, b.onclick = b.isios ? false : function (c) {
                        return b.lastmouseup ? (b.lastmouseup = false, b.cancelEvent(c)) : true
                    }, b.onmousemove = b.ontouchmove,
                    b.cursorgrabvalue && (b.css(b.ispage ? b.doc : b.win, {cursor: b.cursorgrabvalue}), b.css(b.rail, {cursor: b.cursorgrabvalue}))) : (b.onmousedown = function (c) {
                        if (!(b.rail.drag && b.rail.drag.pt != 1)) {
                            if (b.locked)return b.cancelEvent(c);
                            b.cancelScroll();
                            b.rail.drag = {x: c.clientX, y: c.clientY, sx: b.scroll.x, sy: b.scroll.y, pt: 1};
                            return b.cancelEvent(c)
                        }
                    }, b.onmouseup = function (c) {
                        if (b.rail.drag && b.rail.drag.pt == 1)return b.rail.drag = false, b.cancelEvent(c)
                    }, b.onmousemove = function (c) {
                        if (b.rail.drag) {
                            if (b.rail.drag.pt == 1) {
                                b.scroll.y =
                                    b.rail.drag.sy + (c.clientY - b.rail.drag.y);
                                if (b.scroll.y < 0)b.scroll.y = 0;
                                var d = b.scrollvaluemax;
                                if (b.scroll.y > d)b.scroll.y = d;
                                b.synched("mousemove", function () {
                                    if (b.rail.drag && b.rail.drag.pt == 1)b.showCursor(), b.cursorfreezed = true, b.doScroll(Math.round(b.scroll.y * b.scrollratio.y))
                                });
                                return b.cancelEvent(c)
                            }
                        } else b.checkarea = true
                    });
                    (b.cantouch || b.opt.touchbehavior) && b.bind(b.win, "mousedown", b.onmousedown);
                    b.hasmstouch && (b.css(b.rail, {"-ms-touch-action": "none"}), b.css(b.cursor, {"-ms-touch-action": "none"}),
                        b.bind(b.win, "MSPointerDown", b.ontouchstart), b.bind(document, "MSPointerUp", b.ontouchend), b.bind(document, "MSPointerMove", b.ontouchmove), b.bind(b.cursor, "MSGestureHold", function (b) {
                        b.preventDefault()
                    }), b.bind(b.cursor, "contextmenu", function (b) {
                        b.preventDefault()
                    }));
                    b.bind(b.cursor, "mousedown", b.onmousedown);
                    b.bind(b.cursor, "mouseup", function (c) {
                        if (!(b.rail.drag && b.rail.drag.pt == 2))return b.rail.drag = false, b.hasmoving = false, b.hideCursor(), b.cancelEvent(c)
                    });
                    b.bind(document, "mouseup", b.onmouseup);
                    b.bind(document,
                        "mousemove", b.onmousemove);
                    b.onclick && b.bind(document, "click", b.onclick);
                    b.cantouch || (b.rail.mouseenter(function () {
                        b.showCursor();
                        b.rail.active = true
                    }), b.rail.mouseleave(function () {
                        b.rail.active = false;
                        b.rail.drag || b.hideCursor()
                    }), b.isiframe || b.bind(b.isie && b.ispage ? document : b.docscroll, "mousewheel", b.onmousewheel), b.bind(b.rail, "mousewheel", b.onmousewheel));
                    b.zoom && (b.zoom.mouseenter(function () {
                        b.showCursor();
                        b.rail.active = true
                    }), b.zoom.mouseleave(function () {
                        b.rail.active = false;
                        b.rail.drag || b.hideCursor()
                    }));
                    !b.ispage && !b.cantouch && !/HTML|BODY/.test(b.win[0].nodeName) && (b.win.attr("tabindex") || b.win.attr({tabindex: t++}), b.ischrome && b.opt.disableoutline && b.win.css({outline: "none"}), b.win.focus(function (c) {
                        o = b.getTarget(c).id || true;
                        b.hasfocus = true;
                        b.noticeCursor()
                    }), b.win.blur(function () {
                        o = false;
                        b.hasfocus = false
                    }), b.win.mouseenter(function (c) {
                        q = b.getTarget(c).id || true;
                        b.hasmousefocus = true;
                        b.noticeCursor()
                    }), b.win.mouseleave(function () {
                        q = false;
                        b.hasmousefocus = false
                    }))
                }
                b.onkeypress = function (c) {
                    if (b.locked &&
                        b.page.maxh == 0)return true;
                    var c = c ? c : window.e, d = b.getTarget(c);
                    if (d && /INPUT|TEXTAREA|SELECT|OPTION/.test(d.nodeName) && (!d.getAttribute("type") && !d.type || !/submit|button|cancel/i.tp))return true;
                    if (b.hasfocus || b.hasmousefocus && !o || b.ispage && !o && !q) {
                        d = c.keyCode;
                        if (b.locked && d != 27)return b.cancelEvent(c);
                        var g = false;
                        switch (d) {
                            case 38:
                            case 63233:
                                b.doScrollBy(72);
                                g = true;
                                break;
                            case 40:
                            case 63235:
                                b.doScrollBy(-72);
                                g = true;
                                break;
                            case 33:
                            case 63276:
                                b.doScrollBy(b.view.h);
                                g = true;
                                break;
                            case 34:
                            case 63277:
                                b.doScrollBy(-b.view.h);
                                g = true;
                                break;
                            case 36:
                            case 63273:
                                b.doScrollTo(0);
                                g = true;
                                break;
                            case 35:
                            case 63275:
                                b.doScrollTo(b.page.maxh);
                                g = true;
                                break;
                            case 32:
                                b.opt.spacebarenabled && (b.doScrollBy(-b.view.h), g = true);
                                break;
                            case 27:
                                b.zoomactive && (b.doZoom(), g = true)
                        }
                        if (g)return b.cancelEvent(c)
                    }
                };
                b.bind(document, b.isopera ? "keypress" : "keydown", b.onkeypress);
                b.bind(window, "resize", b.resize);
                b.bind(window, "orientationchange", b.resize);
                b.bind(window, "load", b.resize);
                b.onAttributeChange = function () {
                    b.lazyResize()
                };
                if (!b.ispage && !b.haswrapper)"WebKitMutationObserver"in
                window ? (b.observer = new WebKitMutationObserver(function (c) {
                    c.forEach(b.onAttributeChange)
                }), b.observer.observe(b.win[0], {
                    attributes: true,
                    subtree: false
                })) : (b.bind(b.win, b.isie && !b.isie9 ? "propertychange" : "DOMAttrModified", b.onAttributeChange), b.isie9 && b.win[0].attachEvent("onpropertychange", b.onAttributeChange));
                !b.ispage && b.opt.boxzoom && b.bind(window, "resize", b.resizeZoom);
                b.istextarea && b.bind(b.win, "mouseup", b.resize);
                b.resize()
            }
            if (this.doc[0].nodeName == "IFRAME") {
                var h = function () {
                    b.iframexd = false;
                    try {
                        var c = "contentDocument"in this ? this.contentDocument : this.contentWindow.document
                    } catch (d) {
                        b.iframexd = true, c = false
                    }
                    if (b.iframexd)return true;
                    if (b.isiframe)b.iframe = {
                        html: b.doc.contents().find("html")[0],
                        body: b.doc.contents().find("body")[0]
                    }, b.getContentSize = function () {
                        return {
                            w: Math.max(b.iframe.html.scrollWidth, b.iframe.body.scrollWidth),
                            h: Math.max(b.iframe.html.scrollHeight, b.iframe.body.scrollHeight)
                        }
                    }, b.docscroll = e(this.contentWindow);
                    if (b.opt.iframeautoresize && !b.isiframe) {
                        b.win.scrollTop(0);
                        b.doc.height("");
                        var g = Math.max(c.getElementsByTagName("html")[0].scrollHeight, c.body.scrollHeight);
                        b.doc.height(g)
                    }
                    b.resize();
                    b.isie7 && b.css(e(c).find("html"), {"overflow-y": "hidden"});
                    b.css(e(c.body), {"overflow-y": "hidden"});
                    "contentWindow"in this ? b.bind(this.contentWindow, "scroll", b.onscroll) : b.bind(c, "scroll", b.onscroll);
                    b.bind(c, "mouseup", b.onmouseup);
                    b.bind(c, "mousewheel", b.onmousewheel);
                    b.bind(c, b.isopera ? "keypress" : "keydown", b.onkeypress);
                    if (b.cantouch || b.opt.touchbehavior)b.bind(c, "mousedown",
                        b.onmousedown), b.cursorgrabvalue && b.css(e(c.body), {cursor: b.cursorgrabvalue});
                    b.bind(c, "mousemove", b.onmousemove);
                    b.zoom && (b.opt.dblclickzoom && b.bind(c, "dblclick", b.doZoom), b.ongesturezoom && b.bind(c, "gestureend", b.ongesturezoom))
                };
                this.doc[0].readyState && this.doc[0].readyState == "complete" && setTimeout(function () {
                    h.call(b.doc[0], false)
                }, 500);
                b.bind(this.doc, "load", h)
            }
        };
        this.showCursor = function (c) {
            if (b.cursortimeout)clearTimeout(b.cursortimeout), b.cursortimeout = 0;
            if (b.rail) {
                b.autohidedom && b.autohidedom.stop().css({opacity: b.opt.cursoropacitymax});
                if (typeof c != "undefined")b.scroll.y = Math.round(c * 1 / b.scrollratio.y);
                b.cursor.css({height: b.cursorheight, top: b.scroll.y});
                b.zoom && b.zoom.stop().css({opacity: b.opt.cursoropacitymax})
            }
        };
        this.hideCursor = function (c) {
            if (!b.cursortimeout && b.rail && b.autohidedom)b.cursortimeout = setTimeout(function () {
                b.rail.active || (b.autohidedom.stop().animate({opacity: b.opt.cursoropacitymin}), b.zoom && b.zoom.stop().animate({opacity: b.opt.cursoropacitymin}));
                b.cursortimeout = 0
            }, c || 400)
        };
        this.noticeCursor = function (c, d) {
            b.showCursor(d);
            b.hideCursor(c)
        };
        this.getContentSize = b.ispage ? function () {
            return {
                w: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
                h: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }
        } : b.haswrapper ? function () {
            return {
                w: b.doc.outerWidth() + parseInt(b.win.css("paddingLeft")) + parseInt(b.win.css("paddingRight")),
                h: b.doc.outerHeight() + parseInt(b.win.css("paddingTop")) + parseInt(b.win.css("paddingBottom"))
            }
        } : function () {
            return {w: b.docscroll[0].scrollWidth, h: b.docscroll[0].scrollHeight}
        };
        this.resize = this.onResize = function (c, d) {
            if (b.rail == false)return false;
            if (!b.haswrapper && !b.ispage)if (b.win.css("display") == "none")return b.visibility && b.hideRail(), false; else!b.visibility && b.getScrollTop() == 0 && b.doScrollTo(Math.floor(b.scroll.y * b.scrollratio.y)), !b.hidden && !b.visibility && b.showRail();
            var e = b.page.maxh, f = b.page.maxw, h = b.view.w;
            b.view = {
                w: b.ispage ? b.win.width() : parseInt(b.win[0].clientWidth),
                h: b.ispage ? b.win.height() : parseInt(b.win[0].clientHeight)
            };
            b.page = d ? d : b.getContentSize();
            b.page.maxh =
                Math.max(0, b.page.h - b.view.h);
            b.page.maxw = Math.max(0, b.page.w - b.view.w);
            if (b.page.maxh == e && b.page.maxw == f && b.view.w == h)if (b.ispage)return b; else {
                e = b.win.offset();
                if (b.lastposition && (f = b.lastposition, f.top == e.top && f.left == e.left))return b;
                b.lastposition = e
            }
            if (b.page.maxh == 0)return b.hideRail(), b.scrollvaluemax = 0, b.scroll.y = 0, b.scrollratio = {
                x: 0,
                y: 0
            }, b.cursorheight = 0, b.locked = true, b.setScrollTop(0), false; else if (!b.hidden && !b.visibility)b.showRail(), b.locked = false;
            b.istextarea && b.win.css("resize") && b.win.css("resize") !=
            "none" && (b.view.h -= 20);
            b.ispage || b.updateScrollBar(b.view);
            b.cursorheight = Math.min(b.view.h, Math.round(b.view.h * (b.view.h / b.page.h)));
            b.cursorheight = Math.max(b.opt.cursorminheight, b.cursorheight);
            b.scrollvaluemax = b.view.h - b.cursorheight - b.cursor.hborder;
            b.scrollratio = {x: 0, y: b.page.maxh / b.scrollvaluemax};
            b.getScrollTop() > b.page.maxh ? b.doScroll(b.page.maxh) : (b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y)), b.noticeCursor());
            return b
        };
        this.lazyResize = function () {
            b.delayed("resize", b.resize,
                250)
        };
        this._bind = function (c, d, e, f) {
            b.events.push({e: c, n: d, f: e});
            c.addEventListener ? c.addEventListener(d, e, f || false) : c.attachEvent ? c.attachEvent("on" + d, e) : c["on" + d] = e
        };
        this.bind = function (c, d, e, f) {
            var h = "jquery"in c ? c[0] : c;
            h.addEventListener ? (b.cantouch && /mouseup|mousedown|mousemove/.test(d) && b._bind(h, d == "mousedown" ? "touchstart" : d == "mouseup" ? "touchend" : "touchmove", function (b) {
                if (b.touches) {
                    if (b.touches.length < 2) {
                        var c = b.touches.length ? b.touches[0] : b;
                        c.original = b;
                        e.call(this, c)
                    }
                } else if (b.changedTouches)c =
                    b.changedTouches[0], c.original = b, e.call(this, c)
            }, f || false), b._bind(h, d, e, f || false), d == "mousewheel" && b._bind(h, "DOMMouseScroll", e, f || false), b.cantouch && d == "mouseup" && b._bind(h, "touchcancel", e, f || false)) : b._bind(h, d, function (c) {
                if ((c = c || window.event || false) && c.srcElement)c.target = c.srcElement;
                return e.call(h, c) === false || f === false ? b.cancelEvent(c) : true
            })
        };
        this._unbind = function (b, d, e) {
            b.removeEventListener ? b.removeEventListener(d, e, false) : b.detachEvent ? b.detachEvent("on" + d, e) : b["on" + d] = false
        };
        this.unbindAll =
            function () {
                for (var c = 0; c < b.events.length; c++) {
                    var d = b.events[c];
                    b._unbind(d.e, d.n, d.f)
                }
            };
        this.cancelEvent = function (b) {
            b = b.original ? b.original : b ? b : window.event || false;
            if (!b)return false;
            b.preventDefault && b.preventDefault();
            b.stopPropagation && b.stopPropagation();
            b.preventManipulation && b.preventManipulation();
            b.cancelBubble = true;
            b.cancel = true;
            return b.returnValue = false
        };
        this.showRail = function () {
            if (b.page.maxh != 0 && (b.ispage || b.win.css("display") != "none"))b.visibility = true, b.rail.css("display", "block");
            return b
        };
        this.hideRail = function () {
            b.visibility = false;
            b.rail.css("display", "none");
            return b
        };
        this.show = function () {
            b.hidden = false;
            b.locked = false;
            return b.showRail()
        };
        this.hide = function () {
            b.hidden = true;
            b.locked = true;
            return b.hideRail()
        };
        this.remove = function () {
            b.doZoomOut();
            b.unbindAll();
            b.observer !== false && b.observer.disconnect();
            b.events = [];
            b.rail.remove();
            b.zoom && b.zoom.remove();
            b.cursor = false;
            b.rail = false;
            b.zoom = false;
            for (var c = 0; c < b.saved.css.length; c++) {
                var d = b.saved.css[c];
                d[0].css(d[1], typeof d[2] ==
                "undefined" ? "" : d[2])
            }
            b.saved = false;
            b.me.data("__nicescroll", "");
            return b
        };
        this.isScrollable = function (b) {
            for (b = b.target ? b.target : b; b && b.nodeName && !/BODY|HTML/.test(b.nodeName);) {
                var d = e(b);
                if (/scroll|auto/.test(d.css("overflowY") || d.css("overflow") || ""))return b.clientHeight != b.scrollHeight;
                b = b.parentNode ? b.parentNode : false
            }
            return false
        };
        this.onmousewheel = function (c) {
            if (b.locked && b.page.maxh == 0)return true;
            if (b.opt.preservenativescrolling && b.checkarea)b.checkarea = false, b.nativescrollingarea = b.isScrollable(c);
            if (b.nativescrollingarea)return true;
            if (b.locked)return b.cancelEvent(c);
            if (b.rail.drag)return b.cancelEvent(c);
            var d = 0;
            if (d = c.detail ? c.detail * -1 : c.wheelDelta / 40)b.scrollmom && b.scrollmom.y.stop(), b.lastdelta += d * b.opt.mousescrollstep, b.synched("mousewheel", function () {
                if (!b.rail.drag) {
                    var c = b.lastdelta;
                    b.lastdelta = 0;
                    b.doScrollBy(c)
                }
            });
            return b.cancelEvent(c)
        };
        this.stop = function () {
            b.cancelScroll();
            b.scrollmon && b.scrollmon.stop();
            b.cursorfreezed = false;
            b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y));
            b.noticeCursor();
            return b
        };
        b.ishwscroll && b.hastransition && b.opt.usetransition ? (this.prepareTransition = function (c) {
            var d = Math.round(b.opt.scrollspeed * 10), c = Math.min(d, Math.round(c / 20 * b.opt.scrollspeed)), d = c > 20 ? b.prefixstyle + "transform " + c + "ms ease-out 0s" : "";
            if (!b.lasttransitionstyle || b.lasttransitionstyle != d)b.lasttransitionstyle = d, b.doc.css(b.transitionstyle, d);
            return c
        }, this.doScroll = function (c, d) {
            var e = b.getScrollTop();
            if (c < 0 && e <= 0)return b.noticeCursor(); else if (c > b.page.maxh && e >= b.page.maxh)return b.checkContentSize(),
                b.noticeCursor();
            b.newscrolly = c;
            b.newscrollspeed = d || false;
            if (b.timer)return false;
            if (!b.scrollendtrapped)b.scrollendtrapped = true, b.bind(b.doc, b.transitionend, b.onScrollEnd, false);
            b.timer = setTimeout(function () {
                var c = b.getScrollTop(), c = b.newscrollspeed ? b.newscrollspeed : Math.abs(c - b.newscrolly), d = b.prepareTransition(c);
                b.timer = setTimeout(function () {
                    if (b.newscrolly < 0 && !b.opt.bouncescroll)b.newscrolly = 0; else if (b.newscrolly > b.page.maxh && !b.opt.bouncescroll)b.newscrolly = b.page.maxh;
                    if (b.newscrolly == b.getScrollTop())b.timer =
                        0, b.onScrollEnd(); else {
                        var c = b.getScrollTop();
                        b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
                        if (d > 0 && (b.timerscroll = {
                                ts: (new Date).getTime(),
                                s: b.getScrollTop(),
                                e: b.newscrolly,
                                sp: d,
                                bz: new BezierClass(c, b.newscrolly, d, 0, 1, 0, 1)
                            }, !b.cursorfreezed))b.timerscroll.tm = setInterval(function () {
                            b.showCursor(b.getScrollTop())
                        }, 60);
                        b.setScrollTop(b.newscrolly);
                        b.timer = 0
                    }
                }, 15)
            }, b.opt.scrollspeed)
        }, this.cancelScroll = function () {
            if (!b.scrollendtrapped)return true;
            var c = b.getScrollTop();
            b.scrollendtrapped =
                false;
            b._unbind(b.doc, b.transitionend, b.onScrollEnd);
            b.prepareTransition(0);
            b.setScrollTop(c);
            b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
            b.timerscroll = false;
            b.cursorfreezed = false;
            b.noticeCursor(false, c);
            return b
        }, this.onScrollEnd = function () {
            b.scrollendtrapped = false;
            b._unbind(b.doc, b.transitionend, b.onScrollEnd);
            b.timerscroll && b.timerscroll.tm && clearInterval(b.timerscroll.tm);
            b.timerscroll = false;
            b.cursorfreezed = false;
            var c = b.getScrollTop();
            b.setScrollTop(c);
            b.noticeCursor(false,
                c);
            c < 0 ? b.doScroll(0, 60) : c > b.page.maxh && b.doScroll(b.page.maxh, 60)
        }) : (this.doScroll = function (c) {
            function d() {
                if (b.cancelAnimationFrame)return true;
                if (h = 1 - h)return b.timer = n(d) || 1;
                var c = b.getScrollTop(), e = b.bzscroll ? b.bzscroll.getNow() : b.newscrolly, c = e - c;
                if (c < 0 && e < b.newscrolly || c > 0 && e > b.newscrolly)e = b.newscrolly;
                b.setScrollTop(e);
                e == b.newscrolly ? (b.timer = 0, b.cursorfreezed = false, b.bzscroll = false, e < 0 ? b.doScroll(0) : e > b.page.maxh && b.doScroll(b.page.maxh)) : b.timer = n(d) || 1
            }

            if (b.newscrolly == c)return true;
            var e = b.getScrollTop();
            b.newscrolly = c;
            if (!b.bouncescroll)if (b.newscrolly < 0) {
                if (b.newspeedy)b.newspeedy.x = 0;
                b.newscrolly = 0
            } else if (b.newscrolly > b.page.maxh) {
                if (b.newspeedy)b.newspeedy.x = b.page.maxh;
                b.newscrolly = b.page.maxh
            }
            var f = Math.floor(Math.abs(c - e) / 40);
            f > 0 ? (f = Math.min(10, f) * 100, b.bzscroll = b.bzscroll ? b.bzscroll.update(c, f) : new BezierClass(e, c, f, 0, 1, 0, 1)) : b.bzscroll = false;
            if (!b.timer) {
                e == b.page.maxh && c >= b.page.maxh && b.checkContentSize();
                var h = 1;
                b.cancelAnimationFrame = false;
                b.timer = 1;
                d();
                e == b.page.maxh &&
                c >= e && b.checkContentSize();
                b.noticeCursor()
            }
        }, this.cancelScroll = function () {
            b.timer && p(b.timer);
            b.timer = 0;
            b.bzscroll = false;
            return b
        });
        this.doScrollBy = function (c, d) {
            var e = 0, e = d ? Math.floor((b.scroll.y - c) * b.scrollratio.y) : (b.timer ? b.newscrolly : b.getScrollTop(true)) - c;
            if (b.bouncescroll) {
                var f = Math.round(b.view.h / 2);
                e < -f ? e = -f : e > b.page.maxh + f && (e = b.page.maxh + f)
            }
            b.cursorfreezed = false;
            b.doScroll(e)
        };
        this.doScrollTo = function (c, d) {
            d && Math.round(c * b.scrollratio.y);
            b.cursorfreezed = false;
            b.doScroll(c)
        };
        this.checkContentSize =
            function () {
                var c = b.getContentSize();
                c.h != b.page.h && b.resize(false, c)
            };
        b.onscroll = function () {
            b.rail.drag || b.cursorfreezed || b.synched("scroll", function () {
                b.scroll.y = Math.round(b.getScrollTop() * (1 / b.scrollratio.y));
                b.noticeCursor()
            })
        };
        b.bind(b.docscroll, "scroll", b.onscroll);
        this.doZoomIn = function (c) {
            if (!b.zoomactive) {
                b.zoomactive = true;
                b.zoomrestore = {style: {}};
                var d = "position,top,left,zIndex,backgroundColor,marginTop,marginBottom,marginLeft,marginRight".split(","), f = b.win[0].style, h;
                for (h in d) {
                    var i =
                        d[h];
                    b.zoomrestore.style[i] = typeof f[i] != "undefined" ? f[i] : ""
                }
                b.zoomrestore.style.width = b.win.css("width");
                b.zoomrestore.style.height = b.win.css("height");
                b.zoomrestore.padding = {
                    w: b.win.outerWidth() - b.win.width(),
                    h: b.win.outerHeight() - b.win.height()
                };
                if (b.isios4)b.zoomrestore.scrollTop = e(window).scrollTop(), e(window).scrollTop(0);
                b.win.css({
                    position: b.isios4 ? "absolute" : "fixed",
                    top: 0,
                    left: 0,
                    "z-index": b.opt.zindex + 100,
                    margin: "0px"
                });
                d = b.win.css("backgroundColor");
                (d == "" || /transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(d)) &&
                b.win.css("backgroundColor", "#fff");
                b.rail.css({"z-index": b.opt.zindex + 110});
                b.zoom.css({"z-index": b.opt.zindex + 112});
                b.zoom.css("backgroundPosition", "0px -18px");
                b.resizeZoom();
                return b.cancelEvent(c)
            }
        };
        this.doZoomOut = function (c) {
            if (b.zoomactive)return b.zoomactive = false, b.win.css("margin", ""), b.win.css(b.zoomrestore.style), b.isios4 && e(window).scrollTop(b.zoomrestore.scrollTop), b.rail.css({"z-index": b.ispage ? b.opt.zindex : b.opt.zindex + 2}), b.zoom.css({"z-index": b.opt.zindex}), b.zoomrestore = false, b.zoom.css("backgroundPosition",
                "0px 0px"), b.onResize(), b.cancelEvent(c)
        };
        this.doZoom = function (c) {
            return b.zoomactive ? b.doZoomOut(c) : b.doZoomIn(c)
        };
        this.resizeZoom = function () {
            if (b.zoomactive) {
                var c = b.getScrollTop();
                b.win.css({
                    width: e(window).width() - b.zoomrestore.padding.w + "px",
                    height: e(window).height() - b.zoomrestore.padding.h + "px"
                });
                b.onResize();
                b.setScrollTop(Math.min(b.page.maxh, c))
            }
        };
        this.init();
        e.nicescroll.push(this)
    }, s = function (e) {
        var d = this;
        this.nc = e;
        this.lasttime = this.speedy = this.lasty = 0;
        this.snapy = false;
        this.demuly = 0;
        this.lastscrolly = -1;
        this.timer = this.chky = 0;
        this.time = function () {
            return (new Date).getTime()
        };
        this.reset = function (e) {
            d.stop();
            d.lasttime = d.time();
            d.speedy = 0;
            d.lasty = e;
            d.lastscrolly = -1
        };
        this.update = function (h) {
            d.lasttime = d.time();
            var b = h - d.lasty, i = e.getScrollTop() + b;
            d.snapy = i < 0 || i > d.nc.page.maxh;
            d.speedy = b;
            d.lasty = h
        };
        this.stop = function () {
            if (d.timer)clearTimeout(d.timer), d.timer = 0, d.lastscrolly = -1
        };
        this.doSnapy = function (e) {
            e < 0 ? d.nc.doScroll(0, 60) : e > d.nc.page.maxh && d.nc.doScroll(d.nc.page.maxh, 60)
        };
        this.doMomentum =
            function (e) {
                var b = d.time(), f = e ? b + e : d.lasttime;
                d.speedy = Math.min(60, d.speedy);
                if (d.speedy && f && b - f <= 50 && d.speedy) {
                    var e = b - f, j = d.nc.page.maxh;
                    d.demuly = 0;
                    d.lastscrolly = d.nc.getScrollTop();
                    d.chky = d.lastscrolly;
                    var l = function () {
                        var b = Math.floor(d.lastscrolly - d.speedy * (1 - d.demuly));
                        d.demuly += b < 0 || b > j ? 0.08 : 0.01;
                        d.lastscrolly = b;
                        d.nc.synched("domomentum", function () {
                            d.nc.getScrollTop() != d.chky && d.stop();
                            d.chky = b;
                            d.nc.setScrollTop(b);
                            d.timer ? d.nc.showCursor(b) : (d.nc.hideCursor(), d.doSnapy(b))
                        });
                        d.timer = d.demuly <
                        1 ? setTimeout(l, e) : 0
                    };
                    l()
                } else d.snapy && d.doSnapy(d.nc.getScrollTop())
            }
    }, l = e.fn.scrollTop;
    e.cssHooks.scrollTop = {
        get: function (f) {
            var d = e.data(f, "__nicescroll") || false;
            return d && d.ishwscroll ? d.getScrollTop() : l.call(f)
        }, set: function (f, d) {
            var h = e.data(f, "__nicescroll") || false;
            h && h.ishwscroll ? h.setScrollTop(parseInt(d)) : l.call(f, d);
            return this
        }
    };
    e.fn.scrollTop = function (f) {
        if (typeof f == "undefined") {
            var d = this[0] ? e.data(this[0], "__nicescroll") || false : false;
            return d && d.ishwscroll ? d.getScrollTop() : l.call(this)
        } else return this.each(function () {
            var d =
                e.data(this, "__nicescroll") || false;
            d && d.ishwscroll ? d.setScrollTop(parseInt(f)) : l.call(e(this), f)
        })
    };
    var m = function (f) {
        var d = this;
        this.length = 0;
        this.name = "nicescrollarray";
        this.each = function (b) {
            for (var e = 0; e < d.length; e++)b.call(d[e]);
            return d
        };
        this.push = function (b) {
            d[d.length] = b;
            d.length++
        };
        this.eq = function (b) {
            return d[b]
        };
        if (f)for (a = 0; a < f.length; a++) {
            var h = e.data(f[a], "__nicescroll") || false;
            h && (this[this.length] = h, this.length++)
        }
        return this
    };
    (function (e, d, h) {
        for (var b = 0; b < d.length; b++)h(e, d[b])
    })(m.prototype,
        "show,hide,onResize,resize,remove,stop".split(","), function (e, d) {
            e[d] = function () {
                return this.each(function () {
                    this[d].call()
                })
            }
        });
    e.fn.getNiceScroll = function (f) {
        return typeof f == "undefined" ? new m(this) : e.data(this[f], "__nicescroll") || false
    };
    e.extend(e.expr[":"], {
        nicescroll: function (f) {
            return e.data(f, "__nicescroll") ? true : false
        }
    });
    e.fn.niceScroll = function (f, d) {
        typeof d == "undefined" && typeof f == "object" && !("jquery"in f) && (d = f, f = false);
        var h = new m;
        typeof d == "undefined" && (d = {});
        if (f)d.doc = e(f), d.win = e(this);
        var b = !("doc"in d);
        if (!b && !("win"in d))d.win = e(this);
        this.each(function () {
            var f = e(this).data("__nicescroll") || false;
            if (!f)d.doc = b ? e(this) : d.doc, f = new z(d, e(this)), e(this).data("__nicescroll", f);
            h.push(f)
        });
        return h.length == 1 ? h[0] : h
    };
    window.NiceScroll = {
        getjQuery: function () {
            return e
        }
    };
    if (!e.nicescroll)e.nicescroll = new m
})(jQuery);
/*
 xBreadcrumbs (Extended Breadcrums) jQuery Plugin
 ? 2009 ajaxBlender.com
 For any questions please visit www.ajaxblender.com 
 or email us at support@ajaxblender.com
 */

;
(function ($) {
    /*  Variables  */
    $.fn.xBreadcrumbs = function (settings) {
        var element = $(this);
        var

            settings = $.extend({}, $.fn.xBreadcrumbs.defaults, settings);

        function _build() {
            if (settings.collapsible) {
                var sz = element.children('LI').length;
                element.children('LI').children('A').css('white-space', 'nowrap').css('float', 'left');
                element.children('LI').children('A').each(function (i, el) {
                    if (i != sz - 1) {
                        $(this).css('overflow', 'hidden');
                        $(this).attr('init-width', $(this).width());
                        $(this).width(settings.collapsedWidth);
                    }
                });
            }

            element.children('LI').mouseenter(function () {
                if ($(this).hasClass('hover')) {
                    return;
                }

                _hideAllSubLevels();
                if (!_subLevelExists($(this))) {
                    return;
                }

                // Show sub-level
                var subLevel = $(this).children('UL');
                _showHideSubLevel(subLevel, true);

                if (settings.collapsible && !$(this).hasClass('current')) {
                    var initWidth = $(this).children('A').attr('init-width');
                    $(this).children('A').animate({width: initWidth}, 'normal');
                }
            });

            element.children('LI').mouseleave(function () {
                var subLevel = $(this).children('UL');
                _showHideSubLevel(subLevel, false);

                if (settings.collapsible && !$(this).hasClass('current')) {
                    $(this).children('A').animate({width: settings.collapsedWidth}, 'fast');
                }
            });
        };

        function _hideAllSubLevels() {
            element.children('LI').children('UL').each(function () {
                $(this).hide();
                $(this).parent().removeClass('hover');
            });
        };

        function _showHideSubLevel(subLevel, isShow) {
            if (isShow) {
                subLevel.parent().addClass('hover');
                if ($.browser.msie) {
                    var pos = subLevel.parent().position();
                    subLevel.css('left', parseInt(pos['left']));
                }
                if (settings.showSpeed != '') {
                    subLevel.fadeIn(settings.showSpeed);
                }
                else {
                    subLevel.show();
                }
            } else {
                subLevel.parent().removeClass('hover');
                if (settings.hideSpeed != '') {
                    subLevel.fadeOut(settings.hideSpeed);
                }
                else {
                    subLevel.hide();
                }
            }
        };

        function _subLevelExists(obj) {
            return obj.children('UL').length > 0;
        };

        //    Entry point
        _build();
    };

    /*  Default Settings  */
    $.fn.xBreadcrumbs.defaults = {
        showSpeed: 'fast',
        hideSpeed: '',
        collapsible: false,
        collapsedWidth: 10
    };
})(jQuery);
/*! qTip2 v2.0.0 | http://craigsworks.com/projects/qtip2/ | Licensed MIT, GPL */
(function (e, t, n) {
    (function (e) {
        "use strict";
        typeof define == "function" && define.amd ? define(["jquery"], e) : jQuery && !jQuery.fn.qtip && e(jQuery)
    })(function (r) {
        function P(e) {
            var t = function (e) {
                return e === o || "object" != typeof e
            }, n = function (e) {
                return !r.isFunction(e) && (!e && !e.attr || e.length < 1 || "object" == typeof e && !e.jquery)
            };
            if (!e || "object" != typeof e)return s;
            t(e.metadata) && (e.metadata = {type: e.metadata});
            if ("content"in e) {
                if (t(e.content) || e.content.jquery)e.content = {text: e.content};
                n(e.content.text || s) && (e.content.text = s), "title"in e.content && (t(e.content.title) && (e.content.title = {text: e.content.title}), n(e.content.title.text || s) && (e.content.title.text = s))
            }
            return "position"in e && t(e.position) && (e.position = {
                my: e.position,
                at: e.position
            }), "show"in e && t(e.show) && (e.show = e.show.jquery ? {target: e.show} : {event: e.show}), "hide"in e && t(e.hide) && (e.hide = e.hide.jquery ? {target: e.hide} : {event: e.hide}), "style"in e && t(e.style) && (e.style = {classes: e.style}), r.each(w, function () {
                this.sanitize && this.sanitize(e)
            }), e
        }

        function H(u, a, m, g) {
            function U(e) {
                var t = 0, n, r = a, i = e.split(".");
                while (r = r[i[t++]])t < i.length && (n = r);
                return [n || a, i.pop()]
            }

            function z(e, t, n) {
                var i = r.Event("tooltip" + e);
                return i.originalEvent = (n ? r.extend({}, n) : o) || R.event || o, F.trigger(i, [y].concat(t || [])), !i.isDefaultPrevented()
            }

            function W() {
                var e = a.style.widget;
                F.toggleClass("ui-helper-reset " + T, e).toggleClass(k, a.style.def && !e), q.content && q.content.toggleClass(T + "-content", e), q.titlebar && q.titlebar.toggleClass(T + "-header", e), q.button && q.button.toggleClass(x + "-icon", !e)
            }

            function X(e) {
                q.title && (q.titlebar.remove(), q.titlebar = q.title = q.button = o, e !== s && y.reposition())
            }

            function V() {
                var e = a.content.title.button, t = typeof e == "string", n = t ? e : "Close tooltip";
                q.button && q.button.remove(), e.jquery ? q.button = e : q.button = r("<a />", {
                    "class": "ui-state-default ui-tooltip-close " + (a.style.widget ? "" : x + "-icon"),
                    title: n,
                    "aria-label": n
                }).prepend(r("<span />", {
                    "class": "ui-icon ui-icon-close",
                    html: "&times;"
                })), q.button.appendTo(q.titlebar).attr("role", "button").click(function (e) {
                    return F.hasClass(N) || y.hide(e), s
                }), y.redraw()
            }

            function J() {
                var e = H + "-title";
                q.titlebar && X(), q.titlebar = r("<div />", {"class": x + "-titlebar " + (a.style.widget ? "ui-widget-header" : "")}).append(q.title = r("<div />", {
                    id: e,
                    "class": x + "-title",
                    "aria-atomic": i
                })).insertBefore(q.content).delegate(".ui-tooltip-close", "mousedown keydown mouseup keyup mouseout", function (e) {
                    r(this).toggleClass("ui-state-active ui-state-focus", e.type.substr(-4) === "down")
                }).delegate(".ui-tooltip-close", "mouseover mouseout", function (e) {
                    r(this).toggleClass("ui-state-hover", e.type === "mouseover")
                }), a.content.title.button ? V() : y.rendered && y.redraw()
            }

            function K(e) {
                var t = q.button, n = q.title;
                if (!y.rendered)return s;
                e ? (n || J(), V()) : t.remove()
            }

            function Q(e, t) {
                var n = q.title;
                if (!y.rendered || !e)return s;
                r.isFunction(e) && (e = e.call(u, R.event, y));
                if (e === s || !e && e !== "")return X(s);
                e.jquery && e.length > 0 ? n.empty().append(e.css({display: "block"})) : n.html(e), y.redraw(), t !== s && y.rendered && F[0].offsetWidth > 0 && y.reposition(R.event)
            }

            function G(e, t) {
                function o(e) {
                    function a(n) {
                        n && (delete u[n.src], clearTimeout(y.timers.img[n.src]), r(n).unbind(I)), r.isEmptyObject(u) && (y.redraw(), t !== s && y.reposition(R.event), e())
                    }

                    var o, u = {};
                    if ((o = i.find("img[src]:not([height]):not([width])")).length === 0)return a();
                    o.each(function (e, t) {
                        if (u[t.src] !== n)return;
                        var i = 0, s = 3;
                        (function o() {
                            if (t.height || t.width || i > s)return a(t);
                            i += 1, y.timers.img[t.src] = setTimeout(o, 700)
                        })(), r(t).bind("error" + I + " load" + I, function () {
                            a(this)
                        }), u[t.src] = t
                    })
                }

                var i = q.content;
                return !y.rendered || !e ? s : (r.isFunction(e) && (e = e.call(u, R.event, y) || ""), e.jquery && e.length > 0 ? i.empty().append(e.css({display: "block"})) : i.html(e), y.rendered < 0 ? F.queue("fx", o) : (j = 0, o(r.noop)), y)
            }

            function Y() {
                function c(e) {
                    if (F.hasClass(N))return s;
                    clearTimeout(y.timers.show), clearTimeout(y.timers.hide);
                    var t = function () {
                        y.toggle(i, e)
                    };
                    a.show.delay > 0 ? y.timers.show = setTimeout(t, a.show.delay) : t()
                }

                function h(e) {
                    if (F.hasClass(N) || B || j)return s;
                    var t = r(e.relatedTarget || e.target), i = t.closest(C)[0] === F[0], u = t[0] === o.show[0];
                    clearTimeout(y.timers.show), clearTimeout(y.timers.hide);
                    if (n.target === "mouse" && i || a.hide.fixed && /mouse(out|leave|move)/.test(e.type) && (i || u)) {
                        try {
                            e.preventDefault(), e.stopImmediatePropagation()
                        } catch (f) {
                        }
                        return
                    }
                    a.hide.delay > 0 ? y.timers.hide = setTimeout(function () {
                        y.hide(e)
                    }, a.hide.delay) : y.hide(e)
                }

                function p(e) {
                    if (F.hasClass(N))return s;
                    clearTimeout(y.timers.inactive), y.timers.inactive = setTimeout(function () {
                        y.hide(e)
                    }, a.hide.inactive)
                }

                function d(e) {
                    y.rendered && F[0].offsetWidth > 0 && y.reposition(e)
                }

                var n = a.position, o = {
                    show: a.show.target,
                    hide: a.hide.target,
                    viewport: r(n.viewport),
                    document: r(t),
                    body: r(t.body),
                    window: r(e)
                }, f = {
                    show: r.trim("" + a.show.event).split(" "),
                    hide: r.trim("" + a.hide.event).split(" ")
                }, l = r.browser.msie && parseInt(r.browser.version, 10) === 6;
                F.bind("mouseenter" + I + " mouseleave" + I, function (e) {
                    var t = e.type === "mouseenter";
                    t && y.focus(e), F.toggleClass(A, t)
                }), /mouse(out|leave)/i.test(a.hide.event) && a.hide.leave === "window" && o.window.bind("mouseout" + I + " blur" + I, function (e) {
                    !/select|option/.test(e.target.nodeName) && !e.relatedTarget && y.hide(e)
                }), a.hide.fixed ? (o.hide = o.hide.add(F), F.bind("mouseover" + I, function () {
                    F.hasClass(N) || clearTimeout(y.timers.hide)
                })) : /mouse(over|enter)/i.test(a.show.event) && o.hide.bind("mouseleave" + I, function (e) {
                    clearTimeout(y.timers.show)
                }), ("" + a.hide.event).indexOf("unfocus") > -1 && n.container.closest("html").bind("mousedown" + I + " touchstart" + I, function (e) {
                    var t = r(e.target), n = y.rendered && !F.hasClass(N) && F[0].offsetWidth > 0, i = t.parents(C).filter(F[0]).length > 0;
                    t[0] !== u[0] && t[0] !== F[0] && !i && !u.has(t[0]).length && !t.attr("disabled") && y.hide(e)
                }), "number" == typeof a.hide.inactive && (o.show.bind("qtip-" + m + "-inactive", p), r.each(b.inactiveEvents, function (e, t) {
                    o.hide.add(q.tooltip).bind(t + I + "-inactive", p)
                })), r.each(f.hide, function (e, t) {
                    var n = r.inArray(t, f.show), i = r(o.hide);
                    n > -1 && i.add(o.show).length === i.length || t === "unfocus" ? (o.show.bind(t + I, function (e) {
                        F[0].offsetWidth > 0 ? h(e) : c(e)
                    }), delete f.show[n]) : o.hide.bind(t + I, h)
                }), r.each(f.show, function (e, t) {
                    o.show.bind(t + I, c)
                }), "number" == typeof a.hide.distance && o.show.add(F).bind("mousemove" + I, function (e) {
                    var t = R.origin || {}, n = a.hide.distance, r = Math.abs;
                    (r(e.pageX - t.pageX) >= n || r(e.pageY - t.pageY) >= n) && y.hide(e)
                }), n.target === "mouse" && (o.show.bind("mousemove" + I, function (e) {
                    E = {pageX: e.pageX, pageY: e.pageY, type: "mousemove"}
                }), n.adjust.mouse && (a.hide.event && (F.bind("mouseleave" + I, function (e) {
                    (e.relatedTarget || e.target) !== o.show[0] && y.hide(e)
                }), q.target.bind("mouseenter" + I + " mouseleave" + I, function (e) {
                    R.onTarget = e.type === "mouseenter"
                })), o.document.bind("mousemove" + I, function (e) {
                    y.rendered && R.onTarget && !F.hasClass(N) && F[0].offsetWidth > 0 && y.reposition(e || E)
                }))), (n.adjust.resize || o.viewport.length) && (r.event.special.resize ? o.viewport : o.window).bind("resize" + I, d), (o.viewport.length || l && F.css("position") === "fixed") && o.viewport.bind("scroll" + I, d)
            }

            function Z() {
                var n = [a.show.target[0], a.hide.target[0], y.rendered && q.tooltip[0], a.position.container[0], a.position.viewport[0], a.position.container.closest("html")[0], e, t];
                y.rendered ? r([]).pushStack(r.grep(n, function (e) {
                    return typeof e == "object"
                })).unbind(I) : a.show.target.unbind(I + "-create")
            }

            var y = this, O = t.body, H = x + "-" + m, B = 0, j = 0, F = r(), I = ".qtip-" + m, q, R;
            y.id = m, y.rendered = s, y.destroyed = s, y.elements = q = {target: u}, y.timers = {img: {}}, y.options = a, y.checks = {}, y.plugins = {}, y.cache = R = {
                event: {},
                target: r(),
                disabled: s,
                attr: g,
                onTarget: s,
                lastClass: ""
            }, y.checks.builtin = {
                "^id$": function (e, t, n) {
                    var o = n === i ? b.nextid : n, u = x + "-" + o;
                    o !== s && o.length > 0 && !r("#" + u).length && (F[0].id = u, q.content[0].id = u + "-content", q.title[0].id = u + "-title")
                }, "^content.text$": function (e, t, n) {
                    G(n)
                }, "^content.title.text$": function (e, t, n) {
                    if (!n)return X();
                    !q.title && n && J(), Q(n)
                }, "^content.title.button$": function (e, t, n) {
                    K(n)
                }, "^position.(my|at)$": function (e, t, n) {
                    "string" == typeof n && (e[t] = new w.Corner(n))
                }, "^position.container$": function (e, t, n) {
                    y.rendered && F.appendTo(n)
                }, "^show.ready$": function () {
                    y.rendered ? y.toggle(i) : y.render(1)
                }, "^style.classes$": function (e, t, n) {
                    F.attr("class", x + " qtip " + n)
                }, "^style.widget|content.title": W, "^events.(render|show|move|hide|focus|blur)$": function (e, t, n) {
                    F[(r.isFunction(n) ? "" : "un") + "bind"]("tooltip" + t, n)
                }, "^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)": function () {
                    var e = a.position;
                    F.attr("tracking", e.target === "mouse" && e.adjust.mouse), Z(), Y()
                }
            }, r.extend(y, {
                render: function (e) {
                    if (y.rendered)return y;
                    var t = a.content.text, n = a.content.title.text, o = a.position;
                    return r.attr(u[0], "aria-describedby", H), F = q.tooltip = r("<div/>", {
                        id: H,
                        "class": x + " qtip " + k + " " + a.style.classes + " " + x + "-pos-" + a.position.my.abbrev(),
                        width: a.style.width || "",
                        height: a.style.height || "",
                        tracking: o.target === "mouse" && o.adjust.mouse,
                        role: "alert",
                        "aria-live": "polite",
                        "aria-atomic": s,
                        "aria-describedby": H + "-content",
                        "aria-hidden": i
                    }).toggleClass(N, R.disabled).data("qtip", y).appendTo(a.position.container).append(q.content = r("<div />", {
                        "class": x + "-content",
                        id: H + "-content",
                        "aria-atomic": i
                    })), y.rendered = -1, j = 1, B = 1, n && (J(), r.isFunction(n) || Q(n, s)), r.isFunction(t) || G(t, s), y.rendered = i, W(), r.each(a.events, function (e, t) {
                        r.isFunction(t) && F.bind(e === "toggle" ? "tooltipshow tooltiphide" : "tooltip" + e, t)
                    }), r.each(w, function () {
                        this.initialize === "render" && this(y)
                    }), Y(), F.queue("fx", function (t) {
                        z("render"), j = 0, B = 0, y.redraw(), (a.show.ready || e) && y.toggle(i, R.event, s), t()
                    }), y
                }, get: function (e) {
                    var t, n;
                    switch (e.toLowerCase()) {
                        case"dimensions":
                            t = {height: F.outerHeight(s), width: F.outerWidth(s)};
                            break;
                        case"offset":
                            t = w.offset(F, a.position.container);
                            break;
                        default:
                            n = U(e.toLowerCase()), t = n[0][n[1]], t = t.precedance ? t.string() : t
                    }
                    return t
                }, set: function (e, t) {
                    function p(e, t) {
                        var n, r, i;
                        for (n in c)for (r in c[n])if (i = (new RegExp(r, "i")).exec(e))t.push(i), c[n][r].apply(y, t)
                    }

                    var n = /^position\.(my|at|adjust|target|container)|style|content|show\.ready/i, u = /^content\.(title|attr)|style/i, f = s, l = s, c = y.checks, h;
                    return "string" == typeof e ? (h = e, e = {}, e[h] = t) : e = r.extend(i, {}, e), r.each(e, function (t, i) {
                        var s = U(t.toLowerCase()), o;
                        o = s[0][s[1]], s[0][s[1]] = "object" == typeof i && i.nodeType ? r(i) : i, e[t] = [s[0], s[1], i, o], f = n.test(t) || f, l = u.test(t) || l
                    }), P(a), B = j = 1, r.each(e, p), B = j = 0, y.rendered && F[0].offsetWidth > 0 && (f && y.reposition(a.position.target === "mouse" ? o : R.event), l && y.redraw()), y
                }, toggle: function (e, n) {
                    function b() {
                        e ? (r.browser.msie && F[0].style.removeAttribute("filter"), F.css("overflow", ""), "string" == typeof u.autofocus && r(u.autofocus, F).focus(), u.target.trigger("qtip-" + m + "-inactive")) : F.css({
                            display: "",
                            visibility: "",
                            opacity: "",
                            left: "",
                            top: ""
                        }), z(e ? "visible" : "hidden")
                    }

                    if (n) {
                        if (/over|enter/.test(n.type) && /out|leave/.test(R.event.type) && a.show.target.add(n.target).length === a.show.target.length && F.has(n.relatedTarget).length)return y;
                        R.event = r.extend({}, n)
                    }
                    if (!y.rendered)return e ? y.render(1) : y;
                    var o = e ? "show" : "hide", u = a[o], f = a[e ? "hide" : "show"], l = a.position, c = a.content, h = F[0].offsetWidth > 0, p = e || u.target.length === 1, d = !n || u.target.length < 2 || R.target[0] === n.target, v, g;
                    return (typeof e).search("boolean|number") && (e = !h), !F.is(":animated") && h === e && d ? y : z(o, [90]) ? (r.attr(F[0], "aria-hidden", !e), e ? (R.origin = r.extend({}, E), y.focus(n), r.isFunction(c.text) && G(c.text, s), r.isFunction(c.title.text) && Q(c.title.text, s), !_ && l.target === "mouse" && l.adjust.mouse && (r(t).bind("mousemove.qtip", function (e) {
                        E = {pageX: e.pageX, pageY: e.pageY, type: "mousemove"}
                    }), _ = i), y.reposition(n, arguments[2]), !u.solo || r(C, u.solo).not(F).qtip("hide", r.Event("tooltipsolo"))) : (clearTimeout(y.timers.show), delete R.origin, _ && !r(C + '[tracking="true"]:visible', u.solo).not(F).length && (r(t).unbind("mousemove.qtip"), _ = s), y.blur(n)), u.effect === s || p === s ? (F[o](), b.call(F)) : r.isFunction(u.effect) ? (F.stop(1, 1), u.effect.call(F, y), F.queue("fx", function (e) {
                        b(), e()
                    })) : F.fadeTo(90, e ? 1 : 0, b), e && u.target.trigger("qtip-" + m + "-inactive"), y) : y
                }, show: function (e) {
                    return y.toggle(i, e)
                }, hide: function (e) {
                    return y.toggle(s, e)
                }, focus: function (e) {
                    if (!y.rendered)return y;
                    var t = r(C), n = parseInt(F[0].style.zIndex, 10), i = b.zindex + t.length, s = r.extend({}, e), o;
                    return F.hasClass(L) || z("focus", [i], s) && (n !== i && (t.each(function () {
                        this.style.zIndex > n && (this.style.zIndex = this.style.zIndex - 1)
                    }), t.filter("." + L).qtip("blur", s)), F.addClass(L)[0].style.zIndex = i), y
                }, blur: function (e) {
                    return F.removeClass(L), z("blur", [F.css("zIndex")], e), y
                }, reposition: function (n, i) {
                    if (!y.rendered || B)return y;
                    B = 1;
                    var o = a.position.target, u = a.position, f = u.my, l = u.at, m = u.adjust, g = m.method.split(" "), b = F.outerWidth(s), S = F.outerHeight(s), x = 0, T = 0, N = F.css("position") === "fixed", C = u.viewport, k = {
                        left: 0,
                        top: 0
                    }, L = u.container, A = F[0].offsetWidth > 0, O, M, _;
                    if (r.isArray(o) && o.length === 2)l = {x: h, y: c}, k = {
                        left: o[0],
                        top: o[1]
                    }; else if (o === "mouse" && (n && n.pageX || R.event.pageX))l = {
                        x: h,
                        y: c
                    }, n = (!n || n.type !== "resize" && n.type !== "scroll" ? n && n.pageX && n.type === "mousemove" ? n : E && E.pageX && (m.mouse || !n || !n.pageX) ? {
                            pageX: E.pageX,
                            pageY: E.pageY
                        } : !m.mouse && R.origin && R.origin.pageX && a.show.distance ? R.origin : n : R.event) || n || R.event || E || {}, k = {
                        top: n.pageY,
                        left: n.pageX
                    }; else {
                        o === "event" && n && n.target && n.type !== "scroll" && n.type !== "resize" ? R.target = r(n.target) : o !== "event" && (R.target = r(o.jquery ? o : q.target)), o = R.target, o = r(o).eq(0);
                        if (o.length === 0)return y;
                        o[0] === t || o[0] === e ? (x = w.iOS ? e.innerWidth : o.width(), T = w.iOS ? e.innerHeight : o.height(), o[0] === e && (k = {
                            top: (C || o).scrollTop(),
                            left: (C || o).scrollLeft()
                        })) : w.imagemap && o.is("area") ? O = w.imagemap(y, o, l, w.viewport ? g : s) : w.svg && typeof o[0].xmlbase == "string" ? O = w.svg(y, o, l, w.viewport ? g : s) : (x = o.outerWidth(s), T = o.outerHeight(s), k = w.offset(o, L)), O && (x = O.width, T = O.height, M = O.offset, k = O.position);
                        if (w.iOS > 3.1 && w.iOS < 4.1 || w.iOS >= 4.3 && w.iOS < 4.33 || !w.iOS && N)_ = r(e), k.left -= _.scrollLeft(), k.top -= _.scrollTop();
                        k.left += l.x === d ? x : l.x === v ? x / 2 : 0, k.top += l.y === p ? T : l.y === v ? T / 2 : 0
                    }
                    return k.left += m.x + (f.x === d ? -b : f.x === v ? -b / 2 : 0), k.top += m.y + (f.y === p ? -S : f.y === v ? -S / 2 : 0), w.viewport ? (k.adjusted = w.viewport(y, k, u, x, T, b, S), M && k.adjusted.left && (k.left += M.left), M && k.adjusted.top && (k.top += M.top)) : k.adjusted = {
                        left: 0,
                        top: 0
                    }, z("move", [k, C.elem || C], n) ? (delete k.adjusted, i === s || !A || isNaN(k.left) || isNaN(k.top) || o === "mouse" || !r.isFunction(u.effect) ? F.css(k) : r.isFunction(u.effect) && (u.effect.call(F, y, r.extend({}, k)), F.queue(function (e) {
                        r(this).css({
                            opacity: "",
                            height: ""
                        }), r.browser.msie && this.style.removeAttribute("filter"), e()
                    })), B = 0, y) : y
                }, redraw: function () {
                    if (y.rendered < 1 || j)return y;
                    var e = a.style, t = a.position.container, n, r, i, s;
                    return j = 1, z("redraw"), e.height && F.css(l, e.height), e.width ? F.css(f, e.width) : (F.css(f, "").appendTo(D), r = F.width(), r % 2 < 1 && (r += 1), i = F.css("max-width") || "", s = F.css("min-width") || "", n = (i + s).indexOf("%") > -1 ? t.width() / 100 : 0, i = (i.indexOf("%") > -1 ? n : 1) * parseInt(i, 10) || r, s = (s.indexOf("%") > -1 ? n : 1) * parseInt(s, 10) || 0, r = i + s ? Math.min(Math.max(r, s), i) : r, F.css(f, Math.round(r)).appendTo(t)), z("redrawn"), j = 0, y
                }, disable: function (e) {
                    return "boolean" != typeof e && (e = !F.hasClass(N) && !R.disabled), y.rendered ? (F.toggleClass(N, e), r.attr(F[0], "aria-disabled", e)) : R.disabled = !!e, y
                }, enable: function () {
                    return y.disable(s)
                }, destroy: function () {
                    var e = u[0], t = r.attr(e, M), n = u.data("qtip");
                    y.destroyed = i, y.rendered && (F.stop(1, 0).remove(), r.each(y.plugins, function () {
                        this.destroy && this.destroy()
                    })), clearTimeout(y.timers.show), clearTimeout(y.timers.hide), Z();
                    if (!n || y === n)r.removeData(e, "qtip"), a.suppress && t && (r.attr(e, "title", t), u.removeAttr(M)), u.removeAttr("aria-describedby");
                    return u.unbind(".qtip-" + m), delete S[y.id], u
                }
            })
        }

        function B(e, n) {
            var u, a, f, l, c, h = r(this), p = r(t.body), d = this === t ? p : h, v = h.metadata ? h.metadata(n.metadata) : o, m = n.metadata.type === "html5" && v ? v[n.metadata.name] : o, g = h.data(n.metadata.name || "qtipopts");
            try {
                g = typeof g == "string" ? r.parseJSON(g) : g
            } catch (y) {
            }
            l = r.extend(i, {}, b.defaults, n, typeof g == "object" ? P(g) : o, P(m || v)), a = l.position, l.id = e;
            if ("boolean" == typeof l.content.text) {
                f = h.attr(l.content.attr);
                if (l.content.attr === s || !f)return s;
                l.content.text = f
            }
            a.container.length || (a.container = p), a.target === s && (a.target = d), l.show.target === s && (l.show.target = d), l.show.solo === i && (l.show.solo = a.container.closest("body")), l.hide.target === s && (l.hide.target = d), l.position.viewport === i && (l.position.viewport = a.container), a.container = a.container.eq(0), a.at = new w.Corner(a.at), a.my = new w.Corner(a.my);
            if (r.data(this, "qtip"))if (l.overwrite)h.qtip("destroy"); else if (l.overwrite === s)return s;
            return l.suppress && (c = r.attr(this, "title")) && r(this).removeAttr("title").attr(M, c).attr("title", ""), u = new H(h, l, e, !!f), r.data(this, "qtip", u), h.bind("remove.qtip-" + e + " removeqtip.qtip-" + e, function () {
                u.destroy()
            }), u
        }

        function j(e) {
            var t = this, n = e.elements.tooltip, o = e.options.content.ajax, u = b.defaults.content.ajax, a = ".qtip-ajax", f = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, l = i, c = s, h;
            e.checks.ajax = {
                "^content.ajax": function (e, r, i) {
                    r === "ajax" && (o = i), r === "once" ? t.init() : o && o.url ? t.load() : n.unbind(a)
                }
            }, r.extend(t, {
                init: function () {
                    return o && o.url && n.unbind(a)[o.once ? "one" : "bind"]("tooltipshow" + a, t.load), t
                }, load: function (n) {
                    function g() {
                        var t;
                        if (e.destroyed)return;
                        l = s, v && (c = i, e.show(n.originalEvent)), (t = u.complete || o.complete) && r.isFunction(t) && t.apply(o.context || e, arguments)
                    }

                    function y(t, n, i) {
                        var s;
                        if (e.destroyed)return;
                        d && "string" == typeof t && (t = r("<div/>").append(t.replace(f, "")).find(d)), (s = u.success || o.success) && r.isFunction(s) ? s.call(o.context || e, t, n, i) : e.set("content.text", t)
                    }

                    function b(t, n, r) {
                        if (e.destroyed || t.status === 0)return;
                        e.set("content.text", n + ": " + r)
                    }

                    if (c) {
                        c = s;
                        return
                    }
                    var a = o.url.lastIndexOf(" "), p = o.url, d, v = !o.loading && l;
                    if (v)try {
                        n.preventDefault()
                    } catch (m) {
                    } else if (n && n.isDefaultPrevented())return t;
                    h && h.abort && h.abort(), a > -1 && (d = p.substr(a), p = p.substr(0, a)), h = r.ajax(r.extend({
                        error: u.error || b,
                        context: e
                    }, o, {url: p, success: y, complete: g}))
                }, destroy: function () {
                    h && h.abort && h.abort(), e.destroyed = i
                }
            }), t.init()
        }

        function F(e, t, n) {
            var r = Math.ceil(t / 2), i = Math.ceil(n / 2), s = {
                bottomright: [[0, 0], [t, n], [t, 0]],
                bottomleft: [[0, 0], [t, 0], [0, n]],
                topright: [[0, n], [t, 0], [t, n]],
                topleft: [[0, 0], [0, n], [t, n]],
                topcenter: [[0, n], [r, 0], [t, n]],
                bottomcenter: [[0, 0], [t, 0], [r, n]],
                rightcenter: [[0, 0], [t, i], [0, n]],
                leftcenter: [[t, 0], [t, n], [0, i]]
            };
            return s.lefttop = s.bottomright, s.righttop = s.bottomleft, s.leftbottom = s.topright, s.rightbottom = s.topleft, s[e.string()]
        }

        function I(e, t) {
            function A(e) {
                var t = E.is(":visible");
                E.show(), e(), E.toggle(t)
            }

            function O() {
                x.width = g.height, x.height = g.width
            }

            function M() {
                x.width = g.width, x.height = g.height
            }

            function _(t, r, o, f) {
                if (!b.tip)return;
                var l = m.corner.clone(), w = o.adjusted, E = e.options.position.adjust.method.split(" "), x = E[0], T = E[1] || E[0], N = {
                    left: s,
                    top: s,
                    x: 0,
                    y: 0
                }, C, k = {}, L;
                m.corner.fixed !== i && (x === y && l.precedance === u && w.left && l.y !== v ? l.precedance = l.precedance === u ? a : u : x !== y && w.left && (l.x = l.x === v ? w.left > 0 ? h : d : l.x === h ? d : h), T === y && l.precedance === a && w.top && l.x !== v ? l.precedance = l.precedance === a ? u : a : T !== y && w.top && (l.y = l.y === v ? w.top > 0 ? c : p : l.y === c ? p : c), l.string() !== S.corner.string() && (S.top !== w.top || S.left !== w.left) && m.update(l, s)), C = m.position(l, w), C[l.x] += P(l, l.x), C[l.y] += P(l, l.y), C.right !== n && (C.left = -C.right), C.bottom !== n && (C.top = -C.bottom), C.user = Math.max(0, g.offset);
                if (N.left = x === y && !!w.left)l.x === v ? k["margin-left"] = N.x = C["margin-left"] - w.left : (L = C.right !== n ? [w.left, -C.left] : [-w.left, C.left], (N.x = Math.max(L[0], L[1])) > L[0] && (o.left -= w.left, N.left = s), k[C.right !== n ? d : h] = N.x);
                if (N.top = T === y && !!w.top)l.y === v ? k["margin-top"] = N.y = C["margin-top"] - w.top : (L = C.bottom !== n ? [w.top, -C.top] : [-w.top, C.top], (N.y = Math.max(L[0], L[1])) > L[0] && (o.top -= w.top, N.top = s), k[C.bottom !== n ? p : c] = N.y);
                b.tip.css(k).toggle(!(N.x && N.y || l.x === v && N.y || l.y === v && N.x)), o.left -= C.left.charAt ? C.user : x !== y || N.top || !N.left && !N.top ? C.left : 0, o.top -= C.top.charAt ? C.user : T !== y || N.left || !N.left && !N.top ? C.top : 0, S.left = w.left, S.top = w.top, S.corner = l.clone()
            }

            function D() {
                var t = g.corner, n = e.options.position, r = n.at, o = n.my.string ? n.my.string() : n.my;
                return t === s || o === s && r === s ? s : (t === i ? m.corner = new w.Corner(o) : t.string || (m.corner = new w.Corner(t), m.corner.fixed = i), S.corner = new w.Corner(m.corner.string()), m.corner.string() !== "centercenter")
            }

            function P(e, t, n) {
                t = t ? t : e[e.precedance];
                var r = b.titlebar && e.y === c, i = r ? b.titlebar : E, s = "border-" + t + "-width", o = function (e) {
                    return parseInt(e.css(s), 10)
                }, u;
                return A(function () {
                    u = (n ? o(n) : o(b.content) || o(i) || o(E)) || 0
                }), u
            }

            function H(e) {
                var t = b.titlebar && e.y === c, n = t ? b.titlebar : b.content, i = r.browser.mozilla, s = i ? "-moz-" : r.browser.webkit ? "-webkit-" : "", o = "border-radius-" + e.y + e.x, u = "border-" + e.y + "-" + e.x + "-radius", a = function (e) {
                    return parseInt(n.css(e), 10) || parseInt(E.css(e), 10)
                }, f;
                return A(function () {
                    f = a(u) || a(s + u) || a(s + o) || a(o) || 0
                }), f
            }

            function B(e) {
                function N(e, t, n) {
                    var r = e.css(t) || p;
                    return n && r === e.css(n) ? s : f.test(r) ? s : r
                }

                var t, n, o, u = b.tip.css("cssText", ""), a = e || m.corner, f = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i, l = "border-" + a[a.precedance] + "-color", h = "background-color", p = "transparent", d = " !important", y = b.titlebar, w = y && (a.y === c || a.y === v && u.position().top + x.height / 2 + g.offset < y.outerHeight(i)), S = w ? y : b.content;
                A(function () {
                    T.fill = N(u, h) || N(S, h) || N(b.content, h) || N(E, h) || u.css(h), T.border = N(u, l, "color") || N(S, l, "color") || N(b.content, l, "color") || N(E, l, "color") || E.css(l), r("*", u).add(u).css("cssText", h + ":" + p + d + ";border:0" + d + ";")
                })
            }

            function j(e) {
                var t = e.precedance === a, n = x[t ? f : l], r = x[t ? l : f], i = e.string().indexOf(v) > -1, s = n * (i ? .5 : 1), o = Math.pow, u = Math.round, c, h, p, d = Math.sqrt(o(s, 2) + o(r, 2)), m = [N / s * d, N / r * d];
                return m[2] = Math.sqrt(o(m[0], 2) - o(N, 2)), m[3] = Math.sqrt(o(m[1], 2) - o(N, 2)), c = d + m[2] + m[3] + (i ? 0 : m[0]), h = c / d, p = [u(h * r), u(h * n)], {
                    height: p[t ? 0 : 1],
                    width: p[t ? 1 : 0]
                }
            }

            function I(e, t, n) {
                return "<qvml:" + e + ' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" ' + (t || "") + ' style="behavior: url(#default#VML); ' + (n || "") + '" />'
            }

            var m = this, g = e.options.style.tip, b = e.elements, E = b.tooltip, S = {
                top: 0,
                left: 0
            }, x = {
                width: g.width,
                height: g.height
            }, T = {}, N = g.border || 0, C = ".qtip-tip", k = !!(r("<canvas />")[0] || {}).getContext, L;
            m.corner = o, m.mimic = o, m.border = N, m.offset = g.offset, m.size = x, e.checks.tip = {
                "^position.my|style.tip.(corner|mimic|border)$": function () {
                    m.init() || m.destroy(), e.reposition()
                }, "^style.tip.(height|width)$": function () {
                    x = {width: g.width, height: g.height}, m.create(), m.update(), e.reposition()
                }, "^content.title.text|style.(classes|widget)$": function () {
                    b.tip && b.tip.length && m.update()
                }
            }, r.extend(m, {
                init: function () {
                    var e = D() && (k || r.browser.msie);
                    return e && (m.create(), m.update(), E.unbind(C).bind("tooltipmove" + C, _), k || E.bind("tooltipredraw tooltipredrawn", function (e) {
                        e.type === "tooltipredraw" ? (L = b.tip.html(), b.tip.html("")) : b.tip.html(L)
                    })), e
                }, create: function () {
                    var e = x.width, t = x.height, n;
                    b.tip && b.tip.remove(), b.tip = r("<div />", {"class": "ui-tooltip-tip"}).css({
                        width: e,
                        height: t
                    }).prependTo(E), k ? r("<canvas />").appendTo(b.tip)[0].getContext("2d").save() : (n = I("shape", 'coordorigin="0,0"', "position:absolute;"), b.tip.html(n + n), r("*", b.tip).bind("click mousedown", function (e) {
                        e.stopPropagation()
                    }))
                }, update: function (e, t) {
                    var n = b.tip, f = n.children(), l = x.width, y = x.height, C = g.mimic, L = Math.round, A, _, D, H, q;
                    e || (e = S.corner || m.corner), C === s ? C = e : (C = new w.Corner(C), C.precedance = e.precedance, C.x === "inherit" ? C.x = e.x : C.y === "inherit" ? C.y = e.y : C.x === C.y && (C[e.precedance] = e[e.precedance])), A = C.precedance, e.precedance === u ? O() : M(), b.tip.css({
                        width: l = x.width,
                        height: y = x.height
                    }), B(e), T.border !== "transparent" ? (N = P(e, o), g.border === 0 && N > 0 && (T.fill = T.border), m.border = N = g.border !== i ? g.border : N) : m.border = N = 0, D = F(C, l, y), m.size = q = j(e), n.css(q), e.precedance === a ? H = [L(C.x === h ? N : C.x === d ? q.width - l - N : (q.width - l) / 2), L(C.y === c ? q.height - y : 0)] : H = [L(C.x === h ? q.width - l : 0), L(C.y === c ? N : C.y === p ? q.height - y - N : (q.height - y) / 2)], k ? (f.attr(q), _ = f[0].getContext("2d"), _.restore(), _.save(), _.clearRect(0, 0, 3e3, 3e3), _.fillStyle = T.fill, _.strokeStyle = T.border, _.lineWidth = N * 2, _.lineJoin = "miter", _.miterLimit = 100, _.translate(H[0], H[1]), _.beginPath(), _.moveTo(D[0][0], D[0][1]), _.lineTo(D[1][0], D[1][1]), _.lineTo(D[2][0], D[2][1]), _.closePath(), N && (E.css("background-clip") === "border-box" && (_.strokeStyle = T.fill, _.stroke()), _.strokeStyle = T.border, _.stroke()), _.fill()) : (D = "m" + D[0][0] + "," + D[0][1] + " l" + D[1][0] + "," + D[1][1] + " " + D[2][0] + "," + D[2][1] + " xe", H[2] = N && /^(r|b)/i.test(e.string()) ? parseFloat(r.browser.version, 10) === 8 ? 2 : 1 : 0, f.css({
                        coordsize: l + N + " " + (y + N),
                        antialias: "" + (C.string().indexOf(v) > -1),
                        left: H[0],
                        top: H[1],
                        width: l + N,
                        height: y + N
                    }).each(function (e) {
                        var t = r(this);
                        t[t.prop ? "prop" : "attr"]({
                            coordsize: l + N + " " + (y + N),
                            path: D,
                            fillcolor: T.fill,
                            filled: !!e,
                            stroked: !e
                        }).toggle(!!N || !!e), !e && t.html() === "" && t.html(I("stroke", 'weight="' + N * 2 + 'px" color="' + T.border + '" miterlimit="1000" joinstyle="miter"'))
                    })), t !== s && m.position(e)
                }, position: function (e) {
                    var t = b.tip, n = {}, i = Math.max(0, g.offset), o, p, d;
                    return g.corner === s || !t ? s : (e = e || m.corner, o = e.precedance, p = j(e), d = [e.x, e.y], o === u && d.reverse(), r.each(d, function (t, r) {
                        var s, u, d;
                        r === v ? (s = o === a ? h : c, n[s] = "50%", n["margin-" + s] = -Math.round(p[o === a ? f : l] / 2) + i) : (s = P(e, r), u = P(e, r, b.content), d = H(e), n[r] = t ? u : i + (d > s ? d : -s))
                    }), n[e[o]] -= p[o === u ? f : l], t.css({
                        top: "",
                        bottom: "",
                        left: "",
                        right: "",
                        margin: ""
                    }).css(n), n)
                }, destroy: function () {
                    b.tip && b.tip.remove(), b.tip = !1, E.unbind(C)
                }
            }), m.init()
        }

        function q(n) {
            function y() {
                m = r(v, f).not("[disabled]").map(function () {
                    return typeof this.focus == "function" ? this : null
                })
            }

            function b(e) {
                m.length < 1 && e.length ? e.not("body").blur() : m.first().focus()
            }

            function E(e) {
                var t = r(e.target), n = t.closest(".qtip"), i;
                i = n.length < 1 ? s : parseInt(n[0].style.zIndex, 10) > parseInt(f[0].style.zIndex, 10), !i && r(e.target).closest(C)[0] !== f[0] && b(t)
            }

            var o = this, u = n.options.show.modal, a = n.elements, f = a.tooltip, l = "#qtip-overlay", c = ".qtipmodal", h = c + n.id, p = "is-modal-qtip", d = r(t.body), v = w.modal.focusable.join(","), m = {}, g;
            n.checks.modal = {
                "^show.modal.(on|blur)$": function () {
                    o.init(), a.overlay.toggle(f.is(":visible"))
                }, "^content.text$": function () {
                    y()
                }
            }, r.extend(o, {
                init: function () {
                    return u.on ? (g = o.create(), f.attr(p, i).css("z-index", w.modal.zindex + r(C + "[" + p + "]").length).unbind(c).unbind(h).bind("tooltipshow" + c + " tooltiphide" + c, function (e, t, n) {
                        var i = e.originalEvent;
                        if (e.target === f[0])if (i && e.type === "tooltiphide" && /mouse(leave|enter)/.test(i.type) && r(i.relatedTarget).closest(g[0]).length)try {
                            e.preventDefault()
                        } catch (s) {
                        } else(!i || i && !i.solo) && o[e.type.replace("tooltip", "")](e, n)
                    }).bind("tooltipfocus" + c, function (e) {
                        if (e.isDefaultPrevented() || e.target !== f[0])return;
                        var t = r(C).filter("[" + p + "]"), n = w.modal.zindex + t.length, i = parseInt(f[0].style.zIndex, 10);
                        g[0].style.zIndex = n - 2, t.each(function () {
                            this.style.zIndex > i && (this.style.zIndex -= 1)
                        }), t.end().filter("." + L).qtip("blur", e.originalEvent), f.addClass(L)[0].style.zIndex = n;
                        try {
                            e.preventDefault()
                        } catch (s) {
                        }
                    }).bind("tooltiphide" + c, function (e) {
                        e.target === f[0] && r("[" + p + "]").filter(":visible").not(f).last().qtip("focus", e)
                    }), u.escape && r(t).unbind(h).bind("keydown" + h, function (e) {
                        e.keyCode === 27 && f.hasClass(L) && n.hide(e)
                    }), u.blur && a.overlay.unbind(h).bind("click" + h, function (e) {
                        f.hasClass(L) && n.hide(e)
                    }), y(), o) : o
                }, create: function () {
                    function n() {
                        g.css({height: r(e).height(), width: r(e).width()})
                    }

                    var t = r(l);
                    return t.length ? a.overlay = t.insertAfter(r(C).last()) : (g = a.overlay = r("<div />", {
                        id: l.substr(1),
                        html: "<div></div>",
                        mousedown: function () {
                            return s
                        }
                    }).hide().insertAfter(r(C).last()), r(e).unbind(c).bind("resize" + c, n), n(), g)
                }, toggle: function (e, t, n) {
                    if (e && e.isDefaultPrevented())return o;
                    var a = u.effect, l = t ? "show" : "hide", c = g.is(":visible"), v = r("[" + p + "]").filter(":visible").not(f), m;
                    return g || (g = o.create()), g.is(":animated") && c === t || !t && v.length ? o : (t ? (g.css({
                        left: 0,
                        top: 0
                    }), g.toggleClass("blurs", u.blur), u.stealfocus !== s && (d.bind("focusin" + h, E), b(r("body :focus")))) : d.unbind("focusin" + h), g.stop(i, s), r.isFunction(a) ? a.call(g, t) : a === s ? g[l]() : g.fadeTo(parseInt(n, 10) || 90, t ? 1 : 0, function () {
                        t || r(this).hide()
                    }), t || g.queue(function (e) {
                        g.css({left: "", top: ""}), e()
                    }), o)
                }, show: function (e, t) {
                    return o.toggle(e, i, t)
                }, hide: function (e, t) {
                    return o.toggle(e, s, t)
                }, destroy: function () {
                    var e = g;
                    return e && (e = r("[" + p + "]").not(f).length < 1, e ? (a.overlay.remove(), r(t).unbind(c)) : a.overlay.unbind(c + n.id), d.undelegate("*", "focusin" + h)), f.removeAttr(p).unbind(c)
                }
            }), o.init()
        }

        function R(e) {
            var t = this, n = e.elements, i = n.tooltip, s = ".bgiframe-" + e.id;
            r.extend(t, {
                init: function () {
                    n.bgiframe = r('<iframe class="ui-tooltip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';"  style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>'), n.bgiframe.appendTo(i), i.bind("tooltipmove" + s, t.adjust)
                }, adjust: function () {
                    var t = e.get("dimensions"), r = e.plugins.tip, s = n.tip, o, u;
                    u = parseInt(i.css("border-left-width"), 10) || 0, u = {
                        left: -u,
                        top: -u
                    }, r && s && (o = r.corner.precedance === "x" ? ["width", "left"] : ["height", "top"], u[o[1]] -= s[o[0]]()), n.bgiframe.css(u).css(t)
                }, destroy: function () {
                    n.bgiframe.remove(), i.unbind(s)
                }
            }), t.init()
        }

        var i = !0, s = !1, o = null, u = "x", a = "y", f = "width", l = "height", c = "top", h = "left", p = "bottom", d = "right", v = "center", m = "flip", g = "flipinvert", y = "shift", b, w, E, S = {}, x = "ui-tooltip", T = "ui-widget", N = "ui-state-disabled", C = "div.qtip." + x, k = x + "-default", L = x + "-focus", A = x + "-hover", O = "_replacedByqTip", M = "oldtitle", _, D;
        D = r("<div/>", {id: "qtip-rcontainer"}), r(function () {
            D.appendTo(t.body)
        }), b = r.fn.qtip = function (e, t, u) {
            var a = ("" + e).toLowerCase(), f = o, l = r.makeArray(arguments).slice(1), c = l[l.length - 1], h = this[0] ? r.data(this[0], "qtip") : o;
            if (!arguments.length && h || a === "api")return h;
            if ("string" == typeof e)return this.each(function () {
                var e = r.data(this, "qtip");
                if (!e)return i;
                c && c.timeStamp && (e.cache.event = c);
                if (a !== "option" && a !== "options" || !t)e[a] && e[a].apply(e[a], l); else {
                    if (!r.isPlainObject(t) && u === n)return f = e.get(t), s;
                    e.set(t, u)
                }
            }), f !== o ? f : this;
            if ("object" == typeof e || !arguments.length)return h = P(r.extend(i, {}, e)), b.bind.call(this, h, c)
        }, b.bind = function (e, t) {
            return this.each(function (o) {
                function p(e) {
                    function t() {
                        c.render(typeof e == "object" || u.show.ready), a.show.add(a.hide).unbind(l)
                    }

                    if (c.cache.disabled)return s;
                    c.cache.event = r.extend({}, e), c.cache.target = e ? r(e.target) : [n], u.show.delay > 0 ? (clearTimeout(c.timers.show), c.timers.show = setTimeout(t, u.show.delay), f.show !== f.hide && a.hide.bind(f.hide, function () {
                        clearTimeout(c.timers.show)
                    })) : t()
                }

                var u, a, f, l, c, h;
                h = r.isArray(e.id) ? e.id[o] : e.id, h = !h || h === s || h.length < 1 || S[h] ? b.nextid++ : S[h] = h, l = ".qtip-" + h + "-create", c = B.call(this, h, e);
                if (c === s)return i;
                u = c.options, r.each(w, function () {
                    this.initialize === "initialize" && this(c)
                }), a = {
                    show: u.show.target,
                    hide: u.hide.target
                }, f = {
                    show: r.trim("" + u.show.event).replace(/ /g, l + " ") + l,
                    hide: r.trim("" + u.hide.event).replace(/ /g, l + " ") + l
                }, /mouse(over|enter)/i.test(f.show) && !/mouse(out|leave)/i.test(f.hide) && (f.hide += " mouseleave" + l), a.show.bind("mousemove" + l, function (e) {
                    E = {pageX: e.pageX, pageY: e.pageY, type: "mousemove"}, c.cache.onTarget = i
                }), a.show.bind(f.show, p), (u.show.ready || u.prerender) && p(t)
            })
        }, w = b.plugins = {
            Corner: function (e) {
                e = ("" + e).replace(/([A-Z])/, " $1").replace(/middle/gi, v).toLowerCase(), this.x = (e.match(/left|right/i) || e.match(/center/) || ["inherit"])[0].toLowerCase(), this.y = (e.match(/top|bottom|center/i) || ["inherit"])[0].toLowerCase();
                var t = e.charAt(0);
                this.precedance = t === "t" || t === "b" ? a : u, this.string = function () {
                    return this.precedance === a ? this.y + this.x : this.x + this.y
                }, this.abbrev = function () {
                    var e = this.x.substr(0, 1), t = this.y.substr(0, 1);
                    return e === t ? e : this.precedance === a ? t + e : e + t
                }, this.invertx = function (e) {
                    this.x = this.x === h ? d : this.x === d ? h : e || this.x
                }, this.inverty = function (e) {
                    this.y = this.y === c ? p : this.y === p ? c : e || this.y
                }, this.clone = function () {
                    return {
                        x: this.x,
                        y: this.y,
                        precedance: this.precedance,
                        string: this.string,
                        abbrev: this.abbrev,
                        clone: this.clone,
                        invertx: this.invertx,
                        inverty: this.inverty
                    }
                }
            },
            offset: function (e, t) {
                function f(e, t) {
                    n.left += t * e.scrollLeft(), n.top += t * e.scrollTop()
                }

                var n = e.offset(), i = e.closest("body")[0], s = t, o, u, a;
                if (s) {
                    do s.css("position") !== "static" && (u = s.position(), n.left -= u.left + (parseInt(s.css("borderLeftWidth"), 10) || 0) + (parseInt(s.css("marginLeft"), 10) || 0), n.top -= u.top + (parseInt(s.css("borderTopWidth"), 10) || 0) + (parseInt(s.css("marginTop"), 10) || 0), !o && (a = s.css("overflow")) !== "hidden" && a !== "visible" && (o = s)); while ((s = r(s[0].offsetParent)).length);
                    o && o[0] !== i && f(o, 1)
                }
                return n
            },
            iOS: parseFloat(("" + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) || s,
            fn: {
                attr: function (e, t) {
                    if (this.length) {
                        var n = this[0], i = "title", s = r.data(n, "qtip");
                        if (e === i && s && "object" == typeof s && s.options.suppress)return arguments.length < 2 ? r.attr(n, M) : (s && s.options.content.attr === i && s.cache.attr && s.set("content.text", t), this.attr(M, t))
                    }
                    return r.fn["attr" + O].apply(this, arguments)
                }, clone: function (e) {
                    var t = r([]), n = "title", i = r.fn["clone" + O].apply(this, arguments);
                    return e || i.filter("[" + M + "]").attr("title", function () {
                        return r.attr(this, M)
                    }).removeAttr(M), i
                }
            }
        }, r.each(w.fn, function (e, t) {
            if (!t || r.fn[e + O])return i;
            var n = r.fn[e + O] = r.fn[e];
            r.fn[e] = function () {
                return t.apply(this, arguments) || n.apply(this, arguments)
            }
        }), r.ui || (r["cleanData" + O] = r.cleanData, r.cleanData = function (e) {
            for (var t = 0, i; (i = e[t]) !== n; t++)try {
                r(i).triggerHandler("removeqtip")
            } catch (s) {
            }
            r["cleanData" + O](e)
        }), b.version = "@VERSION", b.nextid = 0, b.inactiveEvents = "click dblclick mousedown mouseup mousemove mouseleave mouseenter".split(" "), b.zindex = 15e3, b.defaults = {
            prerender: s,
            id: s,
            overwrite: i,
            suppress: i,
            content: {text: i, attr: "title", title: {text: s, button: s}},
            position: {
                my: "top left",
                at: "bottom right",
                target: s,
                container: s,
                viewport: s,
                adjust: {x: 0, y: 0, mouse: i, resize: i, method: "flip flip"},
                effect: function (e, t, n) {
                    r(this).animate(t, {duration: 200, queue: s})
                }
            },
            show: {target: s, event: "mouseenter", effect: i, delay: 90, solo: s, ready: s, autofocus: s},
            hide: {
                target: s,
                event: "mouseleave",
                effect: i,
                delay: 0,
                fixed: s,
                inactive: s,
                leave: "window",
                distance: s
            },
            style: {classes: "", widget: s, width: s, height: s, def: i},
            events: {render: o, move: o, show: o, hide: o, toggle: o, visible: o, hidden: o, focus: o, blur: o}
        }, w.svg = function (e, n, i, s) {
            var o = r(t), u = n[0], a = {width: 0, height: 0, position: {top: 1e10, left: 1e10}}, f, l, c, h, p;
            while (!u.getBBox)u = u.parentNode;
            if (u.getBBox && u.parentNode) {
                f = u.getBBox(), l = u.getScreenCTM(), c = u.farthestViewportElement || u;
                if (!c.createSVGPoint)return a;
                h = c.createSVGPoint(), h.x = f.x, h.y = f.y, p = h.matrixTransform(l), a.position.left = p.x, a.position.top = p.y, h.x += f.width, h.y += f.height, p = h.matrixTransform(l), a.width = p.x - a.position.left, a.height = p.y - a.position.top, a.position.left += o.scrollLeft(), a.position.top += o.scrollTop()
            }
            return a
        }, w.ajax = function (e) {
            var t = e.plugins.ajax;
            return "object" == typeof t ? t : e.plugins.ajax = new j(e)
        }, w.ajax.initialize = "render", w.ajax.sanitize = function (e) {
            var t = e.content, n;
            t && "ajax"in t && (n = t.ajax, typeof n != "object" && (n = e.content.ajax = {url: n}), "boolean" != typeof n.once && n.once && (n.once = !!n.once))
        }, r.extend(i, b.defaults, {content: {ajax: {loading: i, once: i}}}), w.tip = function (e) {
            var t = e.plugins.tip;
            return "object" == typeof t ? t : e.plugins.tip = new I(e)
        }, w.tip.initialize = "render", w.tip.sanitize = function (e) {
            var t = e.style, n;
            t && "tip"in t && (n = e.style.tip, typeof n != "object" && (e.style.tip = {corner: n}), /string|boolean/i.test(typeof n.corner) || (n.corner = i), typeof n.width != "number" && delete n.width, typeof n.height != "number" && delete n.height, typeof n.border != "number" && n.border !== i && delete n.border, typeof n.offset != "number" && delete n.offset)
        }, r.extend(i, b.defaults, {
            style: {
                tip: {
                    corner: i,
                    mimic: s,
                    width: 6,
                    height: 6,
                    border: i,
                    offset: 0
                }
            }
        }), w.modal = function (e) {
            var t = e.plugins.modal;
            return "object" == typeof t ? t : e.plugins.modal = new q(e)
        }, w.modal.initialize = "render", w.modal.sanitize = function (e) {
            e.show && (typeof e.show.modal != "object" ? e.show.modal = {on: !!e.show.modal} : typeof e.show.modal.on == "undefined" && (e.show.modal.on = i))
        }, w.modal.zindex = b.zindex - 200, w.modal.focusable = ["a[href]", "area[href]", "input", "select", "textarea", "button", "iframe", "object", "embed", "[tabindex]", "[contenteditable]"], r.extend(i, b.defaults, {
            show: {
                modal: {
                    on: s,
                    effect: i,
                    blur: i,
                    stealfocus: i,
                    escape: i
                }
            }
        }), w.viewport = function (n, r, i, s, o, m, b) {
            function j(e, t, n, i, s, o, u, a, f) {
                var l = r[s], c = S[e], h = T[e], p = n === y, d = -O.offset[s] + A.offset[s] + A["scroll" + s], m = c === s ? f : c === o ? -f : -f / 2, b = h === s ? a : h === o ? -a : -a / 2, w = _ && _.size ? _.size[u] || 0 : 0, E = _ && _.corner && _.corner.precedance === e && !p ? w : 0, x = d - l + E, N = l + f - A[u] - d + E, C = m - (S.precedance === e || c === S[t] ? b : 0) - (h === v ? a / 2 : 0);
                return p ? (E = _ && _.corner && _.corner.precedance === t ? w : 0, C = (c === s ? 1 : -1) * m - E, r[s] += x > 0 ? x : N > 0 ? -N : 0, r[s] = Math.max(-O.offset[s] + A.offset[s] + (E && _.corner[e] === v ? _.offset : 0), l - C, Math.min(Math.max(-O.offset[s] + A.offset[s] + A[u], l + C), r[s]))) : (i *= n === g ? 2 : 0, x > 0 && (c !== s || N > 0) ? (r[s] -= C + i, H["invert" + e](s)) : N > 0 && (c !== o || x > 0) && (r[s] -= (c === v ? -C : C) + i, H["invert" + e](o)), r[s] < d && -r[s] > N && (r[s] = l, H = S.clone())), r[s] - l
            }

            var w = i.target, E = n.elements.tooltip, S = i.my, T = i.at, N = i.adjust, C = N.method.split(" "), k = C[0], L = C[1] || C[0], A = i.viewport, O = i.container, M = n.cache, _ = n.plugins.tip, D = {
                left: 0,
                top: 0
            }, P, H, B;
            if (!A.jquery || w[0] === e || w[0] === t.body || N.method === "none")return D;
            P = E.css("position") === "fixed", A = {
                elem: A,
                height: A[(A[0] === e ? "h" : "outerH") + "eight"](),
                width: A[(A[0] === e ? "w" : "outerW") + "idth"](),
                scrollleft: P ? 0 : A.scrollLeft(),
                scrolltop: P ? 0 : A.scrollTop(),
                offset: A.offset() || {left: 0, top: 0}
            }, O = {
                elem: O,
                scrollLeft: O.scrollLeft(),
                scrollTop: O.scrollTop(),
                offset: O.offset() || {left: 0, top: 0}
            };
            if (k !== "shift" || L !== "shift")H = S.clone();
            return D = {
                left: k !== "none" ? j(u, a, k, N.x, h, d, f, s, m) : 0,
                top: L !== "none" ? j(a, u, L, N.y, c, p, l, o, b) : 0
            }, H && M.lastClass !== (B = x + "-pos-" + H.abbrev()) && E.removeClass(n.cache.lastClass).addClass(n.cache.lastClass = B), D
        }, w.imagemap = function (e, t, n, i) {
            function E(e, t, n) {
                var r = 0, i = 1, s = 1, o = 0, u = 0, a = e.width, f = e.height;
                while (a > 0 && f > 0 && i > 0 && s > 0) {
                    a = Math.floor(a / 2), f = Math.floor(f / 2), n.x === h ? i = a : n.x === d ? i = e.width - a : i += Math.floor(a / 2), n.y === c ? s = f : n.y === p ? s = e.height - f : s += Math.floor(f / 2), r = t.length;
                    while (r--) {
                        if (t.length < 2)break;
                        o = t[r][0] - e.position.left, u = t[r][1] - e.position.top, (n.x === h && o >= i || n.x === d && o <= i || n.x === v && (o < i || o > e.width - i) || n.y === c && u >= s || n.y === p && u <= s || n.y === v && (u < s || u > e.height - s)) && t.splice(r, 1)
                    }
                }
                return {left: t[0][0], top: t[0][1]}
            }

            t.jquery || (t = r(t));
            var s = e.cache.areas = {}, o = (t[0].shape || t.attr("shape")).toLowerCase(), u = t[0].coords || t.attr("coords"), a = u.split(","), f = [], l = r('img[usemap="#' + t.parent("map").attr("name") + '"]'), m = l.offset(), g = {
                width: 0,
                height: 0,
                position: {top: 1e10, right: 0, bottom: 0, left: 1e10}
            }, y = 0, b = 0, w;
            m.left += Math.ceil((l.outerWidth() - l.width()) / 2), m.top += Math.ceil((l.outerHeight() - l.height()) / 2);
            if (o === "poly") {
                y = a.length;
                while (y--)b = [parseInt(a[--y], 10), parseInt(a[y + 1], 10)], b[0] > g.position.right && (g.position.right = b[0]), b[0] < g.position.left && (g.position.left = b[0]), b[1] > g.position.bottom && (g.position.bottom = b[1]), b[1] < g.position.top && (g.position.top = b[1]), f.push(b)
            } else {
                y = -1;
                while (y++ < a.length)f.push(parseInt(a[y], 10))
            }
            switch (o) {
                case"rect":
                    g = {
                        width: Math.abs(f[2] - f[0]),
                        height: Math.abs(f[3] - f[1]),
                        position: {left: Math.min(f[0], f[2]), top: Math.min(f[1], f[3])}
                    };
                    break;
                case"circle":
                    g = {width: f[2] + 2, height: f[2] + 2, position: {left: f[0], top: f[1]}};
                    break;
                case"poly":
                    g.width = Math.abs(g.position.right - g.position.left), g.height = Math.abs(g.position.bottom - g.position.top), n.abbrev() === "c" ? g.position = {
                        left: g.position.left + g.width / 2,
                        top: g.position.top + g.height / 2
                    } : (s[n + u] || (g.position = E(g, f.slice(), n), i && (i[0] === "flip" || i[1] === "flip") && (g.offset = E(g, f.slice(), {
                        x: n.x === h ? d : n.x === d ? h : v,
                        y: n.y === c ? p : n.y === p ? c : v
                    }), g.offset.left -= g.position.left, g.offset.top -= g.position.top), s[n + u] = g), g = s[n + u]), g.width = g.height = 0
            }
            return g.position.left += m.left, g.position.top += m.top, g
        }, w.bgiframe = function (e) {
            var t = r.browser, n = e.plugins.bgiframe;
            return r("select, object").length < 1 || !t.msie || ("" + t.version).charAt(0) !== "6" ? s : "object" == typeof n ? n : e.plugins.bgiframe = new R(e)
        }, w.bgiframe.initialize = "render"
    })
})(window, document);
(function (b) {
    b.gritter = {};
    b.gritter.options = {position: "", class_name: "", fade_in_speed: "medium", fade_out_speed: 1000, time: 6000};
    b.gritter.add = function (f) {
        try {
            return a.add(f || {})
        } catch (d) {
            var c = "Gritter Error: " + d;
            (typeof(console) != "undefined" && console.error) ? console.error(c, f) : alert(c)
        }
    };
    b.gritter.remove = function (d, c) {
        a.removeSpecific(d, c || {})
    };
    b.gritter.removeAll = function (c) {
        a.stop(c || {})
    };
    var a = {
        position: "",
        fade_in_speed: "",
        fade_out_speed: "",
        time: "",
        _custom_timer: 0,
        _item_count: 0,
        _is_setup: 0,
        _tpl_close: '<div class="gritter-close"></div>',
        _tpl_title: '<span class="gritter-title">[[title]]</span>',
        _tpl_item: '<div id="gritter-item-[[number]]" class="gritter-item-wrapper [[item_class]]" style="display:none"><div class="gritter-top"></div><div class="gritter-item">[[close]][[image]]<div class="[[class_name]]">[[title]]<p>[[text]]</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div>',
        _tpl_wrap: '<div id="gritter-notice-wrapper"></div>',
        add: function (g) {
            if (typeof(g) == "string") {
                g = {text: g}
            }
            if (!g.text) {
                throw'You must supply "text" parameter.'
            }
            if (!this._is_setup) {
                this._runSetup()
            }
            var k = g.title, n = g.text, e = g.image || "", l = g.sticky || false, m = g.class_name || b.gritter.options.class_name, j = b.gritter.options.position, d = g.time || "";
            this._verifyWrapper();
            this._item_count++;
            var f = this._item_count, i = this._tpl_item;
            b(["before_open", "after_open", "before_close", "after_close"]).each(function (p, q) {
                a["_" + q + "_" + f] = (b.isFunction(g[q])) ? g[q] : function () {
                }
            });
            this._custom_timer = 0;
            if (d) {
                this._custom_timer = d
            }
            var c = (e != "") ? '<img src="' + e + '" class="gritter-image" />' : "", h = (e != "") ? "gritter-with-image" : "gritter-without-image";
            if (k) {
                k = this._str_replace("[[title]]", k, this._tpl_title)
            } else {
                k = ""
            }
            i = this._str_replace(["[[title]]", "[[text]]", "[[close]]", "[[image]]", "[[number]]", "[[class_name]]", "[[item_class]]"], [k, n, this._tpl_close, c, this._item_count, h, m], i);
            if (this["_before_open_" + f]() === false) {
                return false
            }
            b("#gritter-notice-wrapper").addClass(j).append(i);
            var o = b("#gritter-item-" + this._item_count);
            o.fadeIn(this.fade_in_speed, function () {
                a["_after_open_" + f](b(this))
            });
            if (!l) {
                this._setFadeTimer(o, f)
            }
            b(o).bind("mouseenter mouseleave", function (p) {
                if (p.type == "mouseenter") {
                    if (!l) {
                        a._restoreItemIfFading(b(this), f)
                    }
                } else {
                    if (!l) {
                        a._setFadeTimer(b(this), f)
                    }
                }
                a._hoverState(b(this), p.type)
            });
            b(o).find(".gritter-close").click(function () {
                a.removeSpecific(f, {}, null, true)
            });
            return f
        },
        _countRemoveWrapper: function (c, d, f) {
            d.remove();
            this["_after_close_" + c](d, f);
            if (b(".gritter-item-wrapper").length == 0) {
                b("#gritter-notice-wrapper").remove()
            }
        },
        _fade: function (g, d, j, f) {
            var j = j || {}, i = (typeof(j.fade) != "undefined") ? j.fade : true, c = j.speed || this.fade_out_speed, h = f;
            this["_before_close_" + d](g, h);
            if (f) {
                g.unbind("mouseenter mouseleave")
            }
            if (i) {
                g.animate({opacity: 0}, c, function () {
                    g.animate({height: 0}, 300, function () {
                        a._countRemoveWrapper(d, g, h)
                    })
                })
            } else {
                this._countRemoveWrapper(d, g)
            }
        },
        _hoverState: function (d, c) {
            if (c == "mouseenter") {
                d.addClass("hover");
                d.find(".gritter-close").show()
            } else {
                d.removeClass("hover");
                d.find(".gritter-close").hide()
            }
        },
        removeSpecific: function (c, g, f, d) {
            if (!f) {
                var f = b("#gritter-item-" + c)
            }
            this._fade(f, c, g || {}, d)
        },
        _restoreItemIfFading: function (d, c) {
            clearTimeout(this["_int_id_" + c]);
            d.stop().css({opacity: "", height: ""})
        },
        _runSetup: function () {
            for (opt in b.gritter.options) {
                this[opt] = b.gritter.options[opt]
            }
            this._is_setup = 1
        },
        _setFadeTimer: function (f, d) {
            var c = (this._custom_timer) ? this._custom_timer : this.time;
            this["_int_id_" + d] = setTimeout(function () {
                a._fade(f, d)
            }, c)
        },
        stop: function (e) {
            var c = (b.isFunction(e.before_close)) ? e.before_close : function () {
            };
            var f = (b.isFunction(e.after_close)) ? e.after_close : function () {
            };
            var d = b("#gritter-notice-wrapper");
            c(d);
            d.fadeOut(function () {
                b(this).remove();
                f()
            })
        },
        _str_replace: function (v, e, o, n) {
            var k = 0, h = 0, t = "", m = "", g = 0, q = 0, l = [].concat(v), c = [].concat(e), u = o, d = c instanceof Array, p = u instanceof Array;
            u = [].concat(u);
            if (n) {
                this.window[n] = 0
            }
            for (k = 0, g = u.length; k < g; k++) {
                if (u[k] === "") {
                    continue
                }
                for (h = 0, q = l.length; h < q; h++) {
                    t = u[k] + "";
                    m = d ? (c[h] !== undefined ? c[h] : "") : c[0];
                    u[k] = (t).split(l[h]).join(m);
                    if (n && u[k] !== t) {
                        this.window[n] += (t.length - u[k].length) / l[h].length
                    }
                }
            }
            return p ? u : u[0]
        },
        _verifyWrapper: function () {
            if (b("#gritter-notice-wrapper").length == 0) {
                b("body").append(this._tpl_wrap)
            }
        }
    }
})(jQuery);
/**
 * notyfy - Yet another jQuery Notification Plugin v
 *
 * Based on the original notyfy plugin: https://needim.github.com/notyfy/
 *
 * Examples and Documentation - http://craga89.github.com/notyfy/
 *
 * Licensed under the MIT licenses:
 * http://www.opensource.org/licenses/mit-license.php
 *
 **/
(function ($) {

    function NotyfyObject(options) {
        var self = this;

        $.extend(self, {
            container: $('#notyfy_container_' + options.layout),
            closed: false,
            shown: false,

            _triggerEvent: function (type, args) {
                var callback = $.Event('notyfy' + type);
                self.wrapper.trigger(callback, [self].concat(args || []));
                return !callback.isDefaultPrevented();
            },

            _generateID: function () {
                var id;
                do {
                    id = 'notyfy_' + (new Date().getTime() * Math.floor(Math.random() * 1000000));
                }
                while (document.getElementById(id));
                return id;
            },

            init: function () {
                var adjuster;

                // Mix in the passed in options with the default options
                self.options = $.extend({}, $.notyfy.defaults, {id: self._generateID()}, options);

                // Generate notyfy container ifneeded
                if (!self.container.length) {
                    // Use custom container ifprovided
                    if (options.custom) {
                        self.container = options.custom.addClass('notyfy_container_inline');
                    }

                    // Otherwise create one using jQuery
                    else {
                        self.container = $('<ul />', {
                            'id': 'notyfy_container_' + self.options.layout,
                            'class': 'notyfy_container'
                        })
                            .appendTo(self.options.custom || document.body);
                    }

                    // Apply any layout adjuters on window resize
                    if ((adjuster = $.notyfy.layouts[self.options.layout])) {
                        $(window).bind('resize.' + self.options.id, function (event) {
                            adjuster.call(self.container);
                        })
                            .triggerHandler('resize.' + self.options.id);
                    }

                    // Add new class
                    self.container.addClass('i-am-new');
                }

                // Not needed? Remove new class
                else {
                    self.container.removeClass('i-am-new');
                }

                // Build the notyfy dom initial structure
                self._build();

                return self;
            },

            _build: function () {
                // Generate notyfy bar
                var bar = $('<div />', {
                    'id': self.options.id,
                    'class': "notyfy_bar"
                })
                    .append(self.options.template)
                    .find('.notyfy_text')
                    .html(self.options.text).end();

                // Generate notyfy container
                self.wrapper = $('<li />', {
                    'class': ['notyfy_wrapper', 'notyfy_' + self.options.type].join(' ')
                }).hide().append(bar);

                // Apply theme class
                if (self.options.theme) {
                    self.wrapper.addClass('notyfytheme_' + self.options.theme);
                }

                // Set buttons ifavailable
                if (self.options.buttons) {
                    self.options.closeWith = [];
                    self.options.timeout = false;

                    self.buttons = $('<div/>', {
                        'class': 'notyfy_buttons'
                    })
                        .appendTo($('.notyfy_bar', self.wrapper))
                        .append(
                        $.map(self.options.buttons, function (button, i) {
                            return $('<button/>', {
                                'class': button.addClass || 'gray',
                                'html': button.text,
                                'click': function () {
                                    if ($.isFunction(button.onClick)) {
                                        button.onClick.call($(this), self);
                                    }
                                }
                            })[0]
                        })
                    );
                }

                // Attach events
                $.each(self.options.events, function (event, callback) {
                    if ($.isFunction(callback)) {
                        self.wrapper.bind('notyfy' + event, callback);
                    }
                })

                // For easy access
                self.message = self.wrapper.find('.notyfy_message');
                self.closeButton = self.wrapper.find('.notyfy_close');

                // store notyfy for api
                $.notyfy.store[self.options.id] = self;
            },

            show: function (event) {
                // Append the container
                self.wrapper.appendTo(self.container);

                // Add close handlers to notyfy/buttons
                if ($.inArray('click', self.options.closeWith) > -1) {
                    self.wrapper.css('cursor', 'pointer').one('click', self.close);
                }
                if ($.inArray('hover', self.options.closeWith) > -1) {
                    self.wrapper.one('mouseenter', self.close);
                }
                if ($.inArray('button', self.options.closeWith) > -1) {
                    self.closeButton.one('click', self.close);
                }
                if ($.inArray('button', self.options.closeWith) == -1) {
                    self.closeButton.remove();
                }

                // Trigger show event
                self._triggerEvent('show');

                // After-animation methods
                function after() {
                    self._triggerEvent('shown');
                    self.shown = true;
                }

                // If an animation method was passed, use it and queue after()
                if ($.isFunction(self.options.showEffect)) {
                    self.wrapper.clearQueue().stop();
                    self.options.showEffect.call(self, self.wrapper);
                    self.wrapper.queue(after);
                }

                // Otherwise just invoke show() and after()
                else {
                    self.wrapper.show();
                    after();
                }

                // If notyfy is have a timeout option
                if (self.options.timeout) {
                    clearTimeout(self._delay);
                    self._delay = setTimeout(function () {
                        self.close();
                    }, parseInt(self.options.timeout, 10));
                }

                return self;

            },

            close: function (event) {
                if (self.closed) return;

                // If we are still waiting in the queue just delete from queue
                if (!self.shown) {
                    $.notyfy.queue = $.map($.notyfy.queue, function (n, i) {
                        if (n.options.id != self.options.id) {
                            return n;
                        }
                    });
                    return;
                }

                // Add closing class
                self.wrapper.addClass('i-am-closing-now');

                // Trigger hide event
                self._triggerEvent('hide');

                function after() {
                    // Trigger hidden event
                    self._triggerEvent('hidden');

                    // Modal Cleaning
                    if (self.options.modal) {
                        renderer.hideModalFor(self);
                    }

                    // Layout Cleaning
                    renderer.setLayoutCountFor(self, -1);
                    if (renderer.getLayoutCountFor(self) == 0) {
                        self.wrapper.remove();
                    }

                    // Make sure self.wrapper has not been removed before attempting to remove it
                    if (typeof self.wrapper !== 'undefined' && self.wrapper !== null) {
                        self.wrapper.remove();
                        self.wrapper = null;
                        self.closed = true;
                    }

                    // Delete notyfy reference from store
                    delete $.notyfy.store[self.options.id];

                    // Queue render
                    if (!self.options.dismissQueue) {
                        $.notyfy.ontap = true;
                        renderer.render();
                    }
                }

                // If an animation method was passed, use it and queue after()
                if ($.isFunction(self.options.hideEffect)) {
                    self.wrapper.clearQueue().stop();
                    self.options.hideEffect.call(self, self.wrapper);
                    self.wrapper.queue(after);
                }

                // Otherwise just invoke show() and after()
                else {
                    self.wrapper.hide();
                    after();
                }

            },

            setText: function (text) {
                if (!self.closed) {
                    self.options.text = text;
                    self.wrapper.find('.notyfy_text').html(text);
                }
                return self;
            },

            setType: function (type) {
                if (!self.closed) {
                    self.options.type = type;
                }
                return self;
            }
        });

        self.init();
    };

    var renderer = $.notyfyRenderer = {
        _modal: $('<div/>', {
            'id': 'notyfy_modal',
            'data': {'notyfy_modal_count': 0}
        }),
        _modals: 0,

        init: function (options) {
            // Create new Noty
            var notyfy = new NotyfyObject(options);

            // Add it to the frontback of the queue depending on options
            $.notyfy.queue[notyfy.options.force ? 'unshift' : 'push'](notyfy);

            // Render the notyfy
            renderer.render();

            return notyfy;
        },

        render: function () {
            var instance = $.notyfy.queue[0];

            if ($.type(instance) === 'object') {
                if (instance.options.dismissQueue) {
                    renderer.show($.notyfy.queue.shift());
                } else {
                    if ($.notyfy.ontap) {
                        renderer.show($.notyfy.queue.shift());
                        $.notyfy.ontap = false;
                    }
                }
            }

            // Queue is over
            else {
                $.notyfy.ontap = true;
            }
        },

        show: function (notyfy) {
            if (notyfy.options.modal) {
                renderer.createModalFor(notyfy);
                renderer.setModalCount(+1);
            }

            renderer.setLayoutCountFor(notyfy, +1);

            notyfy.show();
        },

        createModalFor: function (notyfy) {
            if (!renderer._modal[0].parentNode) {
                renderer._modal.prependTo(document.body).fadeIn('fast');
            }
        },

        hideModalFor: function (notyfy) {
            renderer.setModalCount(-1);

            if (renderer.getModalCount() == 0) {
                renderer._modal.fadeOut('fast', function () {
                    renderer._modal.detach();
                });
            }
        },

        getLayoutCountFor: function (notyfy) {
            return notyfy.container.data('notyfy_layout_count') || 0;
        },

        setLayoutCountFor: function (notyfy, arg) {
            return notyfy.container.data('notyfy_layout_count', renderer.getLayoutCountFor(notyfy) + arg);
        },

        getModalCount: function () {
            return renderer._modals;
        },
        setModalCount: function (arg) {
            return (renderer._modals += arg);
        }
    };

    var win = $(window);

    $.notyfy = {
        ontap: true,
        queue: [],
        store: {},
        layouts: {
            center: function () {
                this[0].style.top = (win.height() / 2 - this.outerHeight() / 2) + 'px';
                this[0].style.left = (win.width() / 2 - this.outerWidth() / 2) + 'px';
            },
            centerLeft: function () {
                this[0].style.top = (win.height() / 2 - this.outerHeight() / 2) + 'px';
            },
            centerRight: function () {
                this[0].style.top = (win.height() / 2 - this.outerHeight() / 2) + 'px';
            },
            topCenter: function () {
                this[0].style.left = (win.width() / 2 - this.outerWidth() / 2) + 'px';
            },
            bottomCenter: function () {
                this[0].style.left = (win.width() / 2 - this.outerWidth() / 2) + 'px';
            }
        },

        get: function (id) {
            return $.notyfy.store.hasOwnProperty(id) ? $.notyfy.store[id] : false;
        },

        close: function (id) {
            return $.notyfy.get(id) ? $.notyfy.get(id).close() : false;
        },

        setText: function (id, text) {
            return $.notyfy.get(id) ? $.notyfy.get(id).setText(text) : false;
        },

        setType: function (id, type) {
            return $.notyfy.get(id) ? $.notyfy.get(id).setType(type) : false;
        },

        clearQueue: function () {
            $.notyfy.queue = [];
        },

        closeAll: function () {
            $.notyfy.clearQueue();
            $.each($.notyfy.store, function (id, notyfy) {
                notyfy.close();
            });
        },

        consumeAlert: function (options) {
            window.alert = function (text) {
                if (options) {
                    options.text = text;
                }
                else {
                    options = {text: text};
                }
                renderer.init(options);
            };
        },

        stopConsumeAlert: function () {
            delete window.alert;
        },

        defaults: {
            layout: 'top',
            theme: false,
            type: 'alert',
            text: '',
            dismissQueue: true,
            template: '<div class="notyfy_message"><span class="notyfy_text"></span><div class="notyfy_close"></div></div>',
            showEffect: function (bar) {
                bar.animate({height: 'toggle'}, 500, 'swing');
            },
            hideEffect: function (bar) {
                bar.animate({height: 'toggle'}, 500, 'swing');
            },
            timeout: false,
            force: false,
            modal: false,
            buttons: false,
            closeWith: ['click'],
            events: {
                show: null,
                hide: null,
                shown: null,
                hidden: null
            }
        }
    };

    // Helper method
    window.notyfy = function (options) {
        return renderer.init(options);
    }

    // This is for custom container
    $.fn.notyfy = function (options) {
        options.custom = $(this);
        return renderer.init(options);
    };

})(jQuery);

/**
 * jQuery jPages v0.7
 * Client side pagination with jQuery
 * http://luis-almeida.github.com/jPages
 *
 * Licensed under the MIT license.
 * Copyright 2012 Luís Almeida
 * https://github.com/luis-almeida
 */

(function ($, window, document, undefined) {

    var name = "jPages",
        instance = null,
        defaults = {
            containerID: "",
            first: false,
            previous: "previous",
            next: "next",
            last: false,
            links: "numeric", // blank || title
            startPage: 1,
            perPage: 10,
            midRange: 5,
            startRange: 1,
            endRange: 1,
            keyBrowse: false,
            scrollBrowse: false,
            pause: 0,
            clickStop: false,
            delay: 50,
            direction: "forward", // backwards || auto || random ||
            animation: "", // http://daneden.me/animate/ - any entrance animations
            fallback: 400,
            minHeight: true,
            callback: undefined // function( pages, items ) { }
        };


    function Plugin(element, options) {
        this.options = $.extend({}, defaults, options);

        this._container = $("#" + this.options.containerID);
        if (!this._container.length) return;

        this.jQwindow = $(window);
        this.jQdocument = $(document);

        this._holder = $(element);
        this._nav = {};

        this._first = $(this.options.first);
        this._previous = $(this.options.previous);
        this._next = $(this.options.next);
        this._last = $(this.options.last);

        /* only visible items! */
        this._items = this._container.children(":visible");
        this._itemsShowing = $([]);
        this._itemsHiding = $([]);

        this._numPages = Math.ceil(this._items.length / this.options.perPage);
        this._currentPageNum = this.options.startPage;

        this._clicked = false;
        this._cssAnimSupport = this.getCSSAnimationSupport();

        this.init();
    }

    Plugin.prototype = {

        constructor: Plugin,

        getCSSAnimationSupport: function () {
            var animation = false,
                animationstring = 'animation',
                keyframeprefix = '',
                domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
                pfx = '',
                elm = this._container.get(0);

            if (elm.style.animationName) animation = true;

            if (animation === false) {
                for (var i = 0; i < domPrefixes.length; i++) {
                    if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                        pfx = domPrefixes[i];
                        animationstring = pfx + 'Animation';
                        keyframeprefix = '-' + pfx.toLowerCase() + '-';
                        animation = true;
                        break;
                    }
                }
            }

            return animation;
        },

        init: function () {
            this.setStyles();
            this.setNav();
            this.paginate(this._currentPageNum);
            this.setMinHeight();
        },

        setStyles: function () {
            var requiredStyles = "<style>" +
                ".jp-invisible { visibility: hidden !important; } " +
                ".jp-hidden { display: none !important; }" +
                "</style>";

            $(requiredStyles).appendTo("head");

            if (this._cssAnimSupport && this.options.animation.length)
                this._items.addClass("animated jp-hidden");
            else this._items.hide();

        },

        setNav: function () {
            var navhtml = this.writeNav();

            this._holder.each(this.bind(function (index, element) {
                var holder = $(element);
                holder.html(navhtml);
                this.cacheNavElements(holder, index);
                this.bindNavHandlers(index);
                this.disableNavSelection(element);
            }, this));

            if (this.options.keyBrowse) this.bindNavKeyBrowse();
            if (this.options.scrollBrowse) this.bindNavScrollBrowse();
        },

        writeNav: function () {
            var i = 1, navhtml;
            navhtml = this.writeBtn("first") + this.writeBtn("previous");

            for (; i <= this._numPages; i++) {
                if (i === 1 && this.options.startRange === 0) navhtml += "<li><span>...</span></li>";
                if (i > this.options.startRange && i <= this._numPages - this.options.endRange)
                    navhtml += "<li><a href='#' class='jp-hidden'>";
                else
                    navhtml += "<li><a>";

                switch (this.options.links) {
                    case "numeric":
                        navhtml += i;
                        break;
                    case "blank":
                        break;
                    case "title":
                        var title = this._items.eq(i - 1).attr("data-title");
                        navhtml += title !== undefined ? title : "";
                        break;
                }

                navhtml += "</a></li>";
                if (i === this.options.startRange || i === this._numPages - this.options.endRange)
                    navhtml += "<li><span>...</span></li>";
            }
            navhtml += this.writeBtn("next") + this.writeBtn("last") + "</div>";
            return navhtml;
        },

        writeBtn: function (which) {

            return this.options[which] !== false && !$(this["_" + which]).length ?
            "<li><a class='jp-" + which + "'>" + this.options[which] + "</a></li>" : "";

        },

        cacheNavElements: function (holder, index) {
            this._nav[index] = {};
            this._nav[index].holder = holder;
            this._nav[index].first = this._first.length ? this._first : this._nav[index].holder.find("a.jp-first");
            this._nav[index].previous = this._previous.length ? this._previous : this._nav[index].holder.find("a.jp-previous");
            this._nav[index].next = this._next.length ? this._next : this._nav[index].holder.find("a.jp-next");
            this._nav[index].last = this._last.length ? this._last : this._nav[index].holder.find("a.jp-last");
            this._nav[index].fstBreak = this._nav[index].holder.find("span:first");
            this._nav[index].lstBreak = this._nav[index].holder.find("span:last");
            this._nav[index].pages = this._nav[index].holder.find("a").not(".jp-first, .jp-previous, .jp-next, .jp-last");
            this._nav[index].permPages =
                this._nav[index].pages.slice(0, this.options.startRange)
                    .add(this._nav[index].pages.slice(this._numPages - this.options.endRange, this._numPages));
            this._nav[index].pagesShowing = $([]);
            this._nav[index].currentPage = $([]);
        },

        bindNavHandlers: function (index) {
            var nav = this._nav[index];

            // default nav
            nav.holder.bind("click.jPages", this.bind(function (evt) {
                var newPage = this.getNewPage(nav, $(evt.target));
                if (this.validNewPage(newPage)) {
                    this._clicked = true;
                    this.paginate(newPage);
                }
                evt.preventDefault();
            }, this));

            // custom first
            if (this._first.length) {
                this._first.bind("click.jPages", this.bind(function () {
                    if (this.validNewPage(1)) {
                        this._clicked = true;
                        this.paginate(1);
                    }
                }, this));
            }

            // custom previous
            if (this._previous.length) {
                this._previous.bind("click.jPages", this.bind(function () {
                    var newPage = this._currentPageNum - 1;
                    if (this.validNewPage(newPage)) {
                        this._clicked = true;
                        this.paginate(newPage);
                    }
                }, this));
            }

            // custom next
            if (this._next.length) {
                this._next.bind("click.jPages", this.bind(function () {
                    var newPage = this._currentPageNum + 1;
                    if (this.validNewPage(newPage)) {
                        this._clicked = true;
                        this.paginate(newPage);
                    }
                }, this));
            }

            // custom last
            if (this._last.length) {
                this._last.bind("click.jPages", this.bind(function () {
                    if (this.validNewPage(this._numPages)) {
                        this._clicked = true;
                        this.paginate(this._numPages);
                    }
                }, this));
            }

        },

        disableNavSelection: function (element) {
            if (typeof element.onselectstart != "undefined")
                element.onselectstart = function () {
                    return false;
                };
            else if (typeof element.style.MozUserSelect != "undefined")
                element.style.MozUserSelect = "none";
            else
                element.onmousedown = function () {
                    return false;
                };
        },

        bindNavKeyBrowse: function () {
            this.jQdocument.bind("keydown.jPages", this.bind(function (evt) {
                var target = evt.target.nodeName.toLowerCase();
                if (this.elemScrolledIntoView() && target !== "input" && target != "textarea") {
                    var newPage = this._currentPageNum;

                    if (evt.which == 37) newPage = this._currentPageNum - 1;
                    if (evt.which == 39) newPage = this._currentPageNum + 1;

                    if (this.validNewPage(newPage)) {
                        this._clicked = true;
                        this.paginate(newPage);
                    }
                }
            }, this));
        },

        elemScrolledIntoView: function () {
            var docViewTop, docViewBottom, elemTop, elemBottom;
            docViewTop = this.jQwindow.scrollTop();
            docViewBottom = docViewTop + this.jQwindow.height();
            elemTop = this._container.offset().top;
            elemBottom = elemTop + this._container.height();
            return ((elemBottom >= docViewTop) && (elemTop <= docViewBottom));

            // comment above and uncomment below if you want keyBrowse to happen
            // only when container is completely visible in the page
            /*return ((elemBottom >= docViewTop) && (elemTop <= docViewBottom) &&
             (elemBottom <= docViewBottom) &&  (elemTop >= docViewTop) );*/
        },

        bindNavScrollBrowse: function () {
            this._container.bind("mousewheel.jPages DOMMouseScroll.jPages", this.bind(function (evt) {
                var newPage = (evt.originalEvent.wheelDelta || -evt.originalEvent.detail) > 0 ?
                    (this._currentPageNum - 1) : (this._currentPageNum + 1);
                if (this.validNewPage(newPage)) {
                    this._clicked = true;
                    this.paginate(newPage);
                }
                evt.preventDefault();
                return false;
            }, this));
        },

        getNewPage: function (nav, target) {
            if (target.is(nav.currentPage)) return this._currentPageNum;
            if (target.is(nav.pages)) return nav.pages.index(target) + 1;
            if (target.is(nav.first)) return 1;
            if (target.is(nav.last)) return this._numPages;
            if (target.is(nav.previous)) return nav.pages.index(nav.currentPage);
            if (target.is(nav.next)) return nav.pages.index(nav.currentPage) + 2;
        },

        validNewPage: function (newPage) {
            return newPage !== this._currentPageNum && newPage > 0 && newPage <= this._numPages;
        },

        paginate: function (page) {
            var itemRange, pageInterval;
            itemRange = this.updateItems(page);
            pageInterval = this.updatePages(page);
            this._currentPageNum = page;
            if ($.isFunction(this.options.callback))
                this.callback(page, itemRange, pageInterval);

            this.updatePause();
        },

        updateItems: function (page) {
            var range = this.getItemRange(page);
            this._itemsHiding = this._itemsShowing;
            this._itemsShowing = this._items.slice(range.start, range.end);
            if (this._cssAnimSupport && this.options.animation.length) this.cssAnimations(page);
            else this.jQAnimations(page);
            return range;
        },

        getItemRange: function (page) {
            var range = {};
            range.start = (page - 1) * this.options.perPage;
            range.end = range.start + this.options.perPage;
            if (range.end > this._items.length) range.end = this._items.length;
            return range;
        },

        cssAnimations: function (page) {
            clearInterval(this._delay);

            this._itemsHiding
                .removeClass(this.options.animation + " jp-invisible")
                .addClass("jp-hidden");

            this._itemsShowing
                .removeClass("jp-hidden")
                .addClass("jp-invisible");

            this._itemsOriented = this.getDirectedItems(page);
            this._index = 0;

            this._delay = setInterval(this.bind(function () {
                if (this._index === this._itemsOriented.length) clearInterval(this._delay);
                else {
                    this._itemsOriented
                        .eq(this._index)
                        .removeClass("jp-invisible")
                        .addClass(this.options.animation);
                }
                this._index = this._index + 1;
            }, this), this.options.delay);
        },

        jQAnimations: function (page) {
            clearInterval(this._delay);
            this._itemsHiding.addClass("jp-hidden");
            this._itemsShowing.fadeTo(0, 0).removeClass("jp-hidden");
            this._itemsOriented = this.getDirectedItems(page);
            this._index = 0;
            this._delay = setInterval(this.bind(function () {
                if (this._index === this._itemsOriented.length) clearInterval(this._delay);
                else {
                    this._itemsOriented
                        .eq(this._index)
                        .fadeTo(this.options.fallback, 1);
                }
                this._index = this._index + 1;
            }, this), this.options.delay);
        },

        getDirectedItems: function (page) {
            var itemsToShow;

            switch (this.options.direction) {
                case "backwards":
                    itemsToShow = $(this._itemsShowing.get().reverse());
                    break;
                case "random":
                    itemsToShow = $(this._itemsShowing.get().sort(function () {
                        return (Math.round(Math.random()) - 0.5);
                    }));
                    break;
                case "auto":
                    itemsToShow = page >= this._currentPageNum ?
                        this._itemsShowing : $(this._itemsShowing.get().reverse());
                    break;
                default:
                    itemsToShow = this._itemsShowing;
            }

            return itemsToShow;
        },

        updatePages: function (page) {
            var interval, index, nav;
            interval = this.getInterval(page);
            for (index in this._nav) {
                if (this._nav.hasOwnProperty(index)) {
                    nav = this._nav[index];
                    this.updateBtns(nav, page);
                    this.updateCurrentPage(nav, page);
                    this.updatePagesShowing(nav, interval);
                    this.updateBreaks(nav, interval);
                }
            }
            return interval;
        },

        getInterval: function (page) {
            var neHalf, upperLimit, start, end;
            neHalf = Math.ceil(this.options.midRange / 2);
            upperLimit = this._numPages - this.options.midRange;
            start = page > neHalf ? Math.max(Math.min(page - neHalf, upperLimit), 0) : 0;
            end = page > neHalf ?
                Math.min(page + neHalf - (this.options.midRange % 2 > 0 ? 1 : 0), this._numPages) :
                Math.min(this.options.midRange, this._numPages);
            return {start: start, end: end};
        },

        updateBtns: function (nav, page) {
            if (page === 1) {
                nav.first.addClass("jp-disabled");
                nav.previous.addClass("jp-disabled");
            }
            if (page === this._numPages) {
                nav.next.addClass("jp-disabled");
                nav.last.addClass("jp-disabled");
            }
            if (this._currentPageNum === 1 && page > 1) {
                nav.first.removeClass("jp-disabled");
                nav.previous.removeClass("jp-disabled");
            }
            if (this._currentPageNum === this._numPages && page < this._numPages) {
                nav.next.removeClass("jp-disabled");
                nav.last.removeClass("jp-disabled");
            }
        },

        updateCurrentPage: function (nav, page) {
            nav.currentPage.removeClass("jp-current");
            nav.currentPage = nav.pages.eq(page - 1).addClass("jp-current");
        },

        updatePagesShowing: function (nav, interval) {
            var newRange = nav.pages.slice(interval.start, interval.end).not(nav.permPages);
            nav.pagesShowing.not(newRange).addClass("jp-hidden");
            newRange.not(nav.pagesShowing).removeClass("jp-hidden");
            nav.pagesShowing = newRange;
        },

        updateBreaks: function (nav, interval) {
            if (
                interval.start > this.options.startRange ||
                (this.options.startRange === 0 && interval.start > 0)
            ) nav.fstBreak.removeClass("jp-hidden");
            else nav.fstBreak.addClass("jp-hidden");

            if (interval.end < this._numPages - this.options.endRange) nav.lstBreak.removeClass("jp-hidden");
            else nav.lstBreak.addClass("jp-hidden");
        },

        callback: function (page, itemRange, pageInterval) {
            var pages = {
                    current: page,
                    interval: pageInterval,
                    count: this._numPages
                },
                items = {
                    showing: this._itemsShowing,
                    oncoming: this._items.slice(itemRange.start + this.options.perPage, itemRange.end + this.options.perPage),
                    range: itemRange,
                    count: this._items.length
                };

            pages.interval.start = pages.interval.start + 1;
            items.range.start = items.range.start + 1;
            this.options.callback(pages, items);
        },

        updatePause: function () {
            if (this.options.pause && this._numPages > 1) {
                clearTimeout(this._pause);
                if (this.options.clickStop && this._clicked) return;
                else {
                    this._pause = setTimeout(this.bind(function () {
                        this.paginate(this._currentPageNum !== this._numPages ? this._currentPageNum + 1 : 1);
                    }, this), this.options.pause);
                }
            }
        },

        setMinHeight: function () {
            if (this.options.minHeight && !this._container.is("table, tbody")) {
                setTimeout(this.bind(function () {
                    this._container.css({"min-height": this._container.css("height")});
                }, this), 1000);
            }
        },

        bind: function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        },

        destroy: function () {
            this.jQdocument.unbind("keydown.jPages");
            this._container.unbind("mousewheel.jPages DOMMouseScroll.jPages");

            if (this.options.minHeight) this._container.css("min-height", "");
            if (this._cssAnimSupport && this.options.animation.length)
                this._items.removeClass("animated jp-hidden jp-invisible " + this.options.animation);
            else this._items.removeClass("jp-hidden").fadeTo(0, 1);
            this._holder.unbind("click.jPages").empty();
        }

    };

    $.fn[name] = function (arg) {
        var type = $.type(arg);

        if (type === "object") {
            if (this.length && !$.data(this, name)) {
                instance = new Plugin(this, arg);
                this.each(function () {
                    $.data(this, name, instance);
                });
            }
            return this;
        }

        if (type === "string" && arg === "destroy") {
            instance.destroy();
            this.each(function () {
                $.removeData(this, name);
            });
            return this;
        }

        if (type === 'number' && arg % 1 === 0) {
            if (instance.validNewPage(arg)) instance.paginate(arg);
            return this;
        }

        return this;
    };

})(jQuery, window, document);
/*

 FullCalendar v1.5.4
 http://arshaw.com/fullcalendar/

 Use fullcalendar.css for basic styling.
 For event drag & drop, requires jQuery UI draggable.
 For event resizing, requires jQuery UI resizable.

 Copyright (c) 2011 Adam Shaw
 Dual licensed under the MIT and GPL licenses, located in
 MIT-LICENSE.txt and GPL-LICENSE.txt respectively.

 Date: Tue Sep 4 23:38:33 2012 -0700

 */
(function (m, ma) {
    function wb(a) {
        m.extend(true, Ya, a)
    }

    function Yb(a, b, e) {
        function d(k) {
            if (E) {
                u();
                q();
                na();
                S(k)
            } else f()
        }

        function f() {
            B = b.theme ? "ui" : "fc";
            a.addClass("fc");
            b.isRTL && a.addClass("fc-rtl");
            b.theme && a.addClass("ui-widget");
            E = m("<div class='fc-content' style='position:relative'/>").prependTo(a);
            C = new Zb(X, b);
            (P = C.render()) && a.prepend(P);
            y(b.defaultView);
            m(window).resize(oa);
            t() || g()
        }

        function g() {
            setTimeout(function () {
                !n.start && t() && S()
            }, 0)
        }

        function l() {
            m(window).unbind("resize", oa);
            C.destroy();
            E.remove();
            a.removeClass("fc fc-rtl ui-widget")
        }

        function j() {
            return i.offsetWidth !== 0
        }

        function t() {
            return m("body")[0].offsetWidth !== 0
        }

        function y(k) {
            if (!n || k != n.name) {
                F++;
                pa();
                var D = n, Z;
                if (D) {
                    (D.beforeHide || xb)();
                    Za(E, E.height());
                    D.element.hide()
                } else Za(E, 1);
                E.css("overflow", "hidden");
                if (n = Y[k])n.element.show(); else n = Y[k] = new Ja[k](Z = s = m("<div class='fc-view fc-view-" + k + "' style='position:absolute'/>").appendTo(E), X);
                D && C.deactivateButton(D.name);
                C.activateButton(k);
                S();
                E.css("overflow", "");
                D &&
                Za(E, 1);
                Z || (n.afterShow || xb)();
                F--
            }
        }

        function S(k) {
            if (j()) {
                F++;
                pa();
                o === ma && u();
                var D = false;
                if (!n.start || k || r < n.start || r >= n.end) {
                    n.render(r, k || 0);
                    fa(true);
                    D = true
                } else if (n.sizeDirty) {
                    n.clearEvents();
                    fa();
                    D = true
                } else if (n.eventsDirty) {
                    n.clearEvents();
                    D = true
                }
                n.sizeDirty = false;
                n.eventsDirty = false;
                ga(D);
                W = a.outerWidth();
                C.updateTitle(n.title);
                k = new Date;
                k >= n.start && k < n.end ? C.disableButton("today") : C.enableButton("today");
                F--;
                n.trigger("viewDisplay", i)
            }
        }

        function Q() {
            q();
            if (j()) {
                u();
                fa();
                pa();
                n.clearEvents();
                n.renderEvents(J);
                n.sizeDirty = false
            }
        }

        function q() {
            m.each(Y, function (k, D) {
                D.sizeDirty = true
            })
        }

        function u() {
            o = b.contentHeight ? b.contentHeight : b.height ? b.height - (P ? P.height() : 0) - Sa(E) : Math.round(E.width() / Math.max(b.aspectRatio, 0.5))
        }

        function fa(k) {
            F++;
            n.setHeight(o, k);
            if (s) {
                s.css("position", "relative");
                s = null
            }
            n.setWidth(E.width(), k);
            F--
        }

        function oa() {
            if (!F)if (n.start) {
                var k = ++v;
                setTimeout(function () {
                    if (k == v && !F && j())if (W != (W = a.outerWidth())) {
                        F++;
                        Q();
                        n.trigger("windowResize", i);
                        F--
                    }
                }, 200)
            } else g()
        }

        function ga(k) {
            if (!b.lazyFetching ||
                ya(n.visStart, n.visEnd))ra(); else k && da()
        }

        function ra() {
            K(n.visStart, n.visEnd)
        }

        function sa(k) {
            J = k;
            da()
        }

        function ha(k) {
            da(k)
        }

        function da(k) {
            na();
            if (j()) {
                n.clearEvents();
                n.renderEvents(J, k);
                n.eventsDirty = false
            }
        }

        function na() {
            m.each(Y, function (k, D) {
                D.eventsDirty = true
            })
        }

        function ua(k, D, Z) {
            n.select(k, D, Z === ma ? true : Z)
        }

        function pa() {
            n && n.unselect()
        }

        function U() {
            S(-1)
        }

        function ca() {
            S(1)
        }

        function ka() {
            gb(r, -1);
            S()
        }

        function qa() {
            gb(r, 1);
            S()
        }

        function G() {
            r = new Date;
            S()
        }

        function p(k, D, Z) {
            if (k instanceof Date)r =
                N(k); else yb(r, k, D, Z);
            S()
        }

        function L(k, D, Z) {
            k !== ma && gb(r, k);
            D !== ma && hb(r, D);
            Z !== ma && ba(r, Z);
            S()
        }

        function c() {
            return N(r)
        }

        function z() {
            return n
        }

        function H(k, D) {
            if (D === ma)return b[k];
            if (k == "height" || k == "contentHeight" || k == "aspectRatio") {
                b[k] = D;
                Q()
            }
        }

        function T(k, D) {
            if (b[k])return b[k].apply(D || i, Array.prototype.slice.call(arguments, 2))
        }

        var X = this;
        X.options = b;
        X.render = d;
        X.destroy = l;
        X.refetchEvents = ra;
        X.reportEvents = sa;
        X.reportEventChange = ha;
        X.rerenderEvents = da;
        X.changeView = y;
        X.select = ua;
        X.unselect = pa;
        X.prev = U;
        X.next = ca;
        X.prevYear = ka;
        X.nextYear = qa;
        X.today = G;
        X.gotoDate = p;
        X.incrementDate = L;
        X.formatDate = function (k, D) {
            return Oa(k, D, b)
        };
        X.formatDates = function (k, D, Z) {
            return ib(k, D, Z, b)
        };
        X.getDate = c;
        X.getView = z;
        X.option = H;
        X.trigger = T;
        $b.call(X, b, e);
        var ya = X.isFetchNeeded, K = X.fetchEvents, i = a[0], C, P, E, B, n, Y = {}, W, o, s, v = 0, F = 0, r = new Date, J = [], M;
        yb(r, b.year, b.month, b.date);
        b.droppable && m(document).bind("dragstart", function (k, D) {
            var Z = k.target, ja = m(Z);
            if (!ja.parents(".fc").length) {
                var ia = b.dropAccept;
                if (m.isFunction(ia) ?
                        ia.call(Z, ja) : ja.is(ia)) {
                    M = Z;
                    n.dragStart(M, k, D)
                }
            }
        }).bind("dragstop", function (k, D) {
            if (M) {
                n.dragStop(M, k, D);
                M = null
            }
        })
    }

    function Zb(a, b) {
        function e() {
            q = b.theme ? "ui" : "fc";
            if (b.header)return Q = m("<table class='fc-header' style='width:100%'/>").append(m("<tr/>").append(f("left")).append(f("center")).append(f("right")))
        }

        function d() {
            Q.remove()
        }

        function f(u) {
            var fa = m("<td class='fc-header-" + u + "'/>");
            (u = b.header[u]) && m.each(u.split(" "), function (oa) {
                oa > 0 && fa.append("<span class='fc-header-space'/>");
                var ga;
                m.each(this.split(","), function (ra, sa) {
                    if (sa == "title") {
                        fa.append("<span class='fc-header-title'><h2>&nbsp;</h2></span>");
                        ga && ga.addClass(q + "-corner-right");
                        ga = null
                    } else {
                        var ha;
                        if (a[sa])ha = a[sa]; else if (Ja[sa])ha = function () {
                            na.removeClass(q + "-state-hover");
                            a.changeView(sa)
                        };
                        if (ha) {
                            ra = b.theme ? jb(b.buttonIcons, sa) : null;
                            var da = jb(b.buttonText, sa), na = m("<span class='fc-button fc-button-" + sa + " " + q + "-state-default'><span class='fc-button-inner'><span class='fc-button-content'>" + (ra ? "<span class='fc-icon-wrap'><span class='ui-icon ui-icon-" +
                                ra + "'/></span>" : da) + "</span><span class='fc-button-effect'><span></span></span></span></span>");
                            if (na) {
                                na.click(function () {
                                    na.hasClass(q + "-state-disabled") || ha()
                                }).mousedown(function () {
                                    na.not("." + q + "-state-active").not("." + q + "-state-disabled").addClass(q + "-state-down")
                                }).mouseup(function () {
                                    na.removeClass(q + "-state-down")
                                }).hover(function () {
                                    na.not("." + q + "-state-active").not("." + q + "-state-disabled").addClass(q + "-state-hover")
                                }, function () {
                                    na.removeClass(q + "-state-hover").removeClass(q + "-state-down")
                                }).appendTo(fa);
                                ga || na.addClass(q + "-corner-left");
                                ga = na
                            }
                        }
                    }
                });
                ga && ga.addClass(q + "-corner-right")
            });
            return fa
        }

        function g(u) {
            Q.find("h2").html(u)
        }

        function l(u) {
            Q.find("span.fc-button-" + u).addClass(q + "-state-active")
        }

        function j(u) {
            Q.find("span.fc-button-" + u).removeClass(q + "-state-active")
        }

        function t(u) {
            Q.find("span.fc-button-" + u).addClass(q + "-state-disabled")
        }

        function y(u) {
            Q.find("span.fc-button-" + u).removeClass(q + "-state-disabled")
        }

        var S = this;
        S.render = e;
        S.destroy = d;
        S.updateTitle = g;
        S.activateButton = l;
        S.deactivateButton =
            j;
        S.disableButton = t;
        S.enableButton = y;
        var Q = m([]), q
    }

    function $b(a, b) {
        function e(c, z) {
            return !ca || c < ca || z > ka
        }

        function d(c, z) {
            ca = c;
            ka = z;
            L = [];
            c = ++qa;
            G = z = U.length;
            for (var H = 0; H < z; H++)f(U[H], c)
        }

        function f(c, z) {
            g(c, function (H) {
                if (z == qa) {
                    if (H) {
                        for (var T = 0; T < H.length; T++) {
                            H[T].source = c;
                            oa(H[T])
                        }
                        L = L.concat(H)
                    }
                    G--;
                    G || ua(L)
                }
            })
        }

        function g(c, z) {
            var H, T = Aa.sourceFetchers, X;
            for (H = 0; H < T.length; H++) {
                X = T[H](c, ca, ka, z);
                if (X === true)return; else if (typeof X == "object") {
                    g(X, z);
                    return
                }
            }
            if (H = c.events)if (m.isFunction(H)) {
                u();
                H(N(ca), N(ka), function (C) {
                    z(C);
                    fa()
                })
            } else m.isArray(H) ? z(H) : z(); else if (c.url) {
                var ya = c.success, K = c.error, i = c.complete;
                H = m.extend({}, c.data || {});
                T = Ta(c.startParam, a.startParam);
                X = Ta(c.endParam, a.endParam);
                if (T)H[T] = Math.round(+ca / 1E3);
                if (X)H[X] = Math.round(+ka / 1E3);
                u();
                m.ajax(m.extend({}, ac, c, {
                    data: H, success: function (C) {
                        C = C || [];
                        var P = $a(ya, this, arguments);
                        if (m.isArray(P))C = P;
                        z(C)
                    }, error: function () {
                        $a(K, this, arguments);
                        z()
                    }, complete: function () {
                        $a(i, this, arguments);
                        fa()
                    }
                }))
            } else z()
        }

        function l(c) {
            if (c =
                    j(c)) {
                G++;
                f(c, qa)
            }
        }

        function j(c) {
            if (m.isFunction(c) || m.isArray(c))c = {events: c}; else if (typeof c == "string")c = {url: c};
            if (typeof c == "object") {
                ga(c);
                U.push(c);
                return c
            }
        }

        function t(c) {
            U = m.grep(U, function (z) {
                return !ra(z, c)
            });
            L = m.grep(L, function (z) {
                return !ra(z.source, c)
            });
            ua(L)
        }

        function y(c) {
            var z, H = L.length, T, X = na().defaultEventEnd, ya = c.start - c._start, K = c.end ? c.end - (c._end || X(c)) : 0;
            for (z = 0; z < H; z++) {
                T = L[z];
                if (T._id == c._id && T != c) {
                    T.start = new Date(+T.start + ya);
                    T.end = c.end ? T.end ? new Date(+T.end + K) : new Date(+X(T) +
                        K) : null;
                    T.title = c.title;
                    T.url = c.url;
                    T.allDay = c.allDay;
                    T.className = c.className;
                    T.editable = c.editable;
                    T.color = c.color;
                    T.backgroudColor = c.backgroudColor;
                    T.borderColor = c.borderColor;
                    T.textColor = c.textColor;
                    oa(T)
                }
            }
            oa(c);
            ua(L)
        }

        function S(c, z) {
            oa(c);
            if (!c.source) {
                if (z) {
                    pa.events.push(c);
                    c.source = pa
                }
                L.push(c)
            }
            ua(L)
        }

        function Q(c) {
            if (c) {
                if (!m.isFunction(c)) {
                    var z = c + "";
                    c = function (T) {
                        return T._id == z
                    }
                }
                L = m.grep(L, c, true);
                for (H = 0; H < U.length; H++)if (m.isArray(U[H].events))U[H].events = m.grep(U[H].events, c, true)
            } else {
                L =
                    [];
                for (var H = 0; H < U.length; H++)if (m.isArray(U[H].events))U[H].events = []
            }
            ua(L)
        }

        function q(c) {
            if (m.isFunction(c))return m.grep(L, c); else if (c) {
                c += "";
                return m.grep(L, function (z) {
                    return z._id == c
                })
            }
            return L
        }

        function u() {
            p++ || da("loading", null, true)
        }

        function fa() {
            --p || da("loading", null, false)
        }

        function oa(c) {
            var z = c.source || {}, H = Ta(z.ignoreTimezone, a.ignoreTimezone);
            c._id = c._id || (c.id === ma ? "_fc" + bc++ : c.id + "");
            if (c.date) {
                if (!c.start)c.start = c.date;
                delete c.date
            }
            c._start = N(c.start = kb(c.start, H));
            c.end = kb(c.end,
                H);
            if (c.end && c.end <= c.start)c.end = null;
            c._end = c.end ? N(c.end) : null;
            if (c.allDay === ma)c.allDay = Ta(z.allDayDefault, a.allDayDefault);
            if (c.className) {
                if (typeof c.className == "string")c.className = c.className.split(/\s+/)
            } else c.className = []
        }

        function ga(c) {
            if (c.className) {
                if (typeof c.className == "string")c.className = c.className.split(/\s+/)
            } else c.className = [];
            for (var z = Aa.sourceNormalizers, H = 0; H < z.length; H++)z[H](c)
        }

        function ra(c, z) {
            return c && z && sa(c) == sa(z)
        }

        function sa(c) {
            return (typeof c == "object" ? c.events ||
                c.url : "") || c
        }

        var ha = this;
        ha.isFetchNeeded = e;
        ha.fetchEvents = d;
        ha.addEventSource = l;
        ha.removeEventSource = t;
        ha.updateEvent = y;
        ha.renderEvent = S;
        ha.removeEvents = Q;
        ha.clientEvents = q;
        ha.normalizeEvent = oa;
        var da = ha.trigger, na = ha.getView, ua = ha.reportEvents, pa = {events: []}, U = [pa], ca, ka, qa = 0, G = 0, p = 0, L = [];
        for (ha = 0; ha < b.length; ha++)j(b[ha])
    }

    function gb(a, b, e) {
        a.setFullYear(a.getFullYear() + b);
        e || Ka(a);
        return a
    }

    function hb(a, b, e) {
        if (+a) {
            b = a.getMonth() + b;
            var d = N(a);
            d.setDate(1);
            d.setMonth(b);
            a.setMonth(b);
            for (e || Ka(a); a.getMonth() !=
            d.getMonth();)a.setDate(a.getDate() + (a < d ? 1 : -1))
        }
        return a
    }

    function ba(a, b, e) {
        if (+a) {
            b = a.getDate() + b;
            var d = N(a);
            d.setHours(9);
            d.setDate(b);
            a.setDate(b);
            e || Ka(a);
            lb(a, d)
        }
        return a
    }

    function lb(a, b) {
        if (+a)for (; a.getDate() != b.getDate();)a.setTime(+a + (a < b ? 1 : -1) * cc)
    }

    function xa(a, b) {
        a.setMinutes(a.getMinutes() + b);
        return a
    }

    function Ka(a) {
        a.setHours(0);
        a.setMinutes(0);
        a.setSeconds(0);
        a.setMilliseconds(0);
        return a
    }

    function N(a, b) {
        if (b)return Ka(new Date(+a));
        return new Date(+a)
    }

    function zb() {
        var a = 0, b;
        do b = new Date(1970,
            a++, 1); while (b.getHours());
        return b
    }

    function Fa(a, b, e) {
        for (b = b || 1; !a.getDay() || e && a.getDay() == 1 || !e && a.getDay() == 6;)ba(a, b);
        return a
    }

    function Ca(a, b) {
        return Math.round((N(a, true) - N(b, true)) / Ab)
    }

    function yb(a, b, e, d) {
        if (b !== ma && b != a.getFullYear()) {
            a.setDate(1);
            a.setMonth(0);
            a.setFullYear(b)
        }
        if (e !== ma && e != a.getMonth()) {
            a.setDate(1);
            a.setMonth(e)
        }
        d !== ma && a.setDate(d)
    }

    function kb(a, b) {
        if (typeof a == "object")return a;
        if (typeof a == "number")return new Date(a * 1E3);
        if (typeof a == "string") {
            if (a.match(/^\d+(\.\d+)?$/))return new Date(parseFloat(a) *
                1E3);
            if (b === ma)b = true;
            return Bb(a, b) || (a ? new Date(a) : null)
        }
        return null
    }

    function Bb(a, b) {
        a = a.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
        if (!a)return null;
        var e = new Date(a[1], 0, 1);
        if (b || !a[13]) {
            b = new Date(a[1], 0, 1, 9, 0);
            if (a[3]) {
                e.setMonth(a[3] - 1);
                b.setMonth(a[3] - 1)
            }
            if (a[5]) {
                e.setDate(a[5]);
                b.setDate(a[5])
            }
            lb(e, b);
            a[7] && e.setHours(a[7]);
            a[8] && e.setMinutes(a[8]);
            a[10] && e.setSeconds(a[10]);
            a[12] && e.setMilliseconds(Number("0." +
                    a[12]) * 1E3);
            lb(e, b)
        } else {
            e.setUTCFullYear(a[1], a[3] ? a[3] - 1 : 0, a[5] || 1);
            e.setUTCHours(a[7] || 0, a[8] || 0, a[10] || 0, a[12] ? Number("0." + a[12]) * 1E3 : 0);
            if (a[14]) {
                b = Number(a[16]) * 60 + (a[18] ? Number(a[18]) : 0);
                b *= a[15] == "-" ? 1 : -1;
                e = new Date(+e + b * 60 * 1E3)
            }
        }
        return e
    }

    function mb(a) {
        if (typeof a == "number")return a * 60;
        if (typeof a == "object")return a.getHours() * 60 + a.getMinutes();
        if (a = a.match(/(\d+)(?::(\d+))?\s*(\w+)?/)) {
            var b = parseInt(a[1], 10);
            if (a[3]) {
                b %= 12;
                if (a[3].toLowerCase().charAt(0) == "p")b += 12
            }
            return b * 60 + (a[2] ? parseInt(a[2],
                    10) : 0)
        }
    }

    function Oa(a, b, e) {
        return ib(a, null, b, e)
    }

    function ib(a, b, e, d) {
        d = d || Ya;
        var f = a, g = b, l, j = e.length, t, y, S, Q = "";
        for (l = 0; l < j; l++) {
            t = e.charAt(l);
            if (t == "'")for (y = l + 1; y < j; y++) {
                if (e.charAt(y) == "'") {
                    if (f) {
                        Q += y == l + 1 ? "'" : e.substring(l + 1, y);
                        l = y
                    }
                    break
                }
            } else if (t == "(")for (y = l + 1; y < j; y++) {
                if (e.charAt(y) == ")") {
                    l = Oa(f, e.substring(l + 1, y), d);
                    if (parseInt(l.replace(/\D/, ""), 10))Q += l;
                    l = y;
                    break
                }
            } else if (t == "[")for (y = l + 1; y < j; y++) {
                if (e.charAt(y) == "]") {
                    t = e.substring(l + 1, y);
                    l = Oa(f, t, d);
                    if (l != Oa(g, t, d))Q += l;
                    l = y;
                    break
                }
            } else if (t ==
                "{") {
                f = b;
                g = a
            } else if (t == "}") {
                f = a;
                g = b
            } else {
                for (y = j; y > l; y--)if (S = dc[e.substring(l, y)]) {
                    if (f)Q += S(f, d);
                    l = y - 1;
                    break
                }
                if (y == l)if (f)Q += t
            }
        }
        return Q
    }

    function Ua(a) {
        return a.end ? ec(a.end, a.allDay) : ba(N(a.start), 1)
    }

    function ec(a, b) {
        a = N(a);
        return b || a.getHours() || a.getMinutes() ? ba(a, 1) : Ka(a)
    }

    function fc(a, b) {
        return (b.msLength - a.msLength) * 100 + (a.event.start - b.event.start)
    }

    function Cb(a, b) {
        return a.end > b.start && a.start < b.end
    }

    function nb(a, b, e, d) {
        var f = [], g, l = a.length, j, t, y, S, Q;
        for (g = 0; g < l; g++) {
            j = a[g];
            t = j.start;
            y = b[g];
            if (y > e && t < d) {
                if (t < e) {
                    t = N(e);
                    S = false
                } else {
                    t = t;
                    S = true
                }
                if (y > d) {
                    y = N(d);
                    Q = false
                } else {
                    y = y;
                    Q = true
                }
                f.push({event: j, start: t, end: y, isStart: S, isEnd: Q, msLength: y - t})
            }
        }
        return f.sort(fc)
    }

    function ob(a) {
        var b = [], e, d = a.length, f, g, l, j;
        for (e = 0; e < d; e++) {
            f = a[e];
            for (g = 0; ;) {
                l = false;
                if (b[g])for (j = 0; j < b[g].length; j++)if (Cb(b[g][j], f)) {
                    l = true;
                    break
                }
                if (l)g++; else break
            }
            if (b[g])b[g].push(f); else b[g] = [f]
        }
        return b
    }

    function Db(a, b, e) {
        a.unbind("mouseover").mouseover(function (d) {
            for (var f = d.target, g; f != this;) {
                g = f;
                f = f.parentNode
            }
            if ((f =
                    g._fci) !== ma) {
                g._fci = ma;
                g = b[f];
                e(g.event, g.element, g);
                m(d.target).trigger(d)
            }
            d.stopPropagation()
        })
    }

    function Va(a, b, e) {
        for (var d = 0, f; d < a.length; d++) {
            f = m(a[d]);
            f.width(Math.max(0, b - pb(f, e)))
        }
    }

    function Eb(a, b, e) {
        for (var d = 0, f; d < a.length; d++) {
            f = m(a[d]);
            f.height(Math.max(0, b - Sa(f, e)))
        }
    }

    function pb(a, b) {
        return gc(a) + hc(a) + (b ? ic(a) : 0)
    }

    function gc(a) {
        return (parseFloat(m.css(a[0], "paddingLeft", true)) || 0) + (parseFloat(m.css(a[0], "paddingRight", true)) || 0)
    }

    function ic(a) {
        return (parseFloat(m.css(a[0], "marginLeft",
                true)) || 0) + (parseFloat(m.css(a[0], "marginRight", true)) || 0)
    }

    function hc(a) {
        return (parseFloat(m.css(a[0], "borderLeftWidth", true)) || 0) + (parseFloat(m.css(a[0], "borderRightWidth", true)) || 0)
    }

    function Sa(a, b) {
        return jc(a) + kc(a) + (b ? Fb(a) : 0)
    }

    function jc(a) {
        return (parseFloat(m.css(a[0], "paddingTop", true)) || 0) + (parseFloat(m.css(a[0], "paddingBottom", true)) || 0)
    }

    function Fb(a) {
        return (parseFloat(m.css(a[0], "marginTop", true)) || 0) + (parseFloat(m.css(a[0], "marginBottom", true)) || 0)
    }

    function kc(a) {
        return (parseFloat(m.css(a[0],
                "borderTopWidth", true)) || 0) + (parseFloat(m.css(a[0], "borderBottomWidth", true)) || 0)
    }

    function Za(a, b) {
        b = typeof b == "number" ? b + "px" : b;
        a.each(function (e, d) {
            d.style.cssText += ";min-height:" + b + ";_height:" + b
        })
    }

    function xb() {
    }

    function Gb(a, b) {
        return a - b
    }

    function Hb(a) {
        return Math.max.apply(Math, a)
    }

    function Pa(a) {
        return (a < 10 ? "0" : "") + a
    }

    function jb(a, b) {
        if (a[b] !== ma)return a[b];
        b = b.split(/(?=[A-Z])/);
        for (var e = b.length - 1, d; e >= 0; e--) {
            d = a[b[e].toLowerCase()];
            if (d !== ma)return d
        }
        return a[""]
    }

    function Qa(a) {
        return a.replace(/&/g,
            "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#039;").replace(/"/g, "&quot;").replace(/\n/g, "<br />")
    }

    function Ib(a) {
        return a.id + "/" + a.className + "/" + a.style.cssText.replace(/(^|;)\s*(top|left|width|height)\s*:[^;]*/ig, "")
    }

    function qb(a) {
        a.attr("unselectable", "on").css("MozUserSelect", "none").bind("selectstart.ui", function () {
            return false
        })
    }

    function ab(a) {
        a.children().removeClass("fc-first fc-last").filter(":first-child").addClass("fc-first").end().filter(":last-child").addClass("fc-last")
    }

    function rb(a, b) {
        a.each(function (e, d) {
            d.className = d.className.replace(/^fc-\w*/, "fc-" + lc[b.getDay()])
        })
    }

    function Jb(a, b) {
        var e = a.source || {}, d = a.color, f = e.color, g = b("eventColor"), l = a.backgroundColor || d || e.backgroundColor || f || b("eventBackgroundColor") || g;
        d = a.borderColor || d || e.borderColor || f || b("eventBorderColor") || g;
        a = a.textColor || e.textColor || b("eventTextColor");
        b = [];
        l && b.push("background-color:" + l);
        d && b.push("border-color:" + d);
        a && b.push("color:" + a);
        return b.join(";")
    }

    function $a(a, b, e) {
        if (m.isFunction(a))a =
            [a];
        if (a) {
            var d, f;
            for (d = 0; d < a.length; d++)f = a[d].apply(b, e) || f;
            return f
        }
    }

    function Ta() {
        for (var a = 0; a < arguments.length; a++)if (arguments[a] !== ma)return arguments[a]
    }

    function mc(a, b) {
        function e(j, t) {
            if (t) {
                hb(j, t);
                j.setDate(1)
            }
            j = N(j, true);
            j.setDate(1);
            t = hb(N(j), 1);
            var y = N(j), S = N(t), Q = f("firstDay"), q = f("weekends") ? 0 : 1;
            if (q) {
                Fa(y);
                Fa(S, -1, true)
            }
            ba(y, -((y.getDay() - Math.max(Q, q) + 7) % 7));
            ba(S, (7 - S.getDay() + Math.max(Q, q)) % 7);
            Q = Math.round((S - y) / (Ab * 7));
            if (f("weekMode") == "fixed") {
                ba(S, (6 - Q) * 7);
                Q = 6
            }
            d.title = l(j,
                f("titleFormat"));
            d.start = j;
            d.end = t;
            d.visStart = y;
            d.visEnd = S;
            g(6, Q, q ? 5 : 7, true)
        }

        var d = this;
        d.render = e;
        sb.call(d, a, b, "month");
        var f = d.opt, g = d.renderBasic, l = b.formatDate
    }

    function nc(a, b) {
        function e(j, t) {
            t && ba(j, t * 7);
            j = ba(N(j), -((j.getDay() - f("firstDay") + 7) % 7));
            t = ba(N(j), 7);
            var y = N(j), S = N(t), Q = f("weekends");
            if (!Q) {
                Fa(y);
                Fa(S, -1, true)
            }
            d.title = l(y, ba(N(S), -1), f("titleFormat"));
            d.start = j;
            d.end = t;
            d.visStart = y;
            d.visEnd = S;
            g(1, 1, Q ? 7 : 5, false)
        }

        var d = this;
        d.render = e;
        sb.call(d, a, b, "basicWeek");
        var f = d.opt, g = d.renderBasic,
            l = b.formatDates
    }

    function oc(a, b) {
        function e(j, t) {
            if (t) {
                ba(j, t);
                f("weekends") || Fa(j, t < 0 ? -1 : 1)
            }
            d.title = l(j, f("titleFormat"));
            d.start = d.visStart = N(j, true);
            d.end = d.visEnd = ba(N(d.start), 1);
            g(1, 1, 1, false)
        }

        var d = this;
        d.render = e;
        sb.call(d, a, b, "basicDay");
        var f = d.opt, g = d.renderBasic, l = b.formatDate
    }

    function sb(a, b, e) {
        function d(w, I, R, V) {
            v = I;
            F = R;
            f();
            (I = !C) ? g(w, V) : z();
            l(I)
        }

        function f() {
            if (k = L("isRTL")) {
                D = -1;
                Z = F - 1
            } else {
                D = 1;
                Z = 0
            }
            ja = L("firstDay");
            ia = L("weekends") ? 0 : 1;
            la = L("theme") ? "ui" : "fc";
            $ = L("columnFormat")
        }

        function g(w,
                   I) {
            var R, V = la + "-widget-header", ea = la + "-widget-content", aa;
            R = "<table class='fc-border-separate' style='width:100%' cellspacing='0'><thead><tr>";
            for (aa = 0; aa < F; aa++)R += "<th class='fc- " + V + "'/>";
            R += "</tr></thead><tbody>";
            for (aa = 0; aa < w; aa++) {
                R += "<tr class='fc-week" + aa + "'>";
                for (V = 0; V < F; V++)R += "<td class='fc- " + ea + " fc-day" + (aa * F + V) + "'><div>" + (I ? "<div class='fc-day-number'/>" : "") + "<div class='fc-day-content'><div style='position:relative'>&nbsp;</div></div></div></td>";
                R += "</tr>"
            }
            R += "</tbody></table>";
            w =
                m(R).appendTo(a);
            K = w.find("thead");
            i = K.find("th");
            C = w.find("tbody");
            P = C.find("tr");
            E = C.find("td");
            B = E.filter(":first-child");
            n = P.eq(0).find("div.fc-day-content div");
            ab(K.add(K.find("tr")));
            ab(P);
            P.eq(0).addClass("fc-first");
            y(E);
            Y = m("<div style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(a)
        }

        function l(w) {
            var I = w || v == 1, R = p.start.getMonth(), V = Ka(new Date), ea, aa, va;
            I && i.each(function (wa, Ga) {
                ea = m(Ga);
                aa = ca(wa);
                ea.html(ya(aa, $));
                rb(ea, aa)
            });
            E.each(function (wa, Ga) {
                ea = m(Ga);
                aa = ca(wa);
                aa.getMonth() ==
                R ? ea.removeClass("fc-other-month") : ea.addClass("fc-other-month");
                +aa == +V ? ea.addClass(la + "-state-highlight fc-today") : ea.removeClass(la + "-state-highlight fc-today");
                ea.find("div.fc-day-number").text(aa.getDate());
                I && rb(ea, aa)
            });
            P.each(function (wa, Ga) {
                va = m(Ga);
                if (wa < v) {
                    va.show();
                    wa == v - 1 ? va.addClass("fc-last") : va.removeClass("fc-last")
                } else va.hide()
            })
        }

        function j(w) {
            o = w;
            w = o - K.height();
            var I, R, V;
            if (L("weekMode") == "variable")I = R = Math.floor(w / (v == 1 ? 2 : 6)); else {
                I = Math.floor(w / v);
                R = w - I * (v - 1)
            }
            B.each(function (ea,
                             aa) {
                if (ea < v) {
                    V = m(aa);
                    Za(V.find("> div"), (ea == v - 1 ? R : I) - Sa(V))
                }
            })
        }

        function t(w) {
            W = w;
            M.clear();
            s = Math.floor(W / F);
            Va(i.slice(0, -1), s)
        }

        function y(w) {
            w.click(S).mousedown(X)
        }

        function S(w) {
            if (!L("selectable")) {
                var I = parseInt(this.className.match(/fc\-day(\d+)/)[1]);
                I = ca(I);
                c("dayClick", this, I, true, w)
            }
        }

        function Q(w, I, R) {
            R && r.build();
            R = N(p.visStart);
            for (var V = ba(N(R), F), ea = 0; ea < v; ea++) {
                var aa = new Date(Math.max(R, w)), va = new Date(Math.min(V, I));
                if (aa < va) {
                    var wa;
                    if (k) {
                        wa = Ca(va, R) * D + Z + 1;
                        aa = Ca(aa, R) * D + Z + 1
                    } else {
                        wa =
                            Ca(aa, R);
                        aa = Ca(va, R)
                    }
                    y(q(ea, wa, ea, aa - 1))
                }
                ba(R, 7);
                ba(V, 7)
            }
        }

        function q(w, I, R, V) {
            w = r.rect(w, I, R, V, a);
            return H(w, a)
        }

        function u(w) {
            return N(w)
        }

        function fa(w, I) {
            Q(w, ba(N(I), 1), true)
        }

        function oa() {
            T()
        }

        function ga(w, I, R) {
            var V = ua(w);
            c("dayClick", E[V.row * F + V.col], w, I, R)
        }

        function ra(w, I) {
            J.start(function (R) {
                T();
                R && q(R.row, R.col, R.row, R.col)
            }, I)
        }

        function sa(w, I, R) {
            var V = J.stop();
            T();
            if (V) {
                V = pa(V);
                c("drop", w, V, true, I, R)
            }
        }

        function ha(w) {
            return N(w.start)
        }

        function da(w) {
            return M.left(w)
        }

        function na(w) {
            return M.right(w)
        }

        function ua(w) {
            return {row: Math.floor(Ca(w, p.visStart) / 7), col: ka(w.getDay())}
        }

        function pa(w) {
            return U(w.row, w.col)
        }

        function U(w, I) {
            return ba(N(p.visStart), w * 7 + I * D + Z)
        }

        function ca(w) {
            return U(Math.floor(w / F), w % F)
        }

        function ka(w) {
            return (w - Math.max(ja, ia) + F) % F * D + Z
        }

        function qa(w) {
            return P.eq(w)
        }

        function G() {
            return {left: 0, right: W}
        }

        var p = this;
        p.renderBasic = d;
        p.setHeight = j;
        p.setWidth = t;
        p.renderDayOverlay = Q;
        p.defaultSelectionEnd = u;
        p.renderSelection = fa;
        p.clearSelection = oa;
        p.reportDayClick = ga;
        p.dragStart = ra;
        p.dragStop =
            sa;
        p.defaultEventEnd = ha;
        p.getHoverListener = function () {
            return J
        };
        p.colContentLeft = da;
        p.colContentRight = na;
        p.dayOfWeekCol = ka;
        p.dateCell = ua;
        p.cellDate = pa;
        p.cellIsAllDay = function () {
            return true
        };
        p.allDayRow = qa;
        p.allDayBounds = G;
        p.getRowCnt = function () {
            return v
        };
        p.getColCnt = function () {
            return F
        };
        p.getColWidth = function () {
            return s
        };
        p.getDaySegmentContainer = function () {
            return Y
        };
        Kb.call(p, a, b, e);
        Lb.call(p);
        Mb.call(p);
        pc.call(p);
        var L = p.opt, c = p.trigger, z = p.clearEvents, H = p.renderOverlay, T = p.clearOverlays, X = p.daySelectionMousedown,
            ya = b.formatDate, K, i, C, P, E, B, n, Y, W, o, s, v, F, r, J, M, k, D, Z, ja, ia, la, $;
        qb(a.addClass("fc-grid"));
        r = new Nb(function (w, I) {
            var R, V, ea;
            i.each(function (aa, va) {
                R = m(va);
                V = R.offset().left;
                if (aa)ea[1] = V;
                ea = [V];
                I[aa] = ea
            });
            ea[1] = V + R.outerWidth();
            P.each(function (aa, va) {
                if (aa < v) {
                    R = m(va);
                    V = R.offset().top;
                    if (aa)ea[1] = V;
                    ea = [V];
                    w[aa] = ea
                }
            });
            ea[1] = V + R.outerHeight()
        });
        J = new Ob(r);
        M = new Pb(function (w) {
            return n.eq(w)
        })
    }

    function pc() {
        function a(U, ca) {
            S(U);
            ua(e(U), ca)
        }

        function b() {
            Q();
            ga().empty()
        }

        function e(U) {
            var ca = da(), ka =
                na(), qa = N(g.visStart);
            ka = ba(N(qa), ka);
            var G = m.map(U, Ua), p, L, c, z, H, T, X = [];
            for (p = 0; p < ca; p++) {
                L = ob(nb(U, G, qa, ka));
                for (c = 0; c < L.length; c++) {
                    z = L[c];
                    for (H = 0; H < z.length; H++) {
                        T = z[H];
                        T.row = p;
                        T.level = c;
                        X.push(T)
                    }
                }
                ba(qa, 7);
                ba(ka, 7)
            }
            return X
        }

        function d(U, ca, ka) {
            t(U) && f(U, ca);
            ka.isEnd && y(U) && pa(U, ca, ka);
            q(U, ca)
        }

        function f(U, ca) {
            var ka = ra(), qa;
            ca.draggable({
                zIndex: 9,
                delay: 50,
                opacity: l("dragOpacity"),
                revertDuration: l("dragRevertDuration"),
                start: function (G, p) {
                    j("eventDragStart", ca, U, G, p);
                    fa(U, ca);
                    ka.start(function (L,
                                       c, z, H) {
                        ca.draggable("option", "revert", !L || !z && !H);
                        ha();
                        if (L) {
                            qa = z * 7 + H * (l("isRTL") ? -1 : 1);
                            sa(ba(N(U.start), qa), ba(Ua(U), qa))
                        } else qa = 0
                    }, G, "drag")
                },
                stop: function (G, p) {
                    ka.stop();
                    ha();
                    j("eventDragStop", ca, U, G, p);
                    if (qa)oa(this, U, qa, 0, U.allDay, G, p); else {
                        ca.css("filter", "");
                        u(U, ca)
                    }
                }
            })
        }

        var g = this;
        g.renderEvents = a;
        g.compileDaySegs = e;
        g.clearEvents = b;
        g.bindDaySeg = d;
        Qb.call(g);
        var l = g.opt, j = g.trigger, t = g.isEventDraggable, y = g.isEventResizable, S = g.reportEvents, Q = g.reportEventClear, q = g.eventElementHandlers, u = g.showEvents,
            fa = g.hideEvents, oa = g.eventDrop, ga = g.getDaySegmentContainer, ra = g.getHoverListener, sa = g.renderDayOverlay, ha = g.clearOverlays, da = g.getRowCnt, na = g.getColCnt, ua = g.renderDaySegs, pa = g.resizableDayEvent
    }

    function qc(a, b) {
        function e(j, t) {
            t && ba(j, t * 7);
            j = ba(N(j), -((j.getDay() - f("firstDay") + 7) % 7));
            t = ba(N(j), 7);
            var y = N(j), S = N(t), Q = f("weekends");
            if (!Q) {
                Fa(y);
                Fa(S, -1, true)
            }
            d.title = l(y, ba(N(S), -1), f("titleFormat"));
            d.start = j;
            d.end = t;
            d.visStart = y;
            d.visEnd = S;
            g(Q ? 7 : 5)
        }

        var d = this;
        d.render = e;
        Rb.call(d, a, b, "agendaWeek");
        var f = d.opt, g = d.renderAgenda, l = b.formatDates
    }

    function rc(a, b) {
        function e(j, t) {
            if (t) {
                ba(j, t);
                f("weekends") || Fa(j, t < 0 ? -1 : 1)
            }
            t = N(j, true);
            var y = ba(N(t), 1);
            d.title = l(j, f("titleFormat"));
            d.start = d.visStart = t;
            d.end = d.visEnd = y;
            g(1)
        }

        var d = this;
        d.render = e;
        Rb.call(d, a, b, "agendaDay");
        var f = d.opt, g = d.renderAgenda, l = b.formatDate
    }

    function Rb(a, b, e) {
        function d(h) {
            Ba = h;
            f();
            v ? P() : g();
            l()
        }

        function f() {
            Wa = i("theme") ? "ui" : "fc";
            Sb = i("weekends") ? 0 : 1;
            Tb = i("firstDay");
            if (Ub = i("isRTL")) {
                Ha = -1;
                Ia = Ba - 1
            } else {
                Ha = 1;
                Ia = 0
            }
            La = mb(i("minTime"));
            bb = mb(i("maxTime"));
            Vb = i("columnFormat")
        }

        function g() {
            var h = Wa + "-widget-header", O = Wa + "-widget-content", x, A, ta, za, Da, Ea = i("slotMinutes") % 15 == 0;
            x = "<table style='width:100%' class='fc-agenda-days fc-border-separate' cellspacing='0'><thead><tr><th class='fc-agenda-axis " + h + "'>&nbsp;</th>";
            for (A = 0; A < Ba; A++)x += "<th class='fc- fc-col" + A + " " + h + "'/>";
            x += "<th class='fc-agenda-gutter " + h + "'>&nbsp;</th></tr></thead><tbody><tr><th class='fc-agenda-axis " + h + "'>&nbsp;</th>";
            for (A = 0; A < Ba; A++)x += "<td class='fc- fc-col" +
                A + " " + O + "'><div><div class='fc-day-content'><div style='position:relative'>&nbsp;</div></div></div></td>";
            x += "<td class='fc-agenda-gutter " + O + "'>&nbsp;</td></tr></tbody></table>";
            v = m(x).appendTo(a);
            F = v.find("thead");
            r = F.find("th").slice(1, -1);
            J = v.find("tbody");
            M = J.find("td").slice(0, -1);
            k = M.find("div.fc-day-content div");
            D = M.eq(0);
            Z = D.find("> div");
            ab(F.add(F.find("tr")));
            ab(J.add(J.find("tr")));
            aa = F.find("th:first");
            va = v.find(".fc-agenda-gutter");
            ja = m("<div style='position:absolute;z-index:2;left:0;width:100%'/>").appendTo(a);
            if (i("allDaySlot")) {
                ia = m("<div style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(ja);
                x = "<table style='width:100%' class='fc-agenda-allday' cellspacing='0'><tr><th class='" + h + " fc-agenda-axis'>" + i("allDayText") + "</th><td><div class='fc-day-content'><div style='position:relative'/></div></td><th class='" + h + " fc-agenda-gutter'>&nbsp;</th></tr></table>";
                la = m(x).appendTo(ja);
                $ = la.find("tr");
                q($.find("td"));
                aa = aa.add(la.find("th:first"));
                va = va.add(la.find("th.fc-agenda-gutter"));
                ja.append("<div class='fc-agenda-divider " +
                    h + "'><div class='fc-agenda-divider-inner'/></div>")
            } else ia = m([]);
            w = m("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:auto'/>").appendTo(ja);
            I = m("<div style='position:relative;width:100%;overflow:hidden'/>").appendTo(w);
            R = m("<div style='position:absolute;z-index:8;top:0;left:0'/>").appendTo(I);
            x = "<table class='fc-agenda-slots' style='width:100%' cellspacing='0'><tbody>";
            ta = zb();
            za = xa(N(ta), bb);
            xa(ta, La);
            for (A = tb = 0; ta < za; A++) {
                Da = ta.getMinutes();
                x += "<tr class='fc-slot" + A + " " +
                    (!Da ? "" : "fc-minor") + "'><th class='fc-agenda-axis " + h + "'>" + (!Ea || !Da ? s(ta, i("axisFormat")) : "&nbsp;") + "</th><td class='" + O + "'><div style='position:relative'>&nbsp;</div></td></tr>";
                xa(ta, i("slotMinutes"));
                tb++
            }
            x += "</tbody></table>";
            V = m(x).appendTo(I);
            ea = V.find("div:first");
            u(V.find("td"));
            aa = aa.add(V.find("th:first"))
        }

        function l() {
            var h, O, x, A, ta = Ka(new Date);
            for (h = 0; h < Ba; h++) {
                A = ua(h);
                O = r.eq(h);
                O.html(s(A, Vb));
                x = M.eq(h);
                +A == +ta ? x.addClass(Wa + "-state-highlight fc-today") : x.removeClass(Wa + "-state-highlight fc-today");
                rb(O.add(x), A)
            }
        }

        function j(h, O) {
            if (h === ma)h = Wb;
            Wb = h;
            ub = {};
            var x = J.position().top, A = w.position().top;
            h = Math.min(h - x, V.height() + A + 1);
            Z.height(h - Sa(D));
            ja.css("top", x);
            w.height(h - A - 1);
            Xa = ea.height() + 1;
            O && y()
        }

        function t(h) {
            Ga = h;
            cb.clear();
            Ma = 0;
            Va(aa.width("").each(function (O, x) {
                Ma = Math.max(Ma, m(x).outerWidth())
            }), Ma);
            h = w[0].clientWidth;
            if (vb = w.width() - h) {
                Va(va, vb);
                va.show().prev().removeClass("fc-last")
            } else va.hide().prev().addClass("fc-last");
            db = Math.floor((h - Ma) / Ba);
            Va(r.slice(0, -1), db)
        }

        function y() {
            function h() {
                w.scrollTop(A)
            }

            var O = zb(), x = N(O);
            x.setHours(i("firstHour"));
            var A = ca(O, x) + 1;
            h();
            setTimeout(h, 0)
        }

        function S() {
            Xb = w.scrollTop()
        }

        function Q() {
            w.scrollTop(Xb)
        }

        function q(h) {
            h.click(fa).mousedown(W)
        }

        function u(h) {
            h.click(fa).mousedown(H)
        }

        function fa(h) {
            if (!i("selectable")) {
                var O = Math.min(Ba - 1, Math.floor((h.pageX - v.offset().left - Ma) / db)), x = ua(O), A = this.parentNode.className.match(/fc-slot(\d+)/);
                if (A) {
                    A = parseInt(A[1]) * i("slotMinutes");
                    var ta = Math.floor(A / 60);
                    x.setHours(ta);
                    x.setMinutes(A % 60 + La);
                    C("dayClick", M[O], x, false,
                        h)
                } else C("dayClick", M[O], x, true, h)
            }
        }

        function oa(h, O, x) {
            x && Na.build();
            var A = N(K.visStart);
            if (Ub) {
                x = Ca(O, A) * Ha + Ia + 1;
                h = Ca(h, A) * Ha + Ia + 1
            } else {
                x = Ca(h, A);
                h = Ca(O, A)
            }
            x = Math.max(0, x);
            h = Math.min(Ba, h);
            x < h && q(ga(0, x, 0, h - 1))
        }

        function ga(h, O, x, A) {
            h = Na.rect(h, O, x, A, ja);
            return E(h, ja)
        }

        function ra(h, O) {
            for (var x = N(K.visStart), A = ba(N(x), 1), ta = 0; ta < Ba; ta++) {
                var za = new Date(Math.max(x, h)), Da = new Date(Math.min(A, O));
                if (za < Da) {
                    var Ea = ta * Ha + Ia;
                    Ea = Na.rect(0, Ea, 0, Ea, I);
                    za = ca(x, za);
                    Da = ca(x, Da);
                    Ea.top = za;
                    Ea.height = Da - za;
                    u(E(Ea,
                        I))
                }
                ba(x, 1);
                ba(A, 1)
            }
        }

        function sa(h) {
            return cb.left(h)
        }

        function ha(h) {
            return cb.right(h)
        }

        function da(h) {
            return {row: Math.floor(Ca(h, K.visStart) / 7), col: U(h.getDay())}
        }

        function na(h) {
            var O = ua(h.col);
            h = h.row;
            i("allDaySlot") && h--;
            h >= 0 && xa(O, La + h * i("slotMinutes"));
            return O
        }

        function ua(h) {
            return ba(N(K.visStart), h * Ha + Ia)
        }

        function pa(h) {
            return i("allDaySlot") && !h.row
        }

        function U(h) {
            return (h - Math.max(Tb, Sb) + Ba) % Ba * Ha + Ia
        }

        function ca(h, O) {
            h = N(h, true);
            if (O < xa(N(h), La))return 0;
            if (O >= xa(N(h), bb))return V.height();
            h = i("slotMinutes");
            O = O.getHours() * 60 + O.getMinutes() - La;
            var x = Math.floor(O / h), A = ub[x];
            if (A === ma)A = ub[x] = V.find("tr:eq(" + x + ") td div")[0].offsetTop;
            return Math.max(0, Math.round(A - 1 + Xa * (O % h / h)))
        }

        function ka() {
            return {left: Ma, right: Ga - vb}
        }

        function qa() {
            return $
        }

        function G(h) {
            var O = N(h.start);
            if (h.allDay)return O;
            return xa(O, i("defaultEventMinutes"))
        }

        function p(h, O) {
            if (O)return N(h);
            return xa(N(h), i("slotMinutes"))
        }

        function L(h, O, x) {
            if (x)i("allDaySlot") && oa(h, ba(N(O), 1), true); else c(h, O)
        }

        function c(h, O) {
            var x =
                i("selectHelper");
            Na.build();
            if (x) {
                var A = Ca(h, K.visStart) * Ha + Ia;
                if (A >= 0 && A < Ba) {
                    A = Na.rect(0, A, 0, A, I);
                    var ta = ca(h, h), za = ca(h, O);
                    if (za > ta) {
                        A.top = ta;
                        A.height = za - ta;
                        A.left += 2;
                        A.width -= 5;
                        if (m.isFunction(x)) {
                            if (h = x(h, O)) {
                                A.position = "absolute";
                                A.zIndex = 8;
                                wa = m(h).css(A).appendTo(I)
                            }
                        } else {
                            A.isStart = true;
                            A.isEnd = true;
                            wa = m(o({
                                title: "",
                                start: h,
                                end: O,
                                className: ["fc-select-helper"],
                                editable: false
                            }, A));
                            wa.css("opacity", i("dragOpacity"))
                        }
                        if (wa) {
                            u(wa);
                            I.append(wa);
                            Va(wa, A.width, true);
                            Eb(wa, A.height, true)
                        }
                    }
                }
            } else ra(h,
                O)
        }

        function z() {
            B();
            if (wa) {
                wa.remove();
                wa = null
            }
        }

        function H(h) {
            if (h.which == 1 && i("selectable")) {
                Y(h);
                var O;
                Ra.start(function (x, A) {
                    z();
                    if (x && x.col == A.col && !pa(x)) {
                        A = na(A);
                        x = na(x);
                        O = [A, xa(N(A), i("slotMinutes")), x, xa(N(x), i("slotMinutes"))].sort(Gb);
                        c(O[0], O[3])
                    } else O = null
                }, h);
                m(document).one("mouseup", function (x) {
                    Ra.stop();
                    if (O) {
                        +O[0] == +O[1] && T(O[0], false, x);
                        n(O[0], O[3], false, x)
                    }
                })
            }
        }

        function T(h, O, x) {
            C("dayClick", M[U(h.getDay())], h, O, x)
        }

        function X(h, O) {
            Ra.start(function (x) {
                B();
                if (x)if (pa(x))ga(x.row,
                    x.col, x.row, x.col); else {
                    x = na(x);
                    var A = xa(N(x), i("defaultEventMinutes"));
                    ra(x, A)
                }
            }, O)
        }

        function ya(h, O, x) {
            var A = Ra.stop();
            B();
            A && C("drop", h, na(A), pa(A), O, x)
        }

        var K = this;
        K.renderAgenda = d;
        K.setWidth = t;
        K.setHeight = j;
        K.beforeHide = S;
        K.afterShow = Q;
        K.defaultEventEnd = G;
        K.timePosition = ca;
        K.dayOfWeekCol = U;
        K.dateCell = da;
        K.cellDate = na;
        K.cellIsAllDay = pa;
        K.allDayRow = qa;
        K.allDayBounds = ka;
        K.getHoverListener = function () {
            return Ra
        };
        K.colContentLeft = sa;
        K.colContentRight = ha;
        K.getDaySegmentContainer = function () {
            return ia
        };
        K.getSlotSegmentContainer = function () {
            return R
        };
        K.getMinMinute = function () {
            return La
        };
        K.getMaxMinute = function () {
            return bb
        };
        K.getBodyContent = function () {
            return I
        };
        K.getRowCnt = function () {
            return 1
        };
        K.getColCnt = function () {
            return Ba
        };
        K.getColWidth = function () {
            return db
        };
        K.getSlotHeight = function () {
            return Xa
        };
        K.defaultSelectionEnd = p;
        K.renderDayOverlay = oa;
        K.renderSelection = L;
        K.clearSelection = z;
        K.reportDayClick = T;
        K.dragStart = X;
        K.dragStop = ya;
        Kb.call(K, a, b, e);
        Lb.call(K);
        Mb.call(K);
        sc.call(K);
        var i = K.opt, C = K.trigger,
            P = K.clearEvents, E = K.renderOverlay, B = K.clearOverlays, n = K.reportSelection, Y = K.unselect, W = K.daySelectionMousedown, o = K.slotSegHtml, s = b.formatDate, v, F, r, J, M, k, D, Z, ja, ia, la, $, w, I, R, V, ea, aa, va, wa, Ga, Wb, Ma, db, vb, Xa, Xb, Ba, tb, Na, Ra, cb, ub = {}, Wa, Tb, Sb, Ub, Ha, Ia, La, bb, Vb;
        qb(a.addClass("fc-agenda"));
        Na = new Nb(function (h, O) {
            function x(eb) {
                return Math.max(Ea, Math.min(tc, eb))
            }

            var A, ta, za;
            r.each(function (eb, uc) {
                A = m(uc);
                ta = A.offset().left;
                if (eb)za[1] = ta;
                za = [ta];
                O[eb] = za
            });
            za[1] = ta + A.outerWidth();
            if (i("allDaySlot")) {
                A =
                    $;
                ta = A.offset().top;
                h[0] = [ta, ta + A.outerHeight()]
            }
            for (var Da = I.offset().top, Ea = w.offset().top, tc = Ea + w.outerHeight(), fb = 0; fb < tb; fb++)h.push([x(Da + Xa * fb), x(Da + Xa * (fb + 1))])
        });
        Ra = new Ob(Na);
        cb = new Pb(function (h) {
            return k.eq(h)
        })
    }

    function sc() {
        function a(o, s) {
            sa(o);
            var v, F = o.length, r = [], J = [];
            for (v = 0; v < F; v++)o[v].allDay ? r.push(o[v]) : J.push(o[v]);
            if (u("allDaySlot")) {
                L(e(r), s);
                na()
            }
            g(d(J), s)
        }

        function b() {
            ha();
            ua().empty();
            pa().empty()
        }

        function e(o) {
            o = ob(nb(o, m.map(o, Ua), q.visStart, q.visEnd));
            var s, v = o.length,
                F, r, J, M = [];
            for (s = 0; s < v; s++) {
                F = o[s];
                for (r = 0; r < F.length; r++) {
                    J = F[r];
                    J.row = 0;
                    J.level = s;
                    M.push(J)
                }
            }
            return M
        }

        function d(o) {
            var s = z(), v = ka(), F = ca(), r = xa(N(q.visStart), v), J = m.map(o, f), M, k, D, Z, ja, ia, la = [];
            for (M = 0; M < s; M++) {
                k = ob(nb(o, J, r, xa(N(r), F - v)));
                vc(k);
                for (D = 0; D < k.length; D++) {
                    Z = k[D];
                    for (ja = 0; ja < Z.length; ja++) {
                        ia = Z[ja];
                        ia.col = M;
                        ia.level = D;
                        la.push(ia)
                    }
                }
                ba(r, 1, true)
            }
            return la
        }

        function f(o) {
            return o.end ? N(o.end) : xa(N(o.start), u("defaultEventMinutes"))
        }

        function g(o, s) {
            var v, F = o.length, r, J, M, k, D, Z, ja, ia, la,
                $ = "", w, I, R = {}, V = {}, ea = pa(), aa;
            v = z();
            if (w = u("isRTL")) {
                I = -1;
                aa = v - 1
            } else {
                I = 1;
                aa = 0
            }
            for (v = 0; v < F; v++) {
                r = o[v];
                J = r.event;
                M = qa(r.start, r.start);
                k = qa(r.start, r.end);
                D = r.col;
                Z = r.level;
                ja = r.forward || 0;
                ia = G(D * I + aa);
                la = p(D * I + aa) - ia;
                la = Math.min(la - 6, la * 0.95);
                D = Z ? la / (Z + ja + 1) : ja ? (la / (ja + 1) - 6) * 2 : la;
                Z = ia + la / (Z + ja + 1) * Z * I + (w ? la - D : 0);
                r.top = M;
                r.left = Z;
                r.outerWidth = D;
                r.outerHeight = k - M;
                $ += l(J, r)
            }
            ea[0].innerHTML = $;
            w = ea.children();
            for (v = 0; v < F; v++) {
                r = o[v];
                J = r.event;
                $ = m(w[v]);
                I = fa("eventRender", J, J, $);
                if (I === false)$.remove();
                else {
                    if (I && I !== true) {
                        $.remove();
                        $ = m(I).css({position: "absolute", top: r.top, left: r.left}).appendTo(ea)
                    }
                    r.element = $;
                    if (J._id === s)t(J, $, r); else $[0]._fci = v;
                    ya(J, $)
                }
            }
            Db(ea, o, t);
            for (v = 0; v < F; v++) {
                r = o[v];
                if ($ = r.element) {
                    J = R[s = r.key = Ib($[0])];
                    r.vsides = J === ma ? (R[s] = Sa($, true)) : J;
                    J = V[s];
                    r.hsides = J === ma ? (V[s] = pb($, true)) : J;
                    s = $.find("div.fc-event-content");
                    if (s.length)r.contentTop = s[0].offsetTop
                }
            }
            for (v = 0; v < F; v++) {
                r = o[v];
                if ($ = r.element) {
                    $[0].style.width = Math.max(0, r.outerWidth - r.hsides) + "px";
                    R = Math.max(0, r.outerHeight -
                        r.vsides);
                    $[0].style.height = R + "px";
                    J = r.event;
                    if (r.contentTop !== ma && R - r.contentTop < 10) {
                        $.find("div.fc-event-time").text(Y(J.start, u("timeFormat")) + " - " + J.title);
                        $.find("div.fc-event-title").remove()
                    }
                    fa("eventAfterRender", J, J, $)
                }
            }
        }

        function l(o, s) {
            var v = "<", F = o.url, r = Jb(o, u), J = r ? " style='" + r + "'" : "", M = ["fc-event", "fc-event-skin", "fc-event-vert"];
            oa(o) && M.push("fc-event-draggable");
            s.isStart && M.push("fc-corner-top");
            s.isEnd && M.push("fc-corner-bottom");
            M = M.concat(o.className);
            if (o.source)M = M.concat(o.source.className ||
                []);
            v += F ? "a href='" + Qa(o.url) + "'" : "div";
            v += " class='" + M.join(" ") + "' style='position:absolute;z-index:8;top:" + s.top + "px;left:" + s.left + "px;" + r + "'><div class='fc-event-inner fc-event-skin'" + J + "><div class='fc-event-head fc-event-skin'" + J + "><div class='fc-event-time'>" + Qa(W(o.start, o.end, u("timeFormat"))) + "</div></div><div class='fc-event-content'><div class='fc-event-title'>" + Qa(o.title) + "</div></div><div class='fc-event-bg'></div></div>";
            if (s.isEnd && ga(o))v += "<div class='ui-resizable-handle ui-resizable-s'>=</div>";
            v += "</" + (F ? "a" : "div") + ">";
            return v
        }

        function j(o, s, v) {
            oa(o) && y(o, s, v.isStart);
            v.isEnd && ga(o) && c(o, s, v);
            da(o, s)
        }

        function t(o, s, v) {
            var F = s.find("div.fc-event-time");
            oa(o) && S(o, s, F);
            v.isEnd && ga(o) && Q(o, s, F);
            da(o, s)
        }

        function y(o, s, v) {
            function F() {
                if (!M) {
                    s.width(r).height("").draggable("option", "grid", null);
                    M = true
                }
            }

            var r, J, M = true, k, D = u("isRTL") ? -1 : 1, Z = U(), ja = H(), ia = T(), la = ka();
            s.draggable({
                zIndex: 9,
                opacity: u("dragOpacity", "month"),
                revertDuration: u("dragRevertDuration"),
                start: function ($, w) {
                    fa("eventDragStart",
                        s, o, $, w);
                    i(o, s);
                    r = s.width();
                    Z.start(function (I, R, V, ea) {
                        B();
                        if (I) {
                            J = false;
                            k = ea * D;
                            if (I.row)if (v) {
                                if (M) {
                                    s.width(ja - 10);
                                    Eb(s, ia * Math.round((o.end ? (o.end - o.start) / wc : u("defaultEventMinutes")) / u("slotMinutes")));
                                    s.draggable("option", "grid", [ja, 1]);
                                    M = false
                                }
                            } else J = true; else {
                                E(ba(N(o.start), k), ba(Ua(o), k));
                                F()
                            }
                            J = J || M && !k
                        } else {
                            F();
                            J = true
                        }
                        s.draggable("option", "revert", J)
                    }, $, "drag")
                },
                stop: function ($, w) {
                    Z.stop();
                    B();
                    fa("eventDragStop", s, o, $, w);
                    if (J) {
                        F();
                        s.css("filter", "");
                        K(o, s)
                    } else {
                        var I = 0;
                        M || (I = Math.round((s.offset().top -
                                X().offset().top) / ia) * u("slotMinutes") + la - (o.start.getHours() * 60 + o.start.getMinutes()));
                        C(this, o, k, I, M, $, w)
                    }
                }
            })
        }

        function S(o, s, v) {
            function F(I) {
                var R = xa(N(o.start), I), V;
                if (o.end)V = xa(N(o.end), I);
                v.text(W(R, V, u("timeFormat")))
            }

            function r() {
                if (M) {
                    v.css("display", "");
                    s.draggable("option", "grid", [$, w]);
                    M = false
                }
            }

            var J, M = false, k, D, Z, ja = u("isRTL") ? -1 : 1, ia = U(), la = z(), $ = H(), w = T();
            s.draggable({
                zIndex: 9,
                scroll: false,
                grid: [$, w],
                axis: la == 1 ? "y" : false,
                opacity: u("dragOpacity"),
                revertDuration: u("dragRevertDuration"),
                start: function (I, R) {
                    fa("eventDragStart", s, o, I, R);
                    i(o, s);
                    J = s.position();
                    D = Z = 0;
                    ia.start(function (V, ea, aa, va) {
                        s.draggable("option", "revert", !V);
                        B();
                        if (V) {
                            k = va * ja;
                            if (u("allDaySlot") && !V.row) {
                                if (!M) {
                                    M = true;
                                    v.hide();
                                    s.draggable("option", "grid", null)
                                }
                                E(ba(N(o.start), k), ba(Ua(o), k))
                            } else r()
                        }
                    }, I, "drag")
                },
                drag: function (I, R) {
                    D = Math.round((R.position.top - J.top) / w) * u("slotMinutes");
                    if (D != Z) {
                        M || F(D);
                        Z = D
                    }
                },
                stop: function (I, R) {
                    var V = ia.stop();
                    B();
                    fa("eventDragStop", s, o, I, R);
                    if (V && (k || D || M))C(this, o, k, M ? 0 : D, M, I, R);
                    else {
                        r();
                        s.css("filter", "");
                        s.css(J);
                        F(0);
                        K(o, s)
                    }
                }
            })
        }

        function Q(o, s, v) {
            var F, r, J = T();
            s.resizable({
                handles: {s: "div.ui-resizable-s"}, grid: J, start: function (M, k) {
                    F = r = 0;
                    i(o, s);
                    s.css("z-index", 9);
                    fa("eventResizeStart", this, o, M, k)
                }, resize: function (M, k) {
                    F = Math.round((Math.max(J, s.height()) - k.originalSize.height) / J);
                    if (F != r) {
                        v.text(W(o.start, !F && !o.end ? null : xa(ra(o), u("slotMinutes") * F), u("timeFormat")));
                        r = F
                    }
                }, stop: function (M, k) {
                    fa("eventResizeStop", this, o, M, k);
                    if (F)P(this, o, 0, u("slotMinutes") * F, M, k); else {
                        s.css("z-index",
                            8);
                        K(o, s)
                    }
                }
            })
        }

        var q = this;
        q.renderEvents = a;
        q.compileDaySegs = e;
        q.clearEvents = b;
        q.slotSegHtml = l;
        q.bindDaySeg = j;
        Qb.call(q);
        var u = q.opt, fa = q.trigger, oa = q.isEventDraggable, ga = q.isEventResizable, ra = q.eventEnd, sa = q.reportEvents, ha = q.reportEventClear, da = q.eventElementHandlers, na = q.setHeight, ua = q.getDaySegmentContainer, pa = q.getSlotSegmentContainer, U = q.getHoverListener, ca = q.getMaxMinute, ka = q.getMinMinute, qa = q.timePosition, G = q.colContentLeft, p = q.colContentRight, L = q.renderDaySegs, c = q.resizableDayEvent, z = q.getColCnt,
            H = q.getColWidth, T = q.getSlotHeight, X = q.getBodyContent, ya = q.reportEventElement, K = q.showEvents, i = q.hideEvents, C = q.eventDrop, P = q.eventResize, E = q.renderDayOverlay, B = q.clearOverlays, n = q.calendar, Y = n.formatDate, W = n.formatDates
    }

    function vc(a) {
        var b, e, d, f, g, l;
        for (b = a.length - 1; b > 0; b--) {
            f = a[b];
            for (e = 0; e < f.length; e++) {
                g = f[e];
                for (d = 0; d < a[b - 1].length; d++) {
                    l = a[b - 1][d];
                    if (Cb(g, l))l.forward = Math.max(l.forward || 0, (g.forward || 0) + 1)
                }
            }
        }
    }

    function Kb(a, b, e) {
        function d(G, p) {
            G = qa[G];
            if (typeof G == "object")return jb(G, p || e);
            return G
        }

        function f(G, p) {
            return b.trigger.apply(b, [G, p || da].concat(Array.prototype.slice.call(arguments, 2), [da]))
        }

        function g(G) {
            return j(G) && !d("disableDragging")
        }

        function l(G) {
            return j(G) && !d("disableResizing")
        }

        function j(G) {
            return Ta(G.editable, (G.source || {}).editable, d("editable"))
        }

        function t(G) {
            U = {};
            var p, L = G.length, c;
            for (p = 0; p < L; p++) {
                c = G[p];
                if (U[c._id])U[c._id].push(c); else U[c._id] = [c]
            }
        }

        function y(G) {
            return G.end ? N(G.end) : na(G)
        }

        function S(G, p) {
            ca.push(p);
            if (ka[G._id])ka[G._id].push(p); else ka[G._id] =
                [p]
        }

        function Q() {
            ca = [];
            ka = {}
        }

        function q(G, p) {
            p.click(function (L) {
                if (!p.hasClass("ui-draggable-dragging") && !p.hasClass("ui-resizable-resizing"))return f("eventClick", this, G, L)
            }).hover(function (L) {
                f("eventMouseover", this, G, L)
            }, function (L) {
                f("eventMouseout", this, G, L)
            })
        }

        function u(G, p) {
            oa(G, p, "show")
        }

        function fa(G, p) {
            oa(G, p, "hide")
        }

        function oa(G, p, L) {
            G = ka[G._id];
            var c, z = G.length;
            for (c = 0; c < z; c++)if (!p || G[c][0] != p[0])G[c][L]()
        }

        function ga(G, p, L, c, z, H, T) {
            var X = p.allDay, ya = p._id;
            sa(U[ya], L, c, z);
            f("eventDrop",
                G, p, L, c, z, function () {
                    sa(U[ya], -L, -c, X);
                    pa(ya)
                }, H, T);
            pa(ya)
        }

        function ra(G, p, L, c, z, H) {
            var T = p._id;
            ha(U[T], L, c);
            f("eventResize", G, p, L, c, function () {
                ha(U[T], -L, -c);
                pa(T)
            }, z, H);
            pa(T)
        }

        function sa(G, p, L, c) {
            L = L || 0;
            for (var z, H = G.length, T = 0; T < H; T++) {
                z = G[T];
                if (c !== ma)z.allDay = c;
                xa(ba(z.start, p, true), L);
                if (z.end)z.end = xa(ba(z.end, p, true), L);
                ua(z, qa)
            }
        }

        function ha(G, p, L) {
            L = L || 0;
            for (var c, z = G.length, H = 0; H < z; H++) {
                c = G[H];
                c.end = xa(ba(y(c), p, true), L);
                ua(c, qa)
            }
        }

        var da = this;
        da.element = a;
        da.calendar = b;
        da.name = e;
        da.opt =
            d;
        da.trigger = f;
        da.isEventDraggable = g;
        da.isEventResizable = l;
        da.reportEvents = t;
        da.eventEnd = y;
        da.reportEventElement = S;
        da.reportEventClear = Q;
        da.eventElementHandlers = q;
        da.showEvents = u;
        da.hideEvents = fa;
        da.eventDrop = ga;
        da.eventResize = ra;
        var na = da.defaultEventEnd, ua = b.normalizeEvent, pa = b.reportEventChange, U = {}, ca = [], ka = {}, qa = b.options
    }

    function Qb() {
        function a(i, C) {
            var P = z(), E = pa(), B = U(), n = 0, Y, W, o = i.length, s, v;
            P[0].innerHTML = e(i);
            d(i, P.children());
            f(i);
            g(i, P, C);
            l(i);
            j(i);
            t(i);
            C = y();
            for (P = 0; P < E; P++) {
                Y = [];
                for (W =
                         0; W < B; W++)Y[W] = 0;
                for (; n < o && (s = i[n]).row == P;) {
                    W = Hb(Y.slice(s.startCol, s.endCol));
                    s.top = W;
                    W += s.outerHeight;
                    for (v = s.startCol; v < s.endCol; v++)Y[v] = W;
                    n++
                }
                C[P].height(Hb(Y))
            }
            Q(i, S(C))
        }

        function b(i, C, P) {
            var E = m("<div/>"), B = z(), n = i.length, Y;
            E[0].innerHTML = e(i);
            E = E.children();
            B.append(E);
            d(i, E);
            l(i);
            j(i);
            t(i);
            Q(i, S(y()));
            E = [];
            for (B = 0; B < n; B++)if (Y = i[B].element) {
                i[B].row === C && Y.css("top", P);
                E.push(Y[0])
            }
            return m(E)
        }

        function e(i) {
            var C = fa("isRTL"), P, E = i.length, B, n, Y, W;
            P = ka();
            var o = P.left, s = P.right, v, F, r, J, M, k =
                "";
            for (P = 0; P < E; P++) {
                B = i[P];
                n = B.event;
                W = ["fc-event", "fc-event-skin", "fc-event-hori"];
                ga(n) && W.push("fc-event-draggable");
                if (C) {
                    B.isStart && W.push("fc-corner-right");
                    B.isEnd && W.push("fc-corner-left");
                    v = p(B.end.getDay() - 1);
                    F = p(B.start.getDay());
                    r = B.isEnd ? qa(v) : o;
                    J = B.isStart ? G(F) : s
                } else {
                    B.isStart && W.push("fc-corner-left");
                    B.isEnd && W.push("fc-corner-right");
                    v = p(B.start.getDay());
                    F = p(B.end.getDay() - 1);
                    r = B.isStart ? qa(v) : o;
                    J = B.isEnd ? G(F) : s
                }
                W = W.concat(n.className);
                if (n.source)W = W.concat(n.source.className ||
                    []);
                Y = n.url;
                M = Jb(n, fa);
                k += Y ? "<a href='" + Qa(Y) + "'" : "<div";
                k += " class='" + W.join(" ") + "' style='position:absolute;z-index:8;left:" + r + "px;" + M + "'><div class='fc-event-inner fc-event-skin'" + (M ? " style='" + M + "'" : "") + ">";
                if (!n.allDay && B.isStart)k += "<span class='fc-event-time'>" + Qa(T(n.start, n.end, fa("timeFormat"))) + "</span>";
                k += "<span class='fc-event-title'>" + Qa(n.title) + "</span></div>";
                if (B.isEnd && ra(n))k += "<div class='ui-resizable-handle ui-resizable-" + (C ? "w" : "e") + "'>&nbsp;&nbsp;&nbsp;</div>";
                k += "</" + (Y ?
                        "a" : "div") + ">";
                B.left = r;
                B.outerWidth = J - r;
                B.startCol = v;
                B.endCol = F + 1
            }
            return k
        }

        function d(i, C) {
            var P, E = i.length, B, n, Y;
            for (P = 0; P < E; P++) {
                B = i[P];
                n = B.event;
                Y = m(C[P]);
                n = oa("eventRender", n, n, Y);
                if (n === false)Y.remove(); else {
                    if (n && n !== true) {
                        n = m(n).css({position: "absolute", left: B.left});
                        Y.replaceWith(n);
                        Y = n
                    }
                    B.element = Y
                }
            }
        }

        function f(i) {
            var C, P = i.length, E, B;
            for (C = 0; C < P; C++) {
                E = i[C];
                (B = E.element) && ha(E.event, B)
            }
        }

        function g(i, C, P) {
            var E, B = i.length, n, Y, W;
            for (E = 0; E < B; E++) {
                n = i[E];
                if (Y = n.element) {
                    W = n.event;
                    if (W._id ===
                        P)H(W, Y, n); else Y[0]._fci = E
                }
            }
            Db(C, i, H)
        }

        function l(i) {
            var C, P = i.length, E, B, n, Y, W = {};
            for (C = 0; C < P; C++) {
                E = i[C];
                if (B = E.element) {
                    n = E.key = Ib(B[0]);
                    Y = W[n];
                    if (Y === ma)Y = W[n] = pb(B, true);
                    E.hsides = Y
                }
            }
        }

        function j(i) {
            var C, P = i.length, E, B;
            for (C = 0; C < P; C++) {
                E = i[C];
                if (B = E.element)B[0].style.width = Math.max(0, E.outerWidth - E.hsides) + "px"
            }
        }

        function t(i) {
            var C, P = i.length, E, B, n, Y, W = {};
            for (C = 0; C < P; C++) {
                E = i[C];
                if (B = E.element) {
                    n = E.key;
                    Y = W[n];
                    if (Y === ma)Y = W[n] = Fb(B);
                    E.outerHeight = B[0].offsetHeight + Y
                }
            }
        }

        function y() {
            var i, C = pa(),
                P = [];
            for (i = 0; i < C; i++)P[i] = ca(i).find("td:first div.fc-day-content > div");
            return P
        }

        function S(i) {
            var C, P = i.length, E = [];
            for (C = 0; C < P; C++)E[C] = i[C][0].offsetTop;
            return E
        }

        function Q(i, C) {
            var P, E = i.length, B, n;
            for (P = 0; P < E; P++) {
                B = i[P];
                if (n = B.element) {
                    n[0].style.top = C[B.row] + (B.top || 0) + "px";
                    B = B.event;
                    oa("eventAfterRender", B, B, n)
                }
            }
        }

        function q(i, C, P) {
            var E = fa("isRTL"), B = E ? "w" : "e", n = C.find("div.ui-resizable-" + B), Y = false;
            qb(C);
            C.mousedown(function (W) {
                W.preventDefault()
            }).click(function (W) {
                if (Y) {
                    W.preventDefault();
                    W.stopImmediatePropagation()
                }
            });
            n.mousedown(function (W) {
                function o(ia) {
                    oa("eventResizeStop", this, i, ia);
                    m("body").css("cursor", "");
                    s.stop();
                    ya();
                    k && ua(this, i, k, 0, ia);
                    setTimeout(function () {
                        Y = false
                    }, 0)
                }

                if (W.which == 1) {
                    Y = true;
                    var s = u.getHoverListener(), v = pa(), F = U(), r = E ? -1 : 1, J = E ? F - 1 : 0, M = C.css("top"), k, D, Z = m.extend({}, i), ja = L(i.start);
                    K();
                    m("body").css("cursor", B + "-resize").one("mouseup", o);
                    oa("eventResizeStart", this, i, W);
                    s.start(function (ia, la) {
                        if (ia) {
                            var $ = Math.max(ja.row, ia.row);
                            ia = ia.col;
                            if (v == 1)$ = 0;
                            if ($ == ja.row)ia = E ? Math.min(ja.col, ia) : Math.max(ja.col, ia);
                            k = $ * 7 + ia * r + J - (la.row * 7 + la.col * r + J);
                            la = ba(sa(i), k, true);
                            if (k) {
                                Z.end = la;
                                $ = D;
                                D = b(c([Z]), P.row, M);
                                D.find("*").css("cursor", B + "-resize");
                                $ && $.remove();
                                na(i)
                            } else if (D) {
                                da(i);
                                D.remove();
                                D = null
                            }
                            ya();
                            X(i.start, ba(N(la), 1))
                        }
                    }, W)
                }
            })
        }

        var u = this;
        u.renderDaySegs = a;
        u.resizableDayEvent = q;
        var fa = u.opt, oa = u.trigger, ga = u.isEventDraggable, ra = u.isEventResizable, sa = u.eventEnd, ha = u.reportEventElement, da = u.showEvents, na = u.hideEvents, ua = u.eventResize, pa = u.getRowCnt,
            U = u.getColCnt, ca = u.allDayRow, ka = u.allDayBounds, qa = u.colContentLeft, G = u.colContentRight, p = u.dayOfWeekCol, L = u.dateCell, c = u.compileDaySegs, z = u.getDaySegmentContainer, H = u.bindDaySeg, T = u.calendar.formatDates, X = u.renderDayOverlay, ya = u.clearOverlays, K = u.clearSelection
    }

    function Mb() {
        function a(Q, q, u) {
            b();
            q || (q = j(Q, u));
            t(Q, q, u);
            e(Q, q, u)
        }

        function b(Q) {
            if (S) {
                S = false;
                y();
                l("unselect", null, Q)
            }
        }

        function e(Q, q, u, fa) {
            S = true;
            l("select", null, Q, q, u, fa)
        }

        function d(Q) {
            var q = f.cellDate, u = f.cellIsAllDay, fa = f.getHoverListener(),
                oa = f.reportDayClick;
            if (Q.which == 1 && g("selectable")) {
                b(Q);
                var ga;
                fa.start(function (ra, sa) {
                    y();
                    if (ra && u(ra)) {
                        ga = [q(sa), q(ra)].sort(Gb);
                        t(ga[0], ga[1], true)
                    } else ga = null
                }, Q);
                m(document).one("mouseup", function (ra) {
                    fa.stop();
                    if (ga) {
                        +ga[0] == +ga[1] && oa(ga[0], true, ra);
                        e(ga[0], ga[1], true, ra)
                    }
                })
            }
        }

        var f = this;
        f.select = a;
        f.unselect = b;
        f.reportSelection = e;
        f.daySelectionMousedown = d;
        var g = f.opt, l = f.trigger, j = f.defaultSelectionEnd, t = f.renderSelection, y = f.clearSelection, S = false;
        g("selectable") && g("unselectAuto") && m(document).mousedown(function (Q) {
            var q =
                g("unselectCancel");
            if (q)if (m(Q.target).parents(q).length)return;
            b(Q)
        })
    }

    function Lb() {
        function a(g, l) {
            var j = f.shift();
            j || (j = m("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>"));
            j[0].parentNode != l[0] && j.appendTo(l);
            d.push(j.css(g).show());
            return j
        }

        function b() {
            for (var g; g = d.shift();)f.push(g.hide().unbind())
        }

        var e = this;
        e.renderOverlay = a;
        e.clearOverlays = b;
        var d = [], f = []
    }

    function Nb(a) {
        var b = this, e, d;
        b.build = function () {
            e = [];
            d = [];
            a(e, d)
        };
        b.cell = function (f, g) {
            var l = e.length, j = d.length,
                t, y = -1, S = -1;
            for (t = 0; t < l; t++)if (g >= e[t][0] && g < e[t][1]) {
                y = t;
                break
            }
            for (t = 0; t < j; t++)if (f >= d[t][0] && f < d[t][1]) {
                S = t;
                break
            }
            return y >= 0 && S >= 0 ? {row: y, col: S} : null
        };
        b.rect = function (f, g, l, j, t) {
            t = t.offset();
            return {top: e[f][0] - t.top, left: d[g][0] - t.left, width: d[j][1] - d[g][0], height: e[l][1] - e[f][0]}
        }
    }

    function Ob(a) {
        function b(j) {
            xc(j);
            j = a.cell(j.pageX, j.pageY);
            if (!j != !l || j && (j.row != l.row || j.col != l.col)) {
                if (j) {
                    g || (g = j);
                    f(j, g, j.row - g.row, j.col - g.col)
                } else f(j, g);
                l = j
            }
        }

        var e = this, d, f, g, l;
        e.start = function (j, t, y) {
            f = j;
            g = l = null;
            a.build();
            b(t);
            d = y || "mousemove";
            m(document).bind(d, b)
        };
        e.stop = function () {
            m(document).unbind(d, b);
            return l
        }
    }

    function xc(a) {
        if (a.pageX === ma) {
            a.pageX = a.originalEvent.pageX;
            a.pageY = a.originalEvent.pageY
        }
    }

    function Pb(a) {
        function b(l) {
            return d[l] = d[l] || a(l)
        }

        var e = this, d = {}, f = {}, g = {};
        e.left = function (l) {
            return f[l] = f[l] === ma ? b(l).position().left : f[l]
        };
        e.right = function (l) {
            return g[l] = g[l] === ma ? e.left(l) + b(l).width() : g[l]
        };
        e.clear = function () {
            d = {};
            f = {};
            g = {}
        }
    }

    var Ya = {
        defaultView: "month",
        aspectRatio: 1.35,
        header: {left: "title", center: "", right: "today prev,next"},
        weekends: true,
        allDayDefault: true,
        ignoreTimezone: true,
        lazyFetching: true,
        startParam: "start",
        endParam: "end",
        titleFormat: {month: "MMMM yyyy", week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}", day: "dddd, MMM d, yyyy"},
        columnFormat: {month: "ddd", week: "ddd M/d", day: "dddd M/d"},
        timeFormat: {"": "h(:mm)t"},
        isRTL: false,
        firstDay: 0,
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNamesShort: ["Jan",
            "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        buttonText: {
            prev: "&nbsp;&#9668;&nbsp;",
            next: "&nbsp;&#9658;&nbsp;",
            prevYear: "&nbsp;&lt;&lt;&nbsp;",
            nextYear: "&nbsp;&gt;&gt;&nbsp;",
            today: "today",
            month: "month",
            week: "week",
            day: "day"
        },
        theme: false,
        buttonIcons: {prev: "circle-triangle-w", next: "circle-triangle-e"},
        unselectAuto: true,
        dropAccept: "*"
    }, yc =
    {
        header: {left: "next,prev today", center: "", right: "title"},
        buttonText: {
            prev: "&nbsp;&#9658;&nbsp;",
            next: "&nbsp;&#9668;&nbsp;",
            prevYear: "&nbsp;&gt;&gt;&nbsp;",
            nextYear: "&nbsp;&lt;&lt;&nbsp;"
        },
        buttonIcons: {prev: "circle-triangle-e", next: "circle-triangle-w"}
    }, Aa = m.fullCalendar = {version: "1.5.4"}, Ja = Aa.views = {};
    m.fn.fullCalendar = function (a) {
        if (typeof a == "string") {
            var b = Array.prototype.slice.call(arguments, 1), e;
            this.each(function () {
                var f = m.data(this, "fullCalendar");
                if (f && m.isFunction(f[a])) {
                    f = f[a].apply(f,
                        b);
                    if (e === ma)e = f;
                    a == "destroy" && m.removeData(this, "fullCalendar")
                }
            });
            if (e !== ma)return e;
            return this
        }
        var d = a.eventSources || [];
        delete a.eventSources;
        if (a.events) {
            d.push(a.events);
            delete a.events
        }
        a = m.extend(true, {}, Ya, a.isRTL || a.isRTL === ma && Ya.isRTL ? yc : {}, a);
        this.each(function (f, g) {
            f = m(g);
            g = new Yb(f, a, d);
            f.data("fullCalendar", g);
            g.render()
        });
        return this
    };
    Aa.sourceNormalizers = [];
    Aa.sourceFetchers = [];
    var ac = {dataType: "json", cache: false}, bc = 1;
    Aa.addDays = ba;
    Aa.cloneDate = N;
    Aa.parseDate = kb;
    Aa.parseISO8601 =
        Bb;
    Aa.parseTime = mb;
    Aa.formatDate = Oa;
    Aa.formatDates = ib;
    var lc = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"], Ab = 864E5, cc = 36E5, wc = 6E4, dc = {
        s: function (a) {
            return a.getSeconds()
        }, ss: function (a) {
            return Pa(a.getSeconds())
        }, m: function (a) {
            return a.getMinutes()
        }, mm: function (a) {
            return Pa(a.getMinutes())
        }, h: function (a) {
            return a.getHours() % 12 || 12
        }, hh: function (a) {
            return Pa(a.getHours() % 12 || 12)
        }, H: function (a) {
            return a.getHours()
        }, HH: function (a) {
            return Pa(a.getHours())
        }, d: function (a) {
            return a.getDate()
        }, dd: function (a) {
            return Pa(a.getDate())
        },
        ddd: function (a, b) {
            return b.dayNamesShort[a.getDay()]
        }, dddd: function (a, b) {
            return b.dayNames[a.getDay()]
        }, M: function (a) {
            return a.getMonth() + 1
        }, MM: function (a) {
            return Pa(a.getMonth() + 1)
        }, MMM: function (a, b) {
            return b.monthNamesShort[a.getMonth()]
        }, MMMM: function (a, b) {
            return b.monthNames[a.getMonth()]
        }, yy: function (a) {
            return (a.getFullYear() + "").substring(2)
        }, yyyy: function (a) {
            return a.getFullYear()
        }, t: function (a) {
            return a.getHours() < 12 ? "a" : "p"
        }, tt: function (a) {
            return a.getHours() < 12 ? "am" : "pm"
        }, T: function (a) {
            return a.getHours() <
            12 ? "A" : "P"
        }, TT: function (a) {
            return a.getHours() < 12 ? "AM" : "PM"
        }, u: function (a) {
            return Oa(a, "yyyy-MM-dd'T'HH:mm:ss'Z'")
        }, S: function (a) {
            a = a.getDate();
            if (a > 10 && a < 20)return "th";
            return ["st", "nd", "rd"][a % 10 - 1] || "th"
        }
    };
    Aa.applyAll = $a;
    Ja.month = mc;
    Ja.basicWeek = nc;
    Ja.basicDay = oc;
    wb({weekMode: "fixed"});
    Ja.agendaWeek = qc;
    Ja.agendaDay = rc;
    wb({
        allDaySlot: true,
        allDayText: "all-day",
        firstHour: 6,
        slotMinutes: 30,
        defaultEventMinutes: 120,
        axisFormat: "h(:mm)tt",
        timeFormat: {agenda: "h:mm{ - h:mm}"},
        dragOpacity: {agenda: 0.5},
        minTime: 0,
        maxTime: 24
    })
})(jQuery);
/*
 jQRangeSlider
 Copyright (C) Guillaume Gautreau 2012
 Dual licensed under the MIT or GPL Version 2 licenses.
 */
(function (c) {
    c.widget("ui.rangeSliderMouseTouch", c.ui.mouse, {
        _mouseInit: function () {
            var a = this;
            c.ui.mouse.prototype._mouseInit.apply(this);
            this._mouseDownEvent = !1;
            this.element.bind("touchstart." + this.widgetName, function (b) {
                return a._touchStart(b)
            })
        }, _mouseDestroy: function () {
            c(document).unbind("touchmove." + this.widgetName, this._touchMoveDelegate).unbind("touchend." + this.widgetName, this._touchEndDelegate);
            c.ui.mouse.prototype._mouseDestroy.apply(this)
        }, _touchStart: function (a) {
            a.which = 1;
            a.preventDefault();
            this._fillTouchEvent(a);
            var b = this, d = this._mouseDownEvent;
            this._mouseDown(a);
            if (d !== this._mouseDownEvent)this._touchEndDelegate = function (a) {
                b._touchEnd(a)
            }, this._touchMoveDelegate = function (a) {
                b._touchMove(a)
            }, c(document).bind("touchmove." + this.widgetName, this._touchMoveDelegate).bind("touchend." + this.widgetName, this._touchEndDelegate)
        }, _touchEnd: function (a) {
            this._fillTouchEvent(a);
            this._mouseUp(a);
            c(document).unbind("touchmove." + this.widgetName, this._touchMoveDelegate).unbind("touchend." + this.widgetName,
                this._touchEndDelegate);
            this._mouseDownEvent = !1;
            c(document).trigger("mouseup")
        }, _touchMove: function (a) {
            a.preventDefault();
            this._fillTouchEvent(a);
            return this._mouseMove(a)
        }, _fillTouchEvent: function (a) {
            var b;
            b = typeof a.targetTouches === "undefined" && typeof a.changedTouches === "undefined" ? a.originalEvent.targetTouches[0] || a.originalEvent.changedTouches[0] : a.targetTouches[0] || a.changedTouches[0];
            a.pageX = b.pageX;
            a.pageY = b.pageY
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.rangeSliderDraggable", c.ui.rangeSliderMouseTouch, {
        cache: null, options: {containment: null}, _create: function () {
            setTimeout(c.proxy(this._initElement, this), 10)
        }, _initElement: function () {
            this._mouseInit();
            this._cache()
        }, _setOption: function (a, b) {
            if (a == "containment")this.options.containment = b === null || c(b).length == 0 ? null : c(b)
        }, _mouseStart: function (a) {
            this._cache();
            this.cache.click = {left: a.pageX, top: a.pageY};
            this.cache.initialOffset = this.element.offset();
            this._triggerMouseEvent("mousestart");
            return !0
        }, _mouseDrag: function (a) {
            a = a.pageX - this.cache.click.left;
            a = this._constraintPosition(a + this.cache.initialOffset.left);
            this._applyPosition(a);
            this._triggerMouseEvent("sliderDrag");
            return !1
        }, _mouseStop: function () {
            this._triggerMouseEvent("stop")
        }, _constraintPosition: function (a) {
            this.element.parent().length !== 0 && this.cache.parent.offset != null && (a = Math.min(a, this.cache.parent.offset.left + this.cache.parent.width - this.cache.width.outer), a = Math.max(a, this.cache.parent.offset.left));
            return a
        }, _applyPosition: function (a) {
            var b =
            {top: this.cache.offset.top, left: a};
            this.element.offset({left: a});
            this.cache.offset = b
        }, _cacheIfNecessary: function () {
            this.cache === null && this._cache()
        }, _cache: function () {
            this.cache = {};
            this._cacheMargins();
            this._cacheParent();
            this._cacheDimensions();
            this.cache.offset = this.element.offset()
        }, _cacheMargins: function () {
            this.cache.margin = {
                left: this._parsePixels(this.element, "marginLeft"),
                right: this._parsePixels(this.element, "marginRight"),
                top: this._parsePixels(this.element, "marginTop"),
                bottom: this._parsePixels(this.element,
                    "marginBottom")
            }
        }, _cacheParent: function () {
            if (this.options.parent !== null) {
                var a = this.element.parent();
                this.cache.parent = {offset: a.offset(), width: a.width()}
            } else this.cache.parent = null
        }, _cacheDimensions: function () {
            this.cache.width = {outer: this.element.outerWidth(), inner: this.element.width()}
        }, _parsePixels: function (a, b) {
            return parseInt(a.css(b), 10) || 0
        }, _triggerMouseEvent: function (a) {
            var b = this._prepareEventData();
            this.element.trigger(a, b)
        }, _prepareEventData: function () {
            return {
                element: this.element, offset: this.cache.offset ||
                null
            }
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.rangeSliderBar", c.ui.rangeSliderDraggable, {
        options: {
            leftHandle: null,
            rightHandle: null,
            bounds: {min: 0, max: 100},
            type: "rangeSliderHandle",
            range: !1,
            drag: function () {
            },
            stop: function () {
            },
            values: {min: 0, max: 20},
            wheelSpeed: 4,
            wheelMode: null
        }, _values: {min: 0, max: 20}, _waitingToInit: 2, _wheelTimeout: !1, _create: function () {
            c.ui.rangeSliderDraggable.prototype._create.apply(this);
            this.element.css("position", "absolute").css("top", 0).addClass("ui-rangeSlider-bar");
            this.options.leftHandle.bind("initialize",
                c.proxy(this._onInitialized, this)).bind("mousestart", c.proxy(this._cache, this)).bind("stop", c.proxy(this._onHandleStop, this));
            this.options.rightHandle.bind("initialize", c.proxy(this._onInitialized, this)).bind("mousestart", c.proxy(this._cache, this)).bind("stop", c.proxy(this._onHandleStop, this));
            this._bindHandles();
            this._values = this.options.values;
            this._setWheelModeOption(this.options.wheelMode)
        }, _setOption: function (a, b) {
            a === "range" ? this._setRangeOption(b) : a === "wheelSpeed" ? this._setWheelSpeedOption(b) :
            a === "wheelMode" && this._setWheelModeOption(b)
        }, _setRangeOption: function (a) {
            if (typeof a != "object" || a === null)a = !1;
            if (!(a === !1 && this.options.range === !1))this.options.range = a !== !1 ? {
                min: typeof a.min === "undefined" ? this.options.range.min || !1 : a.min,
                max: typeof a.max === "undefined" ? this.options.range.max || !1 : a.max
            } : !1, this._setLeftRange(), this._setRightRange()
        }, _setWheelSpeedOption: function (a) {
            if (typeof a === "number" && a > 0)this.options.wheelSpeed = a
        }, _setWheelModeOption: function (a) {
            if (a === null || a === !1 || a === "zoom" ||
                a === "scroll")this.options.wheelMode !== a && this.element.parent().unbind("mousewheel.bar"), this._bindMouseWheel(a), this.options.wheelMode = a
        }, _bindMouseWheel: function (a) {
            a === "zoom" ? this.element.parent().bind("mousewheel.bar", c.proxy(this._mouseWheelZoom, this)) : a === "scroll" && this.element.parent().bind("mousewheel.bar", c.proxy(this._mouseWheelScroll, this))
        }, _setLeftRange: function () {
            if (this.options.range == !1)return !1;
            var a = this._values.max, b = {min: !1, max: !1};
            b.max = (this.options.range.min || !1) !== !1 ? this._leftHandle("substract",
                a, this.options.range.min) : !1;
            b.min = (this.options.range.max || !1) !== !1 ? this._leftHandle("substract", a, this.options.range.max) : !1;
            this._leftHandle("option", "range", b)
        }, _setRightRange: function () {
            var a = this._values.min, b = {min: !1, max: !1};
            b.min = (this.options.range.min || !1) !== !1 ? this._rightHandle("add", a, this.options.range.min) : !1;
            b.max = (this.options.range.max || !1) !== !1 ? this._rightHandle("add", a, this.options.range.max) : !1;
            this._rightHandle("option", "range", b)
        }, _deactivateRange: function () {
            this._leftHandle("option",
                "range", !1);
            this._rightHandle("option", "range", !1)
        }, _reactivateRange: function () {
            this._setRangeOption(this.options.range)
        }, _onInitialized: function () {
            this._waitingToInit--;
            this._waitingToInit === 0 && this._initMe()
        }, _initMe: function () {
            this._cache();
            this.min(this.options.values.min);
            this.max(this.options.values.max);
            var a = this._leftHandle("position"), b = this._rightHandle("position") + this.options.rightHandle.width();
            this.element.offset({left: a});
            this.element.css("width", b - a)
        }, _leftHandle: function () {
            return this._handleProxy(this.options.leftHandle,
                arguments)
        }, _rightHandle: function () {
            return this._handleProxy(this.options.rightHandle, arguments)
        }, _handleProxy: function (a, b) {
            var c = Array.prototype.slice.call(b);
            return a[this.options.type].apply(a, c)
        }, _cache: function () {
            c.ui.rangeSliderDraggable.prototype._cache.apply(this);
            this._cacheHandles()
        }, _cacheHandles: function () {
            this.cache.rightHandle = {};
            this.cache.rightHandle.width = this.options.rightHandle.width();
            this.cache.rightHandle.offset = this.options.rightHandle.offset();
            this.cache.leftHandle = {};
            this.cache.leftHandle.offset =
                this.options.leftHandle.offset()
        }, _mouseStart: function (a) {
            c.ui.rangeSliderDraggable.prototype._mouseStart.apply(this, [a]);
            this._deactivateRange()
        }, _mouseStop: function (a) {
            c.ui.rangeSliderDraggable.prototype._mouseStop.apply(this, [a]);
            this._cacheHandles();
            this._values.min = this._leftHandle("value");
            this._values.max = this._rightHandle("value");
            this._reactivateRange();
            this._leftHandle().trigger("stop");
            this._rightHandle().trigger("stop")
        }, _onDragLeftHandle: function (a, b) {
            this._cacheIfNecessary();
            this._switchedValues() ?
                (this._switchHandles(), this._onDragRightHandle(a, b)) : (this._values.min = b.value, this.cache.offset.left = b.offset.left, this.cache.leftHandle.offset = b.offset, this._positionBar())
        }, _onDragRightHandle: function (a, b) {
            this._cacheIfNecessary();
            this._switchedValues() ? (this._switchHandles(), this._onDragLeftHandle(a, b)) : (this._values.max = b.value, this.cache.rightHandle.offset = b.offset, this._positionBar())
        }, _positionBar: function () {
            var a = this.cache.rightHandle.offset.left + this.cache.rightHandle.width - this.cache.leftHandle.offset.left;
            this.cache.width.inner = a;
            this.element.css("width", a).offset({left: this.cache.leftHandle.offset.left})
        }, _onHandleStop: function () {
            this._setLeftRange();
            this._setRightRange()
        }, _switchedValues: function () {
            if (this.min() > this.max()) {
                var a = this._values.min;
                this._values.min = this._values.max;
                this._values.max = a;
                return !0
            }
            return !1
        }, _switchHandles: function () {
            var a = this.options.leftHandle;
            this.options.leftHandle = this.options.rightHandle;
            this.options.rightHandle = a;
            this._leftHandle("option", "isLeft", !0);
            this._rightHandle("option",
                "isLeft", !1);
            this._bindHandles();
            this._cacheHandles()
        }, _bindHandles: function () {
            this.options.leftHandle.unbind(".bar").bind("sliderDrag.bar update.bar moving.bar", c.proxy(this._onDragLeftHandle, this));
            this.options.rightHandle.unbind(".bar").bind("sliderDrag.bar update.bar moving.bar", c.proxy(this._onDragRightHandle, this))
        }, _constraintPosition: function (a) {
            var b = {};
            b.left = c.ui.rangeSliderDraggable.prototype._constraintPosition.apply(this, [a]);
            b.left = this._leftHandle("position", b.left);
            a = this._rightHandle("position",
                b.left + this.cache.width.outer - this.cache.rightHandle.width);
            b.width = a - b.left + this.cache.rightHandle.width;
            return b
        }, _applyPosition: function (a) {
            c.ui.rangeSliderDraggable.prototype._applyPosition.apply(this, [a.left]);
            this.element.width(a.width)
        }, _mouseWheelZoom: function (a, b, d, e) {
            a = this._values.min + (this._values.max - this._values.min) / 2;
            b = {};
            d = {};
            this.options.range === !1 || this.options.range.min === !1 ? (b.max = a, d.min = a) : (b.max = a - this.options.range.min / 2, d.min = a + this.options.range.min / 2);
            if (this.options.range !== !1 && this.options.range.max !== !1)b.min = a - this.options.range.max / 2, d.max = a + this.options.range.max / 2;
            this._leftHandle("option", "range", b);
            this._rightHandle("option", "range", d);
            clearTimeout(this._wheelTimeout);
            this._wheelTimeout = setTimeout(c.proxy(this._wheelStop, this), 200);
            this.zoomOut(e * this.options.wheelSpeed);
            return !1
        }, _mouseWheelScroll: function (a, b, d, e) {
            this._wheelTimeout === !1 ? this.startScroll() : clearTimeout(this._wheelTimeout);
            this._wheelTimeout = setTimeout(c.proxy(this._wheelStop, this), 200);
            this.scrollLeft(e *
                this.options.wheelSpeed);
            return !1
        }, _wheelStop: function () {
            this.stopScroll();
            this._wheelTimeout = !1
        }, min: function (a) {
            return this._leftHandle("value", a)
        }, max: function (a) {
            return this._rightHandle("value", a)
        }, startScroll: function () {
            this._deactivateRange()
        }, stopScroll: function () {
            this._reactivateRange();
            this._triggerMouseEvent("stop")
        }, scrollLeft: function (a) {
            a = a || 1;
            if (a < 0)return this.scrollRight(-a);
            a = this._leftHandle("moveLeft", a);
            this._rightHandle("moveLeft", a);
            this.update();
            this._triggerMouseEvent("scroll")
        },
        scrollRight: function (a) {
            a = a || 1;
            if (a < 0)return this.scrollLeft(-a);
            a = this._rightHandle("moveRight", a);
            this._leftHandle("moveRight", a);
            this.update();
            this._triggerMouseEvent("scroll")
        }, zoomIn: function (a) {
            a = a || 1;
            if (a < 0)return this.zoomOut(-a);
            var b = this._rightHandle("moveLeft", a);
            a > b && (b /= 2, this._rightHandle("moveRight", b));
            this._leftHandle("moveRight", b);
            this.update();
            this._triggerMouseEvent("zoom")
        }, zoomOut: function (a) {
            a = a || 1;
            if (a < 0)return this.zoomIn(-a);
            var b = this._rightHandle("moveRight", a);
            a > b &&
            (b /= 2, this._rightHandle("moveLeft", b));
            this._leftHandle("moveLeft", b);
            this.update();
            this._triggerMouseEvent("zoom")
        }, values: function (a, b) {
            if (typeof a !== "undefined" && typeof b !== "undefined") {
                var c = Math.min(a, b), e = Math.max(a, b);
                this._deactivateRange();
                this.options.leftHandle.unbind(".bar");
                this.options.rightHandle.unbind(".bar");
                this._values.min = this._leftHandle("value", c);
                this._values.max = this._rightHandle("value", e);
                this._bindHandles();
                this._reactivateRange();
                this.update()
            }
            return {
                min: this._values.min,
                max: this._values.max
            }
        }, update: function () {
            this._values.min = this.min();
            this._values.max = this.max();
            this._cache();
            this._positionBar()
        }
    })
})(jQuery);
(function (c) {
    function a(a, d, e, f) {
        this.label1 = a;
        this.label2 = d;
        this.type = e;
        this.options = f;
        this.handle1 = this.label1[this.type]("option", "handle");
        this.handle2 = this.label2[this.type]("option", "handle");
        this.cache = null;
        this.left = a;
        this.right = d;
        this.updating = this.initialized = this.moving = !1;
        this.Init = function () {
            this.BindHandle(this.handle1);
            this.BindHandle(this.handle2);
            this.options.show === "show" ? (setTimeout(c.proxy(this.PositionLabels, this), 1), this.initialized = !0) : setTimeout(c.proxy(this.AfterInit, this),
                1E3)
        };
        this.AfterInit = function () {
            this.initialized = !0
        };
        this.Cache = function () {
            if (this.label1.css("display") != "none")this.cache = {}, this.cache.label1 = {}, this.cache.label2 = {}, this.cache.handle1 = {}, this.cache.handle2 = {}, this.cache.offsetParent = {}, this.CacheElement(this.label1, this.cache.label1), this.CacheElement(this.label2, this.cache.label2), this.CacheElement(this.handle1, this.cache.handle1), this.CacheElement(this.handle2, this.cache.handle2), this.CacheElement(this.label1.offsetParent(), this.cache.offsetParent)
        };
        this.CacheIfNecessary = function () {
            this.cache === null ? this.Cache() : (this.CacheWidth(this.label1, this.cache.label1), this.CacheWidth(this.label2, this.cache.label2), this.CacheHeight(this.label1, this.cache.label1), this.CacheHeight(this.label2, this.cache.label2), this.CacheWidth(this.label1.offsetParent(), this.cache.offsetParent))
        };
        this.CacheElement = function (a, b) {
            this.CacheWidth(a, b);
            this.CacheHeight(a, b);
            b.offset = a.offset();
            b.margin = {
                left: this.ParsePixels("marginLeft", a), right: this.ParsePixels("marginRight",
                    a)
            };
            b.border = {left: this.ParsePixels("borderLeftWidth", a), right: this.ParsePixels("borderRightWidth", a)}
        };
        this.CacheWidth = function (a, b) {
            b.width = a.width();
            b.outerWidth = a.outerWidth()
        };
        this.CacheHeight = function (a, b) {
            b.outerHeightMargin = a.outerHeight(!0)
        };
        this.ParsePixels = function (a, b) {
            return parseInt(b.css(a), 10) || 0
        };
        this.BindHandle = function (a) {
            a.bind("updating", c.proxy(this.onHandleUpdating, this));
            a.bind("update", c.proxy(this.onHandleUpdated, this));
            a.bind("moving", c.proxy(this.onHandleMoving, this));
            a.bind("stop", c.proxy(this.onHandleStop, this))
        };
        this.PositionLabels = function () {
            this.CacheIfNecessary();
            if (this.cache != null) {
                var a = this.GetRawPosition(this.cache.label1, this.cache.handle1), b = this.GetRawPosition(this.cache.label2, this.cache.handle2);
                this.ConstraintPositions(a, b);
                this.PositionLabel(this.label1, a.left, this.cache.label1);
                this.PositionLabel(this.label2, b.left, this.cache.label2)
            }
        };
        this.PositionLabel = function (a, b, c) {
            var d = this.cache.offsetParent.offset.left + this.cache.offsetParent.border.left;
            d - b >= 0 ? (a.css("right", ""), a.offset({left: b})) : (d += this.cache.offsetParent.width, b = b + c.margin.left + c.outerWidth + c.margin.right, b = d - b, a.css("left", ""), a.css("right", b))
        };
        this.ConstraintPositions = function (a, b) {
            a.center < b.center && a.outerRight > b.outerLeft ? (a = this.getLeftPosition(a, b), this.getRightPosition(a, b)) : a.center > b.center && b.outerRight > a.outerLeft && (b = this.getLeftPosition(b, a), this.getRightPosition(b, a))
        };
        this.getLeftPosition = function (a, b) {
            a.left = (b.center + a.center) / 2 - a.cache.outerWidth - a.cache.margin.right +
                a.cache.border.left;
            return a
        };
        this.getRightPosition = function (a, b) {
            b.left = (b.center + a.center) / 2 + b.cache.margin.left + b.cache.border.left;
            return b
        };
        this.ShowIfNecessary = function () {
            if (!(this.options.show === "show" || this.moving || !this.initialized || this.updating))this.label1.stop(!0, !0).fadeIn(this.options.durationIn || 0), this.label2.stop(!0, !0).fadeIn(this.options.durationIn || 0), this.moving = !0
        };
        this.HideIfNeeded = function () {
            if (this.moving === !0)this.label1.stop(!0, !0).delay(this.options.delayOut || 0).fadeOut(this.options.durationOut ||
                0), this.label2.stop(!0, !0).delay(this.options.delayOut || 0).fadeOut(this.options.durationOut || 0), this.moving = !1
        };
        this.onHandleMoving = function (a, b) {
            this.ShowIfNecessary();
            this.CacheIfNecessary();
            this.UpdateHandlePosition(b);
            this.PositionLabels()
        };
        this.onHandleUpdating = function () {
            this.updating = !0
        };
        this.onHandleUpdated = function () {
            this.updating = !1;
            this.cache = null
        };
        this.onHandleStop = function () {
            this.HideIfNeeded()
        };
        this.UpdateHandlePosition = function (a) {
            this.cache != null && (a.element[0] == this.handle1[0] ? this.UpdatePosition(a,
                this.cache.handle1) : this.UpdatePosition(a, this.cache.handle2))
        };
        this.UpdatePosition = function (a, b) {
            b.offset = a.offset
        };
        this.GetRawPosition = function (a, b) {
            var c = b.offset.left + b.outerWidth / 2, d = c - a.outerWidth / 2, e = d - a.margin.left - a.border.left;
            return {
                left: d,
                outerLeft: e,
                top: b.offset.top - a.outerHeightMargin,
                right: d + a.outerWidth - a.border.left - a.border.right,
                outerRight: e + a.outerWidth + a.margin.left + a.margin.right,
                cache: a,
                center: c
            }
        };
        this.Init()
    }

    c.widget("ui.rangeSliderLabel", c.ui.rangeSliderMouseTouch, {
        options: {
            handle: null,
            formatter: !1,
            handleType: "rangeSliderHandle",
            show: "show",
            durationIn: 0,
            durationOut: 500,
            delayOut: 500,
            isLeft: !1
        }, cache: null, _positionner: null, _valueContainer: null, _innerElement: null, _create: function () {
            this.options.isLeft = this._handle("option", "isLeft");
            this.element.addClass("ui-rangeSlider-label").css("position", "absolute").css("display", "block");
            this._valueContainer = c("<div class='ui-rangeSlider-label-value' />").appendTo(this.element);
            this._innerElement = c("<div class='ui-rangeSlider-label-inner' />").appendTo(this.element);
            this._toggleClass();
            this.options.handle.bind("moving", c.proxy(this._onMoving, this)).bind("update", c.proxy(this._onUpdate, this)).bind("switch", c.proxy(this._onSwitch, this));
            this.options.show !== "show" && this.element.hide();
            this._mouseInit()
        }, _handle: function () {
            return this.options.handle[this.options.handleType].apply(this.options.handle, Array.prototype.slice.apply(arguments))
        }, _setOption: function (a, c) {
            a === "show" ? this._updateShowOption(c) : (a === "durationIn" || a === "durationOut" || a === "delayOut") && this._updateDurations(a,
                c)
        }, _updateShowOption: function (a) {
            this.options.show = a;
            this.options.show !== "show" ? this.element.hide() : (this.element.show(), this._display(this.options.handle[this.options.handleType]("value")), this._positionner.PositionLabels());
            this._positionner.options.show = this.options.show
        }, _updateDurations: function (a, c) {
            parseInt(c) === c && (this._positionner.options[a] = c, this.options[a] = c)
        }, _display: function (a) {
            this.options.formatter == !1 ? this._displayText(Math.round(a)) : this._displayText(this.options.formatter(a))
        },
        _displayText: function (a) {
            this._valueContainer.text(a)
        }, _toggleClass: function () {
            this.element.toggleClass("ui-rangeSlider-leftLabel", this.options.isLeft).toggleClass("ui-rangeSlider-rightLabel", !this.options.isLeft)
        }, _mouseDown: function (a) {
            this.options.handle.trigger(a)
        }, _mouseUp: function (a) {
            this.options.handle.trigger(a)
        }, _mouseMove: function (a) {
            this.options.handle.trigger(a)
        }, _onMoving: function (a, c) {
            this._display(c.value)
        }, _onUpdate: function () {
            this.options.show === "show" && this.update()
        }, _onSwitch: function (a,
                                c) {
            this.options.isLeft = c;
            this._toggleClass();
            this._positionner.PositionLabels()
        }, pair: function (b) {
            if (this._positionner == null)this._positionner = new a(this.element, b, this.widgetName, {
                show: this.options.show,
                durationIn: this.options.durationIn,
                durationOut: this.options.durationOut,
                delayOut: this.options.delayOut
            }), b[this.widgetName]("positionner", this._positionner)
        }, positionner: function (a) {
            if (typeof a !== "undefined")this._positionner = a;
            return this._positionner
        }, update: function () {
            this._positionner.cache = null;
            this._display(this._handle("value"));
            this.options.show == "show" && this._positionner.PositionLabels()
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.rangeSliderHandle", c.ui.rangeSliderDraggable, {
        currentMove: null,
        margin: 0,
        parentElement: null,
        options: {isLeft: !0, bounds: {min: 0, max: 100}, range: !1, value: 0, step: !1},
        _value: 0,
        _left: 0,
        _create: function () {
            c.ui.rangeSliderDraggable.prototype._create.apply(this);
            this.element.css("position", "absolute").css("top", 0).addClass("ui-rangeSlider-handle").toggleClass("ui-rangeSlider-leftHandle", this.options.isLeft).toggleClass("ui-rangeSlider-rightHandle", !this.options.isLeft);
            this._value = this.options.value
        },
        _setOption: function (a, b) {
            if (a === "isLeft" && (b === !0 || b === !1) && b != this.options.isLeft)this.options.isLeft = b, this.element.toggleClass("ui-rangeSlider-leftHandle", this.options.isLeft).toggleClass("ui-rangeSlider-rightHandle", !this.options.isLeft), this._position(this._value), this.element.trigger("switch", this.options.isLeft); else if (a === "step" && this._checkStep(b))this.options.step = b, this.update(); else if (a === "bounds")this.options.bounds = b, this.update(); else if (a === "range" && this._checkRange(b))this.options.range =
                b, this.update();
            c.ui.rangeSliderDraggable.prototype._setOption.apply(this, [a, b])
        },
        _checkRange: function (a) {
            return a === !1 || (typeof a.min === "undefined" || a.min === !1 || parseFloat(a.min) === a.min) && (typeof a.max === "undefined" || a.max === !1 || parseFloat(a.max) === a.max)
        },
        _checkStep: function (a) {
            return a === !1 || parseFloat(a) == a
        },
        _initElement: function () {
            c.ui.rangeSliderDraggable.prototype._initElement.apply(this);
            this.cache.parent.width === 0 || this.cache.parent.width === null ? setTimeout(c.proxy(this._initElement, this),
                500) : (this._position(this.options.value), this._triggerMouseEvent("initialize"))
        },
        _bounds: function () {
            return this.options.bounds
        },
        _cache: function () {
            c.ui.rangeSliderDraggable.prototype._cache.apply(this);
            this._cacheParent()
        },
        _cacheParent: function () {
            var a = this.element.parent();
            this.cache.parent = {
                element: a,
                offset: a.offset(),
                padding: {left: this._parsePixels(a, "paddingLeft")},
                width: a.width()
            }
        },
        _position: function (a) {
            this._applyPosition(this._getPositionForValue(a))
        },
        _constraintPosition: function (a) {
            return this._getPositionForValue(this._getValueForPosition(a))
        },
        _applyPosition: function (a) {
            c.ui.rangeSliderDraggable.prototype._applyPosition.apply(this, [a]);
            this._left = a;
            this._setValue(this._getValueForPosition(a));
            this._triggerMouseEvent("moving")
        },
        _prepareEventData: function () {
            var a = c.ui.rangeSliderDraggable.prototype._prepareEventData.apply(this);
            a.value = this._value;
            return a
        },
        _setValue: function (a) {
            if (a != this._value)this._value = a
        },
        _constraintValue: function (a) {
            a = Math.min(a, this._bounds().max);
            a = Math.max(a, this._bounds().min);
            a = this._round(a);
            if (this.options.range !== !1) {
                var b = this.options.range.min || !1, c = this.options.range.max || !1;
                b !== !1 && (a = Math.max(a, this._round(b)));
                c !== !1 && (a = Math.min(a, this._round(c)))
            }
            return a
        },
        _round: function (a) {
            if (this.options.step !== !1 && this.options.step > 0)return Math.round(a / this.options.step) * this.options.step;
            return a
        },
        _getPositionForValue: function (a) {
            if (this.cache.parent.offset == null)return 0;
            a = this._constraintValue(a);
            return (a - this.options.bounds.min) / (this.options.bounds.max - this.options.bounds.min) * (this.cache.parent.width - this.cache.width.outer) +
                this.cache.parent.offset.left
        },
        _getValueForPosition: function (a) {
            return this._constraintValue(this._getRawValueForPositionAndBounds(a, this.options.bounds.min, this.options.bounds.max))
        },
        _getRawValueForPositionAndBounds: function (a, b, c) {
            return (a - (this.cache.parent.offset == null ? 0 : this.cache.parent.offset.left)) / (this.cache.parent.width - this.cache.width.outer) * (c - b) + b
        },
        value: function (a) {
            typeof a != "undefined" && (this._cache(), a = this._constraintValue(a), this._position(a));
            return this._value
        },
        update: function () {
            this._cache();
            var a = this._constraintValue(this._value), b = this._getPositionForValue(a);
            a != this._value ? (this._triggerMouseEvent("updating"), this._position(a), this._triggerMouseEvent("update")) : b != this.cache.offset.left && (this._triggerMouseEvent("updating"), this._position(a), this._triggerMouseEvent("update"))
        },
        position: function (a) {
            typeof a != "undefined" && (this._cache(), a = this._constraintPosition(a), this._applyPosition(a));
            return this._left
        },
        add: function (a, b) {
            return a + b
        },
        substract: function (a, b) {
            return a - b
        },
        stepsBetween: function (a,
                                b) {
            if (this.options.step === !1)return b - a;
            return (b - a) / this.options.step
        },
        multiplyStep: function (a, b) {
            return a * b
        },
        moveRight: function (a) {
            var b;
            if (this.options.step == !1)return b = this._left, this.position(this._left + a), this._left - b;
            b = this._value;
            this.value(this.add(b, this.multiplyStep(this.options.step, a)));
            return this.stepsBetween(b, this._value)
        },
        moveLeft: function (a) {
            return -this.moveRight(-a)
        },
        stepRatio: function () {
            return this.options.step == !1 ? 1 : this.cache.parent.width / ((this.options.bounds.max - this.options.bounds.min) /
            this.options.step)
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.rangeSlider", {
        options: {
            bounds: {min: 0, max: 100},
            defaultValues: {min: 20, max: 50},
            wheelMode: null,
            wheelSpeed: 4,
            arrows: !0,
            valueLabels: "show",
            formatter: null,
            durationIn: 0,
            durationOut: 400,
            delayOut: 200,
            range: {min: !1, max: !1},
            step: !1
        },
        _values: null,
        _valuesChanged: !1,
        bar: null,
        leftHandle: null,
        rightHandle: null,
        innerBar: null,
        container: null,
        arrows: null,
        labels: null,
        changing: {min: !1, max: !1},
        changed: {min: !1, max: !1},
        _create: function () {
            this._values = {min: this.options.defaultValues.min, max: this.options.defaultValues.max};
            this.labels = {left: null, right: null, leftDisplayed: !0, rightDisplayed: !0};
            this.arrows = {left: null, right: null};
            this.changing = {min: !1, max: !1};
            this.changed = {min: !1, max: !1};
            this.element.css("position") !== "absolute" && this.element.css("position", "relative");
            this.container = c("<div class='ui-rangeSlider-container' />").css("position", "absolute").appendTo(this.element);
            this.innerBar = c("<div class='ui-rangeSlider-innerBar' />").css("position", "absolute").css("top", 0).css("left", 0);
            this.leftHandle = this._createHandle({
                isLeft: !0,
                bounds: this.options.bounds, value: this.options.defaultValues.min, step: this.options.step
            }).appendTo(this.container);
            this.rightHandle = this._createHandle({
                isLeft: !1,
                bounds: this.options.bounds,
                value: this.options.defaultValues.max,
                step: this.options.step
            }).appendTo(this.container);
            this._createBar();
            this.container.prepend(this.innerBar);
            this.arrows.left = this._createArrow("left");
            this.arrows.right = this._createArrow("right");
            this.element.addClass("ui-rangeSlider");
            this.options.arrows ? this.element.addClass("ui-rangeSlider-withArrows") :
                (this.arrows.left.css("display", "none"), this.arrows.right.css("display", "none"), this.element.addClass("ui-rangeSlider-noArrow"));
            this.options.valueLabels !== "hide" ? this._createLabels() : this._destroyLabels();
            this._bindResize();
            setTimeout(c.proxy(this.resize, this), 1);
            setTimeout(c.proxy(this._initValues, this), 1)
        },
        _bindResize: function () {
            var a = this;
            this._resizeProxy = function (b) {
                a.resize(b)
            };
            c(window).resize(this._resizeProxy)
        },
        _initWidth: function () {
            this.container.css("width", this.element.width() - this.container.outerWidth(!0) +
                this.container.width());
            this.innerBar.css("width", this.container.width() - this.innerBar.outerWidth(!0) + this.innerBar.width())
        },
        _initValues: function () {
            this.values(this.options.defaultValues.min, this.options.defaultValues.max)
        },
        _setOption: function (a, b) {
            if (a === "defaultValues") {
                if (typeof b.min !== "undefined" && typeof b.max !== "undefined" && parseFloat(b.min) === b.min && parseFloat(b.max) === b.max)this.options.defaultValues = b
            } else if (a === "wheelMode" || a === "wheelSpeed")this._bar("option", a, b), this.options[a] = this._bar("option",
                a); else if (a === "arrows" && (b === !0 || b === !1) && b !== this.options.arrows)this._setArrowsOption(b); else if (a === "valueLabels")this._setLabelsOption(b); else if (a === "durationIn" || a === "durationOut" || a === "delayOut")this._setLabelsDurations(a, b); else if (a === "formatter" && b !== null && typeof b === "function")this.options.formatter = b, this.options.valueLabels !== "hide" && (this._destroyLabels(), this._createLabels()); else if (a === "bounds" && typeof b.min !== "undefined" && typeof b.max !== "undefined")this.bounds(b.min, b.max); else if (a ===
                "range")this._bar("option", "range", b), this.options.range = this._bar("option", "range"), this._changed(!0); else if (a === "step")this.options.step = b, this._leftHandle("option", "step", b), this._rightHandle("option", "step", b), this._changed(!0)
        },
        _validProperty: function (a, b, c) {
            if (a === null || typeof a[b] === "undefined")return c;
            return a[b]
        },
        _setLabelsOption: function (a) {
            if (!(a !== "hide" && a !== "show" && a !== "change"))this.options.valueLabels = a, a !== "hide" ? (this._createLabels(), this._leftLabel("update"), this._rightLabel("update")) :
                this._destroyLabels()
        },
        _setArrowsOption: function (a) {
            if (a === !0)this.element.removeClass("ui-rangeSlider-noArrow").addClass("ui-rangeSlider-withArrows"), this.arrows.left.css("display", "block"), this.arrows.right.css("display", "block"), this.options.arrows = !0; else if (a === !1)this.element.addClass("ui-rangeSlider-noArrow").removeClass("ui-rangeSlider-withArrows"), this.arrows.left.css("display", "none"), this.arrows.right.css("display", "none"), this.options.arrows = !1;
            this._initWidth()
        },
        _setLabelsDurations: function (a,
                                       b) {
            parseInt(b, 10) === b && (this.labels.left !== null && this._leftLabel("option", a, b), this.labels.right !== null && this._rightLabel("option", a, b), this.options[a] = b)
        },
        _createHandle: function (a) {
            return c("<div />")[this._handleType()](a).bind("sliderDrag", c.proxy(this._changing, this)).bind("stop", c.proxy(this._changed, this))
        },
        _createBar: function () {
            this.bar = c("<div />").prependTo(this.container).bind("sliderDrag scroll zoom", c.proxy(this._changing, this)).bind("stop", c.proxy(this._changed, this));
            this._bar({
                leftHandle: this.leftHandle,
                rightHandle: this.rightHandle,
                values: {min: this.options.defaultValues.min, max: this.options.defaultValues.max},
                type: this._handleType(),
                range: this.options.range,
                wheelMode: this.options.wheelMode,
                wheelSpeed: this.options.wheelSpeed
            });
            this.options.range = this._bar("option", "range");
            this.options.wheelMode = this._bar("option", "wheelMode");
            this.options.wheelSpeed = this._bar("option", "wheelSpeed")
        },
        _createArrow: function (a) {
            var b = c("<div class='ui-rangeSlider-arrow' />").append("<div class='ui-rangeSlider-arrow-inner' />").addClass("ui-rangeSlider-" +
                a + "Arrow").css("position", "absolute").css(a, 0).appendTo(this.element), a = a === "right" ? c.proxy(this._scrollRightClick, this) : c.proxy(this._scrollLeftClick, this);
            b.bind("mousedown touchstart", a);
            return b
        },
        _proxy: function (a, b, c) {
            c = Array.prototype.slice.call(c);
            return a[b].apply(a, c)
        },
        _handleType: function () {
            return "rangeSliderHandle"
        },
        _barType: function () {
            return "rangeSliderBar"
        },
        _bar: function () {
            return this._proxy(this.bar, this._barType(), arguments)
        },
        _labelType: function () {
            return "rangeSliderLabel"
        },
        _leftLabel: function () {
            return this._proxy(this.labels.left,
                this._labelType(), arguments)
        },
        _rightLabel: function () {
            return this._proxy(this.labels.right, this._labelType(), arguments)
        },
        _leftHandle: function () {
            return this._proxy(this.leftHandle, this._handleType(), arguments)
        },
        _rightHandle: function () {
            return this._proxy(this.rightHandle, this._handleType(), arguments)
        },
        _getValue: function (a, b) {
            b === this.rightHandle && (a -= b.outerWidth());
            return a * (this.options.bounds.max - this.options.bounds.min) / (this.container.innerWidth() - b.outerWidth(!0)) + this.options.bounds.min
        },
        _trigger: function (a) {
            var b =
                this;
            setTimeout(function () {
                b.element.trigger(a, {label: b.element, values: b.values()})
            }, 1)
        },
        _changing: function () {
            if (this._updateValues())this._trigger("valuesChanging"), this._valuesChanged = !0
        },
        _changed: function (a) {
            if (this._updateValues() || this._valuesChanged)this._trigger("valuesChanged"), a !== !0 && this._trigger("userValuesChanged"), this._valuesChanged = !1
        },
        _updateValues: function () {
            var a = this._leftHandle("value"), b = this._rightHandle("value"), c = this._min(a, b), e = this._max(a, b), c = c !== this._values.min || e !==
                this._values.max;
            this._values.min = this._min(a, b);
            this._values.max = this._max(a, b);
            return c
        },
        _min: function (a, b) {
            return Math.min(a, b)
        },
        _max: function (a, b) {
            return Math.max(a, b)
        },
        _createLabel: function (a, b) {
            var d;
            a === null ? (d = this._getLabelConstructorParameters(a, b), a = c("<div />").appendTo(this.element)[this._labelType()](d)) : (d = this._getLabelRefreshParameters(a, b), a[this._labelType()](d));
            return a
        },
        _getLabelConstructorParameters: function (a, b) {
            return {
                handle: b,
                handleType: this._handleType(),
                formatter: this._getFormatter(),
                show: this.options.valueLabels,
                durationIn: this.options.durationIn,
                durationOut: this.options.durationOut,
                delayOut: this.options.delayOut
            }
        },
        _getLabelRefreshParameters: function () {
            return {
                formatter: this._getFormatter(),
                show: this.options.valueLabels,
                durationIn: this.options.durationIn,
                durationOut: this.options.durationOut,
                delayOut: this.options.delayOut
            }
        },
        _getFormatter: function () {
            if (this.options.formatter === !1 || this.options.formatter === null)return this._defaultFormatter;
            return this.options.formatter
        },
        _defaultFormatter: function (a) {
            return Math.round(a)
        },
        _destroyLabel: function (a) {
            a !== null && (a.remove(), a = null);
            return a
        },
        _createLabels: function () {
            this.labels.left = this._createLabel(this.labels.left, this.leftHandle);
            this.labels.right = this._createLabel(this.labels.right, this.rightHandle);
            this._leftLabel("pair", this.labels.right)
        },
        _destroyLabels: function () {
            this.labels.left = this._destroyLabel(this.labels.left);
            this.labels.right = this._destroyLabel(this.labels.right)
        },
        _stepRatio: function () {
            return this._leftHandle("stepRatio")
        },
        _scrollRightClick: function (a) {
            a.preventDefault();
            this._bar("startScroll");
            this._bindStopScroll();
            this._continueScrolling("scrollRight", 4 * this._stepRatio(), 1)
        },
        _continueScrolling: function (a, b, c, e) {
            this._bar(a, c);
            e = e || 5;
            e--;
            var f = this, g = Math.max(1, 4 / this._stepRatio());
            this._scrollTimeout = setTimeout(function () {
                e === 0 && (b > 16 ? b = Math.max(16, b / 1.5) : c = Math.min(g, c * 2), e = 5);
                f._continueScrolling(a, b, c, e)
            }, b)
        },
        _scrollLeftClick: function (a) {
            a.preventDefault();
            this._bar("startScroll");
            this._bindStopScroll();
            this._continueScrolling("scrollLeft", 4 * this._stepRatio(),
                1)
        },
        _bindStopScroll: function () {
            var a = this;
            this._stopScrollHandle = function (b) {
                b.preventDefault();
                a._stopScroll()
            };
            c(document).bind("mouseup touchend", this._stopScrollHandle)
        },
        _stopScroll: function () {
            c(document).unbind("mouseup touchend", this._stopScrollHandle);
            this._bar("stopScroll");
            clearTimeout(this._scrollTimeout)
        },
        values: function (a, b) {
            var c = this._bar("values", a, b);
            typeof a !== "undefined" && typeof b !== "undefined" && this._changed(!0);
            return c
        },
        min: function (a) {
            this._values.min = this.values(a, this._values.max).min;
            return this._values.min
        },
        max: function (a) {
            this._values.max = this.values(this._values.min, a).max;
            return this._values.max
        },
        bounds: function (a, b) {
            typeof a !== "undefined" && typeof b !== "undefined" && parseFloat(a) === a && parseFloat(b) === b && a < b && (this._setBounds(a, b), this._changed(!0));
            return this.options.bounds
        },
        _setBounds: function (a, b) {
            this.options.bounds = {min: a, max: b};
            this._leftHandle("option", "bounds", this.options.bounds);
            this._rightHandle("option", "bounds", this.options.bounds);
            this._bar("option", "bounds", this.options.bounds)
        },
        zoomIn: function (a) {
            this._bar("zoomIn", a)
        },
        zoomOut: function (a) {
            this._bar("zoomOut", a)
        },
        scrollLeft: function (a) {
            this._bar("startScroll");
            this._bar("scrollLeft", a);
            this._bar("stopScroll")
        },
        scrollRight: function (a) {
            this._bar("startScroll");
            this._bar("scrollRight", a);
            this._bar("stopScroll")
        },
        resize: function () {
            this._initWidth();
            this._leftHandle("update");
            this._rightHandle("update")
        },
        destroy: function () {
            this.element.removeClass("ui-rangeSlider-withArrows").removeClass("ui-rangeSlider-noArrow");
            this.bar.detach();
            this.leftHandle.detach();
            this.rightHandle.detach();
            this.innerBar.detach();
            this.container.detach();
            this.arrows.left.detach();
            this.arrows.right.detach();
            this.element.removeClass("ui-rangeSlider");
            this._destroyLabels();
            delete this.options;
            c(window).unbind("resize", this._resizeProxy);
            c.Widget.prototype.destroy.apply(this, arguments)
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.dateRangeSliderHandle", c.ui.rangeSliderHandle, {
        _steps: !1, _boundsValues: {}, _create: function () {
            c.ui.rangeSliderHandle.prototype._create.apply(this);
            this._createBoundsValues()
        }, _getValueForPosition: function (a) {
            a = this._getRawValueForPositionAndBounds(a, this.options.bounds.min.valueOf(), this.options.bounds.max.valueOf());
            return this._constraintValue(new Date(a))
        }, _setOption: function (a, b) {
            a === "step" ? (this.options.step = b, this._createSteps(), this.update()) : (c.ui.rangeSliderHandle.prototype._setOption.apply(this,
                [a, b]), a === "bounds" && this._createBoundsValues())
        }, _createBoundsValues: function () {
            this._boundsValues = {min: this.options.bounds.min.valueOf(), max: this.options.bounds.max.valueOf()}
        }, _bounds: function () {
            return this._boundsValues
        }, _createSteps: function () {
            if (this.options.step === !1 || !this._isValidStep())this._steps = !1; else {
                var a = new Date(this.options.bounds.min), b = new Date(this.options.bounds.max), c = a, e = 0;
                for (this._steps = []; c <= b;)this._steps.push(c.valueOf()), c = this._addStep(a, e, this.options.step), e++
            }
        },
        _isValidStep: function () {
            return typeof this.options.step === "object"
        }, _addStep: function (a, b, c) {
            a = new Date(a.valueOf());
            a = this._addThing(a, "FullYear", b, c.years);
            a = this._addThing(a, "Month", b, c.months);
            a = this._addThing(a, "Date", b, c.days);
            a = this._addThing(a, "Hours", b, c.hours);
            a = this._addThing(a, "Minutes", b, c.minutes);
            return a = this._addThing(a, "Seconds", b, c.seconds)
        }, _addThing: function (a, b, c, e) {
            if (c === 0 || (e || 0) === 0)return a;
            a["set" + b](a["get" + b]() + c * (e || 0));
            return a
        }, _round: function (a) {
            if (this._steps === !1)return a;
            for (var b = this.options.bounds.min.valueOf(), c = Math.floor(this._steps.length * Math.max(0, (a - b) / (this.options.bounds.max.valueOf() - b))); this._steps[c] > a;)c--;
            for (; c + 1 < this._steps.length && this._steps[c + 1] <= a;)c++;
            if (c >= this._steps.length - 1)return this._steps[this._steps.length - 1]; else if (c == 0)return this._steps[0];
            b = this._steps[c];
            c = this._steps[c + 1];
            if (a - b < c - a)return b;
            return c
        }, update: function () {
            this._createBoundsValues();
            this._createSteps();
            c.ui.rangeSliderHandle.prototype.update.apply(this)
        },
        add: function (a, b) {
            return this._addStep(new Date(a), 1, b).valueOf()
        }, substract: function (a, b) {
            return this._addStep(new Date(a), -1, b).valueOf()
        }, stepsBetween: function (a, b) {
            if (this.options.step === !1)return val2 - val1;
            var c = Math.min(a, b), e = Math.max(a, b), f = 0, g = !1, h = a > b;
            for (this.add(c, this.options.step) - c < 0 && (g = !0); c < e;)g ? e = this.add(e, this.options.step) : c = this.add(c, this.options.step), f++;
            return h ? -f : f
        }, multiplyStep: function (a, b) {
            var c = {}, e;
            for (e in a)c[e] = a[e] * b;
            return c
        }, stepRatio: function () {
            return this.options.step == !1 ? 1 : this.cache.parent.width / this._steps.length
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.dateRangeSlider", c.ui.rangeSlider, {
        options: {
            bounds: {min: new Date(2010, 0, 1), max: new Date(2012, 0, 1)},
            defaultValues: {min: new Date(2010, 1, 11), max: new Date(2011, 1, 11)}
        }, _create: function () {
            c.ui.rangeSlider.prototype._create.apply(this);
            this.element.addClass("ui-dateRangeSlider")
        }, destroy: function () {
            this.element.removeClass("ui-dateRangeSlider");
            c.ui.rangeSlider.prototype.destroy.apply(this)
        }, _setOption: function (a, b) {
            (a === "defaultValues" || a === "bounds") && typeof b !== "undefined" &&
            b !== null && typeof b.min !== "undefined" && typeof b.max !== "undefined" && b.min instanceof Date && b.max instanceof Date ? c.ui.rangeSlider.prototype._setOption.apply(this, [a, {
                min: b.min.valueOf(),
                max: b.max.valueOf()
            }]) : c.ui.rangeSlider.prototype._setOption.apply(this, this._toArray(arguments))
        }, _handleType: function () {
            return "dateRangeSliderHandle"
        }, option: function (a) {
            if (a === "bounds" || a === "defaultValues") {
                var b = c.ui.rangeSlider.prototype.option.apply(this, arguments);
                return {min: new Date(b.min), max: new Date(b.max)}
            }
            return c.ui.rangeSlider.prototype.option.apply(this,
                this._toArray(arguments))
        }, _defaultFormatter: function (a) {
            var b = a.getMonth() + 1, c = a.getDate();
            return "" + a.getFullYear() + "-" + (b < 10 ? "0" + b : b) + "-" + (c < 10 ? "0" + c : c)
        }, _getFormatter: function () {
            var a = this.options.formatter;
            if (this.options.formatter === !1 || this.options.formatter === null)a = this._defaultFormatter;
            return function (a) {
                return function (c) {
                    return a(new Date(c))
                }
            }(a)
        }, values: function (a, b) {
            var d = null, d = typeof a !== "undefined" && typeof b !== "undefined" && a instanceof Date && b instanceof Date ? c.ui.rangeSlider.prototype.values.apply(this,
                [a.valueOf(), b.valueOf()]) : c.ui.rangeSlider.prototype.values.apply(this, this._toArray(arguments));
            return {min: new Date(d.min), max: new Date(d.max)}
        }, min: function (a) {
            if (typeof a !== "undefined" && a instanceof Date)return new Date(c.ui.rangeSlider.prototype.min.apply(this, [a.valueOf()]));
            return new Date(c.ui.rangeSlider.prototype.min.apply(this))
        }, max: function (a) {
            if (typeof a !== "undefined" && a instanceof Date)return new Date(c.ui.rangeSlider.prototype.max.apply(this, [a.valueOf()]));
            return new Date(c.ui.rangeSlider.prototype.max.apply(this))
        },
        bounds: function (a, b) {
            var d;
            d = typeof a !== "undefined" && a instanceof Date && typeof b !== "undefined" && b instanceof Date ? c.ui.rangeSlider.prototype.bounds.apply(this, [a.valueOf(), b.valueOf()]) : c.ui.rangeSlider.prototype.bounds.apply(this, this._toArray(arguments));
            return {min: new Date(d.min), max: new Date(d.max)}
        }, _toArray: function (a) {
            return Array.prototype.slice.call(a)
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.editRangeSliderLabel", c.ui.rangeSliderLabel, {
        options: {type: "text", step: !1, id: ""}, _input: null, _text: "", _create: function () {
            c.ui.rangeSliderLabel.prototype._create.apply(this);
            this._createInput()
        }, _setOption: function (a, b) {
            a === "type" ? this._setTypeOption(b) : a === "step" && this._setStepOption(b);
            c.ui.rangeSliderLabel.prototype._setOption.apply(this, [a, b])
        }, _createInput: function () {
            this._input = c("<input type='" + this.options.type + "' />").addClass("ui-editRangeSlider-inputValue").appendTo(this._valueContainer);
            this._setInputName();
            this._input.bind("keyup", c.proxy(this._onKeyUp, this));
            this._input.blur(c.proxy(this._onChange, this));
            this.options.type === "number" && (this.options.step !== !1 && this._input.attr("step", this.options.step), this._input.click(c.proxy(this._onChange, this)));
            this._input.val(this._text)
        }, _setInputName: function () {
            this._input.attr("name", this.options.id + (this.options.isLeft ? "left" : "right"))
        }, _onSwitch: function (a, b) {
            c.ui.rangeSliderLabel.prototype._onSwitch.apply(this, [a, b]);
            this._setInputName()
        },
        _destroyInput: function () {
            this._input.detach();
            this._input = null
        }, _onKeyUp: function (a) {
            if (a.which == 13)return this._onChange(a), !1
        }, _onChange: function () {
            var a = this._returnCheckedValue(this._input.val());
            a !== !1 && this._triggerValue(a)
        }, _triggerValue: function (a) {
            this.element.trigger("valueChange", [{
                isLeft: this.options.handle[this.options.handleType]("option", "isLeft"),
                value: a
            }])
        }, _returnCheckedValue: function (a) {
            var b = parseFloat(a);
            if (isNaN(b) || b.toString() != a)return !1;
            return b
        }, _setTypeOption: function (a) {
            if ((a ===
                "text" || a === "number") && this.options.type != a)this._destroyInput(), this.options.type = a, this._createInput()
        }, _setStepOption: function (a) {
            this.options.step = a;
            this.options.type === "number" && this._input.attr("step", a !== !1 ? a : "any")
        }, _displayText: function (a) {
            this._input.val(a);
            this._text = a
        }
    })
})(jQuery);
(function (c) {
    c.widget("ui.editRangeSlider", c.ui.rangeSlider, {
        options: {type: "text", round: 1}, _create: function () {
            c.ui.rangeSlider.prototype._create.apply(this);
            this.element.addClass("ui-editRangeSlider")
        }, destroy: function () {
            this.element.removeClass("ui-editRangeSlider");
            c.ui.rangeSlider.prototype.destroy.apply(this)
        }, _setOption: function (a, b) {
            (a === "type" || a === "step") && this._setLabelOption(a, b);
            a === "type" && (this.options[a] = this.labels.left === null ? b : this._leftLabel("option", a));
            c.ui.rangeSlider.prototype._setOption.apply(this,
                [a, b])
        }, _setLabelOption: function (a, b) {
            this.labels.left !== null && (this._leftLabel("option", a, b), this._rightLabel("option", a, b))
        }, _labelType: function () {
            return "editRangeSliderLabel"
        }, _createLabel: function (a, b) {
            var d = c.ui.rangeSlider.prototype._createLabel.apply(this, [a, b]);
            a === null && d.bind("valueChange", c.proxy(this._onValueChange, this));
            return d
        }, _addPropertiesToParameter: function (a) {
            a.type = this.options.type;
            a.step = this.options.step;
            a.id = this.element.attr("id");
            return a
        }, _getLabelConstructorParameters: function (a,
                                                     b) {
            return this._addPropertiesToParameter(c.ui.rangeSlider.prototype._getLabelConstructorParameters.apply(this, [a, b]))
        }, _getLabelRefreshParameters: function (a, b) {
            return this._addPropertiesToParameter(c.ui.rangeSlider.prototype._getLabelRefreshParameters.apply(this, [a, b]))
        }, _onValueChange: function (a, b) {
            b.isLeft ? this.min(b.value) : this.max(b.value)
        }
    })
})(jQuery);
(function (a) {
    a.uniform = {
        options: {
            selectClass: "selector",
            radioClass: "radio",
            checkboxClass: "checker",
            fileClass: "uploader",
            filenameClass: "filename",
            fileBtnClass: "action",
            fileDefaultText: "No file selected",
            fileBtnText: "Choose File",
            checkedClass: "checked",
            focusClass: "focus",
            disabledClass: "disabled",
            buttonClass: "button",
            activeClass: "active",
            hoverClass: "hover",
            useID: true,
            idPrefix: "uniform",
            resetSelector: false,
            autoHide: true
        }, elements: []
    };
    if (a.browser.msie && a.browser.version < 7) {
        a.support.selectOpacity = false
    } else {
        a.support.selectOpacity = true
    }
    a.fn.uniform = function (k) {
        k = a.extend(a.uniform.options, k);
        var d = this;
        if (k.resetSelector != false) {
            a(k.resetSelector).mouseup(function () {
                function l() {
                    a.uniform.update(d)
                }

                setTimeout(l, 10)
            })
        }
        function j(l) {
            $el = a(l);
            $el.addClass($el.attr("type"));
            b(l)
        }

        function g(l) {
            a(l).addClass("uniform");
            b(l)
        }

        function i(o) {
            var m = a(o);
            var p = a("<div>"), l = a("<span>");
            p.addClass(k.buttonClass);
            if (k.useID && m.attr("id") != "") {
                p.attr("id", k.idPrefix + "-" + m.attr("id"))
            }
            var n;
            if (m.is("a") || m.is("button")) {
                n = m.text()
            } else {
                if (m.is(":submit") || m.is(":reset") || m.is("input[type=button]")) {
                    n = m.attr("value")
                }
            }
            n = n == "" ? m.is(":reset") ? "Reset" : "Submit" : n;
            l.html(n);
            m.css("opacity", 0);
            m.wrap(p);
            m.wrap(l);
            p = m.closest("div");
            l = m.closest("span");
            if (m.is(":disabled")) {
                p.addClass(k.disabledClass)
            }
            p.bind({
                "mouseenter.uniform": function () {
                    p.addClass(k.hoverClass)
                }, "mouseleave.uniform": function () {
                    p.removeClass(k.hoverClass);
                    p.removeClass(k.activeClass)
                }, "mousedown.uniform touchbegin.uniform": function () {
                    p.addClass(k.activeClass)
                }, "mouseup.uniform touchend.uniform": function () {
                    p.removeClass(k.activeClass)
                }, "click.uniform touchend.uniform": function (r) {
                    if (a(r.target).is("span") || a(r.target).is("div")) {
                        if (o[0].dispatchEvent) {
                            var q = document.createEvent("MouseEvents");
                            q.initEvent("click", true, true);
                            o[0].dispatchEvent(q)
                        } else {
                            o[0].click()
                        }
                    }
                }
            });
            o.bind({
                "focus.uniform": function () {
                    p.addClass(k.focusClass)
                }, "blur.uniform": function () {
                    p.removeClass(k.focusClass)
                }
            });
            a.uniform.noSelect(p);
            b(o)
        }

        function e(o) {
            var m = a(o);
            var p = a("<div />"), l = a("<span />");
            if (!m.css("display") == "none" && k.autoHide) {
                p.hide()
            }
            p.addClass(k.selectClass);
            if (k.useID && o.attr("id") != "") {
                p.attr("id", k.idPrefix + "-" + o.attr("id"))
            }
            var n = o.find(":selected:first");
            if (n.length == 0) {
                n = o.find("option:first")
            }
            l.html(n.html());
            o.css("opacity", 0);
            o.wrap(p);
            o.before(l);
            p = o.parent("div");
            l = o.siblings("span");
            o.bind({
                "change.uniform": function () {
                    l.text(o.find(":selected").html());
                    p.removeClass(k.activeClass)
                }, "focus.uniform": function () {
                    p.addClass(k.focusClass)
                }, "blur.uniform": function () {
                    p.removeClass(k.focusClass);
                    p.removeClass(k.activeClass)
                }, "mousedown.uniform touchbegin.uniform": function () {
                    p.addClass(k.activeClass)
                }, "mouseup.uniform touchend.uniform": function () {
                    p.removeClass(k.activeClass)
                }, "click.uniform touchend.uniform": function () {
                    p.removeClass(k.activeClass)
                }, "mouseenter.uniform": function () {
                    p.addClass(k.hoverClass)
                }, "mouseleave.uniform": function () {
                    p.removeClass(k.hoverClass);
                    p.removeClass(k.activeClass)
                }, "keyup.uniform": function () {
                    l.text(o.find(":selected").html())
                }
            });
            if (a(o).attr("disabled")) {
                p.addClass(k.disabledClass)
            }
            a.uniform.noSelect(l);
            b(o)
        }

        function f(n) {
            var m = a(n);
            var o = a("<div />"), l = a("<span />");
            if (!m.css("display") == "none" && k.autoHide) {
                o.hide()
            }
            o.addClass(k.checkboxClass);
            if (k.useID && n.attr("id") != "") {
                o.attr("id", k.idPrefix + "-" + n.attr("id"))
            }
            a(n).wrap(o);
            a(n).wrap(l);
            l = n.parent();
            o = l.parent();
            a(n).css("opacity", 0).bind({
                "focus.uniform": function () {
                    o.addClass(k.focusClass)
                }, "blur.uniform": function () {
                    o.removeClass(k.focusClass)
                }, "click.uniform touchend.uniform": function () {
                    if (!a(n).attr("checked")) {
                        l.removeClass(k.checkedClass)
                    } else {
                        l.addClass(k.checkedClass)
                    }
                }, "mousedown.uniform touchbegin.uniform": function () {
                    o.addClass(k.activeClass)
                }, "mouseup.uniform touchend.uniform": function () {
                    o.removeClass(k.activeClass)
                }, "mouseenter.uniform": function () {
                    o.addClass(k.hoverClass)
                }, "mouseleave.uniform": function () {
                    o.removeClass(k.hoverClass);
                    o.removeClass(k.activeClass)
                }
            });
            if (a(n).attr("checked")) {
                l.addClass(k.checkedClass)
            }
            if (a(n).attr("disabled")) {
                o.addClass(k.disabledClass)
            }
            b(n)
        }

        function c(n) {
            var m = a(n);
            var o = a("<div />"), l = a("<span />");
            if (!m.css("display") == "none" && k.autoHide) {
                o.hide()
            }
            o.addClass(k.radioClass);
            if (k.useID && n.attr("id") != "") {
                o.attr("id", k.idPrefix + "-" + n.attr("id"))
            }
            a(n).wrap(o);
            a(n).wrap(l);
            l = n.parent();
            o = l.parent();
            a(n).css("opacity", 0).bind({
                "focus.uniform": function () {
                    o.addClass(k.focusClass)
                }, "blur.uniform": function () {
                    o.removeClass(k.focusClass)
                }, "click.uniform touchend.uniform": function () {
                    if (!a(n).attr("checked")) {
                        l.removeClass(k.checkedClass)
                    } else {
                        var p = k.radioClass.split(" ")[0];
                        a("." + p + " span." + k.checkedClass + ":has([name='" + a(n).attr("name") + "'])").removeClass(k.checkedClass);
                        l.addClass(k.checkedClass)
                    }
                }, "mousedown.uniform touchend.uniform": function () {
                    if (!a(n).is(":disabled")) {
                        o.addClass(k.activeClass)
                    }
                }, "mouseup.uniform touchbegin.uniform": function () {
                    o.removeClass(k.activeClass)
                }, "mouseenter.uniform touchend.uniform": function () {
                    o.addClass(k.hoverClass)
                }, "mouseleave.uniform": function () {
                    o.removeClass(k.hoverClass);
                    o.removeClass(k.activeClass)
                }
            });
            if (a(n).attr("checked")) {
                l.addClass(k.checkedClass)
            }
            if (a(n).attr("disabled")) {
                o.addClass(k.disabledClass)
            }
            b(n)
        }

        function h(q) {
            var o = a(q);
            var r = a("<div />"), p = a("<span>" + k.fileDefaultText + "</span>"), m = a("<span>" + k.fileBtnText + "</span>");
            if (!o.css("display") == "none" && k.autoHide) {
                r.hide()
            }
            r.addClass(k.fileClass);
            p.addClass(k.filenameClass);
            m.addClass(k.fileBtnClass);
            if (k.useID && o.attr("id") != "") {
                r.attr("id", k.idPrefix + "-" + o.attr("id"))
            }
            o.wrap(r);
            o.after(m);
            o.after(p);
            r = o.closest("div");
            p = o.siblings("." + k.filenameClass);
            m = o.siblings("." + k.fileBtnClass);
            if (!o.attr("size")) {
                var l = r.width();
                o.attr("size", l / 10)
            }
            var n = function () {
                var s = o.val();
                if (s === "") {
                    s = k.fileDefaultText
                } else {
                    s = s.split(/[\/\\]+/);
                    s = s[(s.length - 1)]
                }
                p.text(s)
            };
            n();
            o.css("opacity", 0).bind({
                "focus.uniform": function () {
                    r.addClass(k.focusClass)
                }, "blur.uniform": function () {
                    r.removeClass(k.focusClass)
                }, "mousedown.uniform": function () {
                    if (!a(q).is(":disabled")) {
                        r.addClass(k.activeClass)
                    }
                }, "mouseup.uniform": function () {
                    r.removeClass(k.activeClass)
                }, "mouseenter.uniform": function () {
                    r.addClass(k.hoverClass)
                }, "mouseleave.uniform": function () {
                    r.removeClass(k.hoverClass);
                    r.removeClass(k.activeClass)
                }
            });
            if (a.browser.msie) {
                o.bind("click.uniform.ie7", function () {
                    setTimeout(n, 0)
                })
            } else {
                o.bind("change.uniform", n)
            }
            if (o.attr("disabled")) {
                r.addClass(k.disabledClass)
            }
            a.uniform.noSelect(p);
            a.uniform.noSelect(m);
            b(q)
        }

        a.uniform.restore = function (l) {
            if (l == undefined) {
                l = a(a.uniform.elements)
            }
            a(l).each(function () {
                if (a(this).is(":checkbox")) {
                    a(this).unwrap().unwrap()
                } else {
                    if (a(this).is("select")) {
                        a(this).siblings("span").remove();
                        a(this).unwrap()
                    } else {
                        if (a(this).is(":radio")) {
                            a(this).unwrap().unwrap()
                        } else {
                            if (a(this).is(":file")) {
                                a(this).siblings("span").remove();
                                a(this).unwrap()
                            } else {
                                if (a(this).is("button, :submit, :reset, a, input[type='button']")) {
                                    a(this).unwrap().unwrap()
                                }
                            }
                        }
                    }
                }
                a(this).unbind(".uniform");
                a(this).css("opacity", "1");
                var m = a.inArray(a(l), a.uniform.elements);
                a.uniform.elements.splice(m, 1)
            })
        };
        function b(l) {
            l = a(l).get();
            if (l.length > 1) {
                a.each(l, function (m, n) {
                    a.uniform.elements.push(n)
                })
            } else {
                a.uniform.elements.push(l)
            }
        }

        a.uniform.noSelect = function (l) {
            function m() {
                return false
            }

            a(l).each(function () {
                this.onselectstart = this.ondragstart = m;
                a(this).mousedown(m).css({MozUserSelect: "none"})
            })
        };
        a.uniform.update = function (l) {
            if (l == undefined) {
                l = a(a.uniform.elements)
            }
            l = a(l);
            l.each(function () {
                var n = a(this);
                if (n.is("select")) {
                    var m = n.siblings("span");
                    var p = n.parent("div");
                    p.removeClass(k.hoverClass + " " + k.focusClass + " " + k.activeClass);
                    m.html(n.find(":selected").html());
                    if (n.is(":disabled")) {
                        p.addClass(k.disabledClass)
                    } else {
                        p.removeClass(k.disabledClass)
                    }
                } else {
                    if (n.is(":checkbox")) {
                        var m = n.closest("span");
                        var p = n.closest("div");
                        p.removeClass(k.hoverClass + " " + k.focusClass + " " + k.activeClass);
                        m.removeClass(k.checkedClass);
                        if (n.is(":checked")) {
                            m.addClass(k.checkedClass)
                        }
                        if (n.is(":disabled")) {
                            p.addClass(k.disabledClass)
                        } else {
                            p.removeClass(k.disabledClass)
                        }
                    } else {
                        if (n.is(":radio")) {
                            var m = n.closest("span");
                            var p = n.closest("div");
                            p.removeClass(k.hoverClass + " " + k.focusClass + " " + k.activeClass);
                            m.removeClass(k.checkedClass);
                            if (n.is(":checked")) {
                                m.addClass(k.checkedClass)
                            }
                            if (n.is(":disabled")) {
                                p.addClass(k.disabledClass)
                            } else {
                                p.removeClass(k.disabledClass)
                            }
                        } else {
                            if (n.is(":file")) {
                                var p = n.parent("div");
                                var o = n.siblings(k.filenameClass);
                                btnTag = n.siblings(k.fileBtnClass);
                                p.removeClass(k.hoverClass + " " + k.focusClass + " " + k.activeClass);
                                o.text(n.val());
                                if (n.is(":disabled")) {
                                    p.addClass(k.disabledClass)
                                } else {
                                    p.removeClass(k.disabledClass)
                                }
                            } else {
                                if (n.is(":submit") || n.is(":reset") || n.is("button") || n.is("a") || l.is("input[type=button]")) {
                                    var p = n.closest("div");
                                    p.removeClass(k.hoverClass + " " + k.focusClass + " " + k.activeClass);
                                    if (n.is(":disabled")) {
                                        p.addClass(k.disabledClass)
                                    } else {
                                        p.removeClass(k.disabledClass)
                                    }
                                }
                            }
                        }
                    }
                }
            })
        };
        return this.each(function () {
            if (a.support.selectOpacity) {
                var l = a(this);
                if (l.is("select")) {
                    if (l.attr("multiple") != true) {
                        if (l.attr("size") == undefined || l.attr("size") <= 1) {
                            e(l)
                        }
                    }
                } else {
                    if (l.is(":checkbox")) {
                        f(l)
                    } else {
                        if (l.is(":radio")) {
                            c(l)
                        } else {
                            if (l.is(":file")) {
                                h(l)
                            } else {
                                if (l.is(":text, :password, input[type='email']")) {
                                    j(l)
                                } else {
                                    if (l.is("textarea")) {
                                        g(l)
                                    } else {
                                        if (l.is("a") || l.is(":submit") || l.is(":reset") || l.is("button") || l.is("input[type=button]")) {
                                            i(l)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        })
    }
})(jQuery);
/*
 Copyright 2012 Igor Vaynberg

 Version: 3.2 Timestamp: Mon Sep 10 10:38:04 PDT 2012

 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in
 compliance with the License. You may obtain a copy of the License in the LICENSE file, or at:

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is
 distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations under the License.
 */
(function (e) {
    "undefined" == typeof e.fn.each2 && e.fn.extend({
        each2: function (g) {
            for (var i = e([0]), m = -1, s = this.length; ++m < s && (i.context = i[0] = this[m]) && !1 !== g.call(i[0], m, i););
            return this
        }
    })
})(jQuery);
(function (e, g) {
    function i(a, b) {
        var c = 0, d = b.length, j;
        if ("undefined" === typeof a)return -1;
        if (a.constructor === String)for (; c < d; c += 1) {
            if (0 === a.localeCompare(b[c]))return c
        } else for (; c < d; c += 1)if (j = b[c], j.constructor === String) {
            if (0 === j.localeCompare(a))return c
        } else if (j === a)return c;
        return -1
    }

    function m(a, b) {
        return a === b ? !0 : a === g || b === g || null === a || null === b ? !1 : a.constructor === String ? 0 === a.localeCompare(b) : b.constructor === String ? 0 === b.localeCompare(a) : !1
    }

    function s(a, b) {
        var c, d, j;
        if (null === a || 1 > a.length)return [];
        c = a.split(b);
        d = 0;
        for (j = c.length; d < j; d += 1)c[d] = e.trim(c[d]);
        return c
    }

    function A(a, b, c) {
        var c = c || g, d;
        return function () {
            var j = arguments;
            window.clearTimeout(d);
            d = window.setTimeout(function () {
                b.apply(c, j)
            }, a)
        }
    }

    function l(a) {
        a.preventDefault();
        a.stopPropagation()
    }

    function B(a, b, c) {
        var d = a.toUpperCase().indexOf(b.toUpperCase()), b = b.length;
        0 > d ? c.push(a) : (c.push(a.substring(0, d)), c.push("<span class='select2-match'>"), c.push(a.substring(d, d + b)), c.push("</span>"), c.push(a.substring(d + b, a.length)))
    }

    function C(a) {
        var b,
            c = 0, d = null, j = a.quietMillis || 100;
        return function (h) {
            window.clearTimeout(b);
            b = window.setTimeout(function () {
                var b = c += 1, j = a.data, n = a.transport || e.ajax, f = a.traditional || !1, g = a.type || "GET", j = j.call(this, h.term, h.page, h.context);
                null !== d && d.abort();
                d = n.call(null, {
                    url: a.url,
                    dataType: a.dataType,
                    data: j,
                    type: g,
                    traditional: f,
                    success: function (d) {
                        b < c || (d = a.results(d, h.page), h.callback(d))
                    }
                })
            }, j)
        }
    }

    function D(a) {
        var b = a, c, d = function (a) {
            return "" + a.text
        };
        e.isArray(b) || (d = b.text, e.isFunction(d) || (c = b.text, d = function (a) {
            return a[c]
        }),
            b = b.results);
        return function (a) {
            var c = a.term, f = {results: []}, k;
            if (c === "")a.callback({results: b}); else {
                k = function (b, f) {
                    var g, t, b = b[0];
                    if (b.children) {
                        g = {};
                        for (t in b)b.hasOwnProperty(t) && (g[t] = b[t]);
                        g.children = [];
                        e(b.children).each2(function (a, b) {
                            k(b, g.children)
                        });
                        g.children.length && f.push(g)
                    } else a.matcher(c, d(b)) && f.push(b)
                };
                e(b).each2(function (a, b) {
                    k(b, f.results)
                });
                a.callback(f)
            }
        }
    }

    function E(a) {
        return e.isFunction(a) ? a : function (b) {
            var c = b.term, d = {results: []};
            e(a).each(function () {
                var a = this.text !==
                    g, e = a ? this.text : this;
                if ("" === c || b.matcher(c, e))d.results.push(a ? this : {id: this, text: this})
            });
            b.callback(d)
        }
    }

    function u(a) {
        if (e.isFunction(a))return !0;
        if (!a)return !1;
        throw Error("formatterName must be a function or a falsy value");
    }

    function v(a) {
        return e.isFunction(a) ? a() : a
    }

    function F(a) {
        var b = 0;
        e.each(a, function (a, d) {
            d.children ? b += F(d.children) : b++
        });
        return b
    }

    function H(a, b, c, d) {
        var e = a, h = !1, f, k, n, o;
        if (!d.createSearchChoice || !d.tokenSeparators || 1 > d.tokenSeparators.length)return g;
        for (; ;) {
            h = -1;
            k = 0;
            for (n = d.tokenSeparators.length; k < n && !(o = d.tokenSeparators[k], h = a.indexOf(o), 0 <= h); k++);
            if (0 > h)break;
            f = a.substring(0, h);
            a = a.substring(h + o.length);
            if (0 < f.length && (f = d.createSearchChoice(f, b), f !== g && null !== f && d.id(f) !== g && null !== d.id(f))) {
                h = !1;
                k = 0;
                for (n = b.length; k < n; k++)if (m(d.id(f), d.id(b[k]))) {
                    h = !0;
                    break
                }
                h || c(f)
            }
        }
        if (0 != e.localeCompare(a))return a
    }

    function x(a, b) {
        var c = function () {
        };
        c.prototype = new a;
        c.prototype.constructor = c;
        c.prototype.parent = a.prototype;
        c.prototype = e.extend(c.prototype, b);
        return c
    }

    if (window.Select2 === g) {
        var f, w, y, z, G, q;
        f = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            isArrow: function (a) {
                a = a.which ? a.which : a;
                switch (a) {
                    case f.LEFT:
                    case f.RIGHT:
                    case f.UP:
                    case f.DOWN:
                        return !0
                }
                return !1
            },
            isControl: function (a) {
                switch (a.which) {
                    case f.SHIFT:
                    case f.CTRL:
                    case f.ALT:
                        return !0
                }
                return a.metaKey ? !0 : !1
            },
            isFunctionKey: function (a) {
                a = a.which ? a.which : a;
                return 112 <= a && 123 >= a
            }
        };
        var I = 1;
        G = function () {
            return I++
        };
        e(document).delegate("body", "mousemove", function (a) {
            e.data(document, "select2-lastpos", {x: a.pageX, y: a.pageY})
        });
        e(document).ready(function () {
            e(document).delegate("body", "mousedown touchend", function (a) {
                var b = e(a.target).closest("div.select2-container").get(0), c;
                b ? e(document).find("div.select2-container-active").each(function () {
                    this !== b && e(this).data("select2").blur()
                }) : (b = e(a.target).closest("div.select2-drop").get(0), e(document).find("div.select2-drop-active").each(function () {
                    this !== b && e(this).data("select2").blur()
                }));
                b = e(a.target);
                c = b.attr("for");
                "LABEL" === a.target.tagName && (c && 0 < c.length) && (b = e("#" + c), b = b.data("select2"), b !== g && (b.focus(), a.preventDefault()))
            })
        });
        w = x(Object, {
            bind: function (a) {
                var b = this;
                return function () {
                    a.apply(b, arguments)
                }
            }, init: function (a) {
                var b, c;
                this.opts = a = this.prepareOpts(a);
                this.id = a.id;
                a.element.data("select2") !== g && null !== a.element.data("select2") && this.destroy();
                this.enabled = !0;
                this.container = this.createContainer();
                this.containerId = "s2id_" + (a.element.attr("id") || "autogen" + G());
                this.containerSelector =
                    "#" + this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, "\\$1");
                this.container.attr("id", this.containerId);
                var d = !1, j;
                this.body = function () {
                    !1 === d && (j = a.element.closest("body"), d = !0);
                    return j
                };
                a.element.attr("class") !== g && this.container.addClass(a.element.attr("class").replace(/validate\[[\S ]+] ?/, ""));
                this.container.css(v(a.containerCss));
                this.container.addClass(v(a.containerCssClass));
                this.opts.element.data("select2", this).hide().before(this.container);
                this.container.data("select2",
                    this);
                this.dropdown = this.container.find(".select2-drop");
                this.dropdown.addClass(v(a.dropdownCssClass));
                this.dropdown.data("select2", this);
                this.results = b = this.container.find(".select2-results");
                this.search = c = this.container.find("input.select2-input");
                c.attr("tabIndex", this.opts.element.attr("tabIndex"));
                this.resultsPage = 0;
                this.context = null;
                this.initContainer();
                this.initContainerWidth();
                this.results.bind("mousemove", function (a) {
                    var b = e.data(document, "select2-lastpos");
                    (b === g || b.x !== a.pageX || b.y !== a.pageY) &&
                    e(a.target).trigger("mousemove-filtered", a)
                });
                this.dropdown.delegate(".select2-results", "mousemove-filtered", this.bind(this.highlightUnderEvent));
                var h = this.results, f = A(80, function (a) {
                    h.trigger("scroll-debounced", a)
                });
                h.bind("scroll", function (a) {
                    0 <= i(a.target, h.get()) && f(a)
                });
                this.dropdown.delegate(".select2-results", "scroll-debounced", this.bind(this.loadMoreIfNeeded));
                e.fn.mousewheel && b.mousewheel(function (a, c, d, e) {
                    c = b.scrollTop();
                    0 < e && 0 >= c - e ? (b.scrollTop(0), l(a)) : 0 > e && b.get(0).scrollHeight - b.scrollTop() +
                    e <= b.height() && (b.scrollTop(b.get(0).scrollHeight - b.height()), l(a))
                });
                c.bind("keydown", function () {
                    e.data(c, "keyup-change-value") === g && e.data(c, "keyup-change-value", c.val())
                });
                c.bind("keyup", function () {
                    var a = e.data(c, "keyup-change-value");
                    a !== g && c.val() !== a && (e.removeData(c, "keyup-change-value"), c.trigger("keyup-change"))
                });
                c.bind("keyup-change", this.bind(this.updateResults));
                c.bind("focus", function () {
                    c.addClass("select2-focused");
                    " " === c.val() && c.val("")
                });
                c.bind("blur", function () {
                    c.removeClass("select2-focused")
                });
                this.dropdown.delegate(".select2-results", "mouseup", this.bind(function (a) {
                    0 < e(a.target).closest(".select2-result-selectable:not(.select2-disabled)").length ? (this.highlightUnderEvent(a), this.selectHighlighted(a)) : this.focusSearch();
                    l(a)
                }));
                this.dropdown.bind("click mouseup mousedown", function (a) {
                    a.stopPropagation()
                });
                e.isFunction(this.opts.initSelection) && (this.initSelection(), this.monitorSource());
                (a.element.is(":disabled") || a.element.is("[readonly='readonly']")) && this.disable()
            }, destroy: function () {
                var a =
                    this.opts.element.data("select2");
                a !== g && (a.container.remove(), a.dropdown.remove(), a.opts.element.removeData("select2").unbind(".select2").show())
            }, prepareOpts: function (a) {
                var b, c, d;
                b = a.element;
                "select" === b.get(0).tagName.toLowerCase() && (this.select = c = a.element);
                c && e.each("id multiple ajax query createSearchChoice initSelection data tags".split(" "), function () {
                    if (this in a)throw Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                });
                a = e.extend({}, {
                    populateResults: function (b,
                                               c, d) {
                        var f, n = this.opts.id, o = this;
                        f = function (b, c, j) {
                            var h, l, i, m, r, p, q;
                            h = 0;
                            for (l = b.length; h < l; h = h + 1) {
                                i = b[h];
                                m = n(i) !== g;
                                r = i.children && i.children.length > 0;
                                p = e("<li></li>");
                                p.addClass("select2-results-dept-" + j);
                                p.addClass("select2-result");
                                p.addClass(m ? "select2-result-selectable" : "select2-result-unselectable");
                                r && p.addClass("select2-result-with-children");
                                p.addClass(o.opts.formatResultCssClass(i));
                                m = e("<div></div>");
                                m.addClass("select2-result-label");
                                q = a.formatResult(i, m, d);
                                q !== g && m.html(o.opts.escapeMarkup(q));
                                p.append(m);
                                if (r) {
                                    r = e("<ul></ul>");
                                    r.addClass("select2-result-sub");
                                    f(i.children, r, j + 1);
                                    p.append(r)
                                }
                                p.data("select2-data", i);
                                c.append(p)
                            }
                        };
                        f(c, b, 0)
                    }
                }, e.fn.select2.defaults, a);
                "function" !== typeof a.id && (d = a.id, a.id = function (a) {
                    return a[d]
                });
                if (c)a.query = this.bind(function (a) {
                    var c = {results: [], more: false}, d = a.term, f, n, o;
                    o = function (b, c) {
                        var e;
                        if (b.is("option"))a.matcher(d, b.text(), b) && c.push({
                            id: b.attr("value"),
                            text: b.text(),
                            element: b.get(),
                            css: b.attr("class")
                        }); else if (b.is("optgroup")) {
                            e = {
                                text: b.attr("label"),
                                children: [], element: b.get(), css: b.attr("class")
                            };
                            b.children().each2(function (a, b) {
                                o(b, e.children)
                            });
                            e.children.length > 0 && c.push(e)
                        }
                    };
                    f = b.children();
                    if (this.getPlaceholder() !== g && f.length > 0) {
                        n = f[0];
                        e(n).text() === "" && (f = f.not(n))
                    }
                    f.each2(function (a, b) {
                        o(b, c.results)
                    });
                    a.callback(c)
                }), a.id = function (a) {
                    return a.id
                }, a.formatResultCssClass = function (a) {
                    return a.css
                }; else if (!("query"in a))if ("ajax"in a) {
                    if ((c = a.element.data("ajax-url")) && 0 < c.length)a.ajax.url = c;
                    a.query = C(a.ajax)
                } else"data"in a ? a.query = D(a.data) :
                "tags"in a && (a.query = E(a.tags), a.createSearchChoice = function (a) {
                    return {id: a, text: a}
                }, a.initSelection = function (b, c) {
                    var d = [];
                    e(s(b.val(), a.separator)).each(function () {
                        var b = this, c = this, j = a.tags;
                        e.isFunction(j) && (j = j());
                        e(j).each(function () {
                            if (m(this.id, b)) {
                                c = this.text;
                                return false
                            }
                        });
                        d.push({id: b, text: c})
                    });
                    c(d)
                });
                if ("function" !== typeof a.query)throw"query function not defined for Select2 " + a.element.attr("id");
                return a
            }, monitorSource: function () {
                this.opts.element.bind("change.select2", this.bind(function () {
                    !0 !==
                    this.opts.element.data("select2-change-triggered") && this.initSelection()
                }))
            }, triggerChange: function (a) {
                a = a || {};
                a = e.extend({}, a, {type: "change", val: this.val()});
                this.opts.element.data("select2-change-triggered", !0);
                this.opts.element.trigger(a);
                this.opts.element.data("select2-change-triggered", !1);
                this.opts.element.click();
                this.opts.blurOnChange && this.opts.element.blur()
            }, enable: function () {
                this.enabled || (this.enabled = !0, this.container.removeClass("select2-container-disabled"))
            }, disable: function () {
                this.enabled &&
                (this.close(), this.enabled = !1, this.container.addClass("select2-container-disabled"))
            }, opened: function () {
                return this.container.hasClass("select2-dropdown-open")
            }, positionDropdown: function () {
                var a = this.container.offset(), b = this.container.outerHeight(), c = this.container.outerWidth(), d = this.dropdown.outerHeight(), j = e(window).scrollTop() + document.documentElement.clientHeight, b = a.top + b, f = a.left, j = b + d <= j, g = a.top - d >= this.body().scrollTop(), k = this.dropdown.hasClass("select2-drop-above"), n;
                "static" !== this.body().css("position") &&
                (n = this.body().offset(), b -= n.top, f -= n.left);
                k ? (k = !0, !g && j && (k = !1)) : (k = !1, !j && g && (k = !0));
                k ? (b = a.top - d, this.container.addClass("select2-drop-above"), this.dropdown.addClass("select2-drop-above")) : (this.container.removeClass("select2-drop-above"), this.dropdown.removeClass("select2-drop-above"));
                a = e.extend({top: b, left: f, width: c}, v(this.opts.dropdownCss));
                this.dropdown.css(a)
            }, shouldOpen: function () {
                var a;
                if (this.opened())return !1;
                a = e.Event("open");
                this.opts.element.trigger(a);
                return !a.isDefaultPrevented()
            },
            clearDropdownAlignmentPreference: function () {
                this.container.removeClass("select2-drop-above");
                this.dropdown.removeClass("select2-drop-above")
            }, open: function () {
                if (!this.shouldOpen())return !1;
                window.setTimeout(this.bind(this.opening), 1);
                return !0
            }, opening: function () {
                var a = this.containerId, b = this.containerSelector, c = "scroll." + a, d = "resize." + a;
                this.container.parents().each(function () {
                    e(this).bind(c, function () {
                        var a = e(b);
                        0 == a.length && e(this).unbind(c);
                        a.select2("close")
                    })
                });
                e(window).bind(d, function () {
                    var a =
                        e(b);
                    0 == a.length && e(window).unbind(d);
                    a.select2("close")
                });
                this.clearDropdownAlignmentPreference();
                " " === this.search.val() && this.search.val("");
                this.container.addClass("select2-dropdown-open").addClass("select2-container-active");
                this.updateResults(!0);
                this.dropdown[0] !== this.body().children().last()[0] && this.dropdown.detach().appendTo(this.body());
                this.dropdown.show();
                this.positionDropdown();
                this.dropdown.addClass("select2-drop-active");
                this.ensureHighlightVisible();
                this.focusSearch()
            }, close: function () {
                if (this.opened()) {
                    var a =
                        this;
                    this.container.parents().each(function () {
                        e(this).unbind("scroll." + a.containerId)
                    });
                    e(window).unbind("resize." + this.containerId);
                    this.clearDropdownAlignmentPreference();
                    this.dropdown.hide();
                    this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
                    this.results.empty();
                    this.clearSearch();
                    this.opts.element.trigger(e.Event("close"))
                }
            }, clearSearch: function () {
            }, ensureHighlightVisible: function () {
                var a = this.results, b, c, d, f;
                c = this.highlight();
                0 > c || (0 == c ? a.scrollTop(0) :
                    (b = a.find(".select2-result-selectable"), d = e(b[c]), f = d.offset().top + d.outerHeight(), c === b.length - 1 && (b = a.find("li.select2-more-results"), 0 < b.length && (f = b.offset().top + b.outerHeight())), b = a.offset().top + a.outerHeight(), f > b && a.scrollTop(a.scrollTop() + (f - b)), d = d.offset().top - a.offset().top, 0 > d && a.scrollTop(a.scrollTop() + d)))
            }, moveHighlight: function (a) {
                for (var b = this.results.find(".select2-result-selectable"), c = this.highlight(); -1 < c && c < b.length;) {
                    var c = c + a, d = e(b[c]);
                    if (d.hasClass("select2-result-selectable") && !d.hasClass("select2-disabled")) {
                        this.highlight(c);
                        break
                    }
                }
            }, highlight: function (a) {
                var b = this.results.find(".select2-result-selectable").not(".select2-disabled");
                if (0 === arguments.length)return i(b.filter(".select2-highlighted")[0], b.get());
                a >= b.length && (a = b.length - 1);
                0 > a && (a = 0);
                b.removeClass("select2-highlighted");
                e(b[a]).addClass("select2-highlighted");
                this.ensureHighlightVisible()
            }, countSelectableResults: function () {
                return this.results.find(".select2-result-selectable").not(".select2-disabled").length
            },
            highlightUnderEvent: function (a) {
                a = e(a.target).closest(".select2-result-selectable");
                if (0 < a.length && !a.is(".select2-highlighted")) {
                    var b = this.results.find(".select2-result-selectable");
                    this.highlight(b.index(a))
                } else 0 == a.length && this.results.find(".select2-highlighted").removeClass("select2-highlighted")
            }, loadMoreIfNeeded: function () {
                var a = this.results, b = a.find("li.select2-more-results"), c, d = this.resultsPage + 1, e = this, f = this.search.val(), g = this.context;
                0 !== b.length && (c = b.offset().top - a.offset().top -
                    a.height(), 0 >= c && (b.addClass("select2-active"), this.opts.query({
                    term: f,
                    page: d,
                    context: g,
                    matcher: this.opts.matcher,
                    callback: this.bind(function (c) {
                        e.opened() && (e.opts.populateResults.call(this, a, c.results, {
                            term: f,
                            page: d,
                            context: g
                        }), !0 === c.more ? (b.detach().appendTo(a).text(e.opts.formatLoadMore(d + 1)), window.setTimeout(function () {
                            e.loadMoreIfNeeded()
                        }, 10)) : b.remove(), e.positionDropdown(), e.resultsPage = d)
                    })
                })))
            }, tokenize: function () {
            }, updateResults: function (a) {
                function b() {
                    f.scrollTop(0);
                    d.removeClass("select2-active");
                    k.positionDropdown()
                }

                function c(a) {
                    f.html(k.opts.escapeMarkup(a));
                    b()
                }

                var d = this.search, f = this.results, h = this.opts, i, k = this;
                if (!(!0 !== a && (!1 === this.showSearchInput || !this.opened()))) {
                    d.addClass("select2-active");
                    if (1 <= h.maximumSelectionSize && (i = this.data(), e.isArray(i) && i.length >= h.maximumSelectionSize && u(h.formatSelectionTooBig, "formatSelectionTooBig"))) {
                        c("<li class='select2-selection-limit'>" + h.formatSelectionTooBig(h.maximumSelectionSize) + "</li>");
                        return
                    }
                    d.val().length < h.minimumInputLength && u(h.formatInputTooShort,
                        "formatInputTooShort") ? c("<li class='select2-no-results'>" + h.formatInputTooShort(d.val(), h.minimumInputLength) + "</li>") : (c("<li class='select2-searching'>" + h.formatSearching() + "</li>"), i = this.tokenize(), i != g && null != i && d.val(i), this.resultsPage = 1, h.query({
                        term: d.val(),
                        page: this.resultsPage,
                        context: null,
                        matcher: h.matcher,
                        callback: this.bind(function (i) {
                            var l;
                            this.opened() && ((this.context = i.context === g ? null : i.context, this.opts.createSearchChoice && "" !== d.val() && (l = this.opts.createSearchChoice.call(null,
                                d.val(), i.results), l !== g && null !== l && k.id(l) !== g && null !== k.id(l) && 0 === e(i.results).filter(function () {
                                return m(k.id(this), k.id(l))
                            }).length && i.results.unshift(l)), 0 === i.results.length && u(h.formatNoMatches, "formatNoMatches")) ? c("<li class='select2-no-results'>" + h.formatNoMatches(d.val()) + "</li>") : (f.empty(), k.opts.populateResults.call(this, f, i.results, {
                                term: d.val(),
                                page: this.resultsPage,
                                context: null
                            }), !0 === i.more && u(h.formatLoadMore, "formatLoadMore") && (f.append("<li class='select2-more-results'>" + k.opts.escapeMarkup(h.formatLoadMore(this.resultsPage)) +
                                "</li>"), window.setTimeout(function () {
                                k.loadMoreIfNeeded()
                            }, 10)), this.postprocessResults(i, a), b()))
                        })
                    }))
                }
            }, cancel: function () {
                this.close()
            }, blur: function () {
                this.close();
                this.container.removeClass("select2-container-active");
                this.dropdown.removeClass("select2-drop-active");
                this.search[0] === document.activeElement && this.search.blur();
                this.clearSearch();
                this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus")
            }, focusSearch: function () {
                this.search.show();
                this.search.focus();
                window.setTimeout(this.bind(function () {
                    this.search.show();
                    this.search.focus();
                    this.search.val(this.search.val())
                }), 10)
            }, selectHighlighted: function () {
                var a = this.highlight(), b = this.results.find(".select2-highlighted").not(".select2-disabled"), c = b.closest(".select2-result-selectable").data("select2-data");
                c && (b.addClass("select2-disabled"), this.highlight(a), this.onSelect(c))
            }, getPlaceholder: function () {
                return this.opts.element.attr("placeholder") || this.opts.element.attr("data-placeholder") || this.opts.element.data("placeholder") ||
                    this.opts.placeholder
            }, initContainerWidth: function () {
                var a = function () {
                    var a, c, d, f;
                    if ("off" === this.opts.width)return null;
                    if ("element" === this.opts.width)return 0 === this.opts.element.outerWidth() ? "auto" : this.opts.element.outerWidth() + "px";
                    if ("copy" === this.opts.width || "resolve" === this.opts.width) {
                        a = this.opts.element.attr("style");
                        if (a !== g) {
                            a = a.split(";");
                            d = 0;
                            for (f = a.length; d < f; d += 1)if (c = a[d].replace(/\s/g, "").match(/width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/), null !== c && 1 <= c.length)return c[1]
                        }
                        return "resolve" ===
                        this.opts.width ? (a = this.opts.element.css("width"), 0 < a.indexOf("%") ? a : 0 === this.opts.element.outerWidth() ? "auto" : this.opts.element.outerWidth() + "px") : null
                    }
                    return e.isFunction(this.opts.width) ? this.opts.width() : this.opts.width
                }.call(this);
                null !== a && this.container.attr("style", "width: " + a)
            }
        });
        y = x(w, {
            createContainer: function () {
                return e("<div></div>", {"class": "select2-container"}).html("    <a href='#' onclick='return false;' class='select2-choice'>   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>   <div><b></b></div></a>    <div class='select2-drop select2-offscreen'>   <div class='select2-search'>       <input type='text' autocomplete='off' class='select2-input'/>   </div>   <ul class='select2-results'>   </ul></div>")
            },
            opening: function () {
                this.search.show();
                this.parent.opening.apply(this, arguments);
                this.dropdown.removeClass("select2-offscreen")
            }, close: function () {
                this.opened() && (this.parent.close.apply(this, arguments), this.dropdown.removeAttr("style").addClass("select2-offscreen").insertAfter(this.selection).show())
            }, focus: function () {
                this.close();
                this.selection.focus()
            }, isFocused: function () {
                return this.selection[0] === document.activeElement
            }, cancel: function () {
                this.parent.cancel.apply(this, arguments);
                this.selection.focus()
            },
            initContainer: function () {
                var a, b = this.dropdown;
                this.selection = a = this.container.find(".select2-choice");
                this.search.bind("keydown", this.bind(function (a) {
                    if (this.enabled)if (a.which === f.PAGE_UP || a.which === f.PAGE_DOWN)l(a); else if (this.opened())switch (a.which) {
                        case f.UP:
                        case f.DOWN:
                            this.moveHighlight(a.which === f.UP ? -1 : 1);
                            l(a);
                            break;
                        case f.TAB:
                        case f.ENTER:
                            this.selectHighlighted();
                            l(a);
                            break;
                        case f.ESC:
                            this.cancel(a), l(a)
                    } else a.which === f.TAB || f.isControl(a) || f.isFunctionKey(a) || a.which === f.ESC || !1 ===
                    this.opts.openOnEnter && a.which === f.ENTER || this.open()
                }));
                this.search.bind("focus", this.bind(function () {
                    this.selection.attr("tabIndex", "-1")
                }));
                this.search.bind("blur", this.bind(function () {
                    this.opened() || this.container.removeClass("select2-container-active");
                    window.setTimeout(this.bind(function () {
                        this.selection.attr("tabIndex", this.opts.element.attr("tabIndex"))
                    }), 10)
                }));
                a.bind("mousedown", this.bind(function () {
                    this.opened() ? (this.close(), this.selection.focus()) : this.enabled && this.open()
                }));
                b.bind("mousedown",
                    this.bind(function () {
                        this.search.focus()
                    }));
                a.bind("focus", this.bind(function () {
                    this.container.addClass("select2-container-active");
                    this.search.attr("tabIndex", "-1")
                }));
                a.bind("blur", this.bind(function () {
                    this.opened() || this.container.removeClass("select2-container-active");
                    window.setTimeout(this.bind(function () {
                        this.search.attr("tabIndex", this.opts.element.attr("tabIndex"))
                    }), 10)
                }));
                a.bind("keydown", this.bind(function (a) {
                    if (this.enabled)if (a.which === f.PAGE_UP || a.which === f.PAGE_DOWN)l(a); else if (!(a.which ===
                        f.TAB || f.isControl(a) || f.isFunctionKey(a) || a.which === f.ESC) && !(!1 === this.opts.openOnEnter && a.which === f.ENTER))if (a.which == f.DELETE)this.opts.allowClear && this.clear(); else {
                        this.open();
                        if (a.which !== f.ENTER && !(48 > a.which)) {
                            var b = String.fromCharCode(a.which).toLowerCase();
                            a.shiftKey && (b = b.toUpperCase());
                            this.search.focus();
                            this.search.val(b)
                        }
                        l(a)
                    }
                }));
                a.delegate("abbr", "mousedown", this.bind(function (a) {
                    this.enabled && (this.clear(), l(a), this.close(), this.triggerChange(), this.selection.focus())
                }));
                this.setPlaceholder();
                this.search.bind("focus", this.bind(function () {
                    this.container.addClass("select2-container-active")
                }))
            }, clear: function () {
                this.opts.element.val("");
                this.selection.find("span").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder()
            }, initSelection: function () {
                if ("" === this.opts.element.val())this.close(), this.setPlaceholder(); else {
                    var a = this;
                    this.opts.initSelection.call(null, this.opts.element, function (b) {
                        b !== g && null !== b && (a.updateSelection(b), a.close(), a.setPlaceholder())
                    })
                }
            }, prepareOpts: function () {
                var a =
                    this.parent.prepareOpts.apply(this, arguments);
                "select" === a.element.get(0).tagName.toLowerCase() && (a.initSelection = function (a, c) {
                    var d = a.find(":selected");
                    e.isFunction(c) && c({id: d.attr("value"), text: d.text()})
                });
                return a
            }, setPlaceholder: function () {
                var a = this.getPlaceholder();
                "" === this.opts.element.val() && a !== g && !(this.select && "" !== this.select.find("option:first").text()) && (this.selection.find("span").html(this.opts.escapeMarkup(a)), this.selection.addClass("select2-default"), this.selection.find("abbr").hide())
            },
            postprocessResults: function (a, b) {
                var c = 0, d = this, f = !0;
                this.results.find(".select2-result-selectable").each2(function (a, b) {
                    if (m(d.id(b.data("select2-data")), d.opts.element.val()))return c = a, !1
                });
                this.highlight(c);
                !0 === b && (f = this.showSearchInput = F(a.results) >= this.opts.minimumResultsForSearch, this.dropdown.find(".select2-search")[f ? "removeClass" : "addClass"]("select2-search-hidden"), e(this.dropdown, this.container)[f ? "addClass" : "removeClass"]("select2-with-searchbox"))
            }, onSelect: function (a) {
                var b = this.opts.element.val();
                this.opts.element.val(this.id(a));
                this.updateSelection(a);
                this.close();
                this.selection.focus();
                m(b, this.id(a)) || this.triggerChange()
            }, updateSelection: function (a) {
                var b = this.selection.find("span");
                this.selection.data("select2-data", a);
                b.empty();
                a = this.opts.formatSelection(a, b);
                a !== g && b.append(this.opts.escapeMarkup(a));
                this.selection.removeClass("select2-default");
                this.opts.allowClear && this.getPlaceholder() !== g && this.selection.find("abbr").show()
            }, val: function () {
                var a, b = null, c = this;
                if (0 === arguments.length)return this.opts.element.val();
                a = arguments[0];
                if (this.select)this.select.val(a).find(":selected").each2(function (a, c) {
                    b = {id: c.attr("value"), text: c.text()};
                    return !1
                }), this.updateSelection(b), this.setPlaceholder(); else {
                    if (this.opts.initSelection === g)throw Error("cannot call val() if initSelection() is not defined");
                    a ? (this.opts.element.val(a), this.opts.initSelection(this.opts.element, function (a) {
                        c.opts.element.val(!a ? "" : c.id(a));
                        c.updateSelection(a);
                        c.setPlaceholder()
                    })) : this.clear()
                }
            }, clearSearch: function () {
                this.search.val("")
            },
            data: function (a) {
                var b;
                if (0 === arguments.length)return b = this.selection.data("select2-data"), b == g && (b = null), b;
                !a || "" === a ? this.clear() : (this.opts.element.val(!a ? "" : this.id(a)), this.updateSelection(a))
            }
        });
        z = x(w, {
            createContainer: function () {
                return e("<div></div>", {"class": "select2-container select2-container-multi"}).html("    <ul class='select2-choices'>  <li class='select2-search-field'>    <input type='text' autocomplete='off' class='select2-input'>  </li></ul><div class='select2-drop select2-drop-multi' style='display:none;'>   <ul class='select2-results'>   </ul></div>")
            },
            prepareOpts: function () {
                var a = this.parent.prepareOpts.apply(this, arguments);
                "select" === a.element.get(0).tagName.toLowerCase() && (a.initSelection = function (a, c) {
                    var d = [];
                    a.find(":selected").each2(function (a, b) {
                        d.push({id: b.attr("value"), text: b.text()})
                    });
                    e.isFunction(c) && c(d)
                });
                return a
            }, initContainer: function () {
                var a;
                this.searchContainer = this.container.find(".select2-search-field");
                this.selection = a = this.container.find(".select2-choices");
                this.search.bind("keydown", this.bind(function (b) {
                    if (this.enabled) {
                        if (b.which ===
                            f.BACKSPACE && "" === this.search.val()) {
                            this.close();
                            var c;
                            c = a.find(".select2-search-choice-focus");
                            if (0 < c.length) {
                                this.unselect(c.first());
                                this.search.width(10);
                                l(b);
                                return
                            }
                            c = a.find(".select2-search-choice");
                            0 < c.length && c.last().addClass("select2-search-choice-focus")
                        } else a.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                        if (this.opened())switch (b.which) {
                            case f.UP:
                            case f.DOWN:
                                this.moveHighlight(b.which === f.UP ? -1 : 1);
                                l(b);
                                return;
                            case f.ENTER:
                            case f.TAB:
                                this.selectHighlighted();
                                l(b);
                                return;
                            case f.ESC:
                                this.cancel(b);
                                l(b);
                                return
                        }
                        if (!(b.which === f.TAB || f.isControl(b) || f.isFunctionKey(b) || b.which === f.BACKSPACE || b.which === f.ESC) && !(!1 === this.opts.openOnEnter && b.which === f.ENTER))this.open(), (b.which === f.PAGE_UP || b.which === f.PAGE_DOWN) && l(b)
                    }
                }));
                this.search.bind("keyup", this.bind(this.resizeSearch));
                this.search.bind("blur", this.bind(function (a) {
                    this.container.removeClass("select2-container-active");
                    this.search.removeClass("select2-focused");
                    this.clearSearch();
                    a.stopImmediatePropagation()
                }));
                this.container.delegate(".select2-choices", "mousedown", this.bind(function (a) {
                    this.enabled && !(0 < e(a.target).closest(".select2-search-choice").length) && (this.clearPlaceholder(), this.open(), this.focusSearch(), a.preventDefault())
                }));
                this.container.delegate(".select2-choices", "focus", this.bind(function () {
                    this.enabled && (this.container.addClass("select2-container-active"), this.dropdown.addClass("select2-drop-active"), this.clearPlaceholder())
                }));
                this.clearSearch()
            }, enable: function () {
                this.enabled || (this.parent.enable.apply(this,
                    arguments), this.search.removeAttr("disabled"))
            }, disable: function () {
                this.enabled && (this.parent.disable.apply(this, arguments), this.search.attr("disabled", !0))
            }, initSelection: function () {
                "" === this.opts.element.val() && (this.updateSelection([]), this.close(), this.clearSearch());
                if (this.select || "" !== this.opts.element.val()) {
                    var a = this;
                    this.opts.initSelection.call(null, this.opts.element, function (b) {
                        if (b !== g && b !== null) {
                            a.updateSelection(b);
                            a.close();
                            a.clearSearch()
                        }
                    })
                }
            }, clearSearch: function () {
                var a = this.getPlaceholder();
                a !== g && 0 === this.getVal().length && !1 === this.search.hasClass("select2-focused") ? (this.search.val(a).addClass("select2-default"), this.resizeSearch()) : this.search.val(" ").width(10)
            }, clearPlaceholder: function () {
                this.search.hasClass("select2-default") ? this.search.val("").removeClass("select2-default") : " " === this.search.val() && this.search.val("")
            }, opening: function () {
                this.parent.opening.apply(this, arguments);
                this.clearPlaceholder();
                this.resizeSearch();
                this.focusSearch()
            }, close: function () {
                this.opened() &&
                this.parent.close.apply(this, arguments)
            }, focus: function () {
                this.close();
                this.search.focus()
            }, isFocused: function () {
                return this.search.hasClass("select2-focused")
            }, updateSelection: function (a) {
                var b = [], c = [], d = this;
                e(a).each(function () {
                    0 > i(d.id(this), b) && (b.push(d.id(this)), c.push(this))
                });
                a = c;
                this.selection.find(".select2-search-choice").remove();
                e(a).each(function () {
                    d.addSelectedChoice(this)
                });
                d.postprocessResults()
            }, tokenize: function () {
                var a = this.search.val(), a = this.opts.tokenizer(a, this.data(), this.bind(this.onSelect),
                    this.opts);
                null != a && a != g && (this.search.val(a), 0 < a.length && this.open())
            }, onSelect: function (a) {
                this.addSelectedChoice(a);
                this.select && this.postprocessResults();
                this.opts.closeOnSelect ? (this.close(), this.search.width(10)) : 0 < this.countSelectableResults() ? (this.search.width(10), this.resizeSearch(), this.positionDropdown()) : this.close();
                this.triggerChange({added: a});
                this.focusSearch()
            }, cancel: function () {
                this.close();
                this.focusSearch()
            }, addSelectedChoice: function (a) {
                var b = e("<li class='select2-search-choice'>    <div></div>    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a></li>"),
                    c = this.id(a), d = this.getVal(), f;
                f = this.opts.formatSelection(a, b);
                b.find("div").replaceWith("<div>" + this.opts.escapeMarkup(f) + "</div>");
                b.find(".select2-search-choice-close").bind("mousedown", l).bind("click dblclick", this.bind(function (a) {
                    this.enabled && (e(a.target).closest(".select2-search-choice").fadeOut("fast", this.bind(function () {
                        this.unselect(e(a.target));
                        this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                        this.close();
                        this.focusSearch()
                    })).dequeue(),
                        l(a))
                })).bind("focus", this.bind(function () {
                    this.enabled && (this.container.addClass("select2-container-active"), this.dropdown.addClass("select2-drop-active"))
                }));
                b.data("select2-data", a);
                b.insertBefore(this.searchContainer);
                d.push(c);
                this.setVal(d)
            }, unselect: function (a) {
                var b = this.getVal(), c, d, a = a.closest(".select2-search-choice");
                if (0 === a.length)throw"Invalid argument: " + a + ". Must be .select2-search-choice";
                c = a.data("select2-data");
                d = i(this.id(c), b);
                0 <= d && (b.splice(d, 1), this.setVal(b), this.select &&
                this.postprocessResults());
                a.remove();
                this.triggerChange({removed: c})
            }, postprocessResults: function () {
                var a = this.getVal(), b = this.results.find(".select2-result-selectable"), c = this.results.find(".select2-result-with-children"), d = this;
                b.each2(function (b, c) {
                    var e = d.id(c.data("select2-data"));
                    0 <= i(e, a) ? c.addClass("select2-disabled").removeClass("select2-result-selectable") : c.removeClass("select2-disabled").addClass("select2-result-selectable")
                });
                c.each2(function (a, b) {
                    0 == b.find(".select2-result-selectable").length ?
                        b.addClass("select2-disabled") : b.removeClass("select2-disabled")
                });
                b.each2(function (a, b) {
                    if (!b.hasClass("select2-disabled") && b.hasClass("select2-result-selectable"))return d.highlight(0), !1
                })
            }, resizeSearch: function () {
                var a, b, c, d, f = this.search.outerWidth() - this.search.width();
                a = this.search;
                q || (c = a[0].currentStyle || window.getComputedStyle(a[0], null), q = e("<div></div>").css({
                    position: "absolute",
                    left: "-10000px",
                    top: "-10000px",
                    display: "none",
                    fontSize: c.fontSize,
                    fontFamily: c.fontFamily,
                    fontStyle: c.fontStyle,
                    fontWeight: c.fontWeight,
                    letterSpacing: c.letterSpacing,
                    textTransform: c.textTransform,
                    whiteSpace: "nowrap"
                }), e("body").append(q));
                q.text(a.val());
                a = q.width() + 10;
                b = this.search.offset().left;
                c = this.selection.width();
                d = this.selection.offset().left;
                b = c - (b - d) - f;
                b < a && (b = c - f);
                40 > b && (b = c - f);
                this.search.width(b)
            }, getVal: function () {
                var a;
                if (this.select)return a = this.select.val(), null === a ? [] : a;
                a = this.opts.element.val();
                return s(a, this.opts.separator)
            }, setVal: function (a) {
                var b;
                this.select ? this.select.val(a) : (b =
                    [], e(a).each(function () {
                    0 > i(this, b) && b.push(this)
                }), this.opts.element.val(0 === b.length ? "" : b.join(this.opts.separator)))
            }, val: function () {
                var a, b = [], c = this;
                if (0 === arguments.length)return this.getVal();
                if (a = arguments[0])if (this.setVal(a), this.select)this.select.find(":selected").each(function () {
                    b.push({id: e(this).attr("value"), text: e(this).text()})
                }), this.updateSelection(b); else {
                    if (this.opts.initSelection === g)throw Error("val() cannot be called if initSelection() is not defined");
                    this.opts.initSelection(this.opts.element,
                        function (a) {
                            var b = e(a).map(c.id);
                            c.setVal(b);
                            c.updateSelection(a);
                            c.clearSearch()
                        })
                } else this.opts.element.val(""), this.updateSelection([]);
                this.clearSearch()
            }, onSortStart: function () {
                if (this.select)throw Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
                this.search.width(0);
                this.searchContainer.hide()
            }, onSortEnd: function () {
                var a = [], b = this;
                this.searchContainer.show();
                this.searchContainer.appendTo(this.searchContainer.parent());
                this.resizeSearch();
                this.selection.find(".select2-search-choice").each(function () {
                    a.push(b.opts.id(e(this).data("select2-data")))
                });
                this.setVal(a);
                this.triggerChange()
            }, data: function (a) {
                var b = this, c;
                if (0 === arguments.length)return this.selection.find(".select2-search-choice").map(function () {
                    return e(this).data("select2-data")
                }).get();
                a || (a = []);
                c = e.map(a, function (a) {
                    return b.opts.id(a)
                });
                this.setVal(c);
                this.updateSelection(a);
                this.clearSearch()
            }
        });
        e.fn.select2 = function () {
            var a = Array.prototype.slice.call(arguments, 0), b,
                c, d, f, h = "val destroy opened open close focus isFocused container onSortStart onSortEnd enable disable positionDropdown data".split(" ");
            this.each(function () {
                if (0 === a.length || "object" === typeof a[0])b = 0 === a.length ? {} : e.extend({}, a[0]), b.element = e(this), "select" === b.element.get(0).tagName.toLowerCase() ? f = b.element.attr("multiple") : (f = b.multiple || !1, "tags"in b && (b.multiple = f = !0)), c = f ? new z : new y, c.init(b); else if ("string" === typeof a[0]) {
                    if (0 > i(a[0], h))throw"Unknown method: " + a[0];
                    d = g;
                    c = e(this).data("select2");
                    if (c !== g && (d = "container" === a[0] ? c.container : c[a[0]].apply(c, a.slice(1)), d !== g))return !1
                } else throw"Invalid arguments to select2 plugin: " + a;
            });
            return d === g ? this : d
        };
        e.fn.select2.defaults = {
            width: "copy",
            closeOnSelect: !0,
            openOnEnter: !0,
            containerCss: {},
            dropdownCss: {},
            containerCssClass: "",
            dropdownCssClass: "",
            formatResult: function (a, b, c) {
                b = [];
                B(a.text, c.term, b);
                return b.join("")
            },
            formatSelection: function (a) {
                return a ? a.text : g
            },
            formatResultCssClass: function () {
                return g
            },
            formatNoMatches: function () {
                return "No matches found"
            },
            formatInputTooShort: function (a, b) {
                return "Please enter " + (b - a.length) + " more characters"
            },
            formatSelectionTooBig: function (a) {
                return "You can only select " + a + " item" + (1 == a ? "" : "s")
            },
            formatLoadMore: function () {
                return "Loading more results..."
            },
            formatSearching: function () {
                return "Searching..."
            },
            minimumResultsForSearch: 0,
            minimumInputLength: 0,
            maximumSelectionSize: 0,
            id: function (a) {
                return a.id
            },
            matcher: function (a, b) {
                return 0 <= b.toUpperCase().indexOf(a.toUpperCase())
            },
            separator: ",",
            tokenSeparators: [],
            tokenizer: H,
            escapeMarkup: function (a) {
                return a && "string" === typeof a ? a.replace(/&/g, "&amp;") : a
            },
            blurOnChange: !1
        };
        window.Select2 = {
            query: {ajax: C, local: D, tags: E},
            util: {debounce: A, markMatch: B},
            "class": {"abstract": w, single: y, multi: z}
        }
    }
})(jQuery);
/*! jQuery.counter.js (jQuery Character and Word Counter plugin)
 v2.1 (c) Wilkins Fernandez
 MIT License
 http://archive.plugins.jquery.com/project/word-and-character-counter
 */
(function ($) {
    $.fn.extend({
        counter: function (options) {
            var defaults = {
                    type: 'char', // {char || word}
                    count: 'down', // count {up || down} from or to the goal number
                    goal: 140, // count {to || from} this number
                    text: true, // Show description of counter
                    msg: ''
                },
                $countObj = '',
                countIndex = '',
                noLimit = false,
            // Pass {} as first argument to preserve defaults/options for comparision
                options = $.extend({}, defaults, options),
                methods = {
                    /* Adds the counter to the page and binds counter to user input fields */
                    init: function ($obj) {
                        var objID = $obj.attr('id'),
                            counterID = objID + '_count';

                        // Check if unlimited typing is enabled
                        methods.isLimitless();

                        // Insert counter after text area/box
                        $('<span class="help-block margin-top2"/>').attr('id', objID + '_counter').html('<span id=' + counterID + '/> ' + methods.setMsg()).insertAfter($obj);
                        // Set $countObj jQuery object
                        $countObj = $('#' + counterID);

                        // Bind methods to events
                        methods.bind($obj);
                    },
                    // Bind everything!
                    bind: function ($obj) {
                        $obj.bind("keypress.counter keydown.counter keyup.counter blur.counter focus.counter change.counter paste.counter", methods.updateCounter);
                        $obj.bind("keydown.counter", methods.doStopTyping);
                        $obj.trigger('keydown');
                    },
                    // Enables uninterrupted typing (just counting)
                    isLimitless: function () {
                        if (options.goal === 'sky') {
                            // Override to count up
                            options.count = 'up';
                            // methods.isGoalReached will always return false
                            noLimit = true;

                            return noLimit;
                        }
                    },
                    /* Sets the appropriate message after counter */
                    setMsg: function () {
                        // Show custom message
                        if (options.msg !== '') {
                            return options.msg;
                        }
                        // Show no message
                        if (options.text === false) {
                            return '';
                        }
                        // Only show custom message if there is one
                        if (noLimit) {
                            if (options.msg !== '') {
                                return options.msg;
                            } else {
                                return '';
                            }
                        }

                        this.text = "character word left max".split(' ');
                        this.chars = "s ( )".split(' ');
                        this.msg = null;
                        switch (options.type) {
                            case "char":
                                if (options.count === defaults.count && options.text) {
                                    // x character(s) left
                                    this.msg = this.text[0] + this.chars[1] + this.chars[0] + this.chars[2] + " " + this.text[2];
                                } else if (options.count === "up" && options.text) {
                                    // x characters (x max)
                                    this.msg = this.text[0] + this.chars[0] + " " + this.chars[1] + options.goal + " " + this.text[3] + this.chars[2];
                                }
                                break;
                            case "word":
                                if (options.count === defaults.count && options.text) {
                                    // x word(s) left
                                    this.msg = this.text[1] + this.chars[1] + this.chars[0] + this.chars[2] + " " + this.text[2];
                                } else if (options.count === "up" && options.text) {
                                    // x word(s) (x max)
                                    this.msg = this.text[1] + this.chars[1] + this.chars[0] + this.chars[2] + " " + this.chars[1] + options.goal + " " + this.text[3] + this.chars[2];
                                }
                                break;
                            default:
                        }
                        return this.msg;
                    },
                    /* Returns the amount of words passed in the val argument
                     * @param val Words to count */
                    getWords: function (val) {
                        if (val !== "") {
                            return $.trim(val).replace(/\s+/g, " ").split(" ").length;
                        } else {
                            return 0;
                        }
                    },
                    updateCounter: function (e) {
                        // Save reference to $(this)
                        var $this = $(this);
                        // Is the goal amount passed? (most common when pasting)
                        if (countIndex < 0 || countIndex > options.goal) {
                            methods.passedGoal($this);
                        }
                        // Counting characters...
                        if (options.type === defaults.type) {
                            // ...down
                            if (options.count === defaults.count) {
                                countIndex = options.goal - $this.val().length;
                                // Prevent negative counter
                                if (countIndex <= 0) {
                                    $countObj.text('0');
                                } else {
                                    $countObj.text(countIndex);
                                }
                                // ...up
                            } else if (options.count === 'up') {
                                countIndex = $this.val().length;
                                $countObj.text(countIndex);
                            }

                            // Counting words...
                        } else if (options.type === 'word') {
                            // ...down
                            if (options.count === defaults.count) {
                                // Count words
                                countIndex = methods.getWords($this.val());
                                if (countIndex <= options.goal) {
                                    // Subtract
                                    countIndex = options.goal - countIndex;
                                    // Update text
                                    $countObj.text(countIndex);
                                } else {
                                    // Don't show negative number count
                                    $countObj.text('0');
                                }
                                // ...up
                            } else if (options.count === 'up') {
                                countIndex = methods.getWords($this.val());
                                $countObj.text(countIndex);
                            }
                        }
                        return;
                    },
                    /* Stops the ability to type */
                    doStopTyping: function (e) {
                        // backspace, delete, tab, left, up, right, down, end, home, spacebar
                        var keys = [46, 8, 9, 35, 36, 37, 38, 39, 40, 32];
                        if (methods.isGoalReached(e)) {
                            // NOTE: // Using ( !$.inArray(e.keyCode, keys) ) as a condition causes delays
                            if (e.keyCode !== keys[0] && e.keyCode !== keys[1] && e.keyCode !== keys[2] && e.keyCode !== keys[3] && e.keyCode !== keys[4] && e.keyCode !== keys[5] && e.keyCode !== keys[6] && e.keyCode !== keys[7] && e.keyCode !== keys[8]) {
                                // Stop typing when counting characters
                                if (options.type === defaults.type) {
                                    return false;
                                    // Counting words, only allow backspace & delete
                                } else if (e.keyCode !== keys[9] && e.keyCode !== keys[1] && options.type != defaults.type) {
                                    return true;
                                } else {
                                    return false;
                                }
                            }
                        }
                    },
                    /* Checks to see if the goal number has been reached */
                    isGoalReached: function (e, _goal) {
                        if (noLimit) {
                            return false;
                        }
                        // Counting down
                        if (options.count === defaults.count) {
                            _goal = 0;
                            return (countIndex <= _goal) ? true : false;
                        } else {
                            // Counting up
                            _goal = options.goal;
                            return (countIndex >= _goal) ? true : false;
                        }
                    },
                    /* Removes extra words when the amount of words in the input go over the desired goal.
                     * @param {Number} numOfWords Amount of words you would like shown
                     * @param {String} text The full text to condense */
                    wordStrip: function (numOfWords, text) {
                        var wordCount = text.replace(/\s+/g, ' ').split(' ').length;

                        // Get the word count by counting the spaces (after eliminating trailing white space)
                        text = $.trim(text);

                        // Make it worth executing
                        if (numOfWords <= 0 || numOfWords === wordCount) {
                            return text;
                        } else {
                            text = $.trim(text).split(' ');
                            text.splice(numOfWords, wordCount, '');
                            return $.trim(text.join(' '));
                        }
                    },
                    /* If the goal is passed, trim the chars/words down to what is allowed. Also, reset the counter. */
                    passedGoal: function ($obj) {
                        var userInput = $obj.val();
                        if (options.type === 'word') {
                            $obj.val(methods.wordStrip(options.goal, userInput));
                        }
                        if (options.type === 'char') {
                            $obj.val(userInput.substring(0, options.goal));
                        }
                        // Reset to 0
                        if (options.type === 'down') {
                            $countObj.val('0');
                        }
                        // Reset to goal
                        if (options.type === 'up') {
                            $countObj.val(options.goal);
                        }
                    }
                };
            return this.each(function () {
                methods.init($(this));
            });
        }
    });
})(jQuery);
/**
 *    @name                            Elastic
 *    @descripton                        Elastic is jQuery plugin that grow and shrink your textareas automatically
 *    @version                        1.6.11
 *    @requires                        jQuery 1.2.6+
 *
 *    @author                            Jan Jarfalk
 *    @author-email                    jan.jarfalk@unwrongest.com
 *    @author-website                    http://www.unwrongest.com
 *
 *    @licence                        MIT License - http://www.opensource.org/licenses/mit-license.php
 */

(function ($) {
    jQuery.fn.extend({
        elastic: function () {

            //	We will create a div clone of the textarea
            //	by copying these attributes from the textarea to the div.
            var mimics = [
                'paddingTop',
                'paddingRight',
                'paddingBottom',
                'paddingLeft',
                'fontSize',
                'lineHeight',
                'fontFamily',
                'width',
                'fontWeight',
                'border-top-width',
                'border-right-width',
                'border-bottom-width',
                'border-left-width',
                'borderTopStyle',
                'borderTopColor',
                'borderRightStyle',
                'borderRightColor',
                'borderBottomStyle',
                'borderBottomColor',
                'borderLeftStyle',
                'borderLeftColor'
            ];

            return this.each(function () {

                // Elastic only works on textareas
                if (this.type !== 'textarea') {
                    return false;
                }

                var $textarea = jQuery(this),
                    $twin = jQuery('<div />').css({
                        'position': 'absolute',
                        'display': 'none',
                        'word-wrap': 'break-word',
                        'white-space': 'pre-wrap'
                    }),
                    lineHeight = parseInt($textarea.css('line-height'), 10) || parseInt($textarea.css('font-size'), '10'),
                    minheight = parseInt($textarea.css('height'), 10) || lineHeight * 3,
                    maxheight = parseInt($textarea.css('max-height'), 10) || Number.MAX_VALUE,
                    goalheight = 0;

                // Opera returns max-height of -1 if not set
                if (maxheight < 0) {
                    maxheight = Number.MAX_VALUE;
                }

                // Append the twin to the DOM
                // We are going to meassure the height of this, not the textarea.
                $twin.appendTo($textarea.parent());

                // Copy the essential styles (mimics) from the textarea to the twin
                var i = mimics.length;
                while (i--) {
                    $twin.css(mimics[i].toString(), $textarea.css(mimics[i].toString()));
                }

                // Updates the width of the twin. (solution for textareas with widths in percent)
                function setTwinWidth() {
                    var curatedWidth = Math.floor(parseInt($textarea.width(), 10));
                    if ($twin.width() !== curatedWidth) {
                        $twin.css({'width': curatedWidth + 'px'});

                        // Update height of textarea
                        update(true);
                    }
                }

                // Sets a given height and overflow state on the textarea
                function setHeightAndOverflow(height, overflow) {

                    var curratedHeight = Math.floor(parseInt(height, 10));
                    if ($textarea.height() !== curratedHeight) {
                        $textarea.css({'height': curratedHeight + 'px', 'overflow': overflow});
                    }
                }

                // This function will update the height of the textarea if necessary 
                function update(forced) {

                    // Get curated content from the textarea.
                    var textareaContent = $textarea.val().replace(/&/g, '&amp;').replace(/ {2}/g, '&nbsp;').replace(/<|>/g, '&gt;').replace(/\n/g, '<br />');

                    // Compare curated content with curated twin.
                    var twinContent = $twin.html().replace(/<br>/ig, '<br />');

                    if (forced || textareaContent + '&nbsp;' !== twinContent) {

                        // Add an extra white space so new rows are added when you are at the end of a row.
                        $twin.html(textareaContent + '&nbsp;');

                        // Change textarea height if twin plus the height of one line differs more than 3 pixel from textarea height
                        if (Math.abs($twin.height() + lineHeight - $textarea.height()) > 3) {

                            var goalheight = $twin.height() + lineHeight;
                            if (goalheight >= maxheight) {
                                setHeightAndOverflow(maxheight, 'auto');
                            } else if (goalheight <= minheight) {
                                setHeightAndOverflow(minheight, 'hidden');
                            } else {
                                setHeightAndOverflow(goalheight, 'hidden');
                            }

                        }

                    }

                }

                // Hide scrollbars
                $textarea.css({'overflow': 'hidden'});

                // Update textarea size on keyup, change, cut and paste
                $textarea.bind('keyup change cut paste', function () {
                    update();
                });

                // Update width of twin if browser or textarea is resized (solution for textareas with widths in percent)
                $(window).bind('resize', setTwinWidth);
                $textarea.bind('resize', setTwinWidth);
                $textarea.bind('update', update);

                // Compact textarea on blur
                $textarea.bind('blur', function () {
                    if ($twin.height() < maxheight) {
                        if ($twin.height() > minheight) {
                            $textarea.height($twin.height());
                        } else {
                            $textarea.height(minheight);
                        }
                    }
                });

                // And this line is to catch the browser paste event
                $textarea.bind('input paste', function (e) {
                    setTimeout(update, 250);
                });

                // Run update once when elastic is initialized
                update();

            });

        }
    });
})(jQuery);
/**
 * @license Input Mask plugin for jquery
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 - 2012 Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 1.2.2
 */

(function ($) {
    if ($.fn.inputmask == undefined) {
        $.inputmask = {
            //options default
            defaults: {
                placeholder: "_",
                optionalmarker: {
                    start: "[",
                    end: "]"
                },
                escapeChar: "\\",
                mask: null,
                oncomplete: $.noop, //executes when the mask is complete
                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
                oncleared: $.noop, //executes when the mask is cleared
                repeat: 0, //repetitions of the mask
                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
                clearMaskOnLostFocus: true,
                insertMode: true, //insert the input or overwrite the input
                clearIncomplete: false, //clear the incomplete input on blur
                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
                onKeyUp: $.noop, //override to implement autocomplete on certain keys for example
                onKeyDown: $.noop, //override to implement autocomplete on certain keys for example
                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
                //numeric basic properties
                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
                radixPoint: ".", // | ","
                //numeric basic properties
                definitions: {
                    '9': {
                        validator: "[0-9]",
                        cardinality: 1
                    },
                    'a': {
                        validator: "[A-Za-z\u0410-\u044F\u0401\u0451]",
                        cardinality: 1
                    },
                    '*': {
                        validator: "[A-Za-z\u0410-\u044F\u0401\u04510-9]",
                        cardinality: 1
                    }
                },
                keyCode: {
                    ALT: 18,
                    BACKSPACE: 8,
                    CAPS_LOCK: 20,
                    COMMA: 188,
                    COMMAND: 91,
                    COMMAND_LEFT: 91,
                    COMMAND_RIGHT: 93,
                    CONTROL: 17,
                    DELETE: 46,
                    DOWN: 40,
                    END: 35,
                    ENTER: 13,
                    ESCAPE: 27,
                    HOME: 36,
                    INSERT: 45,
                    LEFT: 37,
                    MENU: 93,
                    NUMPAD_ADD: 107,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    NUMPAD_ENTER: 108,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_SUBTRACT: 109,
                    PAGE_DOWN: 34,
                    PAGE_UP: 33,
                    PERIOD: 190,
                    RIGHT: 39,
                    SHIFT: 16,
                    SPACE: 32,
                    TAB: 9,
                    UP: 38,
                    WINDOWS: 91
                },
                ignorables: [8, 9, 13, 16, 17, 18, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 46, 91, 93, 108]
            },
            val: $.fn.val //store the original jquery val function
        };

        $.fn.inputmask = function (fn, options) {
            var opts = $.extend(true, {}, $.inputmask.defaults, options);
            var pasteEvent = isInputEventSupported('paste') ? 'paste' : 'input';

            var iphone = navigator.userAgent.match(/iphone/i) != null;
            var android = navigator.userAgent.match(/android.*mobile safari.*/i) != null;
            if (android) {
                var browser = navigator.userAgent.match(/mobile safari.*/i);
                var version = parseInt(new RegExp(/[0-9]+/).exec(browser));
                android = version <= 533;
            }
            var caretposCorrection = null;

            if (typeof fn == "string") {
                switch (fn) {
                    case "mask":
                        //init buffer
                        var _buffer = getMaskTemplate();
                        var tests = getTestingChain();

                        return this.each(function () {
                            mask(this);
                        });
                        break;
                    case "unmaskedvalue":
                        var tests = this.data('inputmask')['tests'];
                        var _buffer = this.data('inputmask')['_buffer'];
                        opts.greedy = this.data('inputmask')['greedy'];
                        opts.repeat = this.data('inputmask')['repeat'];
                        opts.definitions = this.data('inputmask')['definitions'];
                        return unmaskedvalue(this);
                        break;
                    case "remove":
                        var tests, _buffer;
                        return this.each(function () {
                            var $input = $(this), input = this;
                            setTimeout(function () {
                                if ($input.data('inputmask')) {
                                    tests = $input.data('inputmask')['tests'];
                                    _buffer = $input.data('inputmask')['_buffer'];
                                    opts.greedy = $input.data('inputmask')['greedy'];
                                    opts.repeat = $input.data('inputmask')['repeat'];
                                    opts.definitions = $input.data('inputmask')['definitions'];
                                    //writeout the unmaskedvalue
                                    input._valueSet(unmaskedvalue($input, true));
                                    //clear data
                                    $input.removeData('inputmask');
                                    //unbind all events
                                    $input.unbind(".inputmask");
                                    $input.removeClass('focus.inputmask');
                                    //restore the value property
                                    var valueProperty;
                                    if (Object.getOwnPropertyDescriptor)
                                        valueProperty = Object.getOwnPropertyDescriptor(input, "value");
                                    if (valueProperty && valueProperty.get) {
                                        if (input._valueGet) {
                                            Object.defineProperty(input, "value", {
                                                get: input._valueGet,
                                                set: input._valueSet
                                            });
                                        }
                                    } else if (document.__lookupGetter__ && input.__lookupGetter__("value")) {
                                        if (input._valueGet) {
                                            input.__defineGetter__("value", input._valueGet);
                                            input.__defineSetter__("value", input._valueSet);
                                        }
                                    }
                                    delete input._valueGet;
                                    delete input._valueSet;
                                }
                            }, 0);
                        });
                        break;
                    case "getemptymask": //return the default (empty) mask value, usefull for setting the default value in validation
                        if (this.data('inputmask'))
                            return this.data('inputmask')['_buffer'].join('');
                        else return "";
                    case "hasMaskedValue": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value 
                        return this.data('inputmask') ? !this.data('inputmask')['autoUnmask'] : false;
                    default:
                        //check if the fn is an alias
                        if (!resolveAlias(fn)) {
                            //maybe fn is a mask so we try
                            //set mask
                            opts.mask = fn;
                        }
                        //init buffer
                        var _buffer = getMaskTemplate();
                        var tests = getTestingChain();

                        return this.each(function () {
                            mask(this);
                        });

                        break;
                }
            }
            if (typeof fn == "object") {
                opts = $.extend(true, {}, $.inputmask.defaults, fn);
                resolveAlias(opts.alias); //resolve aliases
                //init buffer
                var _buffer = getMaskTemplate();
                var tests = getTestingChain();

                return this.each(function () {
                    mask(this);
                });
            }

            //helper functions
            function isInputEventSupported(eventName) {
                var el = document.createElement('input'),
                    eventName = 'on' + eventName,
                    isSupported = (eventName in el);
                if (!isSupported) {
                    el.setAttribute(eventName, 'return;');
                    isSupported = typeof el[eventName] == 'function';
                }
                el = null;
                return isSupported;
            }

            function resolveAlias(aliasStr) {
                var aliasDefinition = opts.aliases[aliasStr];
                if (aliasDefinition) {
                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias); //alias is another alias
                    $.extend(true, opts, aliasDefinition);  //merge alias definition in the options
                    $.extend(true, opts, options);  //reapply extra given options
                    return true;
                }
                return false;
            }

            function getMaskTemplate() {
                var escaped = false, outCount = 0;
                if (opts.mask.length == 1 && opts.greedy == false) {
                    opts.placeholder = "";
                } //hide placeholder with single non-greedy mask
                var singleMask = $.map(opts.mask.split(""), function (element, index) {
                    var outElem = [];
                    if (element == opts.escapeChar) {
                        escaped = true;
                    }
                    else if ((element != opts.optionalmarker.start && element != opts.optionalmarker.end) || escaped) {
                        var maskdef = opts.definitions[element];
                        if (maskdef && !escaped) {
                            for (var i = 0; i < maskdef.cardinality; i++) {
                                outElem.push(getPlaceHolder(outCount + i));
                            }
                        } else {
                            outElem.push(element);
                            escaped = false;
                        }
                        outCount += outElem.length;
                        return outElem;
                    }
                });

                //allocate repetitions
                var repeatedMask = singleMask.slice();
                for (var i = 1; i < opts.repeat && opts.greedy; i++) {
                    repeatedMask = repeatedMask.concat(singleMask.slice());
                }

                return repeatedMask;
            }

            //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol}
            function getTestingChain() {
                var isOptional = false, escaped = false;
                var newBlockMarker = false; //indicates wheter the begin/ending of a block should be indicated

                return $.map(opts.mask.split(""), function (element, index) {
                    var outElem = [];

                    if (element == opts.escapeChar) {
                        escaped = true;
                    } else if (element == opts.optionalmarker.start && !escaped) {
                        isOptional = true;
                        newBlockMarker = true;
                    }
                    else if (element == opts.optionalmarker.end && !escaped) {
                        isOptional = false;
                        newBlockMarker = true;
                    }
                    else {
                        var maskdef = opts.definitions[element];
                        if (maskdef && !escaped) {
                            var prevalidators = maskdef["prevalidator"], prevalidatorsL = prevalidators ? prevalidators.length : 0;
                            for (var i = 1; i < maskdef.cardinality; i++) {
                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator["validator"], cardinality = prevalidator["cardinality"];
                                outElem.push({
                                    fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () {
                                        this.test = validator;
                                    } : new RegExp("."),
                                    cardinality: cardinality ? cardinality : 1,
                                    optionality: isOptional,
                                    newBlockMarker: isOptional == true ? newBlockMarker : false,
                                    offset: 0,
                                    casing: maskdef["casing"],
                                    def: element
                                });
                                if (isOptional == true) //reset newBlockMarker
                                    newBlockMarker = false;
                            }
                            outElem.push({
                                fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () {
                                    this.test = maskdef.validator;
                                } : new RegExp("."),
                                cardinality: maskdef.cardinality,
                                optionality: isOptional,
                                newBlockMarker: newBlockMarker,
                                offset: 0,
                                casing: maskdef["casing"],
                                def: element
                            });
                        } else {
                            outElem.push({
                                fn: null,
                                cardinality: 0,
                                optionality: isOptional,
                                newBlockMarker: newBlockMarker,
                                offset: 0,
                                casing: null,
                                def: element
                            });
                            escaped = false;
                        }
                        //reset newBlockMarker
                        newBlockMarker = false;
                        return outElem;
                    }
                });
            }

            function isValid(pos, c, buffer, strict) { //strict true ~ no correction or autofill
                if (pos < 0 || pos >= getMaskLength()) return false;
                var testPos = determineTestPosition(pos), loopend = c ? 1 : 0, chrs = '';
                for (var i = tests[testPos].cardinality; i > loopend; i--) {
                    chrs += getBufferElement(buffer, testPos - (i - 1));
                }

                if (c) {
                    chrs += c;
                }
                //return is false or a json object => { pos: ??, c: ??}
                return tests[testPos].fn != null ? tests[testPos].fn.test(chrs, buffer, pos, strict, opts) : false;
            }

            function isMask(pos) {
                var testPos = determineTestPosition(pos);
                var test = tests[testPos];

                return test != undefined ? test.fn : false;
            }

            function determineTestPosition(pos) {
                return pos % tests.length;
            }

            function getPlaceHolder(pos) {
                return opts.placeholder.charAt(pos % opts.placeholder.length);
            }

            function getMaskLength() {
                var calculatedLength = _buffer.length;
                if (!opts.greedy && opts.repeat > 1) {
                    calculatedLength += (_buffer.length * (opts.repeat - 1));
                }
                return calculatedLength;
            }

            //pos: from position
            function seekNext(buffer, pos) {
                var maskL = getMaskLength();
                if (pos >= maskL) return maskL;
                var position = pos;
                while (++position < maskL && !isMask(position)) {
                }
                ;
                return position;
            }

            //pos: from position
            function seekPrevious(buffer, pos) {
                var position = pos;
                if (position <= 0) return 0;

                while (--position > 0 && !isMask(position)) {
                }
                ;
                return position;
            }

            function setBufferElement(buffer, position, element) {
                //position = prepareBuffer(buffer, position);

                var test = tests[determineTestPosition(position)];
                var elem = element;
                if (elem != undefined) {
                    switch (test.casing) {
                        case "upper":
                            elem = element.toUpperCase();
                            break;
                        case "lower":
                            elem = element.toLowerCase();
                            break;
                    }
                }

                buffer[position] = elem;
            }

            function getBufferElement(buffer, position, autoPrepare) {
                if (autoPrepare) position = prepareBuffer(buffer, position);
                return buffer[position];
            }

            //needed to handle the non-greedy mask repetitions
            function prepareBuffer(buffer, position, isRTL) {
                var j;
                if (isRTL) {
                    while (position < 0 && buffer.length < getMaskLength()) {
                        j = _buffer.length - 1;
                        position = _buffer.length;
                        while (_buffer[j] !== undefined) {
                            buffer.unshift(_buffer[j--]);
                        }
                    }
                } else {
                    while (buffer[position] == undefined && buffer.length < getMaskLength()) {
                        j = 0;
                        while (_buffer[j] !== undefined) { //add a new buffer
                            buffer.push(_buffer[j++]);
                        }
                    }
                }

                return position;
            }

            function writeBuffer(input, buffer, caretPos) {
                input._valueSet(buffer.join(''));
                if (caretPos != undefined) {
                    if (android) {
                        setTimeout(function () {
                            caret(input, caretPos);
                        }, 100);
                    }
                    else caret(input, caretPos);
                }
            };
            function clearBuffer(buffer, start, end) {
                for (var i = start, maskL = getMaskLength(); i < end && i < maskL; i++) {
                    setBufferElement(buffer, i, getBufferElement(_buffer.slice(), i));
                }
            };

            function setReTargetPlaceHolder(buffer, pos) {
                var testPos = determineTestPosition(pos);
                setBufferElement(buffer, pos, getBufferElement(_buffer, testPos));
            }

            function checkVal(input, buffer, clearInvalid, skipRadixHandling) {
                var isRTL = $(input).data('inputmask')['isRTL'],
                    inputValue = truncateInput(input._valueGet(), isRTL).split('');

                if (isRTL) { //align inputValue for RTL/numeric input
                    var maskL = getMaskLength();
                    var inputValueRev = inputValue.reverse();
                    inputValueRev.length = maskL;

                    for (var i = 0; i < maskL; i++) {
                        var targetPosition = determineTestPosition(maskL - (i + 1));
                        if (tests[targetPosition].fn == null && inputValueRev[i] != getBufferElement(_buffer, targetPosition)) {
                            inputValueRev.splice(i, 0, getBufferElement(_buffer, targetPosition));
                            inputValueRev.length = maskL;
                        } else {
                            inputValueRev[i] = inputValueRev[i] || getBufferElement(_buffer, targetPosition);
                        }
                    }
                    inputValue = inputValueRev.reverse();
                }
                clearBuffer(buffer, 0, buffer.length);
                buffer.length = _buffer.length;
                var lastMatch = -1, checkPosition = -1, np, maskL = getMaskLength(), ivl = inputValue.length, rtlMatch = ivl == 0 ? maskL : -1;
                for (var i = 0; i < ivl; i++) {
                    for (var pos = checkPosition + 1; pos < maskL; pos++) {
                        if (isMask(pos)) {
                            var c = inputValue[i];
                            if ((np = isValid(pos, c, buffer, !clearInvalid)) !== false) {
                                if (np !== true) {
                                    pos = np.pos || pos; //set new position from isValid
                                    c = np.c || c; //set new char from isValid
                                }
                                setBufferElement(buffer, pos, c);
                                lastMatch = checkPosition = pos;
                            } else {
                                setReTargetPlaceHolder(buffer, pos);
                                if (c == getPlaceHolder(pos)) {
                                    checkPosition = pos;
                                    rtlMatch = pos;
                                }
                            }
                            break;
                        } else {   //nonmask
                            setReTargetPlaceHolder(buffer, pos);
                            if (lastMatch == checkPosition) //once outsync the nonmask cannot be the lastmatch
                                lastMatch = pos;
                            checkPosition = pos;
                            if (inputValue[i] == getBufferElement(buffer, pos))
                                break;
                        }
                    }
                }
                //Truncate buffer when using non-greedy masks
                if (opts.greedy == false) {
                    var newBuffer = truncateInput(buffer.join(''), isRTL).split('');
                    while (buffer.length != newBuffer.length) {  //map changes into the original buffer
                        isRTL ? buffer.shift() : buffer.pop();
                    }
                }

                if (clearInvalid) {
                    writeBuffer(input, buffer);
                }
                return isRTL ? (opts.numericInput ? ($.inArray(opts.radixPoint, buffer) != -1 && skipRadixHandling !== true ? $.inArray(opts.radixPoint, buffer) : seekNext(buffer, maskL)) : seekNext(buffer, rtlMatch)) : seekNext(buffer, lastMatch);
            }

            function escapeRegex(str) {
                var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
                return str.replace(new RegExp('(\\' + specials.join('|\\') + ')', 'gim'), '\\$1');
            }

            function truncateInput(inputValue, rtl) {
                return rtl ? inputValue.replace(new RegExp("^(" + escapeRegex(_buffer.join('')) + ")*"), "") : inputValue.replace(new RegExp("(" + escapeRegex(_buffer.join('')) + ")*$"), "");
            }

            function clearOptionalTail(input, buffer) {
                checkVal(input, buffer, false);
                var tmpBuffer = buffer.slice();
                if ($(input).data('inputmask')['isRTL']) {
                    for (var pos = 0; pos <= tmpBuffer.length - 1; pos++) {
                        var testPos = determineTestPosition(pos);
                        if (tests[testPos].optionality) {
                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))
                                tmpBuffer.splice(0, 1);
                            else break;
                        } else break;
                    }
                } else {
                    for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {
                        var testPos = determineTestPosition(pos);
                        if (tests[testPos].optionality) {
                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))
                                tmpBuffer.pop();
                            else break;
                        } else break;
                    }
                }
                writeBuffer(input, tmpBuffer);
            }

            //functionality fn
            function unmaskedvalue($input, skipDatepickerCheck) {
                var input = $input[0];
                if (tests && (skipDatepickerCheck === true || !$input.hasClass('hasDatepicker'))) {
                    var buffer = _buffer.slice();
                    checkVal(input, buffer);
                    return $.map(buffer, function (element, index) {
                        return isMask(index) && element != getBufferElement(_buffer.slice(), index) ? element : null;
                    }).join('');
                }
                else {
                    return input._valueGet();
                }
            }

            function caret(input, begin, end) {
                var npt = input.jquery && input.length > 0 ? input[0] : input;
                if (typeof begin == 'number') {
                    end = (typeof end == 'number') ? end : begin;
                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode
                    if (npt.setSelectionRange) {
                        npt.setSelectionRange(begin, end);
                    } else if (npt.createTextRange) {
                        var range = npt.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', begin);
                        range.select();
                    }
                    npt.focus();
                    if (android && end != npt.selectionEnd) caretposCorrection = {begin: begin, end: end};
                } else {
                    var caretpos = android ? caretposCorrection : null, caretposCorrection = null;
                    if (caretpos == null) {
                        if (npt.setSelectionRange) {
                            begin = npt.selectionStart;
                            end = npt.selectionEnd;
                        } else if (document.selection && document.selection.createRange) {
                            var range = document.selection.createRange();
                            begin = 0 - range.duplicate().moveStart('character', -100000);
                            end = begin + range.text.length;
                        }
                        caretpos = {begin: begin, end: end};
                    }
                    return caretpos;
                }
            };

            function mask(el) {
                var $input = $(el);
                if (!$input.is(":input")) return;

                //correct greedy setting if needed
                opts.greedy = opts.greedy ? opts.greedy : opts.repeat == 0;

                //handle maxlength attribute
                var maxLength = $input.prop('maxLength');
                if (getMaskLength() > maxLength && maxLength > -1) { //FF sets no defined max length to -1 
                    if (maxLength < _buffer.length) _buffer.length = maxLength;
                    if (opts.greedy == false) {
                        opts.repeat = Math.round(maxLength / _buffer.length);
                    }
                }
                $input.prop('maxLength', getMaskLength() * 2);

                //store tests & original buffer in the input element - used to get the unmasked value
                $input.data('inputmask', {
                    'tests': tests,
                    '_buffer': _buffer,
                    'greedy': opts.greedy,
                    'repeat': opts.repeat,
                    'autoUnmask': opts.autoUnmask,
                    'definitions': opts.definitions,
                    'isRTL': false
                });

                patchValueProperty(el);

                //init vars
                var buffer = _buffer.slice(),
                    undoBuffer = el._valueGet(),
                    skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
                    ignorable = false,
                    lastPosition = -1,
                    firstMaskPos = seekNext(buffer, -1),
                    lastMaskPos = seekPrevious(buffer, getMaskLength()),
                    isRTL = false;
                if (el.dir == "rtl" || opts.numericInput) {
                    el.dir = "ltr"
                    $input.css("text-align", "right");
                    $input.removeAttr("dir");
                    var inputData = $input.data('inputmask');
                    inputData['isRTL'] = true;
                    $input.data('inputmask', inputData);
                    isRTL = true;
                }

                //unbind all events - to make sure that no other mask will interfere when re-masking
                $input.unbind(".inputmask");
                $input.removeClass('focus.inputmask');
                //bind events
                $input.bind("mouseenter.inputmask", function () {
                    var $input = $(this), input = this;
                    if (!$input.hasClass('focus.inputmask') && opts.showMaskOnHover) {
                        var nptL = input._valueGet().length;
                        if (nptL < buffer.length) {
                            if (nptL == 0)
                                buffer = _buffer.slice();
                            writeBuffer(input, buffer);
                        }
                    }
                }).bind("blur.inputmask", function () {
                    var $input = $(this), input = this, nptValue = input._valueGet();
                    $input.removeClass('focus.inputmask');
                    if (nptValue != undoBuffer) {
                        $input.change();
                    }
                    if (opts.clearMaskOnLostFocus) {
                        if (nptValue == _buffer.join(''))
                            input._valueSet('');
                        else { //clearout optional tail of the mask
                            clearOptionalTail(input, buffer);
                        }
                    }
                    if (!isComplete(input)) {
                        $input.trigger("incomplete");
                        if (opts.clearIncomplete) {
                            if (opts.clearMaskOnLostFocus)
                                input._valueSet('');
                            else {
                                buffer = _buffer.slice();
                                writeBuffer(input, buffer);
                            }
                        }
                    }
                }).bind("focus.inputmask", function () {
                    var $input = $(this), input = this;
                    if (!$input.hasClass('focus.inputmask') && !opts.showMaskOnHover) {
                        var nptL = input._valueGet().length;
                        if (nptL < buffer.length) {
                            if (nptL == 0)
                                buffer = _buffer.slice();
                            caret(input, checkVal(input, buffer, true));
                        }
                    }
                    $input.addClass('focus.inputmask');
                    undoBuffer = input._valueGet();
                }).bind("mouseleave.inputmask", function () {
                    var $input = $(this), input = this;
                    if (opts.clearMaskOnLostFocus) {
                        if (!$input.hasClass('focus.inputmask')) {
                            if (input._valueGet() == _buffer.join('') || input._valueGet() == '')
                                input._valueSet('');
                            else { //clearout optional tail of the mask
                                clearOptionalTail(input, buffer);
                            }
                        }
                    }
                }).bind("click.inputmask", function () {
                    var input = this;
                    setTimeout(function () {
                        var selectedCaret = caret(input);
                        if (selectedCaret.begin == selectedCaret.end) {
                            var clickPosition = selectedCaret.begin;
                            lastPosition = checkVal(input, buffer, false);
                            if (isRTL)
                                caret(input, clickPosition > lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
                            else
                                caret(input, clickPosition < lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
                        }
                    }, 0);
                }).bind('dblclick.inputmask', function () {
                    var input = this;
                    setTimeout(function () {
                        caret(input, 0, lastPosition);
                    }, 0);
                }).bind("keydown.inputmask", keydownEvent
                ).bind("keypress.inputmask", keypressEvent
                ).bind("keyup.inputmask", keyupEvent
                ).bind(pasteEvent + ".inputmask, dragdrop.inputmask, drop.inputmask", function () {
                        var input = this;
                        setTimeout(function () {
                            caret(input, checkVal(input, buffer, true));
                        }, 0);
                    }).bind('setvalue.inputmask', function () {
                        var input = this;
                        undoBuffer = input._valueGet();
                        checkVal(input, buffer, true);
                        if (input._valueGet() == _buffer.join(''))
                            input._valueSet('');
                    }).bind('complete.inputmask', opts.oncomplete)
                    .bind('incomplete.inputmask', opts.onincomplete)
                    .bind('cleared.inputmask', opts.oncleared);

                //apply mask
                lastPosition = checkVal(el, buffer, true);

                // Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
                var activeElement;
                try {
                    activeElement = document.activeElement;
                } catch (e) {
                }
                if (activeElement === el) { //position the caret when in focus
                    $input.addClass('focus.inputmask');
                    caret(el, lastPosition);
                } else if (opts.clearMaskOnLostFocus) {
                    if (el._valueGet() == _buffer.join('')) {
                        el._valueSet('');
                    } else {
                        clearOptionalTail(el, buffer);
                    }
                }

                installEventRuler(el);

                //private functions
                function isComplete(npt) {
                    var complete = true, nptValue = npt._valueGet(), ml = nptValue.length;
                    for (var i = 0; i < ml; i++) {
                        if (isMask(i) && nptValue.charAt(i) == getPlaceHolder(i)) {
                            complete = false;
                            break;
                        }
                    }
                    return complete;
                }


                function installEventRuler(npt) {
                    var events = $._data(npt).events;

                    $.each(events, function (eventType, eventHandlers) {
                        $(npt).bind(eventType + ".inputmask", function (event) {
                            if (this.readOnly || this.disabled) {
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                return false;
                            }
                        });
                        //!! the bound handlers are executed in the order they where bound
                        //reorder the events
                        var ourHandler = eventHandlers[eventHandlers.length - 1];
                        for (var i = eventHandlers.length - 1; i > 0; i--) {
                            eventHandlers[i] = eventHandlers[i - 1];
                        }
                        eventHandlers[0] = ourHandler;
                    });
                }

                function patchValueProperty(npt) {
                    var valueProperty;
                    if (Object.getOwnPropertyDescriptor)
                        valueProperty = Object.getOwnPropertyDescriptor(npt, "value");
                    if (valueProperty && valueProperty.get) {
                        if (!npt._valueGet) {

                            npt._valueGet = valueProperty.get;
                            npt._valueSet = valueProperty.set;

                            Object.defineProperty(npt, "value", {
                                get: function () {
                                    var $self = $(this), inputData = $(this).data('inputmask');
                                    return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != inputData['_buffer'].join('') ? this._valueGet() : '';
                                },
                                set: function (value) {
                                    this._valueSet(value);
                                    $(this).triggerHandler('setvalue.inputmask');
                                }
                            });
                        }
                    } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                        if (!npt._valueGet) {
                            npt._valueGet = npt.__lookupGetter__("value");
                            npt._valueSet = npt.__lookupSetter__("value");

                            npt.__defineGetter__("value", function () {
                                var $self = $(this), inputData = $(this).data('inputmask');
                                return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != inputData['_buffer'].join('') ? this._valueGet() : '';
                            });
                            npt.__defineSetter__("value", function (value) {
                                this._valueSet(value);
                                $(this).triggerHandler('setvalue.inputmask');
                            });
                        }
                    } else {
                        if (!npt._valueGet) {
                            npt._valueGet = function () {
                                return this.value;
                            }
                            npt._valueSet = function (value) {
                                this.value = value;
                            }
                        }
                        if ($.fn.val.inputmaskpatch != true) {
                            $.fn.val = function () {
                                if (arguments.length == 0) {
                                    var $self = $(this);
                                    if ($self.data('inputmask')) {
                                        if ($self.data('inputmask')['autoUnmask'])
                                            return $self.inputmask('unmaskedvalue');
                                        else {
                                            var result = $.inputmask.val.apply($self);
                                            return result != $self.data('inputmask')['_buffer'].join('') ? result : '';
                                        }
                                    } else return $.inputmask.val.apply($self);
                                } else {
                                    var args = arguments;
                                    return this.each(function () {
                                        var $self = $(this);
                                        var result = $.inputmask.val.apply($self, args);
                                        if ($self.data('inputmask')) $self.triggerHandler('setvalue.inputmask');
                                        return result;
                                    });
                                }
                            };
                            $.extend($.fn.val, {
                                inputmaskpatch: true
                            });
                        }
                    }
                }

                //shift chars to left from start to end and put c at end position if defined
                function shiftL(start, end, c) {
                    while (!isMask(start) && start - 1 >= 0) start--;
                    for (var i = start; i < end && i < getMaskLength(); i++) {
                        if (isMask(i)) {
                            setReTargetPlaceHolder(buffer, i);
                            var j = seekNext(buffer, i);
                            var p = getBufferElement(buffer, j);
                            if (p != getPlaceHolder(j)) {
                                if (j < getMaskLength() && isValid(i, p, buffer, true) !== false && tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def) {
                                    setBufferElement(buffer, i, getBufferElement(buffer, j));
                                    setReTargetPlaceHolder(buffer, j); //cleanup next position
                                } else {
                                    if (isMask(i))
                                        break;
                                }
                            } else if (c == undefined) break;
                        } else {
                            setReTargetPlaceHolder(buffer, i);
                        }
                    }
                    if (c != undefined)
                        setBufferElement(buffer, isRTL ? end : seekPrevious(buffer, end), c);

                    buffer = truncateInput(buffer.join(''), isRTL).split('');
                    if (buffer.length == 0) buffer = _buffer.slice();

                    return start; //return the used start position
                }

                function shiftR(start, end, c, full) { //full => behave like a push right ~ do not stop on placeholders
                    for (var i = start; i <= end && i < getMaskLength(); i++) {
                        if (isMask(i)) {
                            var t = getBufferElement(buffer, i);
                            setBufferElement(buffer, i, c);
                            if (t != getPlaceHolder(i)) {
                                var j = seekNext(buffer, i);
                                if (j < getMaskLength()) {
                                    if (isValid(j, t, buffer, true) !== false && tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def)
                                        c = t;
                                    else {
                                        if (isMask(j))
                                            break;
                                        else c = t;
                                    }
                                } else break;
                            } else if (full !== true) break;
                        } else
                            setReTargetPlaceHolder(buffer, i);
                    }
                    var lengthBefore = buffer.length;
                    buffer = truncateInput(buffer.join(''), isRTL).split('');
                    if (buffer.length == 0) buffer = _buffer.slice();

                    return end - (lengthBefore - buffer.length);  //return new start position
                };

                function keydownEvent(e) {
                    //Safari 5.1.x - modal dialog fires keypress twice workaround
                    skipKeyPressEvent = false;

                    var input = this, k = e.keyCode, pos = caret(input);

                    //set input direction according the position to the radixPoint
                    if (opts.numericInput) {
                        var nptStr = input._valueGet();
                        var radixPosition = nptStr.indexOf(opts.radixPoint);
                        if (radixPosition != -1) {
                            isRTL = pos.begin <= radixPosition || pos.end <= radixPosition;
                        }
                    }

                    //backspace, delete, and escape get special treatment
                    if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127)) {//backspace/delete
                        var maskL = getMaskLength();
                        if (pos.begin == 0 && pos.end == maskL) {
                            buffer = _buffer.slice();
                            writeBuffer(input, buffer);
                            caret(input, checkVal(input, buffer, false));
                        } else if ((pos.end - pos.begin) > 1 || ((pos.end - pos.begin) == 1 && opts.insertMode)) {
                            clearBuffer(buffer, pos.begin, pos.end);
                            writeBuffer(input, buffer, isRTL ? checkVal(input, buffer, false) : pos.begin);
                        } else {
                            var beginPos = pos.begin - (k == opts.keyCode.DELETE ? 0 : 1);
                            if (beginPos < firstMaskPos && k == opts.keyCode.DELETE) {
                                beginPos = firstMaskPos;
                            }
                            if (beginPos >= firstMaskPos) {
                                if (opts.numericInput && opts.greedy && k == opts.keyCode.DELETE && buffer[beginPos] == opts.radixPoint) {
                                    beginPos = seekNext(buffer, beginPos);
                                    isRTL = false;
                                }
                                if (isRTL) {
                                    beginPos = shiftR(firstMaskPos, beginPos, getPlaceHolder(beginPos), true);
                                    beginPos = (opts.numericInput && opts.greedy && k == opts.keyCode.BACKSPACE && buffer[beginPos + 1] == opts.radixPoint) ? beginPos + 1 : seekNext(buffer, beginPos);
                                } else beginPos = shiftL(beginPos, maskL);
                                writeBuffer(input, buffer, beginPos);
                            }
                        }
                        if (input._valueGet() == _buffer.join(''))
                            $(input).trigger('cleared');

                        return false;
                    } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
                        setTimeout(function () {
                            var caretPos = checkVal(input, buffer, false, true);
                            if (!opts.insertMode && caretPos == getMaskLength() && !e.shiftKey) caretPos--;
                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
                        }, 0);
                        return false;
                    } else if (k == opts.keyCode.HOME || k == opts.keyCode.PAGE_UP) {//Home or page_up
                        caret(input, 0, e.shiftKey ? pos.begin : 0);
                        return false;
                    }
                    else if (k == opts.keyCode.ESCAPE) {//escape
                        input._valueSet(undoBuffer);
                        caret(input, 0, checkVal(input, buffer));
                        return false;
                    } else if (k == opts.keyCode.INSERT) {//insert
                        opts.insertMode = !opts.insertMode;
                        caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);
                        return false;
                    } else if (e.ctrlKey && k == 88) {
                        setTimeout(function () {
                            caret(input, checkVal(input, buffer, true));
                        }, 0);
                    } else if (!opts.insertMode) { //overwritemode
                        if (k == opts.keyCode.RIGHT) {//right
                            var caretPos = pos.begin == pos.end ? pos.end + 1 : pos.end;
                            caretPos = caretPos < getMaskLength() ? caretPos : pos.end;
                            caret(input, e.shiftKey ? pos.begin : caretPos, e.shiftKey ? caretPos + 1 : caretPos);
                            return false;
                        } else if (k == opts.keyCode.LEFT) {//left
                            var caretPos = pos.begin - 1;
                            caretPos = caretPos > 0 ? caretPos : 0;
                            caret(input, caretPos, e.shiftKey ? pos.end : caretPos);
                            return false;
                        }
                    }

                    opts.onKeyDown.call(this, e, opts); //extra stuff to execute on keydown
                    ignorable = $.inArray(k, opts.ignorables) != -1;
                }

                function keypressEvent(e) {
                    //Safari 5.1.x - modal dialog fires keypress twice workaround
                    if (skipKeyPressEvent) return false;
                    skipKeyPressEvent = true;

                    var input = this, $input = $(input);

                    e = e || window.event;
                    var k = e.which || e.charCode || e.keyCode;

                    if (opts.numericInput && k == opts.radixPoint.charCodeAt(opts.radixPoint.length - 1)) {
                        var nptStr = input._valueGet();
                        var radixPosition = nptStr.indexOf(opts.radixPoint);
                        caret(input, seekNext(buffer, radixPosition != -1 ? radixPosition : getMaskLength()));
                    }

                    if (e.ctrlKey || e.altKey || e.metaKey || ignorable) {//Ignore
                        return true;
                    } else {
                        if (k) {
                            $input.trigger('input');

                            var pos = caret(input), c = String.fromCharCode(k), maskL = getMaskLength();
                            clearBuffer(buffer, pos.begin, pos.end);

                            if (isRTL) {
                                var p = opts.numericInput ? pos.end : seekPrevious(buffer, pos.end), np;
                                if ((np = isValid(p == maskL || getBufferElement(buffer, p) == opts.radixPoint ? seekPrevious(buffer, p) : p, c, buffer, false)) !== false) {
                                    if (np !== true) {
                                        p = np.pos || pos; //set new position from isValid
                                        c = np.c || c; //set new char from isValid
                                    }

                                    var firstUnmaskedPosition = firstMaskPos;
                                    if (opts.insertMode == true) {
                                        if (opts.greedy == true) {
                                            var bfrClone = buffer.slice();
                                            while (getBufferElement(bfrClone, firstUnmaskedPosition, true) != getPlaceHolder(firstUnmaskedPosition) && firstUnmaskedPosition <= p) {
                                                firstUnmaskedPosition = firstUnmaskedPosition == maskL ? (maskL + 1) : seekNext(buffer, firstUnmaskedPosition);
                                            }
                                        }

                                        if (firstUnmaskedPosition <= p && (opts.greedy || buffer.length < maskL)) {
                                            if (buffer[firstMaskPos] != getPlaceHolder(firstMaskPos) && buffer.length < maskL) {
                                                var offset = prepareBuffer(buffer, -1, isRTL);
                                                if (pos.end != 0) p = p + offset;
                                                maskL = buffer.length;
                                            }
                                            shiftL(firstUnmaskedPosition, opts.numericInput ? seekPrevious(buffer, p) : p, c);
                                        } else return false;
                                    } else setBufferElement(buffer, opts.numericInput ? seekPrevious(buffer, p) : p, c);
                                    writeBuffer(input, buffer, opts.numericInput && p == 0 ? seekNext(buffer, p) : p);
                                    setTimeout(function () { //timeout needed for IE
                                        if (isComplete(input))
                                            $input.trigger("complete");
                                    }, 0);
                                } else if (android) writeBuffer(input, buffer, pos.begin);
                            }
                            else {
                                var p = seekNext(buffer, pos.begin - 1), np;
                                prepareBuffer(buffer, p, isRTL);
                                if ((np = isValid(p, c, buffer, false)) !== false) {
                                    if (np !== true) {
                                        p = np.pos || p; //set new position from isValid
                                        c = np.c || c; //set new char from isValid
                                    }
                                    if (opts.insertMode == true) {
                                        var lastUnmaskedPosition = getMaskLength();
                                        var bfrClone = buffer.slice();
                                        while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) {
                                            lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(buffer, lastUnmaskedPosition);
                                        }
                                        if (lastUnmaskedPosition >= p)
                                            shiftR(p, buffer.length, c);
                                        else return false;
                                    }
                                    else setBufferElement(buffer, p, c);
                                    var next = seekNext(buffer, p);
                                    writeBuffer(input, buffer, next);

                                    setTimeout(function () { //timeout needed for IE
                                        if (isComplete(input))
                                            $input.trigger("complete");
                                    }, 0);
                                } else if (android) writeBuffer(input, buffer, pos.begin);
                            }
                            return false;
                        }
                    }
                }

                function keyupEvent(e) {
                    var $input = $(this), input = this;
                    var k = e.keyCode;
                    opts.onKeyUp.call(this, e, opts); //extra stuff to execute on keyup
                    if (k == opts.keyCode.TAB && $input.hasClass('focus.inputmask') && input._valueGet().length == 0) {
                        buffer = _buffer.slice();
                        writeBuffer(input, buffer);
                        if (!isRTL) caret(input, 0);
                        undoBuffer = input._valueGet();
                    }
                }
            }
        };
    }
})(jQuery);
/*
 Input Mask plugin extensions
 http://github.com/RobinHerbots/jquery.inputmask
 Copyright (c) 2010 - 2012 Robin Herbots
 Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 Version: 1.2.0

 Optional extensions on the jquery.inputmask base
 */
(function ($) {
    //extra definitions
    $.extend($.inputmask.defaults.definitions, {
        'A': { //auto uppercasing
            validator: "[A-Za-z]",
            cardinality: 1,
            casing: "upper"
        }
    });
})(jQuery);
/**
 * jQuery Validation Plugin 1.9.0
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2006 - 2011 Jörn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
(function (c) {
    c.extend(c.fn, {
        validate: function (a) {
            if (this.length) {
                var b = c.data(this[0], "validator");
                if (b)return b;
                this.attr("novalidate", "novalidate");
                b = new c.validator(a, this[0]);
                c.data(this[0], "validator", b);
                if (b.settings.onsubmit) {
                    a = this.find("input, button");
                    a.filter(".cancel").click(function () {
                        b.cancelSubmit = true
                    });
                    b.settings.submitHandler && a.filter(":submit").click(function () {
                        b.submitButton = this
                    });
                    this.submit(function (d) {
                        function e() {
                            if (b.settings.submitHandler) {
                                if (b.submitButton)var f = c("<input type='hidden'/>").attr("name",
                                    b.submitButton.name).val(b.submitButton.value).appendTo(b.currentForm);
                                b.settings.submitHandler.call(b, b.currentForm);
                                b.submitButton && f.remove();
                                return false
                            }
                            return true
                        }

                        b.settings.debug && d.preventDefault();
                        if (b.cancelSubmit) {
                            b.cancelSubmit = false;
                            return e()
                        }
                        if (b.form()) {
                            if (b.pendingRequest) {
                                b.formSubmitted = true;
                                return false
                            }
                            return e()
                        } else {
                            b.focusInvalid();
                            return false
                        }
                    })
                }
                return b
            } else a && a.debug && window.console && console.warn("nothing selected, can't validate, returning nothing")
        }, valid: function () {
            if (c(this[0]).is("form"))return this.validate().form();
            else {
                var a = true, b = c(this[0].form).validate();
                this.each(function () {
                    a &= b.element(this)
                });
                return a
            }
        }, removeAttrs: function (a) {
            var b = {}, d = this;
            c.each(a.split(/\s/), function (e, f) {
                b[f] = d.attr(f);
                d.removeAttr(f)
            });
            return b
        }, rules: function (a, b) {
            var d = this[0];
            if (a) {
                var e = c.data(d.form, "validator").settings, f = e.rules, g = c.validator.staticRules(d);
                switch (a) {
                    case "add":
                        c.extend(g, c.validator.normalizeRule(b));
                        f[d.name] = g;
                        if (b.messages)e.messages[d.name] = c.extend(e.messages[d.name], b.messages);
                        break;
                    case "remove":
                        if (!b) {
                            delete f[d.name];
                            return g
                        }
                        var h = {};
                        c.each(b.split(/\s/), function (j, i) {
                            h[i] = g[i];
                            delete g[i]
                        });
                        return h
                }
            }
            d = c.validator.normalizeRules(c.extend({}, c.validator.metadataRules(d), c.validator.classRules(d), c.validator.attributeRules(d), c.validator.staticRules(d)), d);
            if (d.required) {
                e = d.required;
                delete d.required;
                d = c.extend({required: e}, d)
            }
            return d
        }
    });
    c.extend(c.expr[":"], {
        blank: function (a) {
            return !c.trim("" + a.value)
        }, filled: function (a) {
            return !!c.trim("" + a.value)
        }, unchecked: function (a) {
            return !a.checked
        }
    });
    c.validator = function (a,
                            b) {
        this.settings = c.extend(true, {}, c.validator.defaults, a);
        this.currentForm = b;
        this.init()
    };
    c.validator.format = function (a, b) {
        if (arguments.length == 1)return function () {
            var d = c.makeArray(arguments);
            d.unshift(a);
            return c.validator.format.apply(this, d)
        };
        if (arguments.length > 2 && b.constructor != Array)b = c.makeArray(arguments).slice(1);
        if (b.constructor != Array)b = [b];
        c.each(b, function (d, e) {
            a = a.replace(RegExp("\\{" + d + "\\}", "g"), e)
        });
        return a
    };
    c.extend(c.validator, {
        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            validClass: "valid",
            errorElement: "label",
            focusInvalid: true,
            errorContainer: c([]),
            errorLabelContainer: c([]),
            onsubmit: true,
            ignore: ":hidden",
            ignoreTitle: false,
            onfocusin: function (a) {
                this.lastActive = a;
                if (this.settings.focusCleanup && !this.blockFocusCleanup) {
                    this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass);
                    this.addWrapper(this.errorsFor(a)).hide()
                }
            },
            onfocusout: function (a) {
                if (!this.checkable(a) && (a.name in this.submitted || !this.optional(a)))this.element(a)
            },
            onkeyup: function (a) {
                if (a.name in this.submitted || a == this.lastElement)this.element(a)
            },
            onclick: function (a) {
                if (a.name in this.submitted)this.element(a); else a.parentNode.name in this.submitted && this.element(a.parentNode)
            },
            highlight: function (a, b, d) {
                a.type === "radio" ? this.findByName(a.name).addClass(b).removeClass(d) : c(a).addClass(b).removeClass(d)
            },
            unhighlight: function (a, b, d) {
                a.type === "radio" ? this.findByName(a.name).removeClass(b).addClass(d) : c(a).removeClass(b).addClass(d)
            }
        },
        setDefaults: function (a) {
            c.extend(c.validator.defaults,
                a)
        },
        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date (ISO).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            creditcard: "Please enter a valid credit card number.",
            equalTo: "Please enter the same value again.",
            accept: "Please enter a value with a valid extension.",
            maxlength: c.validator.format("Please enter no more than {0} characters."),
            minlength: c.validator.format("Please enter at least {0} characters."),
            rangelength: c.validator.format("Please enter a value between {0} and {1} characters long."),
            range: c.validator.format("Please enter a value between {0} and {1}."),
            max: c.validator.format("Please enter a value less than or equal to {0}."),
            min: c.validator.format("Please enter a value greater than or equal to {0}.")
        },
        autoCreateRanges: false,
        prototype: {
            init: function () {
                function a(e) {
                    var f = c.data(this[0].form, "validator"), g = "on" + e.type.replace(/^validate/,
                            "");
                    f.settings[g] && f.settings[g].call(f, this[0], e)
                }

                this.labelContainer = c(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || c(this.currentForm);
                this.containers = c(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();
                var b = this.groups = {};
                c.each(this.settings.groups, function (e, f) {
                    c.each(f.split(/\s/), function (g, h) {
                        b[h] = e
                    })
                });
                var d =
                    this.settings.rules;
                c.each(d, function (e, f) {
                    d[e] = c.validator.normalizeRule(f)
                });
                c(this.currentForm).validateDelegate("[type='text'], [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'] ", "focusin focusout keyup", a).validateDelegate("[type='radio'], [type='checkbox'], select, option", "click",
                    a);
                this.settings.invalidHandler && c(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler)
            }, form: function () {
                this.checkForm();
                c.extend(this.submitted, this.errorMap);
                this.invalid = c.extend({}, this.errorMap);
                this.valid() || c(this.currentForm).triggerHandler("invalid-form", [this]);
                this.showErrors();
                return this.valid()
            }, checkForm: function () {
                this.prepareForm();
                for (var a = 0, b = this.currentElements = this.elements(); b[a]; a++)this.check(b[a]);
                return this.valid()
            }, element: function (a) {
                this.lastElement =
                    a = this.validationTargetFor(this.clean(a));
                this.prepareElement(a);
                this.currentElements = c(a);
                var b = this.check(a);
                if (b)delete this.invalid[a.name]; else this.invalid[a.name] = true;
                if (!this.numberOfInvalids())this.toHide = this.toHide.add(this.containers);
                this.showErrors();
                return b
            }, showErrors: function (a) {
                if (a) {
                    c.extend(this.errorMap, a);
                    this.errorList = [];
                    for (var b in a)this.errorList.push({message: a[b], element: this.findByName(b)[0]});
                    this.successList = c.grep(this.successList, function (d) {
                        return !(d.name in a)
                    })
                }
                this.settings.showErrors ?
                    this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
            }, resetForm: function () {
                c.fn.resetForm && c(this.currentForm).resetForm();
                this.submitted = {};
                this.lastElement = null;
                this.prepareForm();
                this.hideErrors();
                this.elements().removeClass(this.settings.errorClass)
            }, numberOfInvalids: function () {
                return this.objectLength(this.invalid)
            }, objectLength: function (a) {
                var b = 0, d;
                for (d in a)b++;
                return b
            }, hideErrors: function () {
                this.addWrapper(this.toHide).hide()
            }, valid: function () {
                return this.size() ==
                    0
            }, size: function () {
                return this.errorList.length
            }, focusInvalid: function () {
                if (this.settings.focusInvalid)try {
                    c(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin")
                } catch (a) {
                }
            }, findLastActive: function () {
                var a = this.lastActive;
                return a && c.grep(this.errorList, function (b) {
                        return b.element.name == a.name
                    }).length == 1 && a
            }, elements: function () {
                var a = this, b = {};
                return c(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function () {
                    !this.name &&
                    a.settings.debug && window.console && console.error("%o has no name assigned", this);
                    if (this.name in b || !a.objectLength(c(this).rules()))return false;
                    return b[this.name] = true
                })
            }, clean: function (a) {
                return c(a)[0]
            }, errors: function () {
                return c(this.settings.errorElement + "." + this.settings.errorClass, this.errorContext)
            }, reset: function () {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = c([]);
                this.toHide = c([]);
                this.currentElements = c([])
            }, prepareForm: function () {
                this.reset();
                this.toHide = this.errors().add(this.containers)
            },
            prepareElement: function (a) {
                this.reset();
                this.toHide = this.errorsFor(a)
            }, check: function (a) {
                a = this.validationTargetFor(this.clean(a));
                var b = c(a).rules(), d = false, e;
                for (e in b) {
                    var f = {method: e, parameters: b[e]};
                    try {
                        var g = c.validator.methods[e].call(this, a.value.replace(/\r/g, ""), a, f.parameters);
                        if (g == "dependency-mismatch")d = true; else {
                            d = false;
                            if (g == "pending") {
                                this.toHide = this.toHide.not(this.errorsFor(a));
                                return
                            }
                            if (!g) {
                                this.formatAndAdd(a, f);
                                return false
                            }
                        }
                    } catch (h) {
                        this.settings.debug && window.console && console.log("exception occured when checking element " +
                            a.id + ", check the '" + f.method + "' method", h);
                        throw h;
                    }
                }
                if (!d) {
                    this.objectLength(b) && this.successList.push(a);
                    return true
                }
            }, customMetaMessage: function (a, b) {
                if (c.metadata) {
                    var d = this.settings.meta ? c(a).metadata()[this.settings.meta] : c(a).metadata();
                    return d && d.messages && d.messages[b]
                }
            }, customMessage: function (a, b) {
                var d = this.settings.messages[a];
                return d && (d.constructor == String ? d : d[b])
            }, findDefined: function () {
                for (var a = 0; a < arguments.length; a++)if (arguments[a] !== undefined)return arguments[a]
            }, defaultMessage: function (a,
                                         b) {
                return this.findDefined(this.customMessage(a.name, b), this.customMetaMessage(a, b), !this.settings.ignoreTitle && a.title || undefined, c.validator.messages[b], "<strong>Warning: No message defined for " + a.name + "</strong>")
            }, formatAndAdd: function (a, b) {
                var d = this.defaultMessage(a, b.method), e = /\$?\{(\d+)\}/g;
                if (typeof d == "function")d = d.call(this, b.parameters, a); else if (e.test(d))d = jQuery.format(d.replace(e, "{$1}"), b.parameters);
                this.errorList.push({message: d, element: a});
                this.errorMap[a.name] = d;
                this.submitted[a.name] =
                    d
            }, addWrapper: function (a) {
                if (this.settings.wrapper)a = a.add(a.parent(this.settings.wrapper));
                return a
            }, defaultShowErrors: function () {
                for (var a = 0; this.errorList[a]; a++) {
                    var b = this.errorList[a];
                    this.settings.highlight && this.settings.highlight.call(this, b.element, this.settings.errorClass, this.settings.validClass);
                    this.showLabel(b.element, b.message)
                }
                if (this.errorList.length)this.toShow = this.toShow.add(this.containers);
                if (this.settings.success)for (a = 0; this.successList[a]; a++)this.showLabel(this.successList[a]);
                if (this.settings.unhighlight) {
                    a = 0;
                    for (b = this.validElements(); b[a]; a++)this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass)
                }
                this.toHide = this.toHide.not(this.toShow);
                this.hideErrors();
                this.addWrapper(this.toShow).show()
            }, validElements: function () {
                return this.currentElements.not(this.invalidElements())
            }, invalidElements: function () {
                return c(this.errorList).map(function () {
                    return this.element
                })
            }, showLabel: function (a, b) {
                var d = this.errorsFor(a);
                if (d.length) {
                    d.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
                    d.attr("generated") && d.html(b)
                } else {
                    d = c("<" + this.settings.errorElement + "/>").attr({
                        "for": this.idOrName(a),
                        generated: true
                    }).addClass(this.settings.errorClass).html(b || "");
                    if (this.settings.wrapper)d = d.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                    this.labelContainer.append(d).length || (this.settings.errorPlacement ? this.settings.errorPlacement(d, c(a)) : d.insertAfter(a))
                }
                if (!b && this.settings.success) {
                    d.text("");
                    typeof this.settings.success == "string" ? d.addClass(this.settings.success) : this.settings.success(d)
                }
                this.toShow =
                    this.toShow.add(d)
            }, errorsFor: function (a) {
                var b = this.idOrName(a);
                return this.errors().filter(function () {
                    return c(this).attr("for") == b
                })
            }, idOrName: function (a) {
                return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name)
            }, validationTargetFor: function (a) {
                if (this.checkable(a))a = this.findByName(a.name).not(this.settings.ignore)[0];
                return a
            }, checkable: function (a) {
                return /radio|checkbox/i.test(a.type)
            }, findByName: function (a) {
                var b = this.currentForm;
                return c(document.getElementsByName(a)).map(function (d,
                                                                      e) {
                    return e.form == b && e.name == a && e || null
                })
            }, getLength: function (a, b) {
                switch (b.nodeName.toLowerCase()) {
                    case "select":
                        return c("option:selected", b).length;
                    case "input":
                        if (this.checkable(b))return this.findByName(b.name).filter(":checked").length
                }
                return a.length
            }, depend: function (a, b) {
                return this.dependTypes[typeof a] ? this.dependTypes[typeof a](a, b) : true
            }, dependTypes: {
                "boolean": function (a) {
                    return a
                }, string: function (a, b) {
                    return !!c(a, b.form).length
                }, "function": function (a, b) {
                    return a(b)
                }
            }, optional: function (a) {
                return !c.validator.methods.required.call(this,
                        c.trim(a.value), a) && "dependency-mismatch"
            }, startRequest: function (a) {
                if (!this.pending[a.name]) {
                    this.pendingRequest++;
                    this.pending[a.name] = true
                }
            }, stopRequest: function (a, b) {
                this.pendingRequest--;
                if (this.pendingRequest < 0)this.pendingRequest = 0;
                delete this.pending[a.name];
                if (b && this.pendingRequest == 0 && this.formSubmitted && this.form()) {
                    c(this.currentForm).submit();
                    this.formSubmitted = false
                } else if (!b && this.pendingRequest == 0 && this.formSubmitted) {
                    c(this.currentForm).triggerHandler("invalid-form", [this]);
                    this.formSubmitted =
                        false
                }
            }, previousValue: function (a) {
                return c.data(a, "previousValue") || c.data(a, "previousValue", {
                        old: null,
                        valid: true,
                        message: this.defaultMessage(a, "remote")
                    })
            }
        },
        classRuleSettings: {
            required: {required: true},
            email: {email: true},
            url: {url: true},
            date: {date: true},
            dateISO: {dateISO: true},
            dateDE: {dateDE: true},
            number: {number: true},
            numberDE: {numberDE: true},
            digits: {digits: true},
            creditcard: {creditcard: true}
        },
        addClassRules: function (a, b) {
            a.constructor == String ? this.classRuleSettings[a] = b : c.extend(this.classRuleSettings,
                a)
        },
        classRules: function (a) {
            var b = {};
            (a = c(a).attr("class")) && c.each(a.split(" "), function () {
                this in c.validator.classRuleSettings && c.extend(b, c.validator.classRuleSettings[this])
            });
            return b
        },
        attributeRules: function (a) {
            var b = {};
            a = c(a);
            for (var d in c.validator.methods) {
                var e;
                if (e = d === "required" && typeof c.fn.prop === "function" ? a.prop(d) : a.attr(d))b[d] = e; else if (a[0].getAttribute("type") === d)b[d] = true
            }
            b.maxlength && /-1|2147483647|524288/.test(b.maxlength) && delete b.maxlength;
            return b
        },
        metadataRules: function (a) {
            if (!c.metadata)return {};
            var b = c.data(a.form, "validator").settings.meta;
            return b ? c(a).metadata()[b] : c(a).metadata()
        },
        staticRules: function (a) {
            var b = {}, d = c.data(a.form, "validator");
            if (d.settings.rules)b = c.validator.normalizeRule(d.settings.rules[a.name]) || {};
            return b
        },
        normalizeRules: function (a, b) {
            c.each(a, function (d, e) {
                if (e === false)delete a[d]; else if (e.param || e.depends) {
                    var f = true;
                    switch (typeof e.depends) {
                        case "string":
                            f = !!c(e.depends, b.form).length;
                            break;
                        case "function":
                            f = e.depends.call(b, b)
                    }
                    if (f)a[d] = e.param !== undefined ?
                        e.param : true; else delete a[d]
                }
            });
            c.each(a, function (d, e) {
                a[d] = c.isFunction(e) ? e(b) : e
            });
            c.each(["minlength", "maxlength", "min", "max"], function () {
                if (a[this])a[this] = Number(a[this])
            });
            c.each(["rangelength", "range"], function () {
                if (a[this])a[this] = [Number(a[this][0]), Number(a[this][1])]
            });
            if (c.validator.autoCreateRanges) {
                if (a.min && a.max) {
                    a.range = [a.min, a.max];
                    delete a.min;
                    delete a.max
                }
                if (a.minlength && a.maxlength) {
                    a.rangelength = [a.minlength, a.maxlength];
                    delete a.minlength;
                    delete a.maxlength
                }
            }
            a.messages && delete a.messages;
            return a
        },
        normalizeRule: function (a) {
            if (typeof a == "string") {
                var b = {};
                c.each(a.split(/\s/), function () {
                    b[this] = true
                });
                a = b
            }
            return a
        },
        addMethod: function (a, b, d) {
            c.validator.methods[a] = b;
            c.validator.messages[a] = d != undefined ? d : c.validator.messages[a];
            b.length < 3 && c.validator.addClassRules(a, c.validator.normalizeRule(a))
        },
        methods: {
            required: function (a, b, d) {
                if (!this.depend(d, b))return "dependency-mismatch";
                switch (b.nodeName.toLowerCase()) {
                    case "select":
                        return (a = c(b).val()) && a.length > 0;
                    case "input":
                        if (this.checkable(b))return this.getLength(a,
                                b) > 0;
                    default:
                        return c.trim(a).length > 0
                }
            }, remote: function (a, b, d) {
                if (this.optional(b))return "dependency-mismatch";
                var e = this.previousValue(b);
                this.settings.messages[b.name] || (this.settings.messages[b.name] = {});
                e.originalMessage = this.settings.messages[b.name].remote;
                this.settings.messages[b.name].remote = e.message;
                d = typeof d == "string" && {url: d} || d;
                if (this.pending[b.name])return "pending";
                if (e.old === a)return e.valid;
                e.old = a;
                var f = this;
                this.startRequest(b);
                var g = {};
                g[b.name] = a;
                c.ajax(c.extend(true, {
                    url: d,
                    mode: "abort", port: "validate" + b.name, dataType: "json", data: g, success: function (h) {
                        f.settings.messages[b.name].remote = e.originalMessage;
                        var j = h === true;
                        if (j) {
                            var i = f.formSubmitted;
                            f.prepareElement(b);
                            f.formSubmitted = i;
                            f.successList.push(b);
                            f.showErrors()
                        } else {
                            i = {};
                            h = h || f.defaultMessage(b, "remote");
                            i[b.name] = e.message = c.isFunction(h) ? h(a) : h;
                            f.showErrors(i)
                        }
                        e.valid = j;
                        f.stopRequest(b, j)
                    }
                }, d));
                return "pending"
            }, minlength: function (a, b, d) {
                return this.optional(b) || this.getLength(c.trim(a), b) >= d
            }, maxlength: function (a,
                                    b, d) {
                return this.optional(b) || this.getLength(c.trim(a), b) <= d
            }, rangelength: function (a, b, d) {
                a = this.getLength(c.trim(a), b);
                return this.optional(b) || a >= d[0] && a <= d[1]
            }, min: function (a, b, d) {
                return this.optional(b) || a >= d
            }, max: function (a, b, d) {
                return this.optional(b) || a <= d
            }, range: function (a, b, d) {
                return this.optional(b) || a >= d[0] && a <= d[1]
            }, email: function (a, b) {
                return this.optional(b) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(a)
            },
            url: function (a, b) {
                return this.optional(b) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(a)
            },
            date: function (a, b) {
                return this.optional(b) || !/Invalid|NaN/.test(new Date(a))
            }, dateISO: function (a, b) {
                return this.optional(b) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(a)
            }, number: function (a, b) {
                return this.optional(b) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(a)
            }, digits: function (a, b) {
                return this.optional(b) || /^\d+$/.test(a)
            }, creditcard: function (a, b) {
                if (this.optional(b))return "dependency-mismatch";
                if (/[^0-9 -]+/.test(a))return false;
                var d = 0, e = 0, f = false;
                a = a.replace(/\D/g, "");
                for (var g = a.length - 1; g >=
                0; g--) {
                    e = a.charAt(g);
                    e = parseInt(e, 10);
                    if (f)if ((e *= 2) > 9)e -= 9;
                    d += e;
                    f = !f
                }
                return d % 10 == 0
            }, accept: function (a, b, d) {
                d = typeof d == "string" ? d.replace(/,/g, "|") : "png|jpe?g|gif";
                return this.optional(b) || a.match(RegExp(".(" + d + ")$", "i"))
            }, equalTo: function (a, b, d) {
                d = c(d).unbind(".validate-equalTo").bind("blur.validate-equalTo", function () {
                    c(b).valid()
                });
                return a == d.val()
            }
        }
    });
    c.format = c.validator.format
})(jQuery);
(function (c) {
    var a = {};
    if (c.ajaxPrefilter)c.ajaxPrefilter(function (d, e, f) {
        e = d.port;
        if (d.mode == "abort") {
            a[e] && a[e].abort();
            a[e] = f
        }
    }); else {
        var b = c.ajax;
        c.ajax = function (d) {
            var e = ("port"in d ? d : c.ajaxSettings).port;
            if (("mode"in d ? d : c.ajaxSettings).mode == "abort") {
                a[e] && a[e].abort();
                return a[e] = b.apply(this, arguments)
            }
            return b.apply(this, arguments)
        }
    }
})(jQuery);
(function (c) {
    !jQuery.event.special.focusin && !jQuery.event.special.focusout && document.addEventListener && c.each({
        focus: "focusin",
        blur: "focusout"
    }, function (a, b) {
        function d(e) {
            e = c.event.fix(e);
            e.type = b;
            return c.event.handle.call(this, e)
        }

        c.event.special[b] = {
            setup: function () {
                this.addEventListener(a, d, true)
            }, teardown: function () {
                this.removeEventListener(a, d, true)
            }, handler: function (e) {
                arguments[0] = c.event.fix(e);
                arguments[0].type = b;
                return c.event.handle.apply(this, arguments)
            }
        }
    });
    c.extend(c.fn, {
        validateDelegate: function (a,
                                    b, d) {
            return this.bind(b, function (e) {
                var f = c(e.target);
                if (f.is(a))return d.apply(f, arguments)
            })
        }
    })
})(jQuery);
﻿/*
 *       Developed by Justin Mead
 *       ©2011 MeadMiracle
 *		www.meadmiracle.com / meadmiracle@gmail.com
 *       Version 1.3
 *       Testing: IE8/Windows XP
 *                Firefox/Windows XP
 *                Chrome/Windows XP
 *       Licensed under the Creative Commons GPL http://creativecommons.org/licenses/GPL/2.0/
 */

(function ($) {
    var settings = new Array();
    var group1 = new Array();
    var group2 = new Array();
    var onSort = new Array();
    $.configureBoxes = function (options) {
        var index = settings.push({
            box1View: 'box1View',
            box1Storage: 'box1Storage',
            box1Filter: 'box1Filter',
            box1Clear: 'box1Clear',
            box1Counter: 'box1Counter',
            box2View: 'box2View',
            box2Storage: 'box2Storage',
            box2Filter: 'box2Filter',
            box2Clear: 'box2Clear',
            box2Counter: 'box2Counter',
            to1: 'to1',
            allTo1: 'allTo1',
            to2: 'to2',
            allTo2: 'allTo2',
            transferMode: 'move',
            sortBy: 'text',
            useFilters: true,
            useCounters: true,
            useSorting: true,
            selectOnSubmit: true
        });
        index--;
        $.extend(settings[index], options);
        group1.push({
            view: settings[index].box1View,
            storage: settings[index].box1Storage,
            filter: settings[index].box1Filter,
            clear: settings[index].box1Clear,
            counter: settings[index].box1Counter,
            index: index
        });
        group2.push({
            view: settings[index].box2View,
            storage: settings[index].box2Storage,
            filter: settings[index].box2Filter,
            clear: settings[index].box2Clear,
            counter: settings[index].box2Counter,
            index: index
        });
        if (settings[index].sortBy == 'text') {
            onSort.push(function (a, b) {
                var aVal = a.text.toLowerCase();
                var bVal = b.text.toLowerCase();
                if (aVal < bVal) {
                    return -1;
                }
                if (aVal > bVal) {
                    return 1;
                }
                return 0;
            });
        } else {
            onSort.push(function (a, b) {
                var aVal = a.value.toLowerCase();
                var bVal = b.value.toLowerCase();
                if (aVal < bVal) {
                    return -1;
                }
                if (aVal > bVal) {
                    return 1;
                }
                return 0;
            });
        }
        if (settings[index].useFilters) {
            $('#' + group1[index].filter).keyup(function () {
                Filter(group1[index]);
            });
            $('#' + group2[index].filter).keyup(function () {
                Filter(group2[index]);
            });
            $('#' + group1[index].clear).click(function () {
                ClearFilter(group1[index]);
            });
            $('#' + group2[index].clear).click(function () {
                ClearFilter(group2[index]);
            });
        }
        if (IsMoveMode(settings[index])) {
            $('#' + group2[index].view).dblclick(function () {
                MoveSelected(group2[index], group1[index]);
            });
            $('#' + settings[index].to1).click(function () {
                MoveSelected(group2[index], group1[index]);
            });
            $('#' + settings[index].allTo1).click(function () {
                MoveAll(group2[index], group1[index]);
            });
        } else {
            $('#' + group2[index].view).dblclick(function () {
                RemoveSelected(group2[index], group1[index]);
            });
            $('#' + settings[index].to1).click(function () {
                RemoveSelected(group2[index], group1[index]);
            });
            $('#' + settings[index].allTo1).click(function () {
                RemoveAll(group2[index], group1[index]);
            });
        }
        $('#' + group1[index].view).dblclick(function () {
            MoveSelected(group1[index], group2[index]);
        });
        $('#' + settings[index].to2).click(function () {
            MoveSelected(group1[index], group2[index]);
        });
        $('#' + settings[index].allTo2).click(function () {
            MoveAll(group1[index], group2[index]);
        });
        if (settings[index].useCounters) {
            UpdateLabel(group1[index]);
            UpdateLabel(group2[index]);
        }
        if (settings[index].useSorting) {
            SortOptions(group1[index]);
            SortOptions(group2[index]);
        }
        $('#' + group1[index].storage + ',#' + group2[index].storage).css('display', 'none');
        if (settings[index].selectOnSubmit) {
            $('#' + settings[index].box2View).closest('form').submit(function () {
                $('#' + settings[index].box2View).children('option').attr('selected', 'selected');
            });
        }
    };
    function UpdateLabel(group) {
        var showingCount = $("#" + group.view + " option").size();
        var hiddenCount = $("#" + group.storage + " option").size();
        $("#" + group.counter).text('Showing ' + showingCount + ' of ' + (showingCount + hiddenCount));
    }

    function Filter(group) {
        var index = group.index;
        var filterLower;
        if (settings[index].useFilters) {
            filterLower = $('#' + group.filter).val().toString().toLowerCase();
        } else {
            filterLower = '';
        }
        $('#' + group.view + ' option').filter(function (i) {
            var toMatch = $(this).text().toString().toLowerCase();
            return toMatch.indexOf(filterLower) == -1;
        }).appendTo('#' + group.storage);
        $('#' + group.storage + ' option').filter(function (i) {
            var toMatch = $(this).text().toString().toLowerCase();
            return toMatch.indexOf(filterLower) != -1;
        }).appendTo('#' + group.view);
        try {
            $('#' + group.view + ' option').removeAttr('selected');
        } catch (ex) {
        }
        if (settings[index].useSorting) {
            SortOptions(group);
        }
        if (settings[index].useCounters) {
            UpdateLabel(group);
        }
    }

    function SortOptions(group) {
        var $toSortOptions = $('#' + group.view + ' option');
        $toSortOptions.sort(onSort[group.index]);
        $('#' + group.view).empty().append($toSortOptions);
    }

    function MoveSelected(fromGroup, toGroup) {
        if (IsMoveMode(settings[fromGroup.index])) {
            $('#' + fromGroup.view + ' option:selected').appendTo('#' + toGroup.view);
        } else {
            $('#' + fromGroup.view + ' option:selected:not([class*=copiedOption])').clone().appendTo('#' + toGroup.view).end().end().addClass('copiedOption');
        }
        try {
            $('#' + fromGroup.view + ' option,#' + toGroup.view + ' option').removeAttr('selected');
        } catch (ex) {
        }
        Filter(toGroup);
        if (settings[fromGroup.index].useCounters) {
            UpdateLabel(fromGroup);
        }
    }

    function MoveAll(fromGroup, toGroup) {
        if (IsMoveMode(settings[fromGroup.index])) {
            $('#' + fromGroup.view + ' option').appendTo('#' + toGroup.view);
        } else {
            $('#' + fromGroup.view + ' option:not([class*=copiedOption])').clone().appendTo('#' + toGroup.view).end().end().addClass('copiedOption');
        }
        try {
            $('#' + fromGroup.view + ' option,#' + toGroup.view + ' option').removeAttr('selected');
        } catch (ex) {
        }
        Filter(toGroup);
        if (settings[fromGroup.index].useCounters) {
            UpdateLabel(fromGroup);
        }
    }

    function RemoveSelected(removeGroup, otherGroup) {
        $('#' + otherGroup.view + ' option.copiedOption').add('#' + otherGroup.storage + ' option.copiedOption').remove();
        try {
            $('#' + removeGroup.view + ' option:selected').appendTo('#' + otherGroup.view).removeAttr('selected');
        } catch (ex) {
        }
        $('#' + removeGroup.view + ' option').add('#' + removeGroup.storage + ' option').clone().addClass('copiedOption').appendTo('#' + otherGroup.view);
        Filter(otherGroup);
        if (settings[removeGroup.index].useCounters) {
            UpdateLabel(removeGroup);
        }
    }

    function RemoveAll(removeGroup, otherGroup) {
        $('#' + otherGroup.view + ' option.copiedOption').add('#' + otherGroup.storage + ' option.copiedOption').remove();
        try {
            $('#' + removeGroup.storage + ' option').clone().addClass('copiedOption').add('#' + removeGroup.view + ' option').appendTo('#' + otherGroup.view).removeAttr('selected');
        } catch (ex) {
        }
        Filter(otherGroup);
        if (settings[removeGroup.index].useCounters) {
            UpdateLabel(removeGroup);
        }
    }

    function ClearFilter(group) {
        $('#' + group.filter).val('');
        $('#' + group.storage + ' option').appendTo('#' + group.view);
        try {
            $('#' + group.view + ' option').removeAttr('selected');
        } catch (ex) {
        }
        if (settings[group.index].useSorting) {
            SortOptions(group);
        }
        if (settings[group.index].useCounters) {
            UpdateLabel(group);
        }
    }

    function IsMoveMode(currSettings) {
        return currSettings.transferMode == 'move';
    }
})(jQuery);
(function ($) {
    var DEBUG = false;
    var version = "1.1";
    $.fn.nailthumb = function (options) {
        var opts = $.extend({}, $.fn.nailthumb.defaults, options);
        return this.each(function () {
            var $this = $(this);
            var o = $.metadata ? $.extend({}, opts, $this.metadata()) : opts;
            thumbize($this, o);
        });
    };
    function thumbize(element, options) {
        var image = setImage(element, options);
        var container = setContainer(element, options);
        if (options.serverSideParams) {
            $.fn.nailthumb.setServerSideParams(image, container, options);
        }
        debugObject("image", image);
        debugObject("container", container);
        if (options.onStart) {
            options.onStart(container, options);
        }
        if (options.loadingClass) {
            container.addClass(options.loadingClass);
        }
        if (options.preload || image.data("nailthumb.replaceto")) {
            debug("wait on load");
            image.one("load", function () {
                debugObject("before check", image);
                if (!image.data("nailthumb.working") && !image.data("nailthumb.replacing")) {
                    image.data("nailthumb.working", true);
                    debugObject("inside check", image);
                    doThumb(image, container, options);
                }
            });
            var src = image.attr("src");
            image.attr("src", null).attr("src", src);
        } else {
            debug("nail thumb directly");
            image.data("nailthumb.working", true);
            doThumb(image, container, options);
        }
    }

    function doThumb(image, container, options) {
        resetImage(image, options);
        resetContainer(container, options);
        var imageDims = getImageDims(image, options);
        debugObject("image", image);
        debugObject("imageDims", imageDims);
        if (imageDims.width == 0 || imageDims.height == 0) {
            imageDims = getHiddenCloneDims(image);
            debugObject("imageCloneDims", imageDims);
        }
        var containerDims = getContainerDims(container, options);
        debugObject("container", container);
        debugObject("containerDims", containerDims);
        var prop = getProportion(containerDims, imageDims, options);
        debug("proportions", prop);
        resize(image, imageDims, container, containerDims, prop, options);
    }

    function setImage(element, options) {
        var image = element.find("img").first();
        var finder = options.imageCustomFinder;
        if (!finder && options.imageUrl) {
            finder = imageUrlFinder;
        } else {
            if (!finder && options.imageFromWrappingLink) {
                finder = imageFromWrappingLinkFinder;
            }
        }
        if (finder) {
            var img = finder(element, options);
            debugObject("finder", img);
            if (!img) {
                img = [];
            }
            if (img.length > 0) {
                image = img;
                image.css("display", "none");
                if (!image.data("nailthumb.replaceto")) {
                    image.data("nailthumb.replaceto", element);
                }
                image.data("nailthumb.originalImageDims", null);
            }
        }
        if (image.length == 0) {
            if (element.is("img")) {
                image = element;
            }
        }
        return image;
    }

    function imageUrlFinder(element, options) {
        var image = $("<img />").attr("src", options.imageUrl).css("display", "none").data("nailthumb.replaceto", element);
        element.append(image);
        return image;
    }

    function imageFromWrappingLinkFinder(element, options) {
        var image;
        var link = element.find("a").first();
        if (link.length == 0 && element.is("a")) {
            link = element;
        }
        if (link.attr("href")) {
            image = $("<img />").attr("src", link.attr("href")).css("display", "none").data("nailthumb.replaceto", link);
            if (link.attr("title")) {
                image.attr("title", link.attr("title"));
            }
            link.append(image);
        }
        return image;
    }

    function resetImage(image, options) {
        if (!options.nostyle) {
            image.css({"position": "relative"});
        }
        if (!image.data("nailthumb.originalImageDims")) {
            image.css({
                "width": "auto",
                "height": "auto",
                "top": 0,
                "left": 0
            }).removeAttr("width").removeAttr("height");
        }
    }

    function setContainer(element, options) {
        var container = element;
        if (element.is("img")) {
            if (options.ifImageAddContainer) {
                var c = $("<div></div>");
                element.wrap(c);
            }
            container = element.parent();
        }
        return container;
    }

    function resetContainer(container, options) {
        if (options.containerClass) {
            container.addClass(options.containerClass);
        }
        if (!options.nostyle) {
            container.css({"overflow": "hidden", "padding": "0px"});
        }
        if (options.replaceAnimation == "animate") {
            if (options.width || options.height) {
                container.animate({
                    "width": options.width,
                    "height": options.height
                }, options.animationTime, options.animation);
            }
        } else {
            if (options.width) {
                container.width(options.width);
            }
            if (options.height) {
                container.height(options.height);
            }
        }
        container.find("span." + options.titleClass).remove();
    }

    function resize(image, imageDims, container, containerDims, prop, options) {
        var iw = imageDims.width * prop;
        var ih = imageDims.height * prop;
        var top = 0, left = 0, diff;
        var direction = getDirections(options.fitDirection);
        if (ih < containerDims.innerHeight) {
            switch (direction.v) {
                case"center":
                    top = -(ih - containerDims.innerHeight) / 2;
                    break;
                case"bottom":
                    top = -(ih - containerDims.innerHeight);
                    diff = "bottom";
                    break;
                case"top":
                    top = 0;
                    diff = "top";
                    break;
                default:
                    break;
            }
        } else {
            if (ih > containerDims.innerHeight) {
                switch (direction.v) {
                    case"center":
                        top = -(ih - containerDims.innerHeight) / 2;
                        break;
                    case"bottom":
                        top = -(ih - containerDims.innerHeight);
                        break;
                    default:
                        break;
                }
            }
        }
        if (iw < containerDims.innerWidth) {
            switch (direction.h) {
                case"center":
                    left = -(iw - containerDims.innerWidth) / 2;
                    break;
                case"right":
                    left = -(iw - containerDims.innerWidth);
                    break;
                default:
                    break;
            }
        } else {
            if (iw > containerDims.innerWidth) {
                switch (direction.h) {
                    case"center":
                        left = -(iw - containerDims.innerWidth) / 2;
                        break;
                    case"right":
                        left = -(iw - containerDims.innerWidth);
                        break;
                    default:
                        break;
                }
            }
        }
        image.addClass(options.imageClass);
        if (image.data("nailthumb.replaceto")) {
            replaceImage(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
        } else {
            showImage(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
        }
    }

    function replaceImage(image, imageDims, container, containerDims, ih, iw, left, top, diff, options) {
        var element = image.data("nailthumb.replaceto");
        var replaceto = findReplaceTo(element, options);
        image.data("nailthumb.replacing", true);
        image.load(function () {
            image.data("nailthumb.replacing", null);
        });
        if (replaceto) {
            replaceto.replaceWith(image);
        } else {
            element.append(image);
        }
        if (options.afterReplace) {
            options.afterReplace(container, image, options);
        }
        showImage(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
    }

    function showImage(image, imageDims, container, containerDims, ih, iw, left, top, diff, options) {
        if (options.replaceAnimation == "animate") {
            image.css("display", "inline");
            container.animate({
                "width": containerDims.innerWidth,
                "height": containerDims.innerHeight
            }, options.animationTime, options.animation);
            image.animate({
                "width": iw,
                "height": ih,
                "top": top,
                "left": left
            }, options.animationTime, options.animation, function () {
                afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
            });
        } else {
            container.css({"width": containerDims.innerWidth, "height": containerDims.innerHeight});
            if (options.replaceAnimation) {
                image.css("display", "none");
            }
            image.css({"width": iw, "height": ih, "top": top, "left": left});
            if (options.replaceAnimation == "fade") {
                image.fadeIn(options.animationTime, options.animation, function () {
                    afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
                });
            } else {
                if (options.replaceAnimation == "slide") {
                    image.slideDown(options.animationTime, options.animation, function () {
                        afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
                    });
                } else {
                    if (options.replaceAnimation && options.replaceAnimation instanceof Function) {
                        options.replaceAnimation(image, function () {
                            afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
                        }, options);
                        if (!options.selfStartAfterAppear) {
                            afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
                        }
                    } else {
                        image.css("display", "inline");
                        afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
                    }
                }
            }
        }
    }

    function afterAppear(image, imageDims, container, containerDims, ih, iw, left, top, diff, options) {
        if (options.afterAppear) {
            options.afterAppear(container, image, options);
        }
        image.data("nailthumb.replaceto", null);
        decorate(image, imageDims, container, containerDims, ih, iw, left, top, diff, options);
    }

    function findReplaceTo(element, options) {
        var rep = null;
        element.find("img").each(function () {
            if (!rep && !$(this).data("nailthumb.replaceto")) {
                rep = $(this);
            }
        });
        return rep;
    }

    function decorate(image, imageDims, container, containerDims, ih, iw, left, top, diff, options) {
        if (options.title || (options.titleAttr && image.attr(options.titleAttr))) {
            var title = options.title ? options.title : image.attr(options.titleAttr);
            if (title) {
                var span = $('<span class="' + options.titleClass + '">' + title + "</span>");
                if (containerDims.innerHeight > ih) {
                    span.css("top", containerDims.innerHeight - ih);
                } else {
                    span.css("top", "0px");
                }
                container.append(span);
                var tit = getHiddenDims(span);
                var im = getHiddenDims(image);
                debugObject("decorate containerDims", containerDims);
                debugObject("decorate imageDims", imageDims);
                debugObject("decorate imageDims", im);
                debugObject("decorate tit", tit);
                var outbound = containerDims.offsetTop + containerDims.innerHeight - tit.offsetTop;
                if (containerDims.height > containerDims.innerHeight) {
                    outbound += (containerDims.height - containerDims.innerHeight) / 2;
                }
                span.css("top", "+=" + outbound);
                if (iw < tit.width) {
                    span.css("width", iw);
                }
                if (left > 0) {
                    span.css("left", left);
                }
                var delta = tit.height;
                if (containerDims.innerHeight > ih && diff != "bottom") {
                    delta += (containerDims.innerHeight - ih) / ((diff == "top") ? 1 : 2);
                }
                var clone = span.clone();
                clone.css("width", "auto").css("display", "none").css("position", "absolute");
                container.append(clone);
                var cloneDims = getHiddenDims(clone);
                clone.remove();
                debugObject("decorate cloneDims", cloneDims);
                if (options.titleWhen == "hover") {
                    container.unbind("mouseenter mouseleave").hover(function () {
                        span.find("span." + options.titleScrollerClass).css("left", 0);
                        containerDims = getHiddenDims(container);
                        tit = getHiddenDims(span);
                        outbound = containerDims.offsetTop + containerDims.innerHeight - tit.offsetTop;
                        if (containerDims.height > containerDims.innerHeight) {
                            outbound += (containerDims.height - containerDims.innerHeight) / 2;
                        }
                        debugObject("decorate hover tit", tit);
                        debug("decorate hover outbound", tit);
                        var doubleDelta = 0;
                        if (outbound < 0) {
                            span.css("top", "+=" + outbound);
                            doubleDelta = delta;
                        } else {
                            doubleDelta = delta - outbound;
                        }
                        if (options.animateTitle) {
                            resetScrollTitle(span, options);
                            span.stop(true).animate({top: "-=" + doubleDelta}, options.titleAnimationTime, options.titleAnimation, function () {
                                scrollTitle(span, cloneDims.width, containerDims.innerWidth, options);
                            });
                        } else {
                            span.css({top: "-=" + doubleDelta});
                            scrollTitle(span, cloneDims.width, containerDims.innerWidth, options);
                        }
                    }, function () {
                        if (options.animateTitle) {
                            resetScrollTitle(span, options);
                            span.animate({top: "+=" + delta}, options.titleAnimationTime, options.titleAnimation, function () {
                                resetScrollTitle(span, options);
                            });
                        } else {
                            resetScrollTitle(span, options);
                            span.css({top: "+=" + delta});
                        }
                    });
                } else {
                    if (options.animateTitle) {
                        span.animate({top: "-=" + delta}, options.titleAnimationTime, options.titleAnimation, function () {
                            scrollTitle(span, cloneDims.width, containerDims.innerWidth, options);
                        });
                    } else {
                        span.css({top: "-=" + delta});
                        scrollTitle(span, cloneDims.width, containerDims.innerWidth, options);
                    }
                }
            }
        }
        if (options.onFinish) {
            options.onFinish(container, options);
        }
        if (options.loadingClass) {
            container.removeClass(options.loadingClass);
        }
        image.data("nailthumb.working", null);
    }

    function resetScrollTitle(span, options) {
        span.find("span." + options.titleScrollerClass).stop();
    }

    function scrollTitle(span, width, visibleWidth, options) {
        if (width > visibleWidth && options.titleScrolling) {
            if (span.find("span." + options.titleScrollerClass).length == 0) {
                span.wrapInner('<span class="' + options.titleScrollerClass + '" />');
                span.find("span." + options.titleScrollerClass).width(width).css("position", "relative").css("white-space", "nowrap");
            }
            span.find("span." + options.titleScrollerClass).css("left", 0);
            setTimeout(scrollFunction(span, width, visibleWidth, options), 1000);
        }
    }

    function scrollFunction(span, width, visibleWidth, options) {
        return function () {
            var indent = Number(span.find("span." + options.titleScrollerClass).css("left").replace(/[^-\d]/g, ""));
            debug("indent", indent);
            debug("width", width);
            debug("visibleWidth", visibleWidth);
            debug("width <= -indent", (width <= -indent));
            var delta = width + indent;
            if (delta <= 0) {
                span.find("span." + options.titleScrollerClass).css("left", visibleWidth);
                delta = width + visibleWidth;
            }
            delta += 10;
            span.find("span." + options.titleScrollerClass).animate({"left": "-=" + delta}, width * 1000 / 30, "linear", scrollFunction(span, width, visibleWidth, options));
        };
    }

    function getProportion(containerDims, imageDims, options) {
        if (options.proportions != null && options.proportions > 0) {
            return options.proportions;
        } else {
            var prop = containerDims.innerWidth / imageDims.width;
            if (options.method && options.method == "resize") {
                if (containerDims.innerHeight / imageDims.height < prop) {
                    prop = containerDims.innerHeight / imageDims.height;
                }
            } else {
                if (containerDims.innerHeight / imageDims.height > prop) {
                    prop = containerDims.innerHeight / imageDims.height;
                }
            }
            if (options.maxEnlargement && options.maxEnlargement < prop) {
                prop = options.maxEnlargement;
            }
            if (options.maxShrink && options.maxShrink > prop) {
                prop = options.maxShrink;
            }
            return prop;
        }
    }

    function getDirections(option) {
        var dir = {h: "center", v: "center"};
        if (option) {
            var opts = option.split(" ");
            if (opts.length > 0) {
                dir = getDirection(opts[0], dir);
            }
            if (opts.length > 1) {
                dir = getDirection(opts[1], dir);
            }
        }
        return dir;
    }

    function getDirection(str, d) {
        switch (str) {
            case"top":
                d.v = "top";
                break;
            case"bottom":
                d.v = "bottom";
                break;
            case"left":
                d.h = "left";
                break;
            case"right":
                d.h = "right";
                break;
            default:
                break;
        }
        return d;
    }

    function getImageDims(image, options) {
        var imageDims;
        if (!image.data("nailthumb.originalImageDims")) {
            imageDims = getHiddenDims(image);
            image.data("nailthumb.originalImageDims", imageDims);
            if (!options.keepImageDimensions) {
                image.one("load", function () {
                    image.data("nailthumb.originalImageDims", null);
                });
            }
        } else {
            imageDims = image.data("nailthumb.originalImageDims");
        }
        return imageDims;
    }

    function getContainerDims(container, options) {
        var containerDims = getHiddenDims(container);
        if (options.width) {
            containerDims.innerWidth = options.width;
        }
        if (options.height) {
            containerDims.innerHeight = options.height;
        }
        return containerDims;
    }

    function getDims(elem) {
        var offset = $(elem).offset();
        return {
            offsetTop: offset.top,
            offsetLeft: offset.left,
            width: $(elem).outerWidth(),
            height: $(elem).outerHeight(),
            innerWidth: $(elem).innerWidth(),
            innerHeight: $(elem).innerHeight()
        };
    }

    function getHiddenDims(elems) {
        var dims = null, i = 0, offset, elem;
        while ((elem = elems[i++])) {
            var hiddenElems = $(elem).parents().andSelf().filter(":hidden");
            if (!hiddenElems.length) {
                dims = getDims(elem);
            } else {
                var backupStyle = [];
                hiddenElems.each(function () {
                    var style = $(this).attr("style");
                    style = typeof style == "undefined" ? "" : style;
                    backupStyle.push(style);
                    $(this).attr("style", style + " display: block !important;");
                });
                hiddenElems.eq(0).css("left", -10000);
                dims = getDims(elem);
                hiddenElems.each(function () {
                    $(this).attr("style", backupStyle.shift());
                });
            }
        }
        return dims;
    }

    function getHiddenCloneDims(elems) {
        var dims = null, i = 0, offset, elem;
        while ((elem = elems[i++])) {
            var hiddenElems = $(elem).parents().andSelf().filter(":hidden");
            if (!hiddenElems.length) {
                dims = getDims(elem);
            } else {
                var backupStyle = [];
                hiddenElems.each(function () {
                    var style = $(this).attr("style");
                    style = typeof style == "undefined" ? "" : style;
                    backupStyle.push(style);
                    $(this).attr("style", style + " display: block !important;");
                });
                hiddenElems.eq(0).css("left", -10000);
                var clone = hiddenElems.eq(0).clone();
                $("body").append(clone);
                dims = getDims(clone);
                hiddenElems.each(function () {
                    $(this).attr("style", backupStyle.shift());
                });
                clone.remove();
            }
        }
        return dims;
    }

    $.fn.nailthumb.evalServerSideParams = function (image, container, options) {
        if (options.serverSideParams) {
            var params = {};
            if (!options.serverSideParams.noServerResize) {
                var w = null, h = null;
                if (options.serverSideParams.width) {
                    w = options.serverSideParams.width;
                } else {
                    if (options.width) {
                        w = options.width;
                    }
                }
                if (options.serverSideParams.height) {
                    h = options.serverSideParams.height;
                } else {
                    if (options.height) {
                        h = options.height;
                    }
                }
                if (!(w && h)) {
                    resetContainer(container, options);
                    var containerDims = getContainerDims(container, options);
                    w = containerDims.innerWidth;
                    h = containerDims.innerHeight;
                }
                if (w && h) {
                    params.w = w;
                    params.h = h;
                    if (options.serverSideParams.mode != "resize") {
                        if (options.method == "crop") {
                            params.mode = "crop";
                        }
                        if (options.serverSideParams.mode) {
                            params.mode = options.serverSideParams.mode;
                        }
                    }
                }
            }
            $.each(options.serverSideParams, function (key, val) {
                if (key != "width" && key != "height" && key != "mode" && key != "noServerResize" && val) {
                    params[key] = val;
                }
            });
            var pars = "";
            $.each(params, function (key, val) {
                pars += ";" + key + "=" + val;
            });
            debug(pars, params);
            return pars;
        } else {
            return "";
        }
    };
    $.fn.nailthumb.setServerSideParams = function (image, container, options) {
        if (options.serverSideParams) {
            var url = image.attr("src");
            if (image.data("nailthumb.originalImageUrl")) {
                url = image.data("nailthumb.originalImageUrl");
            }
            image.data("nailthumb.originalImageUrl", url);
            var pars = $.fn.nailthumb.evalServerSideParams(image, container, options);
            url += pars;
            image.attr("src", url);
        }
    };
    $.fn.nailthumb.toggleDebug = function () {
        DEBUG = !DEBUG;
    };
    $.fn.nailthumb.doThumb = function (image, container, options) {
        doThumb(image, container, options);
    };
    $.fn.nailthumb.defaults = {
        onStart: null,
        onFinish: null,
        loadingClass: "nailthumb-loading",
        imageUrl: null,
        imageFromWrappingLink: false,
        imageCustomFinder: null,
        imageClass: "nailthumb-image",
        afterReplace: null,
        afterAppear: null,
        replaceAnimation: "fade",
        selfStartAfterAppear: false,
        animationTime: 1000,
        animation: "swing",
        keepImageDimensions: false,
        method: "crop",
        fitDirection: null,
        proportions: null,
        ifImageAddContainer: true,
        containerClass: "nailthumb-container",
        maxEnlargement: null,
        maxShrink: null,
        preload: true,
        nostyle: false,
        width: null,
        height: null,
        title: null,
        titleClass: "nailthumb-title",
        titleAttr: "title",
        titleWhen: "hover",
        titleScrolling: true,
        titleScrollerClass: "nailthumb-title-scroller",
        animateTitle: true,
        titleAnimationTime: 500,
        titleAnimation: "swing",
        serverSideParams: null
    };
    function log(log, jQueryobj) {
        try {
            debug(log, jQueryobj, true);
        } catch (ex) {
        }
    }

    function debug(log, jQueryobj, force) {
        try {
            if ((DEBUG && window.console && window.console.log) || force) {
                window.console.log(log + ": " + jQueryobj);
            }
        } catch (ex) {
        }
    }

    function debugObject(log, jQueryobj, force) {
        try {
            if (!jQueryobj) {
                jQueryobj = log;
            }
            debug(log, jQueryobj);
            if ((DEBUG && window.console && window.console.log) || force) {
                window.console.debug(jQueryobj);
            }
        } catch (ex) {
        }
    }
})(jQuery);
﻿
/*
 * jQuery showLoading plugin v1.0

 * 
 * Copyright (c) 2009 Jim Keller
 * Context - http://www.contextllc.com
 * 
 * Dual licensed under the MIT and GPL licenses.
 *
 */
jQuery.fn.showLoading = function (options) {
    var indicatorID;
    var settings = {
        'addClass': '',
        'beforeShow': '',
        'afterShow': '',
        'hPos': 'center',
        'vPos': 'center',
        'indicatorZIndex': 5001,
        'overlayZIndex': 5000,
        'parent': '',
        'marginTop': 0,
        'marginLeft': 0,
        'overlayWidth': null,
        'overlayHeight': null
    };
    jQuery.extend(settings, options);
    var loadingDiv = jQuery('<div></div>');
    var overlayDiv = jQuery('<div></div>');
    if (settings.indicatorID) {
        indicatorID = settings.indicatorID;
    }
    else {
        indicatorID = jQuery(this).attr('id');
    }
    jQuery(loadingDiv).attr('id', 'loading-indicator-' + indicatorID);
    jQuery(loadingDiv).addClass('loading-indicator');
    if (settings.addClass) {
        jQuery(loadingDiv).addClass(settings.addClass);
    }
    jQuery(overlayDiv).css('display', 'none');
    jQuery(document.body).append(overlayDiv);
    jQuery(overlayDiv).attr('id', 'loading-indicator-' + indicatorID + '-overlay');
    jQuery(overlayDiv).addClass('loading-indicator-overlay');
    if (settings.addClass) {
        jQuery(overlayDiv).addClass(settings.addClass + '-overlay');
    }
    var overlay_width;
    var overlay_height;
    var border_top_width = jQuery(this).css('border-top-width');
    var border_left_width = jQuery(this).css('border-left-width');
    border_top_width = isNaN(parseInt(border_top_width)) ? 0 : border_top_width;
    border_left_width = isNaN(parseInt(border_left_width)) ? 0 : border_left_width;
    var overlay_left_pos = jQuery(this).offset().left + parseInt(border_left_width);
    var overlay_top_pos = jQuery(this).offset().top + parseInt(border_top_width);
    if (settings.overlayWidth !== null) {
        overlay_width = settings.overlayWidth;
    }
    else {
        overlay_width = parseInt(jQuery(this).width()) + parseInt(jQuery(this).css('padding-right')) + parseInt(jQuery(this).css('padding-left'));
    }
    if (settings.overlayHeight !== null) {
        overlay_height = settings.overlayWidth;
    }
    else {
        overlay_height = parseInt(jQuery(this).height()) + parseInt(jQuery(this).css('padding-top')) + parseInt(jQuery(this).css('padding-bottom'));
    }
    jQuery(overlayDiv).css('width', overlay_width.toString() + 'px');
    jQuery(overlayDiv).css('height', overlay_height.toString() + 'px');
    jQuery(overlayDiv).css('left', overlay_left_pos.toString() + 'px');
    jQuery(overlayDiv).css('position', 'absolute');
    jQuery(overlayDiv).css('top', overlay_top_pos.toString() + 'px');
    jQuery(overlayDiv).css('z-index', settings.overlayZIndex);
    if (settings.overlayCSS) {
        jQuery(overlayDiv).css(settings.overlayCSS);
    }
    jQuery(loadingDiv).css('display', 'none');
    jQuery(document.body).append(loadingDiv);
    jQuery(loadingDiv).css('position', 'absolute');
    jQuery(loadingDiv).css('z-index', settings.indicatorZIndex);
    var indicatorTop = overlay_top_pos;
    if (settings.marginTop) {
        indicatorTop += parseInt(settings.marginTop);
    }
    var indicatorLeft = overlay_left_pos;
    if (settings.marginLeft) {
        indicatorLeft += parseInt(settings.marginTop);
    }
    if (settings.hPos.toString().toLowerCase() == 'center') {
        jQuery(loadingDiv).css('left', (indicatorLeft + ((jQuery(overlayDiv).width() - parseInt(jQuery(loadingDiv).width())) / 2)).toString() + 'px');
    }
    else if (settings.hPos.toString().toLowerCase() == 'left') {
        jQuery(loadingDiv).css('left', (indicatorLeft + parseInt(jQuery(overlayDiv).css('margin-left'))).toString() + 'px');
    }
    else if (settings.hPos.toString().toLowerCase() == 'right') {
        jQuery(loadingDiv).css('left', (indicatorLeft + (jQuery(overlayDiv).width() - parseInt(jQuery(loadingDiv).width()))).toString() + 'px');
    }
    else {
        jQuery(loadingDiv).css('left', (indicatorLeft + parseInt(settings.hPos)).toString() + 'px');
    }
    if (settings.vPos.toString().toLowerCase() == 'center') {
        jQuery(loadingDiv).css('top', (indicatorTop + ((jQuery(overlayDiv).height() - parseInt(jQuery(loadingDiv).height())) / 2)).toString() + 'px');
    }
    else if (settings.vPos.toString().toLowerCase() == 'top') {
        jQuery(loadingDiv).css('top', indicatorTop.toString() + 'px');
    }
    else if (settings.vPos.toString().toLowerCase() == 'bottom') {
        jQuery(loadingDiv).css('top', (indicatorTop + (jQuery(overlayDiv).height() - parseInt(jQuery(loadingDiv).height()))).toString() + 'px');
    }
    else {
        jQuery(loadingDiv).css('top', (indicatorTop + parseInt(settings.vPos)).toString() + 'px');
    }
    if (settings.css) {
        jQuery(loadingDiv).css(settings.css);
    }
    var callback_options = {'overlay': overlayDiv, 'indicator': loadingDiv, 'element': this};
    if (typeof(settings.beforeShow) == 'function') {
        settings.beforeShow(callback_options);
    }
    jQuery(overlayDiv).show();
    jQuery(loadingDiv).show();
    if (typeof(settings.afterShow) == 'function') {
        settings.afterShow(callback_options);
    }
    return this;
};
jQuery.fn.hideLoading = function (options) {
    var settings = {};
    jQuery.extend(settings, options);
    if (settings.indicatorID) {
        indicatorID = settings.indicatorID;
    }
    else {
        indicatorID = jQuery(this).attr('id');
    }
    jQuery(document.body).find('#loading-indicator-' + indicatorID).remove();
    jQuery(document.body).find('#loading-indicator-' + indicatorID + '-overlay').remove();
    return this;
};
// $('img.photo',this).imagesLoaded(myFunction)
// execute a callback when all images have loaded.
// needed because .load() doesn't work on cached images

// Modified with a two-pass approach to changing image
// src. First, the proxy imagedata is set, which leads
// to the first callback being triggered, which resets
// imagedata to the original src, which fires the final,
// user defined callback.

// modified by yiannis chatzikonstantinou.

// original:
// mit license. paul irish. 2010.
// webkit fix from Oren Solomianik. thx!

// callback function is passed the last image to load
//   as an argument, and the collection as `this`


$.fn.imagesLoaded = function (callback) {
    var elems = this.find('img'),
        elems_src = [],
        self = this,
        len = elems.length;

    if (!elems.length) {
        callback.call(this);
        return this;
    }

    elems.one('load error', function () {
        if (--len === 0) {
            // Rinse and repeat.
            len = elems.length;
            elems.one('load error', function () {
                if (--len === 0) {
                    callback.call(self);
                }
            }).each(function () {
                this.src = elems_src.shift();
            });
        }
    }).each(function () {
        elems_src.push(this.src);
        // webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f
        // data uri bypasses webkit log warning (thx doug jones)
        this.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
    });

    return this;
};

/*!
 jQuery Wookmark plugin 0.5
 @name jquery.wookmark.js
 @author Christoph Ono (chri@sto.ph or @gbks)
 @version 0.5
 @date 3/19/2012
 @category jQuery plugin
 @copyright (c) 2009-2012 Christoph Ono (www.wookmark.com)
 @license Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */
$.fn.wookmark = function (a) {
    if (!this.wookmarkOptions) {
        this.wookmarkOptions = $.extend({
            container: $("body"),
            offset: 2,
            autoResize: false,
            itemWidth: $(this[0]).outerWidth(),
            resizeDelay: 50
        }, a)
    } else if (a) {
        this.wookmarkOptions = $.extend(this.wookmarkOptions, a)
    }
    if (!this.wookmarkColumns) {
        this.wookmarkColumns = null;
        this.wookmarkContainerWidth = null
    }
    this.wookmarkLayout = function () {
        var a = this.wookmarkOptions.itemWidth + this.wookmarkOptions.offset;
        var b = this.wookmarkOptions.container.width();
        var c = Math.floor((b + this.wookmarkOptions.offset) / a);
        var d = Math.round((b - (c * a - this.wookmarkOptions.offset)) / 2);
        var e = 0;
        if (this.wookmarkColumns != null && this.wookmarkColumns.length == c) {
            e = this.wookmarkLayoutColumns(a, d)
        } else {
            e = this.wookmarkLayoutFull(a, c, d)
        }
        this.wookmarkOptions.container.css("height", e + "px")
    };
    this.wookmarkLayoutFull = function (a, b, c) {
        var d = [];
        while (d.length < b) {
            d.push(0)
        }
        this.wookmarkColumns = [];
        while (this.wookmarkColumns.length < b) {
            this.wookmarkColumns.push([])
        }
        var e, f, g, h = 0, i = 0, j = this.length, k = null, l = null, m = 0;
        for (; h < j; h++) {
            e = $(this[h]);
            k = null;
            l = 0;
            for (i = 0; i < b; i++) {
                if (k == null || d[i] < k) {
                    k = d[i];
                    l = i
                }
            }
            e.css({position: "absolute", top: k + "px", left: l * a + c + "px"});
            d[l] = k + e.outerHeight() + this.wookmarkOptions.offset;
            m = Math.max(m, d[l]);
            this.wookmarkColumns[l].push(e)
        }
        return m
    };
    this.wookmarkLayoutColumns = function (a, b) {
        var c = [];
        while (c.length < this.wookmarkColumns.length) {
            c.push(0)
        }
        var d = 0, e = this.wookmarkColumns.length, f;
        var g = 0, h, i;
        var j = 0;
        for (; d < e; d++) {
            f = this.wookmarkColumns[d];
            h = f.length;
            for (g = 0; g < h; g++) {
                i = f[g];
                i.css({left: d * a + b + "px", top: c[d] + "px"});
                c[d] += i.outerHeight() + this.wookmarkOptions.offset;
                j = Math.max(j, c[d])
            }
        }
        return j
    };
    this.wookmarkResizeTimer = null;
    if (!this.wookmarkResizeMethod) {
        this.wookmarkResizeMethod = null
    }
    if (this.wookmarkOptions.autoResize) {
        this.wookmarkOnResize = function (a) {
            if (this.wookmarkResizeTimer) {
                clearTimeout(this.wookmarkResizeTimer)
            }
            this.wookmarkResizeTimer = setTimeout($.proxy(this.wookmarkLayout, this), this.wookmarkOptions.resizeDelay)
        };
        if (!this.wookmarkResizeMethod) {
            this.wookmarkResizeMethod = $.proxy(this.wookmarkOnResize, this)
        }
        $(window).resize(this.wookmarkResizeMethod)
    }
    this.wookmarkClear = function () {
        if (this.wookmarkResizeTimer) {
            clearTimeout(this.wookmarkResizeTimer);
            this.wookmarkResizeTimer = null
        }
        if (this.wookmarkResizeMethod) {
            $(window).unbind("resize", this.wookmarkResizeMethod)
        }
    };
    this.wookmarkLayout();
    this.show()
};

/**
 * @summary     DataTables
 * @description Paginate, search and sort HTML tables
 * @version     1.9.4
 * @file        jquery.dataTables.js
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2008-2012 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,define,_fnExternApiFunc,_fnInitialise,_fnInitComplete,_fnLanguageCompat,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnCreateTr,_fnGatherData,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnServerParams,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAdjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnDetectHeader,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap,_fnGetRowData,_fnGetCellData,_fnSetCellData,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnApplyColumnDefs,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnJsonString,_fnRender,_fnNodeToColumnIndex,_fnInfoMacros,_fnBrowserDetect,_fnGetColumns*/

(/** @lends <global> */function (window, document, undefined) {

    (function (factory) {
        "use strict";

        // Define as an AMD module if possible
        if (typeof define === 'function' && define.amd) {
            define(['jquery'], factory);
        }
        /* Define using browser globals otherwise
         * Prevent multiple instantiations if the script is loaded twice
         */
        else if (jQuery && !jQuery.fn.dataTable) {
            factory(jQuery);
        }
    }
    (/** @lends <global> */function ($) {
        "use strict";
        /**
         * DataTables is a plug-in for the jQuery Javascript library. It is a
         * highly flexible tool, based upon the foundations of progressive
         * enhancement, which will add advanced interaction controls to any
         * HTML table. For a full list of features please refer to
         * <a href="http://datatables.net">DataTables.net</a>.
         *
         * Note that the <i>DataTable</i> object is not a global variable but is
         * aliased to <i>jQuery.fn.DataTable</i> and <i>jQuery.fn.dataTable</i> through which
         * it may be  accessed.
         *
         *  @class
         *  @param {object} [oInit={}] Configuration object for DataTables. Options
         *    are defined by {@link DataTable.defaults}
         *  @requires jQuery 1.3+
         *
         *  @example
         *    // Basic initialisation
         *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
         *
         *  @example
         *    // Initialisation with configuration options - in this case, disable
         *    // pagination and sorting.
         *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "bPaginate": false,
	 *        "bSort": false 
	 *      } );
	 *    } );
         */
        var DataTable = function (oInit) {


            /**
             * Add a column to the list used for the table with default values
             *  @param {object} oSettings dataTables settings object
             *  @param {node} nTh The th element for this column
             *  @memberof DataTable#oApi
             */
            function _fnAddColumn(oSettings, nTh) {
                var oDefaults = DataTable.defaults.columns;
                var iCol = oSettings.aoColumns.length;
                var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
                    "sSortingClass": oSettings.oClasses.sSortable,
                    "sSortingClassJUI": oSettings.oClasses.sSortJUI,
                    "nTh": nTh ? nTh : document.createElement('th'),
                    "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
                    "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
                    "mData": oDefaults.mData ? oDefaults.oDefaults : iCol
                });
                oSettings.aoColumns.push(oCol);

                /* Add a column specific filter */
                if (oSettings.aoPreSearchCols[iCol] === undefined || oSettings.aoPreSearchCols[iCol] === null) {
                    oSettings.aoPreSearchCols[iCol] = $.extend({}, DataTable.models.oSearch);
                }
                else {
                    var oPre = oSettings.aoPreSearchCols[iCol];

                    /* Don't require that the user must specify bRegex, bSmart or bCaseInsensitive */
                    if (oPre.bRegex === undefined) {
                        oPre.bRegex = true;
                    }

                    if (oPre.bSmart === undefined) {
                        oPre.bSmart = true;
                    }

                    if (oPre.bCaseInsensitive === undefined) {
                        oPre.bCaseInsensitive = true;
                    }
                }

                /* Use the column options function to initialise classes etc */
                _fnColumnOptions(oSettings, iCol, null);
            }


            /**
             * Apply options for a column
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iCol column index to consider
             *  @param {object} oOptions object with sType, bVisible and bSearchable etc
             *  @memberof DataTable#oApi
             */
            function _fnColumnOptions(oSettings, iCol, oOptions) {
                var oCol = oSettings.aoColumns[iCol];

                /* User specified column options */
                if (oOptions !== undefined && oOptions !== null) {
                    /* Backwards compatibility for mDataProp */
                    if (oOptions.mDataProp && !oOptions.mData) {
                        oOptions.mData = oOptions.mDataProp;
                    }

                    if (oOptions.sType !== undefined) {
                        oCol.sType = oOptions.sType;
                        oCol._bAutoType = false;
                    }

                    $.extend(oCol, oOptions);
                    _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

                    /* iDataSort to be applied (backwards compatibility), but aDataSort will take
                     * priority if defined
                     */
                    if (oOptions.iDataSort !== undefined) {
                        oCol.aDataSort = [oOptions.iDataSort];
                    }
                    _fnMap(oCol, oOptions, "aDataSort");
                }

                /* Cache the data get and set functions for speed */
                var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
                var mData = _fnGetObjectDataFn(oCol.mData);

                oCol.fnGetData = function (oData, sSpecific) {
                    var innerData = mData(oData, sSpecific);

                    if (oCol.mRender && (sSpecific && sSpecific !== '')) {
                        return mRender(innerData, sSpecific, oData);
                    }
                    return innerData;
                };
                oCol.fnSetData = _fnSetObjectDataFn(oCol.mData);

                /* Feature sorting overrides column specific when off */
                if (!oSettings.oFeatures.bSort) {
                    oCol.bSortable = false;
                }

                /* Check that the class assignment is correct for sorting */
                if (!oCol.bSortable ||
                    ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1)) {
                    oCol.sSortingClass = oSettings.oClasses.sSortableNone;
                    oCol.sSortingClassJUI = "";
                }
                else if ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) {
                    oCol.sSortingClass = oSettings.oClasses.sSortable;
                    oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI;
                }
                else if ($.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1) {
                    oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
                    oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
                }
                else if ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1) {
                    oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
                    oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
                }
            }


            /**
             * Adjust the table column widths for new data. Note: you would probably want to
             * do a redraw after calling this function!
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnAdjustColumnSizing(oSettings) {
                /* Not interested in doing column width calculation if auto-width is disabled */
                if (oSettings.oFeatures.bAutoWidth === false) {
                    return false;
                }

                _fnCalculateColumnWidths(oSettings);
                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
                }
            }


            /**
             * Covert the index of a visible column to the index in the data array (take account
             * of hidden columns)
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iMatch Visible column index to lookup
             *  @returns {int} i the data index
             *  @memberof DataTable#oApi
             */
            function _fnVisibleToColumnIndex(oSettings, iMatch) {
                var aiVis = _fnGetColumns(oSettings, 'bVisible');

                return typeof aiVis[iMatch] === 'number' ?
                    aiVis[iMatch] :
                    null;
            }


            /**
             * Covert the index of an index in the data array and convert it to the visible
             *   column index (take account of hidden columns)
             *  @param {int} iMatch Column index to lookup
             *  @param {object} oSettings dataTables settings object
             *  @returns {int} i the data index
             *  @memberof DataTable#oApi
             */
            function _fnColumnIndexToVisible(oSettings, iMatch) {
                var aiVis = _fnGetColumns(oSettings, 'bVisible');
                var iPos = $.inArray(iMatch, aiVis);

                return iPos !== -1 ? iPos : null;
            }


            /**
             * Get the number of visible columns
             *  @param {object} oSettings dataTables settings object
             *  @returns {int} i the number of visible columns
             *  @memberof DataTable#oApi
             */
            function _fnVisbleColumns(oSettings) {
                return _fnGetColumns(oSettings, 'bVisible').length;
            }


            /**
             * Get an array of column indexes that match a given property
             *  @param {object} oSettings dataTables settings object
             *  @param {string} sParam Parameter in aoColumns to look for - typically
             *    bVisible or bSearchable
             *  @returns {array} Array of indexes with matched properties
             *  @memberof DataTable#oApi
             */
            function _fnGetColumns(oSettings, sParam) {
                var a = [];

                $.map(oSettings.aoColumns, function (val, i) {
                    if (val[sParam]) {
                        a.push(i);
                    }
                });

                return a;
            }


            /**
             * Get the sort type based on an input string
             *  @param {string} sData data we wish to know the type of
             *  @returns {string} type (defaults to 'string' if no type can be detected)
             *  @memberof DataTable#oApi
             */
            function _fnDetectType(sData) {
                var aTypes = DataTable.ext.aTypes;
                var iLen = aTypes.length;

                for (var i = 0; i < iLen; i++) {
                    var sType = aTypes[i](sData);
                    if (sType !== null) {
                        return sType;
                    }
                }

                return 'string';
            }


            /**
             * Figure out how to reorder a display list
             *  @param {object} oSettings dataTables settings object
             *  @returns array {int} aiReturn index list for reordering
             *  @memberof DataTable#oApi
             */
            function _fnReOrderIndex(oSettings, sColumns) {
                var aColumns = sColumns.split(',');
                var aiReturn = [];

                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    for (var j = 0; j < iLen; j++) {
                        if (oSettings.aoColumns[i].sName == aColumns[j]) {
                            aiReturn.push(j);
                            break;
                        }
                    }
                }

                return aiReturn;
            }


            /**
             * Get the column ordering that DataTables expects
             *  @param {object} oSettings dataTables settings object
             *  @returns {string} comma separated list of names
             *  @memberof DataTable#oApi
             */
            function _fnColumnOrdering(oSettings) {
                var sNames = '';
                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    sNames += oSettings.aoColumns[i].sName + ',';
                }
                if (sNames.length == iLen) {
                    return "";
                }
                return sNames.slice(0, -1);
            }


            /**
             * Take the column definitions and static columns arrays and calculate how
             * they relate to column indexes. The callback function will then apply the
             * definition found for a column to a suitable configuration object.
             *  @param {object} oSettings dataTables settings object
             *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
             *  @param {array} aoCols The aoColumns array that defines columns individually
             *  @param {function} fn Callback function - takes two parameters, the calculated
             *    column index and the definition for that column.
             *  @memberof DataTable#oApi
             */
            function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
                var i, iLen, j, jLen, k, kLen;

                // Column definitions with aTargets
                if (aoColDefs) {
                    /* Loop over the definitions array - loop in reverse so first instance has priority */
                    for (i = aoColDefs.length - 1; i >= 0; i--) {
                        /* Each definition can target multiple columns, as it is an array */
                        var aTargets = aoColDefs[i].aTargets;
                        if (!$.isArray(aTargets)) {
                            _fnLog(oSettings, 1, 'aTargets must be an array of targets, not a ' + (typeof aTargets));
                        }

                        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
                            if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
                                /* Add columns that we don't yet know about */
                                while (oSettings.aoColumns.length <= aTargets[j]) {
                                    _fnAddColumn(oSettings);
                                }

                                /* Integer, basic index */
                                fn(aTargets[j], aoColDefs[i]);
                            }
                            else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
                                /* Negative integer, right to left column counting */
                                fn(oSettings.aoColumns.length + aTargets[j], aoColDefs[i]);
                            }
                            else if (typeof aTargets[j] === 'string') {
                                /* Class name matching on TH element */
                                for (k = 0, kLen = oSettings.aoColumns.length; k < kLen; k++) {
                                    if (aTargets[j] == "_all" ||
                                        $(oSettings.aoColumns[k].nTh).hasClass(aTargets[j])) {
                                        fn(k, aoColDefs[i]);
                                    }
                                }
                            }
                        }
                    }
                }

                // Statically defined columns array
                if (aoCols) {
                    for (i = 0, iLen = aoCols.length; i < iLen; i++) {
                        fn(i, aoCols[i]);
                    }
                }
            }

            /**
             * Add a data array to the table, creating DOM node etc. This is the parallel to
             * _fnGatherData, but for adding rows from a Javascript source, rather than a
             * DOM source.
             *  @param {object} oSettings dataTables settings object
             *  @param {array} aData data array to be added
             *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
             *  @memberof DataTable#oApi
             */
            function _fnAddData(oSettings, aDataSupplied) {
                var oCol;

                /* Take an independent copy of the data source so we can bash it about as we wish */
                var aDataIn = ($.isArray(aDataSupplied)) ?
                    aDataSupplied.slice() :
                    $.extend(true, {}, aDataSupplied);

                /* Create the object for storing information about this new row */
                var iRow = oSettings.aoData.length;
                var oData = $.extend(true, {}, DataTable.models.oRow);
                oData._aData = aDataIn;
                oSettings.aoData.push(oData);

                /* Create the cells */
                var nTd, sThisType;
                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    oCol = oSettings.aoColumns[i];

                    /* Use rendered data for filtering / sorting */
                    if (typeof oCol.fnRender === 'function' && oCol.bUseRendered && oCol.mData !== null) {
                        _fnSetCellData(oSettings, iRow, i, _fnRender(oSettings, iRow, i));
                    }
                    else {
                        _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
                    }

                    /* See if we should auto-detect the column type */
                    if (oCol._bAutoType && oCol.sType != 'string') {
                        /* Attempt to auto detect the type - same as _fnGatherData() */
                        var sVarType = _fnGetCellData(oSettings, iRow, i, 'type');
                        if (sVarType !== null && sVarType !== '') {
                            sThisType = _fnDetectType(sVarType);
                            if (oCol.sType === null) {
                                oCol.sType = sThisType;
                            }
                            else if (oCol.sType != sThisType && oCol.sType != "html") {
                                /* String is always the 'fallback' option */
                                oCol.sType = 'string';
                            }
                        }
                    }
                }

                /* Add to the display array */
                oSettings.aiDisplayMaster.push(iRow);

                /* Create the DOM information */
                if (!oSettings.oFeatures.bDeferRender) {
                    _fnCreateTr(oSettings, iRow);
                }

                return iRow;
            }


            /**
             * Read in the data from the target table from the DOM
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnGatherData(oSettings) {
                var iLoop, i, iLen, j, jLen, jInner,
                    nTds, nTrs, nTd, nTr, aLocalData, iThisIndex,
                    iRow, iRows, iColumn, iColumns, sNodeName,
                    oCol, oData;

                /*
                 * Process by row first
                 * Add the data object for the whole table - storing the tr node. Note - no point in getting
                 * DOM based data if we are going to go and replace it with Ajax source data.
                 */
                if (oSettings.bDeferLoading || oSettings.sAjaxSource === null) {
                    nTr = oSettings.nTBody.firstChild;
                    while (nTr) {
                        if (nTr.nodeName.toUpperCase() == "TR") {
                            iThisIndex = oSettings.aoData.length;
                            nTr._DT_RowIndex = iThisIndex;
                            oSettings.aoData.push($.extend(true, {}, DataTable.models.oRow, {
                                "nTr": nTr
                            }));

                            oSettings.aiDisplayMaster.push(iThisIndex);
                            nTd = nTr.firstChild;
                            jInner = 0;
                            while (nTd) {
                                sNodeName = nTd.nodeName.toUpperCase();
                                if (sNodeName == "TD" || sNodeName == "TH") {
                                    _fnSetCellData(oSettings, iThisIndex, jInner, $.trim(nTd.innerHTML));
                                    jInner++;
                                }
                                nTd = nTd.nextSibling;
                            }
                        }
                        nTr = nTr.nextSibling;
                    }
                }

                /* Gather in the TD elements of the Table - note that this is basically the same as
                 * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
                 * setup!
                 */
                nTrs = _fnGetTrNodes(oSettings);
                nTds = [];
                for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                    nTd = nTrs[i].firstChild;
                    while (nTd) {
                        sNodeName = nTd.nodeName.toUpperCase();
                        if (sNodeName == "TD" || sNodeName == "TH") {
                            nTds.push(nTd);
                        }
                        nTd = nTd.nextSibling;
                    }
                }

                /* Now process by column */
                for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
                    oCol = oSettings.aoColumns[iColumn];

                    /* Get the title of the column - unless there is a user set one */
                    if (oCol.sTitle === null) {
                        oCol.sTitle = oCol.nTh.innerHTML;
                    }

                    var
                        bAutoType = oCol._bAutoType,
                        bRender = typeof oCol.fnRender === 'function',
                        bClass = oCol.sClass !== null,
                        bVisible = oCol.bVisible,
                        nCell, sThisType, sRendered, sValType;

                    /* A single loop to rule them all (and be more efficient) */
                    if (bAutoType || bRender || bClass || !bVisible) {
                        for (iRow = 0, iRows = oSettings.aoData.length; iRow < iRows; iRow++) {
                            oData = oSettings.aoData[iRow];
                            nCell = nTds[(iRow * iColumns) + iColumn];

                            /* Type detection */
                            if (bAutoType && oCol.sType != 'string') {
                                sValType = _fnGetCellData(oSettings, iRow, iColumn, 'type');
                                if (sValType !== '') {
                                    sThisType = _fnDetectType(sValType);
                                    if (oCol.sType === null) {
                                        oCol.sType = sThisType;
                                    }
                                    else if (oCol.sType != sThisType &&
                                        oCol.sType != "html") {
                                        /* String is always the 'fallback' option */
                                        oCol.sType = 'string';
                                    }
                                }
                            }

                            if (oCol.mRender) {
                                // mRender has been defined, so we need to get the value and set it
                                nCell.innerHTML = _fnGetCellData(oSettings, iRow, iColumn, 'display');
                            }
                            else if (oCol.mData !== iColumn) {
                                // If mData is not the same as the column number, then we need to
                                // get the dev set value. If it is the column, no point in wasting
                                // time setting the value that is already there!
                                nCell.innerHTML = _fnGetCellData(oSettings, iRow, iColumn, 'display');
                            }

                            /* Rendering */
                            if (bRender) {
                                sRendered = _fnRender(oSettings, iRow, iColumn);
                                nCell.innerHTML = sRendered;
                                if (oCol.bUseRendered) {
                                    /* Use the rendered data for filtering / sorting */
                                    _fnSetCellData(oSettings, iRow, iColumn, sRendered);
                                }
                            }

                            /* Classes */
                            if (bClass) {
                                nCell.className += ' ' + oCol.sClass;
                            }

                            /* Column visibility */
                            if (!bVisible) {
                                oData._anHidden[iColumn] = nCell;
                                nCell.parentNode.removeChild(nCell);
                            }
                            else {
                                oData._anHidden[iColumn] = null;
                            }

                            if (oCol.fnCreatedCell) {
                                oCol.fnCreatedCell.call(oSettings.oInstance,
                                    nCell, _fnGetCellData(oSettings, iRow, iColumn, 'display'), oData._aData, iRow, iColumn
                                );
                            }
                        }
                    }
                }

                /* Row created callbacks */
                if (oSettings.aoRowCreatedCallback.length !== 0) {
                    for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                        oData = oSettings.aoData[i];
                        _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, i]);
                    }
                }
            }


            /**
             * Take a TR element and convert it to an index in aoData
             *  @param {object} oSettings dataTables settings object
             *  @param {node} n the TR element to find
             *  @returns {int} index if the node is found, null if not
             *  @memberof DataTable#oApi
             */
            function _fnNodeToDataIndex(oSettings, n) {
                return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
            }


            /**
             * Take a TD element and convert it into a column data index (not the visible index)
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow The row number the TD/TH can be found in
             *  @param {node} n The TD/TH element to find
             *  @returns {int} index if the node is found, -1 if not
             *  @memberof DataTable#oApi
             */
            function _fnNodeToColumnIndex(oSettings, iRow, n) {
                var anCells = _fnGetTdNodes(oSettings, iRow);

                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    if (anCells[i] === n) {
                        return i;
                    }
                }
                return -1;
            }


            /**
             * Get an array of data for a given row from the internal data cache
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow aoData row id
             *  @param {string} sSpecific data get type ('type' 'filter' 'sort')
             *  @param {array} aiColumns Array of column indexes to get data from
             *  @returns {array} Data array
             *  @memberof DataTable#oApi
             */
            function _fnGetRowData(oSettings, iRow, sSpecific, aiColumns) {
                var out = [];
                for (var i = 0, iLen = aiColumns.length; i < iLen; i++) {
                    out.push(_fnGetCellData(oSettings, iRow, aiColumns[i], sSpecific));
                }
                return out;
            }


            /**
             * Get the data for a given cell from the internal cache, taking into account data mapping
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow aoData row id
             *  @param {int} iCol Column index
             *  @param {string} sSpecific data get type ('display', 'type' 'filter' 'sort')
             *  @returns {*} Cell data
             *  @memberof DataTable#oApi
             */
            function _fnGetCellData(oSettings, iRow, iCol, sSpecific) {
                var sData;
                var oCol = oSettings.aoColumns[iCol];
                var oData = oSettings.aoData[iRow]._aData;

                if ((sData = oCol.fnGetData(oData, sSpecific)) === undefined) {
                    if (oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null) {
                        _fnLog(oSettings, 0, "Requested unknown parameter " +
                            (typeof oCol.mData == 'function' ? '{mData function}' : "'" + oCol.mData + "'") +
                            " from the data source for row " + iRow);
                        oSettings.iDrawError = oSettings.iDraw;
                    }
                    return oCol.sDefaultContent;
                }

                /* When the data source is null, we can use default column data */
                if (sData === null && oCol.sDefaultContent !== null) {
                    sData = oCol.sDefaultContent;
                }
                else if (typeof sData === 'function') {
                    /* If the data source is a function, then we run it and use the return */
                    return sData();
                }

                if (sSpecific == 'display' && sData === null) {
                    return '';
                }
                return sData;
            }


            /**
             * Set the value for a specific cell, into the internal data cache
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow aoData row id
             *  @param {int} iCol Column index
             *  @param {*} val Value to set
             *  @memberof DataTable#oApi
             */
            function _fnSetCellData(oSettings, iRow, iCol, val) {
                var oCol = oSettings.aoColumns[iCol];
                var oData = oSettings.aoData[iRow]._aData;

                oCol.fnSetData(oData, val);
            }


            // Private variable that is used to match array syntax in the data property object
            var __reArray = /\[.*?\]$/;

            /**
             * Return a function that can be used to get data from a source object, taking
             * into account the ability to use nested objects as a source
             *  @param {string|int|function} mSource The data source for the object
             *  @returns {function} Data get function
             *  @memberof DataTable#oApi
             */
            function _fnGetObjectDataFn(mSource) {
                if (mSource === null) {
                    /* Give an empty string for rendering / sorting etc */
                    return function (data, type) {
                        return null;
                    };
                }
                else if (typeof mSource === 'function') {
                    return function (data, type, extra) {
                        return mSource(data, type, extra);
                    };
                }
                else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1)) {
                    /* If there is a . in the source string then the data source is in a 
                     * nested object so we loop over the data for each level to get the next
                     * level down. On each loop we test for undefined, and if found immediately
                     * return. This allows entire objects to be missing and sDefaultContent to
                     * be used if defined, rather than throwing an error
                     */
                    var fetchData = function (data, type, src) {
                        var a = src.split('.');
                        var arrayNotation, out, innerSrc;

                        if (src !== "") {
                            for (var i = 0, iLen = a.length; i < iLen; i++) {
                                // Check if we are dealing with an array notation request
                                arrayNotation = a[i].match(__reArray);

                                if (arrayNotation) {
                                    a[i] = a[i].replace(__reArray, '');

                                    // Condition allows simply [] to be passed in
                                    if (a[i] !== "") {
                                        data = data[a[i]];
                                    }
                                    out = [];

                                    // Get the remainder of the nested object to get
                                    a.splice(0, i + 1);
                                    innerSrc = a.join('.');

                                    // Traverse each entry in the array getting the properties requested
                                    for (var j = 0, jLen = data.length; j < jLen; j++) {
                                        out.push(fetchData(data[j], type, innerSrc));
                                    }

                                    // If a string is given in between the array notation indicators, that
                                    // is used to join the strings together, otherwise an array is returned
                                    var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                                    data = (join === "") ? out : out.join(join);

                                    // The inner call to fetchData has already traversed through the remainder
                                    // of the source requested, so we exit from the loop
                                    break;
                                }

                                if (data === null || data[a[i]] === undefined) {
                                    return undefined;
                                }
                                data = data[a[i]];
                            }
                        }

                        return data;
                    };

                    return function (data, type) {
                        return fetchData(data, type, mSource);
                    };
                }
                else {
                    /* Array or flat object mapping */
                    return function (data, type) {
                        return data[mSource];
                    };
                }
            }


            /**
             * Return a function that can be used to set data from a source object, taking
             * into account the ability to use nested objects as a source
             *  @param {string|int|function} mSource The data source for the object
             *  @returns {function} Data set function
             *  @memberof DataTable#oApi
             */
            function _fnSetObjectDataFn(mSource) {
                if (mSource === null) {
                    /* Nothing to do when the data source is null */
                    return function (data, val) {
                    };
                }
                else if (typeof mSource === 'function') {
                    return function (data, val) {
                        mSource(data, 'set', val);
                    };
                }
                else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1)) {
                    /* Like the get, we need to get data from a nested object */
                    var setData = function (data, val, src) {
                        var a = src.split('.'), b;
                        var arrayNotation, o, innerSrc;

                        for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
                            // Check if we are dealing with an array notation request
                            arrayNotation = a[i].match(__reArray);

                            if (arrayNotation) {
                                a[i] = a[i].replace(__reArray, '');
                                data[a[i]] = [];

                                // Get the remainder of the nested object to set so we can recurse
                                b = a.slice();
                                b.splice(0, i + 1);
                                innerSrc = b.join('.');

                                // Traverse each entry in the array setting the properties requested
                                for (var j = 0, jLen = val.length; j < jLen; j++) {
                                    o = {};
                                    setData(o, val[j], innerSrc);
                                    data[a[i]].push(o);
                                }

                                // The inner call to setData has already traversed through the remainder
                                // of the source and has set the data, thus we can exit here
                                return;
                            }

                            // If the nested object doesn't currently exist - since we are
                            // trying to set the value - create it
                            if (data[a[i]] === null || data[a[i]] === undefined) {
                                data[a[i]] = {};
                            }
                            data = data[a[i]];
                        }

                        // If array notation is used, we just want to strip it and use the property name
                        // and assign the value. If it isn't used, then we get the result we want anyway
                        data[a[a.length - 1].replace(__reArray, '')] = val;
                    };

                    return function (data, val) {
                        return setData(data, val, mSource);
                    };
                }
                else {
                    /* Array or flat object mapping */
                    return function (data, val) {
                        data[mSource] = val;
                    };
                }
            }


            /**
             * Return an array with the full table data
             *  @param {object} oSettings dataTables settings object
             *  @returns array {array} aData Master data array
             *  @memberof DataTable#oApi
             */
            function _fnGetDataMaster(oSettings) {
                var aData = [];
                var iLen = oSettings.aoData.length;
                for (var i = 0; i < iLen; i++) {
                    aData.push(oSettings.aoData[i]._aData);
                }
                return aData;
            }


            /**
             * Nuke the table
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnClearTable(oSettings) {
                oSettings.aoData.splice(0, oSettings.aoData.length);
                oSettings.aiDisplayMaster.splice(0, oSettings.aiDisplayMaster.length);
                oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
                _fnCalculateEnd(oSettings);
            }


            /**
             * Take an array of integers (index array) and remove a target integer (value - not
             * the key!)
             *  @param {array} a Index array to target
             *  @param {int} iTarget value to find
             *  @memberof DataTable#oApi
             */
            function _fnDeleteIndex(a, iTarget) {
                var iTargetIndex = -1;

                for (var i = 0, iLen = a.length; i < iLen; i++) {
                    if (a[i] == iTarget) {
                        iTargetIndex = i;
                    }
                    else if (a[i] > iTarget) {
                        a[i]--;
                    }
                }

                if (iTargetIndex != -1) {
                    a.splice(iTargetIndex, 1);
                }
            }


            /**
             * Call the developer defined fnRender function for a given cell (row/column) with
             * the required parameters and return the result.
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow aoData index for the row
             *  @param {int} iCol aoColumns index for the column
             *  @returns {*} Return of the developer's fnRender function
             *  @memberof DataTable#oApi
             */
            function _fnRender(oSettings, iRow, iCol) {
                var oCol = oSettings.aoColumns[iCol];

                return oCol.fnRender({
                    "iDataRow": iRow,
                    "iDataColumn": iCol,
                    "oSettings": oSettings,
                    "aData": oSettings.aoData[iRow]._aData,
                    "mDataProp": oCol.mData
                }, _fnGetCellData(oSettings, iRow, iCol, 'display'));
            }

            /**
             * Create a new TR element (and it's TD children) for a row
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iRow Row to consider
             *  @memberof DataTable#oApi
             */
            function _fnCreateTr(oSettings, iRow) {
                var oData = oSettings.aoData[iRow];
                var nTd;

                if (oData.nTr === null) {
                    oData.nTr = document.createElement('tr');

                    /* Use a private property on the node to allow reserve mapping from the node
                     * to the aoData array for fast look up
                     */
                    oData.nTr._DT_RowIndex = iRow;

                    /* Special parameters can be given by the data source to be used on the row */
                    if (oData._aData.DT_RowId) {
                        oData.nTr.id = oData._aData.DT_RowId;
                    }

                    if (oData._aData.DT_RowClass) {
                        oData.nTr.className = oData._aData.DT_RowClass;
                    }

                    /* Process each column */
                    for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        var oCol = oSettings.aoColumns[i];
                        nTd = document.createElement(oCol.sCellType);

                        /* Render if needed - if bUseRendered is true then we already have the rendered
                         * value in the data source - so can just use that
                         */
                        nTd.innerHTML = (typeof oCol.fnRender === 'function' && (!oCol.bUseRendered || oCol.mData === null)) ?
                            _fnRender(oSettings, iRow, i) :
                            _fnGetCellData(oSettings, iRow, i, 'display');

                        /* Add user defined class */
                        if (oCol.sClass !== null) {
                            nTd.className = oCol.sClass;
                        }

                        if (oCol.bVisible) {
                            oData.nTr.appendChild(nTd);
                            oData._anHidden[i] = null;
                        }
                        else {
                            oData._anHidden[i] = nTd;
                        }

                        if (oCol.fnCreatedCell) {
                            oCol.fnCreatedCell.call(oSettings.oInstance,
                                nTd, _fnGetCellData(oSettings, iRow, i, 'display'), oData._aData, iRow, i
                            );
                        }
                    }

                    _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, iRow]);
                }
            }


            /**
             * Create the HTML header for the table
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnBuildHead(oSettings) {
                var i, nTh, iLen, j, jLen;
                var iThs = $('th, td', oSettings.nTHead).length;
                var iCorrector = 0;
                var jqChildren;

                /* If there is a header in place - then use it - otherwise it's going to get nuked... */
                if (iThs !== 0) {
                    /* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
                    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        nTh = oSettings.aoColumns[i].nTh;
                        nTh.setAttribute('role', 'columnheader');
                        if (oSettings.aoColumns[i].bSortable) {
                            nTh.setAttribute('tabindex', oSettings.iTabIndex);
                            nTh.setAttribute('aria-controls', oSettings.sTableId);
                        }

                        if (oSettings.aoColumns[i].sClass !== null) {
                            $(nTh).addClass(oSettings.aoColumns[i].sClass);
                        }

                        /* Set the title of the column if it is user defined (not what was auto detected) */
                        if (oSettings.aoColumns[i].sTitle != nTh.innerHTML) {
                            nTh.innerHTML = oSettings.aoColumns[i].sTitle;
                        }
                    }
                }
                else {
                    /* We don't have a header in the DOM - so we are going to have to create one */
                    var nTr = document.createElement("tr");

                    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        nTh = oSettings.aoColumns[i].nTh;
                        nTh.innerHTML = oSettings.aoColumns[i].sTitle;
                        nTh.setAttribute('tabindex', '0');

                        if (oSettings.aoColumns[i].sClass !== null) {
                            $(nTh).addClass(oSettings.aoColumns[i].sClass);
                        }

                        nTr.appendChild(nTh);
                    }
                    $(oSettings.nTHead).html('')[0].appendChild(nTr);
                    _fnDetectHeader(oSettings.aoHeader, oSettings.nTHead);
                }

                /* ARIA role for the rows */
                $(oSettings.nTHead).children('tr').attr('role', 'row');

                /* Add the extra markup needed by jQuery UI's themes */
                if (oSettings.bJUI) {
                    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        nTh = oSettings.aoColumns[i].nTh;

                        var nDiv = document.createElement('div');
                        nDiv.className = oSettings.oClasses.sSortJUIWrapper;
                        $(nTh).contents().appendTo(nDiv);

                        var nSpan = document.createElement('span');
                        nSpan.className = oSettings.oClasses.sSortIcon;
                        nDiv.appendChild(nSpan);
                        nTh.appendChild(nDiv);
                    }
                }

                if (oSettings.oFeatures.bSort) {
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        if (oSettings.aoColumns[i].bSortable !== false) {
                            _fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);
                        }
                        else {
                            $(oSettings.aoColumns[i].nTh).addClass(oSettings.oClasses.sSortableNone);
                        }
                    }
                }

                /* Deal with the footer - add classes if required */
                if (oSettings.oClasses.sFooterTH !== "") {
                    $(oSettings.nTFoot).children('tr').children('th').addClass(oSettings.oClasses.sFooterTH);
                }

                /* Cache the footer elements */
                if (oSettings.nTFoot !== null) {
                    var anCells = _fnGetUniqueThs(oSettings, null, oSettings.aoFooter);
                    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        if (anCells[i]) {
                            oSettings.aoColumns[i].nTf = anCells[i];
                            if (oSettings.aoColumns[i].sClass) {
                                $(anCells[i]).addClass(oSettings.aoColumns[i].sClass);
                            }
                        }
                    }
                }
            }


            /**
             * Draw the header (or footer) element based on the column visibility states. The
             * methodology here is to use the layout array from _fnDetectHeader, modified for
             * the instantaneous column visibility, to construct the new layout. The grid is
             * traversed over cell at a time in a rows x columns grid fashion, although each
             * cell insert can cover multiple elements in the grid - which is tracks using the
             * aApplied array. Cell inserts in the grid will only occur where there isn't
             * already a cell in that position.
             *  @param {object} oSettings dataTables settings object
             *  @param array {objects} aoSource Layout array from _fnDetectHeader
             *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
             *  @memberof DataTable#oApi
             */
            function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
                var i, iLen, j, jLen, k, kLen, n, nLocalTr;
                var aoLocal = [];
                var aApplied = [];
                var iColumns = oSettings.aoColumns.length;
                var iRowspan, iColspan;

                if (bIncludeHidden === undefined) {
                    bIncludeHidden = false;
                }

                /* Make a copy of the master layout array, but without the visible columns in it */
                for (i = 0, iLen = aoSource.length; i < iLen; i++) {
                    aoLocal[i] = aoSource[i].slice();
                    aoLocal[i].nTr = aoSource[i].nTr;

                    /* Remove any columns which are currently hidden */
                    for (j = iColumns - 1; j >= 0; j--) {
                        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
                            aoLocal[i].splice(j, 1);
                        }
                    }

                    /* Prep the applied array - it needs an element for each row */
                    aApplied.push([]);
                }

                for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
                    nLocalTr = aoLocal[i].nTr;

                    /* All cells are going to be replaced, so empty out the row */
                    if (nLocalTr) {
                        while ((n = nLocalTr.firstChild)) {
                            nLocalTr.removeChild(n);
                        }
                    }

                    for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
                        iRowspan = 1;
                        iColspan = 1;

                        /* Check to see if there is already a cell (row/colspan) covering our target
                         * insert point. If there is, then there is nothing to do.
                         */
                        if (aApplied[i][j] === undefined) {
                            nLocalTr.appendChild(aoLocal[i][j].cell);
                            aApplied[i][j] = 1;

                            /* Expand the cell to cover as many rows as needed */
                            while (aoLocal[i + iRowspan] !== undefined &&
                            aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
                                aApplied[i + iRowspan][j] = 1;
                                iRowspan++;
                            }

                            /* Expand the cell to cover as many columns as needed */
                            while (aoLocal[i][j + iColspan] !== undefined &&
                            aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
                                /* Must update the applied array over the rows for the columns */
                                for (k = 0; k < iRowspan; k++) {
                                    aApplied[i + k][j + iColspan] = 1;
                                }
                                iColspan++;
                            }

                            /* Do the actual expansion in the DOM */
                            aoLocal[i][j].cell.rowSpan = iRowspan;
                            aoLocal[i][j].cell.colSpan = iColspan;
                        }
                    }
                }
            }


            /**
             * Insert the required TR nodes into the table for display
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnDraw(oSettings) {
                /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
                var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
                if ($.inArray(false, aPreDraw) !== -1) {
                    _fnProcessingDisplay(oSettings, false);
                    return;
                }

                var i, iLen, n;
                var anRows = [];
                var iRowCount = 0;
                var iStripes = oSettings.asStripeClasses.length;
                var iOpenRows = oSettings.aoOpenRows.length;

                oSettings.bDrawing = true;

                /* Check and see if we have an initial draw position from state saving */
                if (oSettings.iInitDisplayStart !== undefined && oSettings.iInitDisplayStart != -1) {
                    if (oSettings.oFeatures.bServerSide) {
                        oSettings._iDisplayStart = oSettings.iInitDisplayStart;
                    }
                    else {
                        oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
                            0 : oSettings.iInitDisplayStart;
                    }
                    oSettings.iInitDisplayStart = -1;
                    _fnCalculateEnd(oSettings);
                }

                /* Server-side processing draw intercept */
                if (oSettings.bDeferLoading) {
                    oSettings.bDeferLoading = false;
                    oSettings.iDraw++;
                }
                else if (!oSettings.oFeatures.bServerSide) {
                    oSettings.iDraw++;
                }
                else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
                    return;
                }

                if (oSettings.aiDisplay.length !== 0) {
                    var iStart = oSettings._iDisplayStart;
                    var iEnd = oSettings._iDisplayEnd;

                    if (oSettings.oFeatures.bServerSide) {
                        iStart = 0;
                        iEnd = oSettings.aoData.length;
                    }

                    for (var j = iStart; j < iEnd; j++) {
                        var aoData = oSettings.aoData[oSettings.aiDisplay[j]];
                        if (aoData.nTr === null) {
                            _fnCreateTr(oSettings, oSettings.aiDisplay[j]);
                        }

                        var nRow = aoData.nTr;

                        /* Remove the old striping classes and then add the new one */
                        if (iStripes !== 0) {
                            var sStripe = oSettings.asStripeClasses[iRowCount % iStripes];
                            if (aoData._sRowStripe != sStripe) {
                                $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
                                aoData._sRowStripe = sStripe;
                            }
                        }

                        /* Row callback functions - might want to manipulate the row */
                        _fnCallbackFire(oSettings, 'aoRowCallback', null,
                            [nRow, oSettings.aoData[oSettings.aiDisplay[j]]._aData, iRowCount, j]);

                        anRows.push(nRow);
                        iRowCount++;

                        /* If there is an open row - and it is attached to this parent - attach it on redraw */
                        if (iOpenRows !== 0) {
                            for (var k = 0; k < iOpenRows; k++) {
                                if (nRow == oSettings.aoOpenRows[k].nParent) {
                                    anRows.push(oSettings.aoOpenRows[k].nTr);
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    /* Table is empty - create a row with an empty message in it */
                    anRows[0] = document.createElement('tr');

                    if (oSettings.asStripeClasses[0]) {
                        anRows[0].className = oSettings.asStripeClasses[0];
                    }

                    var oLang = oSettings.oLanguage;
                    var sZero = oLang.sZeroRecords;
                    if (oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
                        sZero = oLang.sLoadingRecords;
                    }
                    else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
                        sZero = oLang.sEmptyTable;
                    }

                    var nTd = document.createElement('td');
                    nTd.setAttribute('valign', "top");
                    nTd.colSpan = _fnVisbleColumns(oSettings);
                    nTd.className = oSettings.oClasses.sRowEmpty;
                    nTd.innerHTML = _fnInfoMacros(oSettings, sZero);

                    anRows[iRowCount].appendChild(nTd);
                }

                /* Header and footer callbacks */
                _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
                    _fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay]);

                _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
                    _fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay]);

                /* 
                 * Need to remove any old row from the display - note we can't just empty the tbody using
                 * $().html('') since this will unbind the jQuery event handlers (even although the node 
                 * still exists!) - equally we can't use innerHTML, since IE throws an exception.
                 */
                var
                    nAddFrag = document.createDocumentFragment(),
                    nRemoveFrag = document.createDocumentFragment(),
                    nBodyPar, nTrs;

                if (oSettings.nTBody) {
                    nBodyPar = oSettings.nTBody.parentNode;
                    nRemoveFrag.appendChild(oSettings.nTBody);

                    /* When doing infinite scrolling, only remove child rows when sorting, filtering or start
                     * up. When not infinite scroll, always do it.
                     */
                    if (!oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
                        oSettings.bSorted || oSettings.bFiltered) {
                        while ((n = oSettings.nTBody.firstChild)) {
                            oSettings.nTBody.removeChild(n);
                        }
                    }

                    /* Put the draw table into the dom */
                    for (i = 0, iLen = anRows.length; i < iLen; i++) {
                        nAddFrag.appendChild(anRows[i]);
                    }

                    oSettings.nTBody.appendChild(nAddFrag);
                    if (nBodyPar !== null) {
                        nBodyPar.appendChild(oSettings.nTBody);
                    }
                }

                /* Call all required callback functions for the end of a draw */
                _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

                /* Draw is complete, sorting and filtering must be as well */
                oSettings.bSorted = false;
                oSettings.bFiltered = false;
                oSettings.bDrawing = false;

                if (oSettings.oFeatures.bServerSide) {
                    _fnProcessingDisplay(oSettings, false);
                    if (!oSettings._bInitComplete) {
                        _fnInitComplete(oSettings);
                    }
                }
            }


            /**
             * Redraw the table - taking account of the various features which are enabled
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnReDraw(oSettings) {
                if (oSettings.oFeatures.bSort) {
                    /* Sorting will refilter and draw for us */
                    _fnSort(oSettings, oSettings.oPreviousSearch);
                }
                else if (oSettings.oFeatures.bFilter) {
                    /* Filtering will redraw for us */
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch);
                }
                else {
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings);
                }
            }


            /**
             * Add the options to the page HTML for the table
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnAddOptionsHtml(oSettings) {
                /*
                 * Create a temporary, empty, div which we can later on replace with what we have generated
                 * we do it this way to rendering the 'options' html offline - speed :-)
                 */
                var nHolding = $('<div></div>')[0];
                oSettings.nTable.parentNode.insertBefore(nHolding, oSettings.nTable);

                /* 
                 * All DataTables are wrapped in a div
                 */
                oSettings.nTableWrapper = $('<div id="' + oSettings.sTableId + '_wrapper" class="' + oSettings.oClasses.sWrapper + '" role="grid"></div>')[0];
                oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

                /* Track where we want to insert the option */
                var nInsertNode = oSettings.nTableWrapper;

                /* Loop over the user set positioning and place the elements as needed */
                var aDom = oSettings.sDom.split('');
                var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
                for (var i = 0; i < aDom.length; i++) {
                    iPushFeature = 0;
                    cOption = aDom[i];

                    if (cOption == '<') {
                        /* New container div */
                        nNewNode = $('<div></div>')[0];

                        /* Check to see if we should append an id and/or a class name to the container */
                        cNext = aDom[i + 1];
                        if (cNext == "'" || cNext == '"') {
                            sAttr = "";
                            j = 2;
                            while (aDom[i + j] != cNext) {
                                sAttr += aDom[i + j];
                                j++;
                            }

                            /* Replace jQuery UI constants */
                            if (sAttr == "H") {
                                sAttr = oSettings.oClasses.sJUIHeader;
                            }
                            else if (sAttr == "F") {
                                sAttr = oSettings.oClasses.sJUIFooter;
                            }

                            /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
                             * breaks the string into parts and applies them as needed
                             */
                            if (sAttr.indexOf('.') != -1) {
                                var aSplit = sAttr.split('.');
                                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
                                nNewNode.className = aSplit[1];
                            }
                            else if (sAttr.charAt(0) == "#") {
                                nNewNode.id = sAttr.substr(1, sAttr.length - 1);
                            }
                            else {
                                nNewNode.className = sAttr;
                            }

                            i += j;
                            /* Move along the position array */
                        }

                        nInsertNode.appendChild(nNewNode);
                        nInsertNode = nNewNode;
                    }
                    else if (cOption == '>') {
                        /* End container div */
                        nInsertNode = nInsertNode.parentNode;
                    }
                    else if (cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange) {
                        /* Length */
                        nTmp = _fnFeatureHtmlLength(oSettings);
                        iPushFeature = 1;
                    }
                    else if (cOption == 'f' && oSettings.oFeatures.bFilter) {
                        /* Filter */
                        nTmp = _fnFeatureHtmlFilter(oSettings);
                        iPushFeature = 1;
                    }
                    else if (cOption == 'r' && oSettings.oFeatures.bProcessing) {
                        /* pRocessing */
                        nTmp = _fnFeatureHtmlProcessing(oSettings);
                        iPushFeature = 1;
                    }
                    else if (cOption == 't') {
                        /* Table */
                        nTmp = _fnFeatureHtmlTable(oSettings);
                        iPushFeature = 1;
                    }
                    else if (cOption == 'i' && oSettings.oFeatures.bInfo) {
                        /* Info */
                        nTmp = _fnFeatureHtmlInfo(oSettings);
                        iPushFeature = 1;
                    }
                    else if (cOption == 'p' && oSettings.oFeatures.bPaginate) {
                        /* Pagination */
                        nTmp = _fnFeatureHtmlPaginate(oSettings);
                        iPushFeature = 1;
                    }
                    else if (DataTable.ext.aoFeatures.length !== 0) {
                        /* Plug-in features */
                        var aoFeatures = DataTable.ext.aoFeatures;
                        for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
                            if (cOption == aoFeatures[k].cFeature) {
                                nTmp = aoFeatures[k].fnInit(oSettings);
                                if (nTmp) {
                                    iPushFeature = 1;
                                }
                                break;
                            }
                        }
                    }

                    /* Add to the 2D features array */
                    if (iPushFeature == 1 && nTmp !== null) {
                        if (typeof oSettings.aanFeatures[cOption] !== 'object') {
                            oSettings.aanFeatures[cOption] = [];
                        }
                        oSettings.aanFeatures[cOption].push(nTmp);
                        nInsertNode.appendChild(nTmp);
                    }
                }

                /* Built our DOM structure - replace the holding div with what we want */
                nHolding.parentNode.replaceChild(oSettings.nTableWrapper, nHolding);
            }


            /**
             * Use the DOM source to create up an array of header cells. The idea here is to
             * create a layout grid (array) of rows x columns, which contains a reference
             * to the cell that that point in the grid (regardless of col/rowspan), such that
             * any column / row could be removed and the new grid constructed
             *  @param array {object} aLayout Array to store the calculated layout in
             *  @param {node} nThead The header/footer element for the table
             *  @memberof DataTable#oApi
             */
            function _fnDetectHeader(aLayout, nThead) {
                var nTrs = $(nThead).children('tr');
                var nTr, nCell;
                var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
                var bUnique;
                var fnShiftCol = function (a, i, j) {
                    var k = a[i];
                    while (k[j]) {
                        j++;
                    }
                    return j;
                };

                aLayout.splice(0, aLayout.length);

                /* We know how many rows there are in the layout - so prep it */
                for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                    aLayout.push([]);
                }

                /* Calculate a layout array */
                for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                    nTr = nTrs[i];
                    iColumn = 0;

                    /* For every cell in the row... */
                    nCell = nTr.firstChild;
                    while (nCell) {
                        if (nCell.nodeName.toUpperCase() == "TD" ||
                            nCell.nodeName.toUpperCase() == "TH") {
                            /* Get the col and rowspan attributes from the DOM and sanitise them */
                            iColspan = nCell.getAttribute('colspan') * 1;
                            iRowspan = nCell.getAttribute('rowspan') * 1;
                            iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
                            iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;

                            /* There might be colspan cells already in this row, so shift our target 
                             * accordingly
                             */
                            iColShifted = fnShiftCol(aLayout, i, iColumn);

                            /* Cache calculation for unique columns */
                            bUnique = iColspan === 1 ? true : false;

                            /* If there is col / rowspan, copy the information into the layout grid */
                            for (l = 0; l < iColspan; l++) {
                                for (k = 0; k < iRowspan; k++) {
                                    aLayout[i + k][iColShifted + l] = {
                                        "cell": nCell,
                                        "unique": bUnique
                                    };
                                    aLayout[i + k].nTr = nTr;
                                }
                            }
                        }
                        nCell = nCell.nextSibling;
                    }
                }
            }


            /**
             * Get an array of unique th elements, one for each column
             *  @param {object} oSettings dataTables settings object
             *  @param {node} nHeader automatically detect the layout from this node - optional
             *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
             *  @returns array {node} aReturn list of unique th's
             *  @memberof DataTable#oApi
             */
            function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
                var aReturn = [];
                if (!aLayout) {
                    aLayout = oSettings.aoHeader;
                    if (nHeader) {
                        aLayout = [];
                        _fnDetectHeader(aLayout, nHeader);
                    }
                }

                for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
                    for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
                        if (aLayout[i][j].unique &&
                            (!aReturn[j] || !oSettings.bSortCellsTop)) {
                            aReturn[j] = aLayout[i][j].cell;
                        }
                    }
                }

                return aReturn;
            }


            /**
             * Update the table using an Ajax call
             *  @param {object} oSettings dataTables settings object
             *  @returns {boolean} Block the table drawing or not
             *  @memberof DataTable#oApi
             */
            function _fnAjaxUpdate(oSettings) {
                if (oSettings.bAjaxDataGet) {
                    oSettings.iDraw++;
                    _fnProcessingDisplay(oSettings, true);
                    var iColumns = oSettings.aoColumns.length;
                    var aoData = _fnAjaxParameters(oSettings);
                    _fnServerParams(oSettings, aoData);

                    oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData,
                        function (json) {
                            _fnAjaxUpdateDraw(oSettings, json);
                        }, oSettings);
                    return false;
                }
                else {
                    return true;
                }
            }


            /**
             * Build up the parameters in an object needed for a server-side processing request
             *  @param {object} oSettings dataTables settings object
             *  @returns {bool} block the table drawing or not
             *  @memberof DataTable#oApi
             */
            function _fnAjaxParameters(oSettings) {
                var iColumns = oSettings.aoColumns.length;
                var aoData = [], mDataProp, aaSort, aDataSort;
                var i, j;

                aoData.push({"name": "sEcho", "value": oSettings.iDraw});
                aoData.push({"name": "iColumns", "value": iColumns});
                aoData.push({"name": "sColumns", "value": _fnColumnOrdering(oSettings)});
                aoData.push({"name": "iDisplayStart", "value": oSettings._iDisplayStart});
                aoData.push({
                    "name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
                        oSettings._iDisplayLength : -1
                });

                for (i = 0; i < iColumns; i++) {
                    mDataProp = oSettings.aoColumns[i].mData;
                    aoData.push({
                        "name": "mDataProp_" + i,
                        "value": typeof(mDataProp) === "function" ? 'function' : mDataProp
                    });
                }

                /* Filtering */
                if (oSettings.oFeatures.bFilter !== false) {
                    aoData.push({"name": "sSearch", "value": oSettings.oPreviousSearch.sSearch});
                    aoData.push({"name": "bRegex", "value": oSettings.oPreviousSearch.bRegex});
                    for (i = 0; i < iColumns; i++) {
                        aoData.push({"name": "sSearch_" + i, "value": oSettings.aoPreSearchCols[i].sSearch});
                        aoData.push({"name": "bRegex_" + i, "value": oSettings.aoPreSearchCols[i].bRegex});
                        aoData.push({"name": "bSearchable_" + i, "value": oSettings.aoColumns[i].bSearchable});
                    }
                }

                /* Sorting */
                if (oSettings.oFeatures.bSort !== false) {
                    var iCounter = 0;

                    aaSort = ( oSettings.aaSortingFixed !== null ) ?
                        oSettings.aaSortingFixed.concat(oSettings.aaSorting) :
                        oSettings.aaSorting.slice();

                    for (i = 0; i < aaSort.length; i++) {
                        aDataSort = oSettings.aoColumns[aaSort[i][0]].aDataSort;

                        for (j = 0; j < aDataSort.length; j++) {
                            aoData.push({"name": "iSortCol_" + iCounter, "value": aDataSort[j]});
                            aoData.push({"name": "sSortDir_" + iCounter, "value": aaSort[i][1]});
                            iCounter++;
                        }
                    }
                    aoData.push({"name": "iSortingCols", "value": iCounter});

                    for (i = 0; i < iColumns; i++) {
                        aoData.push({"name": "bSortable_" + i, "value": oSettings.aoColumns[i].bSortable});
                    }
                }

                return aoData;
            }


            /**
             * Add Ajax parameters from plug-ins
             *  @param {object} oSettings dataTables settings object
             *  @param array {objects} aoData name/value pairs to send to the server
             *  @memberof DataTable#oApi
             */
            function _fnServerParams(oSettings, aoData) {
                _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [aoData]);
            }


            /**
             * Data the data from the server (nuking the old) and redraw the table
             *  @param {object} oSettings dataTables settings object
             *  @param {object} json json data return from the server.
             *  @param {string} json.sEcho Tracking flag for DataTables to match requests
             *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
             *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
             *  @param {array} json.aaData The data to display on this page
             *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
             *  @memberof DataTable#oApi
             */
            function _fnAjaxUpdateDraw(oSettings, json) {
                if (json.sEcho !== undefined) {
                    /* Protect against old returns over-writing a new one. Possible when you get
                     * very fast interaction, and later queries are completed much faster
                     */
                    if (json.sEcho * 1 < oSettings.iDraw) {
                        return;
                    }
                    else {
                        oSettings.iDraw = json.sEcho * 1;
                    }
                }

                if (!oSettings.oScroll.bInfinite ||
                    (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered))) {
                    _fnClearTable(oSettings);
                }
                oSettings._iRecordsTotal = parseInt(json.iTotalRecords, 10);
                oSettings._iRecordsDisplay = parseInt(json.iTotalDisplayRecords, 10);

                /* Determine if reordering is required */
                var sOrdering = _fnColumnOrdering(oSettings);
                var bReOrder = (json.sColumns !== undefined && sOrdering !== "" && json.sColumns != sOrdering );
                var aiIndex;
                if (bReOrder) {
                    aiIndex = _fnReOrderIndex(oSettings, json.sColumns);
                }

                var aData = _fnGetObjectDataFn(oSettings.sAjaxDataProp)(json);
                for (var i = 0, iLen = aData.length; i < iLen; i++) {
                    if (bReOrder) {
                        /* If we need to re-order, then create a new array with the correct order and add it */
                        var aDataSorted = [];
                        for (var j = 0, jLen = oSettings.aoColumns.length; j < jLen; j++) {
                            aDataSorted.push(aData[i][aiIndex[j]]);
                        }
                        _fnAddData(oSettings, aDataSorted);
                    }
                    else {
                        /* No re-order required, sever got it "right" - just straight add */
                        _fnAddData(oSettings, aData[i]);
                    }
                }
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

                oSettings.bAjaxDataGet = false;
                _fnDraw(oSettings);
                oSettings.bAjaxDataGet = true;
                _fnProcessingDisplay(oSettings, false);
            }


            /**
             * Generate the node required for filtering text
             *  @returns {node} Filter control element
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlFilter(oSettings) {
                var oPreviousSearch = oSettings.oPreviousSearch;

                var sSearchStr = oSettings.oLanguage.sSearch;
                sSearchStr = (sSearchStr.indexOf('_INPUT_') !== -1) ?
                    sSearchStr.replace('_INPUT_', '<input type="text" />') :
                    sSearchStr === "" ? '<input type="text" />' : sSearchStr + ' <input type="text" />';

                var nFilter = document.createElement('div');
                nFilter.className = oSettings.oClasses.sFilter;
                nFilter.innerHTML = '<label>' + sSearchStr + '</label>';
                if (!oSettings.aanFeatures.f) {
                    nFilter.id = oSettings.sTableId + '_filter';
                }

                var jqFilter = $('input[type="text"]', nFilter);

                // Store a reference to the input element, so other input elements could be
                // added to the filter wrapper if needed (submit button for example)
                nFilter._DT_Input = jqFilter[0];

                jqFilter.val(oPreviousSearch.sSearch.replace('"', '&quot;'));
                jqFilter.bind('keyup.DT', function (e) {
                    /* Update all other filter input elements for the new display */
                    var n = oSettings.aanFeatures.f;
                    var val = this.value === "" ? "" : this.value; // mental IE8 fix :-(

                    for (var i = 0, iLen = n.length; i < iLen; i++) {
                        if (n[i] != $(this).parents('div.dataTables_filter')[0]) {
                            $(n[i]._DT_Input).val(val);
                        }
                    }

                    /* Now do the filter */
                    if (val != oPreviousSearch.sSearch) {
                        _fnFilterComplete(oSettings, {
                            "sSearch": val,
                            "bRegex": oPreviousSearch.bRegex,
                            "bSmart": oPreviousSearch.bSmart,
                            "bCaseInsensitive": oPreviousSearch.bCaseInsensitive
                        });
                    }
                });

                jqFilter
                    .attr('aria-controls', oSettings.sTableId)
                    .bind('keypress.DT', function (e) {
                        /* Prevent form submission */
                        if (e.keyCode == 13) {
                            return false;
                        }
                    }
                );

                return nFilter;
            }


            /**
             * Filter the table using both the global filter and column based filtering
             *  @param {object} oSettings dataTables settings object
             *  @param {object} oSearch search information
             *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
             *  @memberof DataTable#oApi
             */
            function _fnFilterComplete(oSettings, oInput, iForce) {
                var oPrevSearch = oSettings.oPreviousSearch;
                var aoPrevSearch = oSettings.aoPreSearchCols;
                var fnSaveFilter = function (oFilter) {
                    /* Save the filtering values */
                    oPrevSearch.sSearch = oFilter.sSearch;
                    oPrevSearch.bRegex = oFilter.bRegex;
                    oPrevSearch.bSmart = oFilter.bSmart;
                    oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
                };

                /* In server-side processing all filtering is done by the server, so no point hanging around here */
                if (!oSettings.oFeatures.bServerSide) {
                    /* Global filter */
                    _fnFilter(oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart, oInput.bCaseInsensitive);
                    fnSaveFilter(oInput);

                    /* Now do the individual column filter */
                    for (var i = 0; i < oSettings.aoPreSearchCols.length; i++) {
                        _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, aoPrevSearch[i].bRegex,
                            aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
                    }

                    /* Custom filtering */
                    _fnFilterCustom(oSettings);
                }
                else {
                    fnSaveFilter(oInput);
                }

                /* Tell the draw function we have been filtering */
                oSettings.bFiltered = true;
                $(oSettings.oInstance).trigger('filter', oSettings);

                /* Redraw the table */
                oSettings._iDisplayStart = 0;
                _fnCalculateEnd(oSettings);
                _fnDraw(oSettings);

                /* Rebuild search array 'offline' */
                _fnBuildSearchArray(oSettings, 0);
            }


            /**
             * Apply custom filtering functions
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnFilterCustom(oSettings) {
                var afnFilters = DataTable.ext.afnFiltering;
                var aiFilterColumns = _fnGetColumns(oSettings, 'bSearchable');

                for (var i = 0, iLen = afnFilters.length; i < iLen; i++) {
                    var iCorrector = 0;
                    for (var j = 0, jLen = oSettings.aiDisplay.length; j < jLen; j++) {
                        var iDisIndex = oSettings.aiDisplay[j - iCorrector];
                        var bTest = afnFilters[i](
                            oSettings,
                            _fnGetRowData(oSettings, iDisIndex, 'filter', aiFilterColumns),
                            iDisIndex
                        );

                        /* Check if we should use this row based on the filtering function */
                        if (!bTest) {
                            oSettings.aiDisplay.splice(j - iCorrector, 1);
                            iCorrector++;
                        }
                    }
                }
            }


            /**
             * Filter the table on a per-column basis
             *  @param {object} oSettings dataTables settings object
             *  @param {string} sInput string to filter on
             *  @param {int} iColumn column to filter
             *  @param {bool} bRegex treat search string as a regular expression or not
             *  @param {bool} bSmart use smart filtering or not
             *  @param {bool} bCaseInsensitive Do case insenstive matching or not
             *  @memberof DataTable#oApi
             */
            function _fnFilterColumn(oSettings, sInput, iColumn, bRegex, bSmart, bCaseInsensitive) {
                if (sInput === "") {
                    return;
                }

                var iIndexCorrector = 0;
                var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart, bCaseInsensitive);

                for (var i = oSettings.aiDisplay.length - 1; i >= 0; i--) {
                    var sData = _fnDataToSearch(_fnGetCellData(oSettings, oSettings.aiDisplay[i], iColumn, 'filter'),
                        oSettings.aoColumns[iColumn].sType);
                    if (!rpSearch.test(sData)) {
                        oSettings.aiDisplay.splice(i, 1);
                        iIndexCorrector++;
                    }
                }
            }


            /**
             * Filter the data table based on user input and draw the table
             *  @param {object} oSettings dataTables settings object
             *  @param {string} sInput string to filter on
             *  @param {int} iForce optional - force a research of the master array (1) or not (undefined or 0)
             *  @param {bool} bRegex treat as a regular expression or not
             *  @param {bool} bSmart perform smart filtering or not
             *  @param {bool} bCaseInsensitive Do case insenstive matching or not
             *  @memberof DataTable#oApi
             */
            function _fnFilter(oSettings, sInput, iForce, bRegex, bSmart, bCaseInsensitive) {
                var i;
                var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart, bCaseInsensitive);
                var oPrevSearch = oSettings.oPreviousSearch;

                /* Check if we are forcing or not - optional parameter */
                if (!iForce) {
                    iForce = 0;
                }

                /* Need to take account of custom filtering functions - always filter */
                if (DataTable.ext.afnFiltering.length !== 0) {
                    iForce = 1;
                }

                /*
                 * If the input is blank - we want the full data set
                 */
                if (sInput.length <= 0) {
                    oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                }
                else {
                    /*
                     * We are starting a new search or the new search string is smaller 
                     * then the old one (i.e. delete). Search from the master array
                     */
                    if (oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
                        oPrevSearch.sSearch.length > sInput.length || iForce == 1 ||
                        sInput.indexOf(oPrevSearch.sSearch) !== 0) {
                        /* Nuke the old display array - we are going to rebuild it */
                        oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);

                        /* Force a rebuild of the search array */
                        _fnBuildSearchArray(oSettings, 1);

                        /* Search through all records to populate the search array
                         * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1 
                         * mapping
                         */
                        for (i = 0; i < oSettings.aiDisplayMaster.length; i++) {
                            if (rpSearch.test(oSettings.asDataSearch[i])) {
                                oSettings.aiDisplay.push(oSettings.aiDisplayMaster[i]);
                            }
                        }
                    }
                    else {
                        /* Using old search array - refine it - do it this way for speed
                         * Don't have to search the whole master array again
                         */
                        var iIndexCorrector = 0;

                        /* Search the current results */
                        for (i = 0; i < oSettings.asDataSearch.length; i++) {
                            if (!rpSearch.test(oSettings.asDataSearch[i])) {
                                oSettings.aiDisplay.splice(i - iIndexCorrector, 1);
                                iIndexCorrector++;
                            }
                        }
                    }
                }
            }


            /**
             * Create an array which can be quickly search through
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iMaster use the master data array - optional
             *  @memberof DataTable#oApi
             */
            function _fnBuildSearchArray(oSettings, iMaster) {
                if (!oSettings.oFeatures.bServerSide) {
                    /* Clear out the old data */
                    oSettings.asDataSearch = [];

                    var aiFilterColumns = _fnGetColumns(oSettings, 'bSearchable');
                    var aiIndex = (iMaster === 1) ?
                        oSettings.aiDisplayMaster :
                        oSettings.aiDisplay;

                    for (var i = 0, iLen = aiIndex.length; i < iLen; i++) {
                        oSettings.asDataSearch[i] = _fnBuildSearchRow(
                            oSettings,
                            _fnGetRowData(oSettings, aiIndex[i], 'filter', aiFilterColumns)
                        );
                    }
                }
            }


            /**
             * Create a searchable string from a single data row
             *  @param {object} oSettings dataTables settings object
             *  @param {array} aData Row data array to use for the data to search
             *  @memberof DataTable#oApi
             */
            function _fnBuildSearchRow(oSettings, aData) {
                var sSearch = aData.join('  ');

                /* If it looks like there is an HTML entity in the string, attempt to decode it */
                if (sSearch.indexOf('&') !== -1) {
                    sSearch = $('<div>').html(sSearch).text();
                }

                // Strip newline characters
                return sSearch.replace(/[\n\r]/g, " ");
            }

            /**
             * Build a regular expression object suitable for searching a table
             *  @param {string} sSearch string to search for
             *  @param {bool} bRegex treat as a regular expression or not
             *  @param {bool} bSmart perform smart filtering or not
             *  @param {bool} bCaseInsensitive Do case insensitive matching or not
             *  @returns {RegExp} constructed object
             *  @memberof DataTable#oApi
             */
            function _fnFilterCreateSearch(sSearch, bRegex, bSmart, bCaseInsensitive) {
                var asSearch, sRegExpString;

                if (bSmart) {
                    /* Generate the regular expression to use. Something along the lines of:
                     * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
                     */
                    asSearch = bRegex ? sSearch.split(' ') : _fnEscapeRegex(sSearch).split(' ');
                    sRegExpString = '^(?=.*?' + asSearch.join(')(?=.*?') + ').*$';
                    return new RegExp(sRegExpString, bCaseInsensitive ? "i" : "");
                }
                else {
                    sSearch = bRegex ? sSearch : _fnEscapeRegex(sSearch);
                    return new RegExp(sSearch, bCaseInsensitive ? "i" : "");
                }
            }


            /**
             * Convert raw data into something that the user can search on
             *  @param {string} sData data to be modified
             *  @param {string} sType data type
             *  @returns {string} search string
             *  @memberof DataTable#oApi
             */
            function _fnDataToSearch(sData, sType) {
                if (typeof DataTable.ext.ofnSearch[sType] === "function") {
                    return DataTable.ext.ofnSearch[sType](sData);
                }
                else if (sData === null) {
                    return '';
                }
                else if (sType == "html") {
                    return sData.replace(/[\r\n]/g, " ").replace(/<.*?>/g, "");
                }
                else if (typeof sData === "string") {
                    return sData.replace(/[\r\n]/g, " ");
                }
                return sData;
            }


            /**
             * scape a string such that it can be used in a regular expression
             *  @param {string} sVal string to escape
             *  @returns {string} escaped string
             *  @memberof DataTable#oApi
             */
            function _fnEscapeRegex(sVal) {
                var acEscape = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'];
                var reReplace = new RegExp('(\\' + acEscape.join('|\\') + ')', 'g');
                return sVal.replace(reReplace, '\\$1');
            }


            /**
             * Generate the node required for the info display
             *  @param {object} oSettings dataTables settings object
             *  @returns {node} Information element
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlInfo(oSettings) {
                var nInfo = document.createElement('div');
                nInfo.className = oSettings.oClasses.sInfo;

                /* Actions that are to be taken once only for this feature */
                if (!oSettings.aanFeatures.i) {
                    /* Add draw callback */
                    oSettings.aoDrawCallback.push({
                        "fn": _fnUpdateInfo,
                        "sName": "information"
                    });

                    /* Add id */
                    nInfo.id = oSettings.sTableId + '_info';
                }
                oSettings.nTable.setAttribute('aria-describedby', oSettings.sTableId + '_info');

                return nInfo;
            }


            /**
             * Update the information elements in the display
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnUpdateInfo(oSettings) {
                /* Show information about the table */
                if (!oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0) {
                    return;
                }

                var
                    oLang = oSettings.oLanguage,
                    iStart = oSettings._iDisplayStart + 1,
                    iEnd = oSettings.fnDisplayEnd(),
                    iMax = oSettings.fnRecordsTotal(),
                    iTotal = oSettings.fnRecordsDisplay(),
                    sOut;

                if (iTotal === 0) {
                    /* Empty record set */
                    sOut = oLang.sInfoEmpty;
                }
                else {
                    /* Normal record set */
                    sOut = oLang.sInfo;
                }

                if (iTotal != iMax) {
                    /* Record set after filtering */
                    sOut += ' ' + oLang.sInfoFiltered;
                }

                // Convert the macros
                sOut += oLang.sInfoPostFix;
                sOut = _fnInfoMacros(oSettings, sOut);

                if (oLang.fnInfoCallback !== null) {
                    sOut = oLang.fnInfoCallback.call(oSettings.oInstance,
                        oSettings, iStart, iEnd, iMax, iTotal, sOut);
                }

                var n = oSettings.aanFeatures.i;
                for (var i = 0, iLen = n.length; i < iLen; i++) {
                    $(n[i]).html(sOut);
                }
            }


            function _fnInfoMacros(oSettings, str) {
                var
                    iStart = oSettings._iDisplayStart + 1,
                    sStart = oSettings.fnFormatNumber(iStart),
                    iEnd = oSettings.fnDisplayEnd(),
                    sEnd = oSettings.fnFormatNumber(iEnd),
                    iTotal = oSettings.fnRecordsDisplay(),
                    sTotal = oSettings.fnFormatNumber(iTotal),
                    iMax = oSettings.fnRecordsTotal(),
                    sMax = oSettings.fnFormatNumber(iMax);

                // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
                // internally
                if (oSettings.oScroll.bInfinite) {
                    sStart = oSettings.fnFormatNumber(1);
                }

                return str.
                    replace(/_START_/g, sStart).
                    replace(/_END_/g, sEnd).
                    replace(/_TOTAL_/g, sTotal).
                    replace(/_MAX_/g, sMax);
            }


            /**
             * Draw the table for the first time, adding all required features
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnInitialise(oSettings) {
                var i, iLen, iAjaxStart = oSettings.iInitDisplayStart;

                /* Ensure that the table data is fully initialised */
                if (oSettings.bInitialised === false) {
                    setTimeout(function () {
                        _fnInitialise(oSettings);
                    }, 200);
                    return;
                }

                /* Show the display HTML options */
                _fnAddOptionsHtml(oSettings);

                /* Build and draw the header / footer for the table */
                _fnBuildHead(oSettings);
                _fnDrawHead(oSettings, oSettings.aoHeader);
                if (oSettings.nTFoot) {
                    _fnDrawHead(oSettings, oSettings.aoFooter);
                }

                /* Okay to show that something is going on now */
                _fnProcessingDisplay(oSettings, true);

                /* Calculate sizes for columns */
                if (oSettings.oFeatures.bAutoWidth) {
                    _fnCalculateColumnWidths(oSettings);
                }

                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    if (oSettings.aoColumns[i].sWidth !== null) {
                        oSettings.aoColumns[i].nTh.style.width = _fnStringToCss(oSettings.aoColumns[i].sWidth);
                    }
                }

                /* If there is default sorting required - let's do it. The sort function will do the
                 * drawing for us. Otherwise we draw the table regardless of the Ajax source - this allows
                 * the table to look initialised for Ajax sourcing data (show 'loading' message possibly)
                 */
                if (oSettings.oFeatures.bSort) {
                    _fnSort(oSettings);
                }
                else if (oSettings.oFeatures.bFilter) {
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch);
                }
                else {
                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings);
                }

                /* if there is an ajax source load the data */
                if (oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
                    var aoData = [];
                    _fnServerParams(oSettings, aoData);
                    oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData, function (json) {
                        var aData = (oSettings.sAjaxDataProp !== "") ?
                            _fnGetObjectDataFn(oSettings.sAjaxDataProp)(json) : json;

                        /* Got the data - add it to the table */
                        for (i = 0; i < aData.length; i++) {
                            _fnAddData(oSettings, aData[i]);
                        }

                        /* Reset the init display for cookie saving. We've already done a filter, and
                         * therefore cleared it before. So we need to make it appear 'fresh'
                         */
                        oSettings.iInitDisplayStart = iAjaxStart;

                        if (oSettings.oFeatures.bSort) {
                            _fnSort(oSettings);
                        }
                        else {
                            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                            _fnCalculateEnd(oSettings);
                            _fnDraw(oSettings);
                        }

                        _fnProcessingDisplay(oSettings, false);
                        _fnInitComplete(oSettings, json);
                    }, oSettings);
                    return;
                }

                /* Server-side processing initialisation complete is done at the end of _fnDraw */
                if (!oSettings.oFeatures.bServerSide) {
                    _fnProcessingDisplay(oSettings, false);
                    _fnInitComplete(oSettings);
                }
            }


            /**
             * Draw the table for the first time, adding all required features
             *  @param {object} oSettings dataTables settings object
             *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
             *    with client-side processing (optional)
             *  @memberof DataTable#oApi
             */
            function _fnInitComplete(oSettings, json) {
                oSettings._bInitComplete = true;
                _fnCallbackFire(oSettings, 'aoInitComplete', 'init', [oSettings, json]);
            }


            /**
             * Language compatibility - when certain options are given, and others aren't, we
             * need to duplicate the values over, in order to provide backwards compatibility
             * with older language files.
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnLanguageCompat(oLanguage) {
                var oDefaults = DataTable.defaults.oLanguage;

                /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
                 * sZeroRecords - assuming that is given.
                 */
                if (!oLanguage.sEmptyTable && oLanguage.sZeroRecords &&
                    oDefaults.sEmptyTable === "No data available in table") {
                    _fnMap(oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable');
                }

                /* Likewise with loading records */
                if (!oLanguage.sLoadingRecords && oLanguage.sZeroRecords &&
                    oDefaults.sLoadingRecords === "Loading...") {
                    _fnMap(oLanguage, oLanguage, 'sZeroRecords', 'sLoadingRecords');
                }
            }


            /**
             * Generate the node required for user display length changing
             *  @param {object} oSettings dataTables settings object
             *  @returns {node} Display length feature node
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlLength(oSettings) {
                if (oSettings.oScroll.bInfinite) {
                    return null;
                }

                /* This can be overruled by not using the _MENU_ var/macro in the language variable */
                var sName = 'name="' + oSettings.sTableId + '_length"';
                var sStdMenu = '<select size="1" ' + sName + '>';
                var i, iLen;
                var aLengthMenu = oSettings.aLengthMenu;

                if (aLengthMenu.length == 2 && typeof aLengthMenu[0] === 'object' &&
                    typeof aLengthMenu[1] === 'object') {
                    for (i = 0, iLen = aLengthMenu[0].length; i < iLen; i++) {
                        sStdMenu += '<option value="' + aLengthMenu[0][i] + '">' + aLengthMenu[1][i] + '</option>';
                    }
                }
                else {
                    for (i = 0, iLen = aLengthMenu.length; i < iLen; i++) {
                        sStdMenu += '<option value="' + aLengthMenu[i] + '">' + aLengthMenu[i] + '</option>';
                    }
                }
                sStdMenu += '</select>';

                var nLength = document.createElement('div');
                if (!oSettings.aanFeatures.l) {
                    nLength.id = oSettings.sTableId + '_length';
                }
                nLength.className = oSettings.oClasses.sLength;
                nLength.innerHTML = '<label>' + oSettings.oLanguage.sLengthMenu.replace('_MENU_', sStdMenu) + '</label>';

                /*
                 * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
                 * and Stefan Skopnik for fixing the fix!
                 */
                $('select option[value="' + oSettings._iDisplayLength + '"]', nLength).attr("selected", true);

                $('select', nLength).bind('change.DT', function (e) {
                    var iVal = $(this).val();

                    /* Update all other length options for the new display */
                    var n = oSettings.aanFeatures.l;
                    for (i = 0, iLen = n.length; i < iLen; i++) {
                        if (n[i] != this.parentNode) {
                            $('select', n[i]).val(iVal);
                        }
                    }

                    /* Redraw the table */
                    oSettings._iDisplayLength = parseInt(iVal, 10);
                    _fnCalculateEnd(oSettings);

                    /* If we have space to show extra rows (backing up from the end point - then do so */
                    if (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) {
                        oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
                        if (oSettings._iDisplayStart < 0) {
                            oSettings._iDisplayStart = 0;
                        }
                    }

                    if (oSettings._iDisplayLength == -1) {
                        oSettings._iDisplayStart = 0;
                    }

                    _fnDraw(oSettings);
                });


                $('select', nLength).attr('aria-controls', oSettings.sTableId);

                return nLength;
            }


            /**
             * Recalculate the end point based on the start point
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnCalculateEnd(oSettings) {
                if (oSettings.oFeatures.bPaginate === false) {
                    oSettings._iDisplayEnd = oSettings.aiDisplay.length;
                }
                else {
                    /* Set the end point of the display - based on how many elements there are
                     * still to display
                     */
                    if (oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
                        oSettings._iDisplayLength == -1) {
                        oSettings._iDisplayEnd = oSettings.aiDisplay.length;
                    }
                    else {
                        oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
                    }
                }
            }


            /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
             * Note that most of the paging logic is done in 
             * DataTable.ext.oPagination
             */

            /**
             * Generate the node required for default pagination
             *  @param {object} oSettings dataTables settings object
             *  @returns {node} Pagination feature node
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlPaginate(oSettings) {
                if (oSettings.oScroll.bInfinite) {
                    return null;
                }

                var nPaginate = document.createElement('div');
                nPaginate.className = oSettings.oClasses.sPaging + oSettings.sPaginationType;

                DataTable.ext.oPagination[oSettings.sPaginationType].fnInit(oSettings, nPaginate,
                    function (oSettings) {
                        _fnCalculateEnd(oSettings);
                        _fnDraw(oSettings);
                    }
                );

                /* Add a draw callback for the pagination on first instance, to update the paging display */
                if (!oSettings.aanFeatures.p) {
                    oSettings.aoDrawCallback.push({
                        "fn": function (oSettings) {
                            DataTable.ext.oPagination[oSettings.sPaginationType].fnUpdate(oSettings, function (oSettings) {
                                _fnCalculateEnd(oSettings);
                                _fnDraw(oSettings);
                            });
                        },
                        "sName": "pagination"
                    });
                }
                return nPaginate;
            }


            /**
             * Alter the display settings to change the page
             *  @param {object} oSettings dataTables settings object
             *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
             *    or page number to jump to (integer)
             *  @returns {bool} true page has changed, false - no change (no effect) eg 'first' on page 1
             *  @memberof DataTable#oApi
             */
            function _fnPageChange(oSettings, mAction) {
                var iOldStart = oSettings._iDisplayStart;

                if (typeof mAction === "number") {
                    oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
                    if (oSettings._iDisplayStart > oSettings.fnRecordsDisplay()) {
                        oSettings._iDisplayStart = 0;
                    }
                }
                else if (mAction == "first") {
                    oSettings._iDisplayStart = 0;
                }
                else if (mAction == "previous") {
                    oSettings._iDisplayStart = oSettings._iDisplayLength >= 0 ?
                    oSettings._iDisplayStart - oSettings._iDisplayLength :
                        0;

                    /* Correct for under-run */
                    if (oSettings._iDisplayStart < 0) {
                        oSettings._iDisplayStart = 0;
                    }
                }
                else if (mAction == "next") {
                    if (oSettings._iDisplayLength >= 0) {
                        /* Make sure we are not over running the display array */
                        if (oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay()) {
                            oSettings._iDisplayStart += oSettings._iDisplayLength;
                        }
                    }
                    else {
                        oSettings._iDisplayStart = 0;
                    }
                }
                else if (mAction == "last") {
                    if (oSettings._iDisplayLength >= 0) {
                        var iPages = parseInt((oSettings.fnRecordsDisplay() - 1) / oSettings._iDisplayLength, 10) + 1;
                        oSettings._iDisplayStart = (iPages - 1) * oSettings._iDisplayLength;
                    }
                    else {
                        oSettings._iDisplayStart = 0;
                    }
                }
                else {
                    _fnLog(oSettings, 0, "Unknown paging action: " + mAction);
                }
                $(oSettings.oInstance).trigger('page', oSettings);

                return iOldStart != oSettings._iDisplayStart;
            }


            /**
             * Generate the node required for the processing node
             *  @param {object} oSettings dataTables settings object
             *  @returns {node} Processing element
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlProcessing(oSettings) {
                var nProcessing = document.createElement('div');

                if (!oSettings.aanFeatures.r) {
                    nProcessing.id = oSettings.sTableId + '_processing';
                }
                nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
                nProcessing.className = oSettings.oClasses.sProcessing;
                oSettings.nTable.parentNode.insertBefore(nProcessing, oSettings.nTable);

                return nProcessing;
            }


            /**
             * Display or hide the processing indicator
             *  @param {object} oSettings dataTables settings object
             *  @param {bool} bShow Show the processing indicator (true) or not (false)
             *  @memberof DataTable#oApi
             */
            function _fnProcessingDisplay(oSettings, bShow) {
                if (oSettings.oFeatures.bProcessing) {
                    var an = oSettings.aanFeatures.r;
                    for (var i = 0, iLen = an.length; i < iLen; i++) {
                        an[i].style.visibility = bShow ? "visible" : "hidden";
                    }
                }

                $(oSettings.oInstance).trigger('processing', [oSettings, bShow]);
            }

            /**
             * Add any control elements for the table - specifically scrolling
             *  @param {object} oSettings dataTables settings object
             *  @returns {node} Node to add to the DOM
             *  @memberof DataTable#oApi
             */
            function _fnFeatureHtmlTable(oSettings) {
                /* Check if scrolling is enabled or not - if not then leave the DOM unaltered */
                if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
                    return oSettings.nTable;
                }

                /*
                 * The HTML structure that we want to generate in this function is:
                 *  div - nScroller
                 *    div - nScrollHead
                 *      div - nScrollHeadInner
                 *        table - nScrollHeadTable
                 *          thead - nThead
                 *    div - nScrollBody
                 *      table - oSettings.nTable
                 *        thead - nTheadSize
                 *        tbody - nTbody
                 *    div - nScrollFoot
                 *      div - nScrollFootInner
                 *        table - nScrollFootTable
                 *          tfoot - nTfoot
                 */
                var
                    nScroller = document.createElement('div'),
                    nScrollHead = document.createElement('div'),
                    nScrollHeadInner = document.createElement('div'),
                    nScrollBody = document.createElement('div'),
                    nScrollFoot = document.createElement('div'),
                    nScrollFootInner = document.createElement('div'),
                    nScrollHeadTable = oSettings.nTable.cloneNode(false),
                    nScrollFootTable = oSettings.nTable.cloneNode(false),
                    nThead = oSettings.nTable.getElementsByTagName('thead')[0],
                    nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null :
                        oSettings.nTable.getElementsByTagName('tfoot')[0],
                    oClasses = oSettings.oClasses;

                nScrollHead.appendChild(nScrollHeadInner);
                nScrollFoot.appendChild(nScrollFootInner);
                nScrollBody.appendChild(oSettings.nTable);
                nScroller.appendChild(nScrollHead);
                nScroller.appendChild(nScrollBody);
                nScrollHeadInner.appendChild(nScrollHeadTable);
                nScrollHeadTable.appendChild(nThead);
                if (nTfoot !== null) {
                    nScroller.appendChild(nScrollFoot);
                    nScrollFootInner.appendChild(nScrollFootTable);
                    nScrollFootTable.appendChild(nTfoot);
                }

                nScroller.className = oClasses.sScrollWrapper;
                nScrollHead.className = oClasses.sScrollHead;
                nScrollHeadInner.className = oClasses.sScrollHeadInner;
                nScrollBody.className = oClasses.sScrollBody;
                nScrollFoot.className = oClasses.sScrollFoot;
                nScrollFootInner.className = oClasses.sScrollFootInner;

                if (oSettings.oScroll.bAutoCss) {
                    nScrollHead.style.overflow = "hidden";
                    nScrollHead.style.position = "relative";
                    nScrollFoot.style.overflow = "hidden";
                    nScrollBody.style.overflow = "auto";
                }

                nScrollHead.style.border = "0";
                nScrollHead.style.width = "100%";
                nScrollFoot.style.border = "0";
                nScrollHeadInner.style.width = oSettings.oScroll.sXInner !== "" ?
                    oSettings.oScroll.sXInner : "100%";
                /* will be overwritten */

                /* Modify attributes to respect the clones */
                nScrollHeadTable.removeAttribute('id');
                nScrollHeadTable.style.marginLeft = "0";
                oSettings.nTable.style.marginLeft = "0";
                if (nTfoot !== null) {
                    nScrollFootTable.removeAttribute('id');
                    nScrollFootTable.style.marginLeft = "0";
                }

                /* Move caption elements from the body to the header, footer or leave where it is
                 * depending on the configuration. Note that the DTD says there can be only one caption */
                var nCaption = $(oSettings.nTable).children('caption');
                if (nCaption.length > 0) {
                    nCaption = nCaption[0];
                    if (nCaption._captionSide === "top") {
                        nScrollHeadTable.appendChild(nCaption);
                    }
                    else if (nCaption._captionSide === "bottom" && nTfoot) {
                        nScrollFootTable.appendChild(nCaption);
                    }
                }

                /*
                 * Sizing
                 */
                /* When x-scrolling add the width and a scroller to move the header with the body */
                if (oSettings.oScroll.sX !== "") {
                    nScrollHead.style.width = _fnStringToCss(oSettings.oScroll.sX);
                    nScrollBody.style.width = _fnStringToCss(oSettings.oScroll.sX);

                    if (nTfoot !== null) {
                        nScrollFoot.style.width = _fnStringToCss(oSettings.oScroll.sX);
                    }

                    /* When the body is scrolled, then we also want to scroll the headers */
                    $(nScrollBody).scroll(function (e) {
                        nScrollHead.scrollLeft = this.scrollLeft;

                        if (nTfoot !== null) {
                            nScrollFoot.scrollLeft = this.scrollLeft;
                        }
                    });
                }

                /* When yscrolling, add the height */
                if (oSettings.oScroll.sY !== "") {
                    nScrollBody.style.height = _fnStringToCss(oSettings.oScroll.sY);
                }

                /* Redraw - align columns across the tables */
                oSettings.aoDrawCallback.push({
                    "fn": _fnScrollDraw,
                    "sName": "scrolling"
                });

                /* Infinite scrolling event handlers */
                if (oSettings.oScroll.bInfinite) {
                    $(nScrollBody).scroll(function () {
                        /* Use a blocker to stop scrolling from loading more data while other data is still loading */
                        if (!oSettings.bDrawing && $(this).scrollTop() !== 0) {
                            /* Check if we should load the next data set */
                            if ($(this).scrollTop() + $(this).height() >
                                $(oSettings.nTable).height() - oSettings.oScroll.iLoadGap) {
                                /* Only do the redraw if we have to - we might be at the end of the data */
                                if (oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay()) {
                                    _fnPageChange(oSettings, 'next');
                                    _fnCalculateEnd(oSettings);
                                    _fnDraw(oSettings);
                                }
                            }
                        }
                    });
                }

                oSettings.nScrollHead = nScrollHead;
                oSettings.nScrollFoot = nScrollFoot;

                return nScroller;
            }


            /**
             * Update the various tables for resizing. It's a bit of a pig this function, but
             * basically the idea to:
             *   1. Re-create the table inside the scrolling div
             *   2. Take live measurements from the DOM
             *   3. Apply the measurements
             *   4. Clean up
             *  @param {object} o dataTables settings object
             *  @returns {node} Node to add to the DOM
             *  @memberof DataTable#oApi
             */
            function _fnScrollDraw(o) {
                var
                    nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
                    nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
                    nScrollBody = o.nTable.parentNode,
                    i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
                    nTheadSize, nTfootSize,
                    iWidth, aApplied = [], aAppliedFooter = [], iSanityWidth,
                    nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName('div')[0] : null,
                    nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName('table')[0] : null,
                    ie67 = o.oBrowser.bScrollOversize,
                    zeroOut = function (nSizer) {
                        oStyle = nSizer.style;
                        oStyle.paddingTop = "0";
                        oStyle.paddingBottom = "0";
                        oStyle.borderTopWidth = "0";
                        oStyle.borderBottomWidth = "0";
                        oStyle.height = 0;
                    };

                /*
                 * 1. Re-create the table inside the scrolling div
                 */

                /* Remove the old minimised thead and tfoot elements in the inner table */
                $(o.nTable).children('thead, tfoot').remove();

                /* Clone the current header and footer elements and then place it into the inner table */
                nTheadSize = $(o.nTHead).clone()[0];
                o.nTable.insertBefore(nTheadSize, o.nTable.childNodes[0]);
                anHeadToSize = o.nTHead.getElementsByTagName('tr');
                anHeadSizers = nTheadSize.getElementsByTagName('tr');

                if (o.nTFoot !== null) {
                    nTfootSize = $(o.nTFoot).clone()[0];
                    o.nTable.insertBefore(nTfootSize, o.nTable.childNodes[1]);
                    anFootToSize = o.nTFoot.getElementsByTagName('tr');
                    anFootSizers = nTfootSize.getElementsByTagName('tr');
                }

                /*
                 * 2. Take live measurements from the DOM - do not alter the DOM itself!
                 */

                /* Remove old sizing and apply the calculated column widths
                 * Get the unique column headers in the newly created (cloned) header. We want to apply the
                 * calculated sizes to this header
                 */
                if (o.oScroll.sX === "") {
                    nScrollBody.style.width = '100%';
                    nScrollHeadInner.parentNode.style.width = '100%';
                }

                var nThs = _fnGetUniqueThs(o, nTheadSize);
                for (i = 0, iLen = nThs.length; i < iLen; i++) {
                    iVis = _fnVisibleToColumnIndex(o, i);
                    nThs[i].style.width = o.aoColumns[iVis].sWidth;
                }

                if (o.nTFoot !== null) {
                    _fnApplyToChildren(function (n) {
                        n.style.width = "";
                    }, anFootSizers);
                }

                // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
                // will end up forcing the scrollbar to appear, making our measurements wrong for when we
                // then hide it (end of this function), so add the header height to the body scroller.
                if (o.oScroll.bCollapse && o.oScroll.sY !== "") {
                    nScrollBody.style.height = (nScrollBody.offsetHeight + o.nTHead.offsetHeight) + "px";
                }

                /* Size the table as a whole */
                iSanityWidth = $(o.nTable).outerWidth();
                if (o.oScroll.sX === "") {
                    /* No x scrolling */
                    o.nTable.style.width = "100%";

                    /* I know this is rubbish - but IE7 will make the width of the table when 100% include
                     * the scrollbar - which is shouldn't. When there is a scrollbar we need to take this
                     * into account.
                     */
                    if (ie67 && ($('tbody', nScrollBody).height() > nScrollBody.offsetHeight ||
                        $(nScrollBody).css('overflow-y') == "scroll")) {
                        o.nTable.style.width = _fnStringToCss($(o.nTable).outerWidth() - o.oScroll.iBarWidth);
                    }
                }
                else {
                    if (o.oScroll.sXInner !== "") {
                        /* x scroll inner has been given - use it */
                        o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
                    }
                    else if (iSanityWidth == $(nScrollBody).width() &&
                        $(nScrollBody).height() < $(o.nTable).height()) {
                        /* There is y-scrolling - try to take account of the y scroll bar */
                        o.nTable.style.width = _fnStringToCss(iSanityWidth - o.oScroll.iBarWidth);
                        if ($(o.nTable).outerWidth() > iSanityWidth - o.oScroll.iBarWidth) {
                            /* Not possible to take account of it */
                            o.nTable.style.width = _fnStringToCss(iSanityWidth);
                        }
                    }
                    else {
                        /* All else fails */
                        o.nTable.style.width = _fnStringToCss(iSanityWidth);
                    }
                }

                /* Recalculate the sanity width - now that we've applied the required width, before it was
                 * a temporary variable. This is required because the column width calculation is done
                 * before this table DOM is created.
                 */
                iSanityWidth = $(o.nTable).outerWidth();

                /* We want the hidden header to have zero height, so remove padding and borders. Then
                 * set the width based on the real headers
                 */

                // Apply all styles in one pass. Invalidates layout only once because we don't read any 
                // DOM properties.
                _fnApplyToChildren(zeroOut, anHeadSizers);

                // Read all widths in next pass. Forces layout only once because we do not change 
                // any DOM properties.
                _fnApplyToChildren(function (nSizer) {
                    aApplied.push(_fnStringToCss($(nSizer).width()));
                }, anHeadSizers);

                // Apply all widths in final pass. Invalidates layout only once because we do not
                // read any DOM properties.
                _fnApplyToChildren(function (nToSize, i) {
                    nToSize.style.width = aApplied[i];
                }, anHeadToSize);

                $(anHeadSizers).height(0);

                /* Same again with the footer if we have one */
                if (o.nTFoot !== null) {
                    _fnApplyToChildren(zeroOut, anFootSizers);

                    _fnApplyToChildren(function (nSizer) {
                        aAppliedFooter.push(_fnStringToCss($(nSizer).width()));
                    }, anFootSizers);

                    _fnApplyToChildren(function (nToSize, i) {
                        nToSize.style.width = aAppliedFooter[i];
                    }, anFootToSize);

                    $(anFootSizers).height(0);
                }

                /*
                 * 3. Apply the measurements
                 */

                /* "Hide" the header and footer that we used for the sizing. We want to also fix their width
                 * to what they currently are
                 */
                _fnApplyToChildren(function (nSizer, i) {
                    nSizer.innerHTML = "";
                    nSizer.style.width = aApplied[i];
                }, anHeadSizers);

                if (o.nTFoot !== null) {
                    _fnApplyToChildren(function (nSizer, i) {
                        nSizer.innerHTML = "";
                        nSizer.style.width = aAppliedFooter[i];
                    }, anFootSizers);
                }

                /* Sanity check that the table is of a sensible width. If not then we are going to get
                 * misalignment - try to prevent this by not allowing the table to shrink below its min width
                 */
                if ($(o.nTable).outerWidth() < iSanityWidth) {
                    /* The min width depends upon if we have a vertical scrollbar visible or not */
                    var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight ||
                    $(nScrollBody).css('overflow-y') == "scroll")) ?
                    iSanityWidth + o.oScroll.iBarWidth : iSanityWidth;

                    /* IE6/7 are a law unto themselves... */
                    if (ie67 && (nScrollBody.scrollHeight >
                        nScrollBody.offsetHeight || $(nScrollBody).css('overflow-y') == "scroll")) {
                        o.nTable.style.width = _fnStringToCss(iCorrection - o.oScroll.iBarWidth);
                    }

                    /* Apply the calculated minimum width to the table wrappers */
                    nScrollBody.style.width = _fnStringToCss(iCorrection);
                    o.nScrollHead.style.width = _fnStringToCss(iCorrection);

                    if (o.nTFoot !== null) {
                        o.nScrollFoot.style.width = _fnStringToCss(iCorrection);
                    }

                    /* And give the user a warning that we've stopped the table getting too small */
                    if (o.oScroll.sX === "") {
                        _fnLog(o, 1, "The table cannot fit into the current element which will cause column" +
                            " misalignment. The table has been drawn at its minimum possible width.");
                    }
                    else if (o.oScroll.sXInner !== "") {
                        _fnLog(o, 1, "The table cannot fit into the current element which will cause column" +
                            " misalignment. Increase the sScrollXInner value or remove it to allow automatic" +
                            " calculation");
                    }
                }
                else {
                    nScrollBody.style.width = _fnStringToCss('100%');
                    o.nScrollHead.style.width = _fnStringToCss('100%');

                    if (o.nTFoot !== null) {
                        o.nScrollFoot.style.width = _fnStringToCss('100%');
                    }
                }


                /*
                 * 4. Clean up
                 */
                if (o.oScroll.sY === "") {
                    /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
                     * the scrollbar height from the visible display, rather than adding it on. We need to
                     * set the height in order to sort this. Don't want to do it in any other browsers.
                     */
                    if (ie67) {
                        nScrollBody.style.height = _fnStringToCss(o.nTable.offsetHeight + o.oScroll.iBarWidth);
                    }
                }

                if (o.oScroll.sY !== "" && o.oScroll.bCollapse) {
                    nScrollBody.style.height = _fnStringToCss(o.oScroll.sY);

                    var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
                        o.oScroll.iBarWidth : 0;
                    if (o.nTable.offsetHeight < nScrollBody.offsetHeight) {
                        nScrollBody.style.height = _fnStringToCss(o.nTable.offsetHeight + iExtra);
                    }
                }

                /* Finally set the width's of the header and footer tables */
                var iOuterWidth = $(o.nTable).outerWidth();
                nScrollHeadTable.style.width = _fnStringToCss(iOuterWidth);
                nScrollHeadInner.style.width = _fnStringToCss(iOuterWidth);

                // Figure out if there are scrollbar present - if so then we need a the header and footer to
                // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
                var bScrolling = $(o.nTable).height() > nScrollBody.clientHeight || $(nScrollBody).css('overflow-y') == "scroll";
                nScrollHeadInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth + "px" : "0px";

                if (o.nTFoot !== null) {
                    nScrollFootTable.style.width = _fnStringToCss(iOuterWidth);
                    nScrollFootInner.style.width = _fnStringToCss(iOuterWidth);
                    nScrollFootInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth + "px" : "0px";
                }

                /* Adjust the position of the header in case we loose the y-scrollbar */
                $(nScrollBody).scroll();

                /* If sorting or filtering has occurred, jump the scrolling back to the top */
                if (o.bSorted || o.bFiltered) {
                    nScrollBody.scrollTop = 0;
                }
            }


            /**
             * Apply a given function to the display child nodes of an element array (typically
             * TD children of TR rows
             *  @param {function} fn Method to apply to the objects
             *  @param array {nodes} an1 List of elements to look through for display children
             *  @param array {nodes} an2 Another list (identical structure to the first) - optional
             *  @memberof DataTable#oApi
             */
            function _fnApplyToChildren(fn, an1, an2) {
                var index = 0, i = 0, iLen = an1.length;
                var nNode1, nNode2;

                while (i < iLen) {
                    nNode1 = an1[i].firstChild;
                    nNode2 = an2 ? an2[i].firstChild : null;
                    while (nNode1) {
                        if (nNode1.nodeType === 1) {
                            if (an2) {
                                fn(nNode1, nNode2, index);
                            }
                            else {
                                fn(nNode1, index);
                            }
                            index++;
                        }
                        nNode1 = nNode1.nextSibling;
                        nNode2 = an2 ? nNode2.nextSibling : null;
                    }
                    i++;
                }
            }

            /**
             * Convert a CSS unit width to pixels (e.g. 2em)
             *  @param {string} sWidth width to be converted
             *  @param {node} nParent parent to get the with for (required for relative widths) - optional
             *  @returns {int} iWidth width in pixels
             *  @memberof DataTable#oApi
             */
            function _fnConvertToWidth(sWidth, nParent) {
                if (!sWidth || sWidth === null || sWidth === '') {
                    return 0;
                }

                if (!nParent) {
                    nParent = document.body;
                }

                var iWidth;
                var nTmp = document.createElement("div");
                nTmp.style.width = _fnStringToCss(sWidth);

                nParent.appendChild(nTmp);
                iWidth = nTmp.offsetWidth;
                nParent.removeChild(nTmp);

                return ( iWidth );
            }


            /**
             * Calculate the width of columns for the table
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnCalculateColumnWidths(oSettings) {
                var iTableWidth = oSettings.nTable.offsetWidth;
                var iUserInputs = 0;
                var iTmpWidth;
                var iVisibleColumns = 0;
                var iColums = oSettings.aoColumns.length;
                var i, iIndex, iCorrector, iWidth;
                var oHeaders = $('th', oSettings.nTHead);
                var widthAttr = oSettings.nTable.getAttribute('width');
                var nWrapper = oSettings.nTable.parentNode;

                /* Convert any user input sizes into pixel sizes */
                for (i = 0; i < iColums; i++) {
                    if (oSettings.aoColumns[i].bVisible) {
                        iVisibleColumns++;

                        if (oSettings.aoColumns[i].sWidth !== null) {
                            iTmpWidth = _fnConvertToWidth(oSettings.aoColumns[i].sWidthOrig,
                                nWrapper);
                            if (iTmpWidth !== null) {
                                oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth);
                            }

                            iUserInputs++;
                        }
                    }
                }

                /* If the number of columns in the DOM equals the number that we have to process in 
                 * DataTables, then we can use the offsets that are created by the web-browser. No custom 
                 * sizes can be set in order for this to happen, nor scrolling used
                 */
                if (iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
                    oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        iTmpWidth = $(oHeaders[i]).width();
                        if (iTmpWidth !== null) {
                            oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth);
                        }
                    }
                }
                else {
                    /* Otherwise we are going to have to do some calculations to get the width of each column.
                     * Construct a 1 row table with the widest node in the data, and any user defined widths,
                     * then insert it into the DOM and allow the browser to do all the hard work of
                     * calculating table widths.
                     */
                    var
                        nCalcTmp = oSettings.nTable.cloneNode(false),
                        nTheadClone = oSettings.nTHead.cloneNode(true),
                        nBody = document.createElement('tbody'),
                        nTr = document.createElement('tr'),
                        nDivSizing;

                    nCalcTmp.removeAttribute("id");
                    nCalcTmp.appendChild(nTheadClone);
                    if (oSettings.nTFoot !== null) {
                        nCalcTmp.appendChild(oSettings.nTFoot.cloneNode(true));
                        _fnApplyToChildren(function (n) {
                            n.style.width = "";
                        }, nCalcTmp.getElementsByTagName('tr'));
                    }

                    nCalcTmp.appendChild(nBody);
                    nBody.appendChild(nTr);

                    /* Remove any sizing that was previously applied by the styles */
                    var jqColSizing = $('thead th', nCalcTmp);
                    if (jqColSizing.length === 0) {
                        jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
                    }

                    /* Apply custom sizing to the cloned header */
                    var nThs = _fnGetUniqueThs(oSettings, nTheadClone);
                    iCorrector = 0;
                    for (i = 0; i < iColums; i++) {
                        var oColumn = oSettings.aoColumns[i];
                        if (oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "") {
                            nThs[i - iCorrector].style.width = _fnStringToCss(oColumn.sWidthOrig);
                        }
                        else if (oColumn.bVisible) {
                            nThs[i - iCorrector].style.width = "";
                        }
                        else {
                            iCorrector++;
                        }
                    }

                    /* Find the biggest td for each column and put it into the table */
                    for (i = 0; i < iColums; i++) {
                        if (oSettings.aoColumns[i].bVisible) {
                            var nTd = _fnGetWidestNode(oSettings, i);
                            if (nTd !== null) {
                                nTd = nTd.cloneNode(true);
                                if (oSettings.aoColumns[i].sContentPadding !== "") {
                                    nTd.innerHTML += oSettings.aoColumns[i].sContentPadding;
                                }
                                nTr.appendChild(nTd);
                            }
                        }
                    }

                    /* Build the table and 'display' it */
                    nWrapper.appendChild(nCalcTmp);

                    /* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
                     * when not scrolling leave the table width as it is. This results in slightly different,
                     * but I think correct behaviour
                     */
                    if (oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "") {
                        nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
                    }
                    else if (oSettings.oScroll.sX !== "") {
                        nCalcTmp.style.width = "";
                        if ($(nCalcTmp).width() < nWrapper.offsetWidth) {
                            nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth);
                        }
                    }
                    else if (oSettings.oScroll.sY !== "") {
                        nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth);
                    }
                    else if (widthAttr) {
                        nCalcTmp.style.width = _fnStringToCss(widthAttr);
                    }
                    nCalcTmp.style.visibility = "hidden";

                    /* Scrolling considerations */
                    _fnScrollingWidthAdjust(oSettings, nCalcTmp);

                    /* Read the width's calculated by the browser and store them for use by the caller. We
                     * first of all try to use the elements in the body, but it is possible that there are
                     * no elements there, under which circumstances we use the header elements
                     */
                    var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
                    if (oNodes.length === 0) {
                        oNodes = _fnGetUniqueThs(oSettings, $('thead', nCalcTmp)[0]);
                    }

                    /* Browsers need a bit of a hand when a width is assigned to any columns when 
                     * x-scrolling as they tend to collapse the table to the min-width, even if
                     * we sent the column widths. So we need to keep track of what the table width
                     * should be by summing the user given values, and the automatic values
                     */
                    if (oSettings.oScroll.sX !== "") {
                        var iTotal = 0;
                        iCorrector = 0;
                        for (i = 0; i < oSettings.aoColumns.length; i++) {
                            if (oSettings.aoColumns[i].bVisible) {
                                if (oSettings.aoColumns[i].sWidthOrig === null) {
                                    iTotal += $(oNodes[iCorrector]).outerWidth();
                                }
                                else {
                                    iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace('px', ''), 10) +
                                        ($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width());
                                }
                                iCorrector++;
                            }
                        }

                        nCalcTmp.style.width = _fnStringToCss(iTotal);
                        oSettings.nTable.style.width = _fnStringToCss(iTotal);
                    }

                    iCorrector = 0;
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        if (oSettings.aoColumns[i].bVisible) {
                            iWidth = $(oNodes[iCorrector]).width();
                            if (iWidth !== null && iWidth > 0) {
                                oSettings.aoColumns[i].sWidth = _fnStringToCss(iWidth);
                            }
                            iCorrector++;
                        }
                    }

                    var cssWidth = $(nCalcTmp).css('width');
                    oSettings.nTable.style.width = (cssWidth.indexOf('%') !== -1) ?
                        cssWidth : _fnStringToCss($(nCalcTmp).outerWidth());
                    nCalcTmp.parentNode.removeChild(nCalcTmp);
                }

                if (widthAttr) {
                    oSettings.nTable.style.width = _fnStringToCss(widthAttr);
                }
            }


            /**
             * Adjust a table's width to take account of scrolling
             *  @param {object} oSettings dataTables settings object
             *  @param {node} n table node
             *  @memberof DataTable#oApi
             */
            function _fnScrollingWidthAdjust(oSettings, n) {
                if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "") {
                    /* When y-scrolling only, we want to remove the width of the scroll bar so the table
                     * + scroll bar will fit into the area avaialble.
                     */
                    var iOrigWidth = $(n).width();
                    n.style.width = _fnStringToCss($(n).outerWidth() - oSettings.oScroll.iBarWidth);
                }
                else if (oSettings.oScroll.sX !== "") {
                    /* When x-scrolling both ways, fix the table at it's current size, without adjusting */
                    n.style.width = _fnStringToCss($(n).outerWidth());
                }
            }


            /**
             * Get the widest node
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iCol column of interest
             *  @returns {node} widest table node
             *  @memberof DataTable#oApi
             */
            function _fnGetWidestNode(oSettings, iCol) {
                var iMaxIndex = _fnGetMaxLenString(oSettings, iCol);
                if (iMaxIndex < 0) {
                    return null;
                }

                if (oSettings.aoData[iMaxIndex].nTr === null) {
                    var n = document.createElement('td');
                    n.innerHTML = _fnGetCellData(oSettings, iMaxIndex, iCol, '');
                    return n;
                }
                return _fnGetTdNodes(oSettings, iMaxIndex)[iCol];
            }


            /**
             * Get the maximum strlen for each data column
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iCol column of interest
             *  @returns {string} max string length for each column
             *  @memberof DataTable#oApi
             */
            function _fnGetMaxLenString(oSettings, iCol) {
                var iMax = -1;
                var iMaxIndex = -1;

                for (var i = 0; i < oSettings.aoData.length; i++) {
                    var s = _fnGetCellData(oSettings, i, iCol, 'display') + "";
                    s = s.replace(/<.*?>/g, "");
                    if (s.length > iMax) {
                        iMax = s.length;
                        iMaxIndex = i;
                    }
                }

                return iMaxIndex;
            }


            /**
             * Append a CSS unit (only if required) to a string
             *  @param {array} aArray1 first array
             *  @param {array} aArray2 second array
             *  @returns {int} 0 if match, 1 if length is different, 2 if no match
             *  @memberof DataTable#oApi
             */
            function _fnStringToCss(s) {
                if (s === null) {
                    return "0px";
                }

                if (typeof s == 'number') {
                    if (s < 0) {
                        return "0px";
                    }
                    return s + "px";
                }

                /* Check if the last character is not 0-9 */
                var c = s.charCodeAt(s.length - 1);
                if (c < 0x30 || c > 0x39) {
                    return s;
                }
                return s + "px";
            }


            /**
             * Get the width of a scroll bar in this browser being used
             *  @returns {int} width in pixels
             *  @memberof DataTable#oApi
             */
            function _fnScrollBarWidth() {
                var inner = document.createElement('p');
                var style = inner.style;
                style.width = "100%";
                style.height = "200px";
                style.padding = "0px";

                var outer = document.createElement('div');
                style = outer.style;
                style.position = "absolute";
                style.top = "0px";
                style.left = "0px";
                style.visibility = "hidden";
                style.width = "200px";
                style.height = "150px";
                style.padding = "0px";
                style.overflow = "hidden";
                outer.appendChild(inner);

                document.body.appendChild(outer);
                var w1 = inner.offsetWidth;
                outer.style.overflow = 'scroll';
                var w2 = inner.offsetWidth;
                if (w1 == w2) {
                    w2 = outer.clientWidth;
                }

                document.body.removeChild(outer);
                return (w1 - w2);
            }

            /**
             * Change the order of the table
             *  @param {object} oSettings dataTables settings object
             *  @param {bool} bApplyClasses optional - should we apply classes or not
             *  @memberof DataTable#oApi
             */
            function _fnSort(oSettings, bApplyClasses) {
                var
                    i, iLen, j, jLen, k, kLen,
                    sDataType, nTh,
                    aaSort = [],
                    aiOrig = [],
                    oSort = DataTable.ext.oSort,
                    aoData = oSettings.aoData,
                    aoColumns = oSettings.aoColumns,
                    oAria = oSettings.oLanguage.oAria;

                /* No sorting required if server-side or no sorting array */
                if (!oSettings.oFeatures.bServerSide &&
                    (oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null)) {
                    aaSort = ( oSettings.aaSortingFixed !== null ) ?
                        oSettings.aaSortingFixed.concat(oSettings.aaSorting) :
                        oSettings.aaSorting.slice();

                    /* If there is a sorting data type, and a function belonging to it, then we need to
                     * get the data from the developer's function and apply it for this column
                     */
                    for (i = 0; i < aaSort.length; i++) {
                        var iColumn = aaSort[i][0];
                        var iVisColumn = _fnColumnIndexToVisible(oSettings, iColumn);
                        sDataType = oSettings.aoColumns[iColumn].sSortDataType;
                        if (DataTable.ext.afnSortData[sDataType]) {
                            var aData = DataTable.ext.afnSortData[sDataType].call(
                                oSettings.oInstance, oSettings, iColumn, iVisColumn
                            );
                            if (aData.length === aoData.length) {
                                for (j = 0, jLen = aoData.length; j < jLen; j++) {
                                    _fnSetCellData(oSettings, j, iColumn, aData[j]);
                                }
                            }
                            else {
                                _fnLog(oSettings, 0, "Returned data sort array (col " + iColumn + ") is the wrong length");
                            }
                        }
                    }

                    /* Create a value - key array of the current row positions such that we can use their
                     * current position during the sort, if values match, in order to perform stable sorting
                     */
                    for (i = 0, iLen = oSettings.aiDisplayMaster.length; i < iLen; i++) {
                        aiOrig[oSettings.aiDisplayMaster[i]] = i;
                    }

                    /* Build an internal data array which is specific to the sort, so we can get and prep
                     * the data to be sorted only once, rather than needing to do it every time the sorting
                     * function runs. This make the sorting function a very simple comparison
                     */
                    var iSortLen = aaSort.length;
                    var fnSortFormat, aDataSort;
                    for (i = 0, iLen = aoData.length; i < iLen; i++) {
                        for (j = 0; j < iSortLen; j++) {
                            aDataSort = aoColumns[aaSort[j][0]].aDataSort;

                            for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
                                sDataType = aoColumns[aDataSort[k]].sType;
                                fnSortFormat = oSort[(sDataType ? sDataType : 'string') + "-pre"];

                                aoData[i]._aSortData[aDataSort[k]] = fnSortFormat ?
                                    fnSortFormat(_fnGetCellData(oSettings, i, aDataSort[k], 'sort')) :
                                    _fnGetCellData(oSettings, i, aDataSort[k], 'sort');
                            }
                        }
                    }

                    /* Do the sort - here we want multi-column sorting based on a given data source (column)
                     * and sorting function (from oSort) in a certain direction. It's reasonably complex to
                     * follow on it's own, but this is what we want (example two column sorting):
                     *  fnLocalSorting = function(a,b){
                     *  	var iTest;
                     *  	iTest = oSort['string-asc']('data11', 'data12');
                     *  	if (iTest !== 0)
                     *  		return iTest;
                     *    iTest = oSort['numeric-desc']('data21', 'data22');
                     *    if (iTest !== 0)
                     *  		return iTest;
                     *  	return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
                     *  }
                     * Basically we have a test for each sorting column, if the data in that column is equal,
                     * test the next column. If all columns match, then we use a numeric sort on the row 
                     * positions in the original data array to provide a stable sort.
                     */
                    oSettings.aiDisplayMaster.sort(function (a, b) {
                        var k, l, lLen, iTest, aDataSort, sDataType;
                        for (k = 0; k < iSortLen; k++) {
                            aDataSort = aoColumns[aaSort[k][0]].aDataSort;

                            for (l = 0, lLen = aDataSort.length; l < lLen; l++) {
                                sDataType = aoColumns[aDataSort[l]].sType;

                                iTest = oSort[(sDataType ? sDataType : 'string') + "-" + aaSort[k][1]](
                                    aoData[a]._aSortData[aDataSort[l]],
                                    aoData[b]._aSortData[aDataSort[l]]
                                );

                                if (iTest !== 0) {
                                    return iTest;
                                }
                            }
                        }

                        return oSort['numeric-asc'](aiOrig[a], aiOrig[b]);
                    });
                }

                /* Alter the sorting classes to take account of the changes */
                if ((bApplyClasses === undefined || bApplyClasses) && !oSettings.oFeatures.bDeferRender) {
                    _fnSortingClasses(oSettings);
                }

                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    var sTitle = aoColumns[i].sTitle.replace(/<.*?>/g, "");
                    nTh = aoColumns[i].nTh;
                    nTh.removeAttribute('aria-sort');
                    nTh.removeAttribute('aria-label');

                    /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
                    if (aoColumns[i].bSortable) {
                        if (aaSort.length > 0 && aaSort[0][0] == i) {
                            nTh.setAttribute('aria-sort', aaSort[0][1] == "asc" ? "ascending" : "descending");

                            var nextSort = (aoColumns[i].asSorting[aaSort[0][2] + 1]) ?
                                aoColumns[i].asSorting[aaSort[0][2] + 1] : aoColumns[i].asSorting[0];
                            nTh.setAttribute('aria-label', sTitle +
                                (nextSort == "asc" ? oAria.sSortAscending : oAria.sSortDescending));
                        }
                        else {
                            nTh.setAttribute('aria-label', sTitle +
                                (aoColumns[i].asSorting[0] == "asc" ? oAria.sSortAscending : oAria.sSortDescending));
                        }
                    }
                    else {
                        nTh.setAttribute('aria-label', sTitle);
                    }
                }

                /* Tell the draw function that we have sorted the data */
                oSettings.bSorted = true;
                $(oSettings.oInstance).trigger('sort', oSettings);

                /* Copy the master data into the draw array and re-draw */
                if (oSettings.oFeatures.bFilter) {
                    /* _fnFilter() will redraw the table for us */
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1);
                }
                else {
                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                    oSettings._iDisplayStart = 0;
                    /* reset display back to page 0 */
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings);
                }
            }


            /**
             * Attach a sort handler (click) to a node
             *  @param {object} oSettings dataTables settings object
             *  @param {node} nNode node to attach the handler to
             *  @param {int} iDataIndex column sorting index
             *  @param {function} [fnCallback] callback function
             *  @memberof DataTable#oApi
             */
            function _fnSortAttachListener(oSettings, nNode, iDataIndex, fnCallback) {
                _fnBindAction(nNode, {}, function (e) {
                    /* If the column is not sortable - don't to anything */
                    if (oSettings.aoColumns[iDataIndex].bSortable === false) {
                        return;
                    }

                    /*
                     * This is a little bit odd I admit... I declare a temporary function inside the scope of
                     * _fnBuildHead and the click handler in order that the code presented here can be used 
                     * twice - once for when bProcessing is enabled, and another time for when it is 
                     * disabled, as we need to perform slightly different actions.
                     *   Basically the issue here is that the Javascript engine in modern browsers don't 
                     * appear to allow the rendering engine to update the display while it is still executing
                     * it's thread (well - it does but only after long intervals). This means that the 
                     * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
                     * I force an execution break by using setTimeout - but this breaks the expected 
                     * thread continuation for the end-developer's point of view (their code would execute
                     * too early), so we only do it when we absolutely have to.
                     */
                    var fnInnerSorting = function () {
                        var iColumn, iNextSort;

                        /* If the shift key is pressed then we are multiple column sorting */
                        if (e.shiftKey) {
                            /* Are we already doing some kind of sort on this column? */
                            var bFound = false;
                            for (var i = 0; i < oSettings.aaSorting.length; i++) {
                                if (oSettings.aaSorting[i][0] == iDataIndex) {
                                    bFound = true;
                                    iColumn = oSettings.aaSorting[i][0];
                                    iNextSort = oSettings.aaSorting[i][2] + 1;

                                    if (!oSettings.aoColumns[iColumn].asSorting[iNextSort]) {
                                        /* Reached the end of the sorting options, remove from multi-col sort */
                                        oSettings.aaSorting.splice(i, 1);
                                    }
                                    else {
                                        /* Move onto next sorting direction */
                                        oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                                        oSettings.aaSorting[i][2] = iNextSort;
                                    }
                                    break;
                                }
                            }

                            /* No sort yet - add it in */
                            if (bFound === false) {
                                oSettings.aaSorting.push([iDataIndex,
                                    oSettings.aoColumns[iDataIndex].asSorting[0], 0]);
                            }
                        }
                        else {
                            /* If no shift key then single column sort */
                            if (oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex) {
                                iColumn = oSettings.aaSorting[0][0];
                                iNextSort = oSettings.aaSorting[0][2] + 1;
                                if (!oSettings.aoColumns[iColumn].asSorting[iNextSort]) {
                                    iNextSort = 0;
                                }
                                oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                                oSettings.aaSorting[0][2] = iNextSort;
                            }
                            else {
                                oSettings.aaSorting.splice(0, oSettings.aaSorting.length);
                                oSettings.aaSorting.push([iDataIndex,
                                    oSettings.aoColumns[iDataIndex].asSorting[0], 0]);
                            }
                        }

                        /* Run the sort */
                        _fnSort(oSettings);
                    };
                    /* /fnInnerSorting */

                    if (!oSettings.oFeatures.bProcessing) {
                        fnInnerSorting();
                    }
                    else {
                        _fnProcessingDisplay(oSettings, true);
                        setTimeout(function () {
                            fnInnerSorting();
                            if (!oSettings.oFeatures.bServerSide) {
                                _fnProcessingDisplay(oSettings, false);
                            }
                        }, 0);
                    }

                    /* Call the user specified callback function - used for async user interaction */
                    if (typeof fnCallback == 'function') {
                        fnCallback(oSettings);
                    }
                });
            }


            /**
             * Set the sorting classes on the header, Note: it is safe to call this function
             * when bSort and bSortClasses are false
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnSortingClasses(oSettings) {
                var i, iLen, j, jLen, iFound;
                var aaSort, sClass;
                var iColumns = oSettings.aoColumns.length;
                var oClasses = oSettings.oClasses;

                for (i = 0; i < iColumns; i++) {
                    if (oSettings.aoColumns[i].bSortable) {
                        $(oSettings.aoColumns[i].nTh).removeClass(oClasses.sSortAsc + " " + oClasses.sSortDesc +
                            " " + oSettings.aoColumns[i].sSortingClass);
                    }
                }

                if (oSettings.aaSortingFixed !== null) {
                    aaSort = oSettings.aaSortingFixed.concat(oSettings.aaSorting);
                }
                else {
                    aaSort = oSettings.aaSorting.slice();
                }

                /* Apply the required classes to the header */
                for (i = 0; i < oSettings.aoColumns.length; i++) {
                    if (oSettings.aoColumns[i].bSortable) {
                        sClass = oSettings.aoColumns[i].sSortingClass;
                        iFound = -1;
                        for (j = 0; j < aaSort.length; j++) {
                            if (aaSort[j][0] == i) {
                                sClass = ( aaSort[j][1] == "asc" ) ?
                                    oClasses.sSortAsc : oClasses.sSortDesc;
                                iFound = j;
                                break;
                            }
                        }
                        $(oSettings.aoColumns[i].nTh).addClass(sClass);

                        if (oSettings.bJUI) {
                            /* jQuery UI uses extra markup */
                            var jqSpan = $("span." + oClasses.sSortIcon, oSettings.aoColumns[i].nTh);
                            jqSpan.removeClass(oClasses.sSortJUIAsc + " " + oClasses.sSortJUIDesc + " " +
                                oClasses.sSortJUI + " " + oClasses.sSortJUIAscAllowed + " " + oClasses.sSortJUIDescAllowed);

                            var sSpanClass;
                            if (iFound == -1) {
                                sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
                            }
                            else if (aaSort[iFound][1] == "asc") {
                                sSpanClass = oClasses.sSortJUIAsc;
                            }
                            else {
                                sSpanClass = oClasses.sSortJUIDesc;
                            }

                            jqSpan.addClass(sSpanClass);
                        }
                    }
                    else {
                        /* No sorting on this column, so add the base class. This will have been assigned by
                         * _fnAddColumn
                         */
                        $(oSettings.aoColumns[i].nTh).addClass(oSettings.aoColumns[i].sSortingClass);
                    }
                }

                /* 
                 * Apply the required classes to the table body
                 * Note that this is given as a feature switch since it can significantly slow down a sort
                 * on large data sets (adding and removing of classes is always slow at the best of times..)
                 * Further to this, note that this code is admittedly fairly ugly. It could be made a lot 
                 * simpler using jQuery selectors and add/removeClass, but that is significantly slower
                 * (on the order of 5 times slower) - hence the direct DOM manipulation here.
                 * Note that for deferred drawing we do use jQuery - the reason being that taking the first
                 * row found to see if the whole column needs processed can miss classes since the first
                 * column might be new.
                 */
                sClass = oClasses.sSortColumn;

                if (oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses) {
                    var nTds = _fnGetTdNodes(oSettings);

                    /* Determine what the sorting class for each column should be */
                    var iClass, iTargetCol;
                    var asClasses = [];
                    for (i = 0; i < iColumns; i++) {
                        asClasses.push("");
                    }
                    for (i = 0, iClass = 1; i < aaSort.length; i++) {
                        iTargetCol = parseInt(aaSort[i][0], 10);
                        asClasses[iTargetCol] = sClass + iClass;

                        if (iClass < 3) {
                            iClass++;
                        }
                    }

                    /* Make changes to the classes for each cell as needed */
                    var reClass = new RegExp(sClass + "[123]");
                    var sTmpClass, sCurrentClass, sNewClass;
                    for (i = 0, iLen = nTds.length; i < iLen; i++) {
                        /* Determine which column we're looking at */
                        iTargetCol = i % iColumns;

                        /* What is the full list of classes now */
                        sCurrentClass = nTds[i].className;
                        /* What sorting class should be applied? */
                        sNewClass = asClasses[iTargetCol];
                        /* What would the new full list be if we did a replacement? */
                        sTmpClass = sCurrentClass.replace(reClass, sNewClass);

                        if (sTmpClass != sCurrentClass) {
                            /* We changed something */
                            nTds[i].className = $.trim(sTmpClass);
                        }
                        else if (sNewClass.length > 0 && sCurrentClass.indexOf(sNewClass) == -1) {
                            /* We need to add a class */
                            nTds[i].className = sCurrentClass + " " + sNewClass;
                        }
                    }
                }
            }


            /**
             * Save the state of a table in a cookie such that the page can be reloaded
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnSaveState(oSettings) {
                if (!oSettings.oFeatures.bStateSave || oSettings.bDestroying) {
                    return;
                }

                /* Store the interesting variables */
                var i, iLen, bInfinite = oSettings.oScroll.bInfinite;
                var oState = {
                    "iCreate": new Date().getTime(),
                    "iStart": (bInfinite ? 0 : oSettings._iDisplayStart),
                    "iEnd": (bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd),
                    "iLength": oSettings._iDisplayLength,
                    "aaSorting": $.extend(true, [], oSettings.aaSorting),
                    "oSearch": $.extend(true, {}, oSettings.oPreviousSearch),
                    "aoSearchCols": $.extend(true, [], oSettings.aoPreSearchCols),
                    "abVisCols": []
                };

                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    oState.abVisCols.push(oSettings.aoColumns[i].bVisible);
                }

                _fnCallbackFire(oSettings, "aoStateSaveParams", 'stateSaveParams', [oSettings, oState]);

                oSettings.fnStateSave.call(oSettings.oInstance, oSettings, oState);
            }


            /**
             * Attempt to load a saved table state from a cookie
             *  @param {object} oSettings dataTables settings object
             *  @param {object} oInit DataTables init object so we can override settings
             *  @memberof DataTable#oApi
             */
            function _fnLoadState(oSettings, oInit) {
                if (!oSettings.oFeatures.bStateSave) {
                    return;
                }

                var oData = oSettings.fnStateLoad.call(oSettings.oInstance, oSettings);
                if (!oData) {
                    return;
                }

                /* Allow custom and plug-in manipulation functions to alter the saved data set and
                 * cancelling of loading by returning false
                 */
                var abStateLoad = _fnCallbackFire(oSettings, 'aoStateLoadParams', 'stateLoadParams', [oSettings, oData]);
                if ($.inArray(false, abStateLoad) !== -1) {
                    return;
                }

                /* Store the saved state so it might be accessed at any time */
                oSettings.oLoadedState = $.extend(true, {}, oData);

                /* Restore key features */
                oSettings._iDisplayStart = oData.iStart;
                oSettings.iInitDisplayStart = oData.iStart;
                oSettings._iDisplayEnd = oData.iEnd;
                oSettings._iDisplayLength = oData.iLength;
                oSettings.aaSorting = oData.aaSorting.slice();
                oSettings.saved_aaSorting = oData.aaSorting.slice();

                /* Search filtering  */
                $.extend(oSettings.oPreviousSearch, oData.oSearch);
                $.extend(true, oSettings.aoPreSearchCols, oData.aoSearchCols);

                /* Column visibility state
                 * Pass back visibility settings to the init handler, but to do not here override
                 * the init object that the user might have passed in
                 */
                oInit.saved_aoColumns = [];
                for (var i = 0; i < oData.abVisCols.length; i++) {
                    oInit.saved_aoColumns[i] = {};
                    oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
                }

                _fnCallbackFire(oSettings, 'aoStateLoaded', 'stateLoaded', [oSettings, oData]);
            }


            /**
             * Create a new cookie with a value to store the state of a table
             *  @param {string} sName name of the cookie to create
             *  @param {string} sValue the value the cookie should take
             *  @param {int} iSecs duration of the cookie
             *  @param {string} sBaseName sName is made up of the base + file name - this is the base
             *  @param {function} fnCallback User definable function to modify the cookie
             *  @memberof DataTable#oApi
             */
            function _fnCreateCookie(sName, sValue, iSecs, sBaseName, fnCallback) {
                var date = new Date();
                date.setTime(date.getTime() + (iSecs * 1000));

                /* 
                 * Shocking but true - it would appear IE has major issues with having the path not having
                 * a trailing slash on it. We need the cookie to be available based on the path, so we
                 * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
                 * patch to use at least some of the path
                 */
                var aParts = window.location.pathname.split('/');
                var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g, "").toLowerCase();
                var sFullCookie, oData;

                if (fnCallback !== null) {
                    oData = (typeof $.parseJSON === 'function') ?
                        $.parseJSON(sValue) : eval('(' + sValue + ')');
                    sFullCookie = fnCallback(sNameFile, oData, date.toGMTString(),
                        aParts.join('/') + "/");
                }
                else {
                    sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
                        "; expires=" + date.toGMTString() + "; path=" + aParts.join('/') + "/";
                }

                /* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
                 * belonging to DataTables.
                 */
                var
                    aCookies = document.cookie.split(';'),
                    iNewCookieLen = sFullCookie.split(';')[0].length,
                    aOldCookies = [];

                if (iNewCookieLen + document.cookie.length + 10 > 4096) /* Magic 10 for padding */
                {
                    for (var i = 0, iLen = aCookies.length; i < iLen; i++) {
                        if (aCookies[i].indexOf(sBaseName) != -1) {
                            /* It's a DataTables cookie, so eval it and check the time stamp */
                            var aSplitCookie = aCookies[i].split('=');
                            try {
                                oData = eval('(' + decodeURIComponent(aSplitCookie[1]) + ')');

                                if (oData && oData.iCreate) {
                                    aOldCookies.push({
                                        "name": aSplitCookie[0],
                                        "time": oData.iCreate
                                    });
                                }
                            }
                            catch (e) {
                            }
                        }
                    }

                    // Make sure we delete the oldest ones first
                    aOldCookies.sort(function (a, b) {
                        return b.time - a.time;
                    });

                    // Eliminate as many old DataTables cookies as we need to
                    while (iNewCookieLen + document.cookie.length + 10 > 4096) {
                        if (aOldCookies.length === 0) {
                            // Deleted all DT cookies and still not enough space. Can't state save
                            return;
                        }

                        var old = aOldCookies.pop();
                        document.cookie = old.name + "=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=" +
                            aParts.join('/') + "/";
                    }
                }

                document.cookie = sFullCookie;
            }


            /**
             * Read an old cookie to get a cookie with an old table state
             *  @param {string} sName name of the cookie to read
             *  @returns {string} contents of the cookie - or null if no cookie with that name found
             *  @memberof DataTable#oApi
             */
            function _fnReadCookie(sName) {
                var
                    aParts = window.location.pathname.split('/'),
                    sNameEQ = sName + '_' + aParts[aParts.length - 1].replace(/[\/:]/g, "").toLowerCase() + '=',
                    sCookieContents = document.cookie.split(';');

                for (var i = 0; i < sCookieContents.length; i++) {
                    var c = sCookieContents[i];

                    while (c.charAt(0) == ' ') {
                        c = c.substring(1, c.length);
                    }

                    if (c.indexOf(sNameEQ) === 0) {
                        return decodeURIComponent(c.substring(sNameEQ.length, c.length));
                    }
                }
                return null;
            }


            /**
             * Return the settings object for a particular table
             *  @param {node} nTable table we are using as a dataTable
             *  @returns {object} Settings object - or null if not found
             *  @memberof DataTable#oApi
             */
            function _fnSettingsFromNode(nTable) {
                for (var i = 0; i < DataTable.settings.length; i++) {
                    if (DataTable.settings[i].nTable === nTable) {
                        return DataTable.settings[i];
                    }
                }

                return null;
            }


            /**
             * Return an array with the TR nodes for the table
             *  @param {object} oSettings dataTables settings object
             *  @returns {array} TR array
             *  @memberof DataTable#oApi
             */
            function _fnGetTrNodes(oSettings) {
                var aNodes = [];
                var aoData = oSettings.aoData;
                for (var i = 0, iLen = aoData.length; i < iLen; i++) {
                    if (aoData[i].nTr !== null) {
                        aNodes.push(aoData[i].nTr);
                    }
                }
                return aNodes;
            }


            /**
             * Return an flat array with all TD nodes for the table, or row
             *  @param {object} oSettings dataTables settings object
             *  @param {int} [iIndividualRow] aoData index to get the nodes for - optional
             *    if not given then the return array will contain all nodes for the table
             *  @returns {array} TD array
             *  @memberof DataTable#oApi
             */
            function _fnGetTdNodes(oSettings, iIndividualRow) {
                var anReturn = [];
                var iCorrector;
                var anTds, nTd;
                var iRow, iRows = oSettings.aoData.length,
                    iColumn, iColumns, oData, sNodeName, iStart = 0, iEnd = iRows;

                /* Allow the collection to be limited to just one row */
                if (iIndividualRow !== undefined) {
                    iStart = iIndividualRow;
                    iEnd = iIndividualRow + 1;
                }

                for (iRow = iStart; iRow < iEnd; iRow++) {
                    oData = oSettings.aoData[iRow];
                    if (oData.nTr !== null) {
                        /* get the TD child nodes - taking into account text etc nodes */
                        anTds = [];
                        nTd = oData.nTr.firstChild;
                        while (nTd) {
                            sNodeName = nTd.nodeName.toLowerCase();
                            if (sNodeName == 'td' || sNodeName == 'th') {
                                anTds.push(nTd);
                            }
                            nTd = nTd.nextSibling;
                        }

                        iCorrector = 0;
                        for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
                            if (oSettings.aoColumns[iColumn].bVisible) {
                                anReturn.push(anTds[iColumn - iCorrector]);
                            }
                            else {
                                anReturn.push(oData._anHidden[iColumn]);
                                iCorrector++;
                            }
                        }
                    }
                }

                return anReturn;
            }


            /**
             * Log an error message
             *  @param {object} oSettings dataTables settings object
             *  @param {int} iLevel log error messages, or display them to the user
             *  @param {string} sMesg error message
             *  @memberof DataTable#oApi
             */
            function _fnLog(oSettings, iLevel, sMesg) {
                var sAlert = (oSettings === null) ?
                "DataTables warning: " + sMesg :
                "DataTables warning (table id = '" + oSettings.sTableId + "'): " + sMesg;

                if (iLevel === 0) {
                    if (DataTable.ext.sErrMode == 'alert') {
                        alert(sAlert);
                    }
                    else {
                        throw new Error(sAlert);
                    }
                    return;
                }
                else if (window.console && console.log) {
                    console.log(sAlert);
                }
            }


            /**
             * See if a property is defined on one object, if so assign it to the other object
             *  @param {object} oRet target object
             *  @param {object} oSrc source object
             *  @param {string} sName property
             *  @param {string} [sMappedName] name to map too - optional, sName used if not given
             *  @memberof DataTable#oApi
             */
            function _fnMap(oRet, oSrc, sName, sMappedName) {
                if (sMappedName === undefined) {
                    sMappedName = sName;
                }
                if (oSrc[sName] !== undefined) {
                    oRet[sMappedName] = oSrc[sName];
                }
            }


            /**
             * Extend objects - very similar to jQuery.extend, but deep copy objects, and shallow
             * copy arrays. The reason we need to do this, is that we don't want to deep copy array
             * init values (such as aaSorting) since the dev wouldn't be able to override them, but
             * we do want to deep copy arrays.
             *  @param {object} oOut Object to extend
             *  @param {object} oExtender Object from which the properties will be applied to oOut
             *  @returns {object} oOut Reference, just for convenience - oOut === the return.
             *  @memberof DataTable#oApi
             *  @todo This doesn't take account of arrays inside the deep copied objects.
             */
            function _fnExtend(oOut, oExtender) {
                var val;

                for (var prop in oExtender) {
                    if (oExtender.hasOwnProperty(prop)) {
                        val = oExtender[prop];

                        if (typeof oInit[prop] === 'object' && val !== null && $.isArray(val) === false) {
                            $.extend(true, oOut[prop], val);
                        }
                        else {
                            oOut[prop] = val;
                        }
                    }
                }

                return oOut;
            }


            /**
             * Bind an event handers to allow a click or return key to activate the callback.
             * This is good for accessibility since a return on the keyboard will have the
             * same effect as a click, if the element has focus.
             *  @param {element} n Element to bind the action to
             *  @param {object} oData Data object to pass to the triggered function
             *  @param {function} fn Callback function for when the event is triggered
             *  @memberof DataTable#oApi
             */
            function _fnBindAction(n, oData, fn) {
                $(n)
                    .bind('click.DT', oData, function (e) {
                        n.blur(); // Remove focus outline for mouse users
                        fn(e);
                    })
                    .bind('keypress.DT', oData, function (e) {
                        if (e.which === 13) {
                            fn(e);
                        }
                    })
                    .bind('selectstart.DT', function () {
                        /* Take the brutal approach to cancelling text selection */
                        return false;
                    });
            }


            /**
             * Register a callback function. Easily allows a callback function to be added to
             * an array store of callback functions that can then all be called together.
             *  @param {object} oSettings dataTables settings object
             *  @param {string} sStore Name of the array storage for the callbacks in oSettings
             *  @param {function} fn Function to be called back
             *  @param {string} sName Identifying name for the callback (i.e. a label)
             *  @memberof DataTable#oApi
             */
            function _fnCallbackReg(oSettings, sStore, fn, sName) {
                if (fn) {
                    oSettings[sStore].push({
                        "fn": fn,
                        "sName": sName
                    });
                }
            }


            /**
             * Fire callback functions and trigger events. Note that the loop over the callback
             * array store is done backwards! Further note that you do not want to fire off triggers
             * in time sensitive applications (for example cell creation) as its slow.
             *  @param {object} oSettings dataTables settings object
             *  @param {string} sStore Name of the array storage for the callbacks in oSettings
             *  @param {string} sTrigger Name of the jQuery custom event to trigger. If null no trigger
             *    is fired
             *  @param {array} aArgs Array of arguments to pass to the callback function / trigger
             *  @memberof DataTable#oApi
             */
            function _fnCallbackFire(oSettings, sStore, sTrigger, aArgs) {
                var aoStore = oSettings[sStore];
                var aRet = [];

                for (var i = aoStore.length - 1; i >= 0; i--) {
                    aRet.push(aoStore[i].fn.apply(oSettings.oInstance, aArgs));
                }

                if (sTrigger !== null) {
                    $(oSettings.oInstance).trigger(sTrigger, aArgs);
                }

                return aRet;
            }


            /**
             * JSON stringify. If JSON.stringify it provided by the browser, json2.js or any other
             * library, then we use that as it is fast, safe and accurate. If the function isn't
             * available then we need to built it ourselves - the inspiration for this function comes
             * from Craig Buckler ( http://www.sitepoint.com/javascript-json-serialization/ ). It is
             * not perfect and absolutely should not be used as a replacement to json2.js - but it does
             * do what we need, without requiring a dependency for DataTables.
             *  @param {object} o JSON object to be converted
             *  @returns {string} JSON string
             *  @memberof DataTable#oApi
             */
            var _fnJsonString = (window.JSON) ? JSON.stringify : function (o) {
                /* Not an object or array */
                var sType = typeof o;
                if (sType !== "object" || o === null) {
                    // simple data type
                    if (sType === "string") {
                        o = '"' + o + '"';
                    }
                    return o + "";
                }

                /* If object or array, need to recurse over it */
                var
                    sProp, mValue,
                    json = [],
                    bArr = $.isArray(o);

                for (sProp in o) {
                    mValue = o[sProp];
                    sType = typeof mValue;

                    if (sType === "string") {
                        mValue = '"' + mValue + '"';
                    }
                    else if (sType === "object" && mValue !== null) {
                        mValue = _fnJsonString(mValue);
                    }

                    json.push((bArr ? "" : '"' + sProp + '":') + mValue);
                }

                return (bArr ? "[" : "{") + json + (bArr ? "]" : "}");
            };


            /**
             * From some browsers (specifically IE6/7) we need special handling to work around browser
             * bugs - this function is used to detect when these workarounds are needed.
             *  @param {object} oSettings dataTables settings object
             *  @memberof DataTable#oApi
             */
            function _fnBrowserDetect(oSettings) {
                /* IE6/7 will oversize a width 100% element inside a scrolling element, to include the
                 * width of the scrollbar, while other browsers ensure the inner element is contained
                 * without forcing scrolling
                 */
                var n = $(
                    '<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">' +
                    '<div style="position:absolute; top:1px; left:1px; width:100px; overflow:scroll;">' +
                    '<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>' +
                    '</div>' +
                    '</div>')[0];

                document.body.appendChild(n);
                oSettings.oBrowser.bScrollOversize = $('#DT_BrowserTest', n)[0].offsetWidth === 100 ? true : false;
                document.body.removeChild(n);
            }


            /**
             * Perform a jQuery selector action on the table's TR elements (from the tbody) and
             * return the resulting jQuery object.
             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
             *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
             *    criterion ("applied") or all TR elements (i.e. no filter).
             *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
             *    Can be either 'current', whereby the current sorting of the table is used, or
             *    'original' whereby the original order the data was read into the table is used.
             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
             *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
             *    'current' and filter is 'applied', regardless of what they might be given as.
             *  @returns {object} jQuery object, filtered by the given selector.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"filter": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
             */
            this.$ = function (sSelector, oOpts) {
                var i, iLen, a = [], tr;
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var aoData = oSettings.aoData;
                var aiDisplay = oSettings.aiDisplay;
                var aiDisplayMaster = oSettings.aiDisplayMaster;

                if (!oOpts) {
                    oOpts = {};
                }

                oOpts = $.extend({}, {
                    "filter": "none", // applied
                    "order": "current", // "original"
                    "page": "all" // current
                }, oOpts);

                // Current page implies that order=current and fitler=applied, since it is fairly
                // senseless otherwise
                if (oOpts.page == 'current') {
                    for (i = oSettings._iDisplayStart, iLen = oSettings.fnDisplayEnd(); i < iLen; i++) {
                        tr = aoData[aiDisplay[i]].nTr;
                        if (tr) {
                            a.push(tr);
                        }
                    }
                }
                else if (oOpts.order == "current" && oOpts.filter == "none") {
                    for (i = 0, iLen = aiDisplayMaster.length; i < iLen; i++) {
                        tr = aoData[aiDisplayMaster[i]].nTr;
                        if (tr) {
                            a.push(tr);
                        }
                    }
                }
                else if (oOpts.order == "current" && oOpts.filter == "applied") {
                    for (i = 0, iLen = aiDisplay.length; i < iLen; i++) {
                        tr = aoData[aiDisplay[i]].nTr;
                        if (tr) {
                            a.push(tr);
                        }
                    }
                }
                else if (oOpts.order == "original" && oOpts.filter == "none") {
                    for (i = 0, iLen = aoData.length; i < iLen; i++) {
                        tr = aoData[i].nTr;
                        if (tr) {
                            a.push(tr);
                        }
                    }
                }
                else if (oOpts.order == "original" && oOpts.filter == "applied") {
                    for (i = 0, iLen = aoData.length; i < iLen; i++) {
                        tr = aoData[i].nTr;
                        if ($.inArray(i, aiDisplay) !== -1 && tr) {
                            a.push(tr);
                        }
                    }
                }
                else {
                    _fnLog(oSettings, 1, "Unknown selection options");
                }

                /* We need to filter on the TR elements and also 'find' in their descendants
                 * to make the selector act like it would in a full table - so we need
                 * to build both results and then combine them together
                 */
                var jqA = $(a);
                var jqTRs = jqA.filter(sSelector);
                var jqDescendants = jqA.find(sSelector);

                return $([].concat($.makeArray(jqTRs), $.makeArray(jqDescendants)));
            };


            /**
             * Almost identical to $ in operation, but in this case returns the data for the matched
             * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
             * rather than any descendants, so the data can be obtained for the row/cell. If matching
             * rows are found, the data returned is the original data array/object that was used to
             * create the row (or a generated array if from a DOM source).
             *
             * This method is often useful in-combination with $ where both functions are given the
             * same parameters and the array indexes will match identically.
             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
             *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
             *    criterion ("applied") or all elements (i.e. no filter).
             *  @param {string} [oOpts.order=current] Order of the data in the processed array.
             *    Can be either 'current', whereby the current sorting of the table is used, or
             *    'original' whereby the original order the data was read into the table is used.
             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
             *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
             *    'current' and filter is 'applied', regardless of what they might be given as.
             *  @returns {array} Data for the matched elements. If any elements, as a result of the
             *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
             *    entry in the array.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for 
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"filter": "applied"});
		 *      
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the filter" );
		 *    } );
             */
            this._ = function (sSelector, oOpts) {
                var aOut = [];
                var i, iLen, iIndex;
                var aTrs = this.$(sSelector, oOpts);

                for (i = 0, iLen = aTrs.length; i < iLen; i++) {
                    aOut.push(this.fnGetData(aTrs[i]));
                }

                return aOut;
            };


            /**
             * Add a single new row or multiple rows of data to the table. Please note
             * that this is suitable for client-side processing only - if you are using
             * server-side processing (i.e. "bServerSide": true), then to add data, you
             * must add it to the data source, i.e. the server-side, through an Ajax call.
             *  @param {array|object} mData The data to be added to the table. This can be:
             *    <ul>
             *      <li>1D array of data - add a single row with the data provided</li>
             *      <li>2D array of arrays - add multiple rows in a single call</li>
             *      <li>object - data object when using <i>mData</i></li>
             *      <li>array of objects - multiple data objects when using <i>mData</i></li>
             *    </ul>
             *  @param {bool} [bRedraw=true] redraw the table or not
             *  @returns {array} An array of integers, representing the list of indexes in
             *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
             *    the table.
             *  @dtopt API
             *
             *  @example
             *    // Global var for counter
             *    var giCount = 2;
             *
             *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
             *
             *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *        
		 *      giCount++;
		 *    }
             */
            this.fnAddData = function (mData, bRedraw) {
                if (mData.length === 0) {
                    return [];
                }

                var aiReturn = [];
                var iTest;

                /* Find settings from table node */
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                /* Check if we want to add multiple rows or not */
                if (typeof mData[0] === "object" && mData[0] !== null) {
                    for (var i = 0; i < mData.length; i++) {
                        iTest = _fnAddData(oSettings, mData[i]);
                        if (iTest == -1) {
                            return aiReturn;
                        }
                        aiReturn.push(iTest);
                    }
                }
                else {
                    iTest = _fnAddData(oSettings, mData);
                    if (iTest == -1) {
                        return aiReturn;
                    }
                    aiReturn.push(iTest);
                }

                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

                if (bRedraw === undefined || bRedraw) {
                    _fnReDraw(oSettings);
                }
                return aiReturn;
            };


            /**
             * This function will make DataTables recalculate the column sizes, based on the data
             * contained in the table and the sizes applied to the columns (in the DOM, CSS or
             * through the sWidth parameter). This can be useful when the width of the table's
             * parent element changes (for example a window resize).
             *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
             */
            this.fnAdjustColumnSizing = function (bRedraw) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                _fnAdjustColumnSizing(oSettings);

                if (bRedraw === undefined || bRedraw) {
                    this.fnDraw(false);
                }
                else if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
                    /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
                    this.oApi._fnScrollDraw(oSettings);
                }
            };


            /**
             * Quickly and simply clear a table
             *  @param {bool} [bRedraw=true] redraw the table or not
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
             */
            this.fnClearTable = function (bRedraw) {
                /* Find settings from table node */
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                _fnClearTable(oSettings);

                if (bRedraw === undefined || bRedraw) {
                    _fnDraw(oSettings);
                }
            };


            /**
             * The exact opposite of 'opening' a row, this function will close any rows which
             * are currently 'open'.
             *  @param {node} nTr the table row to 'close'
             *  @returns {int} 0 on success, or 1 if failed (can't find the row)
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
             */
            this.fnClose = function (nTr) {
                /* Find settings from table node */
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                for (var i = 0; i < oSettings.aoOpenRows.length; i++) {
                    if (oSettings.aoOpenRows[i].nParent == nTr) {
                        var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
                        if (nTrParent) {
                            /* Remove it if it is currently on display */
                            nTrParent.removeChild(oSettings.aoOpenRows[i].nTr);
                        }
                        oSettings.aoOpenRows.splice(i, 1);
                        return 0;
                    }
                }
                return 1;
            };


            /**
             * Remove a row for the table
             *  @param {mixed} mTarget The index of the row from aoData to be deleted, or
             *    the TR element you want to delete
             *  @param {function|null} [fnCallBack] Callback function
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @returns {array} The row that was deleted
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
             */
            this.fnDeleteRow = function (mTarget, fnCallBack, bRedraw) {
                /* Find settings from table node */
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var i, iLen, iAODataIndex;

                iAODataIndex = (typeof mTarget === 'object') ?
                    _fnNodeToDataIndex(oSettings, mTarget) : mTarget;

                /* Return the data array from this row */
                var oData = oSettings.aoData.splice(iAODataIndex, 1);

                /* Update the _DT_RowIndex parameter */
                for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                    if (oSettings.aoData[i].nTr !== null) {
                        oSettings.aoData[i].nTr._DT_RowIndex = i;
                    }
                }

                /* Remove the target row from the search array */
                var iDisplayIndex = $.inArray(iAODataIndex, oSettings.aiDisplay);
                oSettings.asDataSearch.splice(iDisplayIndex, 1);

                /* Delete from the display arrays */
                _fnDeleteIndex(oSettings.aiDisplayMaster, iAODataIndex);
                _fnDeleteIndex(oSettings.aiDisplay, iAODataIndex);

                /* If there is a user callback function - call it */
                if (typeof fnCallBack === "function") {
                    fnCallBack.call(this, oSettings, oData);
                }

                /* Check for an 'overflow' they case for displaying the table */
                if (oSettings._iDisplayStart >= oSettings.fnRecordsDisplay()) {
                    oSettings._iDisplayStart -= oSettings._iDisplayLength;
                    if (oSettings._iDisplayStart < 0) {
                        oSettings._iDisplayStart = 0;
                    }
                }

                if (bRedraw === undefined || bRedraw) {
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings);
                }

                return oData;
            };


            /**
             * Restore the table to it's original state in the DOM by removing all of DataTables
             * enhancements, alterations to the DOM structure of the table and event listeners.
             *  @param {boolean} [bRemove=false] Completely remove the table from the DOM
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
             */
            this.fnDestroy = function (bRemove) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var nOrig = oSettings.nTableWrapper.parentNode;
                var nBody = oSettings.nTBody;
                var i, iLen;

                bRemove = (bRemove === undefined) ? false : bRemove;

                /* Flag to note that the table is currently being destroyed - no action should be taken */
                oSettings.bDestroying = true;

                /* Fire off the destroy callbacks for plug-ins etc */
                _fnCallbackFire(oSettings, "aoDestroyCallback", "destroy", [oSettings]);

                /* If the table is not being removed, restore the hidden columns */
                if (!bRemove) {
                    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                        if (oSettings.aoColumns[i].bVisible === false) {
                            this.fnSetColumnVis(i, true);
                        }
                    }
                }

                /* Blitz all DT events */
                $(oSettings.nTableWrapper).find('*').andSelf().unbind('.DT');

                /* If there is an 'empty' indicator row, remove it */
                $('tbody>tr>td.' + oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();

                /* When scrolling we had to break the table up - restore it */
                if (oSettings.nTable != oSettings.nTHead.parentNode) {
                    $(oSettings.nTable).children('thead').remove();
                    oSettings.nTable.appendChild(oSettings.nTHead);
                }

                if (oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode) {
                    $(oSettings.nTable).children('tfoot').remove();
                    oSettings.nTable.appendChild(oSettings.nTFoot);
                }

                /* Remove the DataTables generated nodes, events and classes */
                oSettings.nTable.parentNode.removeChild(oSettings.nTable);
                $(oSettings.nTableWrapper).remove();

                oSettings.aaSorting = [];
                oSettings.aaSortingFixed = [];
                _fnSortingClasses(oSettings);

                $(_fnGetTrNodes(oSettings)).removeClass(oSettings.asStripeClasses.join(' '));

                $('th, td', oSettings.nTHead).removeClass([
                        oSettings.oClasses.sSortable,
                        oSettings.oClasses.sSortableAsc,
                        oSettings.oClasses.sSortableDesc,
                        oSettings.oClasses.sSortableNone].join(' ')
                );
                if (oSettings.bJUI) {
                    $('th span.' + oSettings.oClasses.sSortIcon
                        + ', td span.' + oSettings.oClasses.sSortIcon, oSettings.nTHead).remove();

                    $('th, td', oSettings.nTHead).each(function () {
                        var jqWrapper = $('div.' + oSettings.oClasses.sSortJUIWrapper, this);
                        var kids = jqWrapper.contents();
                        $(this).append(kids);
                        jqWrapper.remove();
                    });
                }

                /* Add the TR elements back into the table in their original order */
                if (!bRemove && oSettings.nTableReinsertBefore) {
                    nOrig.insertBefore(oSettings.nTable, oSettings.nTableReinsertBefore);
                }
                else if (!bRemove) {
                    nOrig.appendChild(oSettings.nTable);
                }

                for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                    if (oSettings.aoData[i].nTr !== null) {
                        nBody.appendChild(oSettings.aoData[i].nTr);
                    }
                }

                /* Restore the width of the original table */
                if (oSettings.oFeatures.bAutoWidth === true) {
                    oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
                }

                /* If the were originally stripe classes - then we add them back here. Note
                 * this is not fool proof (for example if not all rows had stripe classes - but
                 * it's a good effort without getting carried away
                 */
                iLen = oSettings.asDestroyStripes.length;
                if (iLen) {
                    var anRows = $(nBody).children('tr');
                    for (i = 0; i < iLen; i++) {
                        anRows.filter(':nth-child(' + iLen + 'n + ' + i + ')').addClass(oSettings.asDestroyStripes[i]);
                    }
                }

                /* Remove the settings object from the settings array */
                for (i = 0, iLen = DataTable.settings.length; i < iLen; i++) {
                    if (DataTable.settings[i] == oSettings) {
                        DataTable.settings.splice(i, 1);
                    }
                }

                /* End it all */
                oSettings = null;
                oInit = null;
            };


            /**
             * Redraw the table
             *  @param {bool} [bComplete=true] Re-filter and resort (if enabled) the table before the draw.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
             */
            this.fnDraw = function (bComplete) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                if (bComplete === false) {
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings);
                }
                else {
                    _fnReDraw(oSettings);
                }
            };


            /**
             * Filter the input based on data
             *  @param {string} sInput String to filter the table on
             *  @param {int|null} [iColumn] Column to limit filtering to
             *  @param {bool} [bRegex=false] Treat as regular expression or not
             *  @param {bool} [bSmart=true] Perform smart filtering or not
             *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
             *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
             */
            this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                if (!oSettings.oFeatures.bFilter) {
                    return;
                }

                if (bRegex === undefined || bRegex === null) {
                    bRegex = false;
                }

                if (bSmart === undefined || bSmart === null) {
                    bSmart = true;
                }

                if (bShowGlobal === undefined || bShowGlobal === null) {
                    bShowGlobal = true;
                }

                if (bCaseInsensitive === undefined || bCaseInsensitive === null) {
                    bCaseInsensitive = true;
                }

                if (iColumn === undefined || iColumn === null) {
                    /* Global filter */
                    _fnFilterComplete(oSettings, {
                        "sSearch": sInput + "",
                        "bRegex": bRegex,
                        "bSmart": bSmart,
                        "bCaseInsensitive": bCaseInsensitive
                    }, 1);

                    if (bShowGlobal && oSettings.aanFeatures.f) {
                        var n = oSettings.aanFeatures.f;
                        for (var i = 0, iLen = n.length; i < iLen; i++) {
                            // IE9 throws an 'unknown error' if document.activeElement is used
                            // inside an iframe or frame...
                            try {
                                if (n[i]._DT_Input != document.activeElement) {
                                    $(n[i]._DT_Input).val(sInput);
                                }
                            }
                            catch (e) {
                                $(n[i]._DT_Input).val(sInput);
                            }
                        }
                    }
                }
                else {
                    /* Single column filter */
                    $.extend(oSettings.aoPreSearchCols[iColumn], {
                        "sSearch": sInput + "",
                        "bRegex": bRegex,
                        "bSmart": bSmart,
                        "bCaseInsensitive": bCaseInsensitive
                    });
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1);
                }
            };


            /**
             * Get the data for the whole table, an individual row or an individual cell based on the
             * provided parameters.
             *  @param {int|node} [mRow] A TR row node, TD/TH cell node or an integer. If given as
             *    a TR node then the data source for the whole row will be returned. If given as a
             *    TD/TH cell node then iCol will be automatically calculated and the data for the
             *    cell returned. If given as an integer, then this is treated as the aoData internal
             *    data index for the row (see fnGetPosition) and the data for that row used.
             *  @param {int} [iCol] Optional column index that you want the data of.
             *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
             *    returned. If mRow is defined, just data for that row, and is iCol is
             *    defined, only data for the designated cell is returned.
             *  @dtopt API
             *
             *  @example
             *    // Row data
             *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
             *
             *  @example
             *    // Individual cell data
             *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
             */
            this.fnGetData = function (mRow, iCol) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                if (mRow !== undefined) {
                    var iRow = mRow;
                    if (typeof mRow === 'object') {
                        var sNode = mRow.nodeName.toLowerCase();
                        if (sNode === "tr") {
                            iRow = _fnNodeToDataIndex(oSettings, mRow);
                        }
                        else if (sNode === "td") {
                            iRow = _fnNodeToDataIndex(oSettings, mRow.parentNode);
                            iCol = _fnNodeToColumnIndex(oSettings, iRow, mRow);
                        }
                    }

                    if (iCol !== undefined) {
                        return _fnGetCellData(oSettings, iRow, iCol, '');
                    }
                    return (oSettings.aoData[iRow] !== undefined) ?
                        oSettings.aoData[iRow]._aData : null;
                }
                return _fnGetDataMaster(oSettings);
            };


            /**
             * Get an array of the TR nodes that are used in the table's body. Note that you will
             * typically want to use the '$' API method in preference to this as it is more
             * flexible.
             *  @param {int} [iRow] Optional row index for the TR element you want
             *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
             *    in the table's body, or iRow is defined, just the TR element requested.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
             */
            this.fnGetNodes = function (iRow) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                if (iRow !== undefined) {
                    return (oSettings.aoData[iRow] !== undefined) ?
                        oSettings.aoData[iRow].nTr : null;
                }
                return _fnGetTrNodes(oSettings);
            };


            /**
             * Get the array indexes of a particular cell from it's DOM element
             * and column index including hidden columns
             *  @param {node} nNode this can either be a TR, TD or TH in the table's body
             *  @returns {int} If nNode is given as a TR, then a single index is returned, or
             *    if given as a cell, an array of [row index, column index (visible),
             *    column index (all)] is given.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *        
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *        
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *      
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
             */
            this.fnGetPosition = function (nNode) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var sNodeName = nNode.nodeName.toUpperCase();

                if (sNodeName == "TR") {
                    return _fnNodeToDataIndex(oSettings, nNode);
                }
                else if (sNodeName == "TD" || sNodeName == "TH") {
                    var iDataIndex = _fnNodeToDataIndex(oSettings, nNode.parentNode);
                    var iColumnIndex = _fnNodeToColumnIndex(oSettings, iDataIndex, nNode);
                    return [iDataIndex, _fnColumnIndexToVisible(oSettings, iColumnIndex), iColumnIndex];
                }
                return null;
            };


            /**
             * Check to see if a row is 'open' or not.
             *  @param {node} nTr the table row to check
             *  @returns {boolean} true if the row is currently open, false otherwise
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
             */
            this.fnIsOpen = function (nTr) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var aoOpenRows = oSettings.aoOpenRows;

                for (var i = 0; i < oSettings.aoOpenRows.length; i++) {
                    if (oSettings.aoOpenRows[i].nParent == nTr) {
                        return true;
                    }
                }
                return false;
            };


            /**
             * This function will place a new row directly after a row which is currently
             * on display on the page, with the HTML contents that is passed into the
             * function. This can be used, for example, to ask for confirmation that a
             * particular record should be deleted.
             *  @param {node} nTr The table row to 'open'
             *  @param {string|node|jQuery} mHtml The HTML to put into the row
             *  @param {string} sClass Class to give the new TD cell
             *  @returns {node} The row opened. Note that if the table row passed in as the
             *    first parameter, is not found in the table, this method will silently
             *    return.
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
             */
            this.fnOpen = function (nTr, mHtml, sClass) {
                /* Find settings from table node */
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);

                /* Check that the row given is in the table */
                var nTableRows = _fnGetTrNodes(oSettings);
                if ($.inArray(nTr, nTableRows) === -1) {
                    return;
                }

                /* the old open one if there is one */
                this.fnClose(nTr);

                var nNewRow = document.createElement("tr");
                var nNewCell = document.createElement("td");
                nNewRow.appendChild(nNewCell);
                nNewCell.className = sClass;
                nNewCell.colSpan = _fnVisbleColumns(oSettings);

                if (typeof mHtml === "string") {
                    nNewCell.innerHTML = mHtml;
                }
                else {
                    $(nNewCell).html(mHtml);
                }

                /* If the nTr isn't on the page at the moment - then we don't insert at the moment */
                var nTrs = $('tr', oSettings.nTBody);
                if ($.inArray(nTr, nTrs) != -1) {
                    $(nNewRow).insertAfter(nTr);
                }

                oSettings.aoOpenRows.push({
                    "nTr": nNewRow,
                    "nParent": nTr
                });

                return nNewRow;
            };


            /**
             * Change the pagination - provides the internal logic for pagination in a simple API
             * function. With this function you can have a DataTables table go to the next,
             * previous, first or last pages.
             *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
             *    or page number to jump to (integer), note that page 0 is the first page.
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
             */
            this.fnPageChange = function (mAction, bRedraw) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                _fnPageChange(oSettings, mAction);
                _fnCalculateEnd(oSettings);

                if (bRedraw === undefined || bRedraw) {
                    _fnDraw(oSettings);
                }
            };


            /**
             * Show a particular column
             *  @param {int} iCol The column whose display should be changed
             *  @param {bool} bShow Show (true) or hide (false) the column
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
             */
            this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var i, iLen;
                var aoColumns = oSettings.aoColumns;
                var aoData = oSettings.aoData;
                var nTd, bAppend, iBefore;

                /* No point in doing anything if we are requesting what is already true */
                if (aoColumns[iCol].bVisible == bShow) {
                    return;
                }

                /* Show the column */
                if (bShow) {
                    var iInsert = 0;
                    for (i = 0; i < iCol; i++) {
                        if (aoColumns[i].bVisible) {
                            iInsert++;
                        }
                    }

                    /* Need to decide if we should use appendChild or insertBefore */
                    bAppend = (iInsert >= _fnVisbleColumns(oSettings));

                    /* Which coloumn should we be inserting before? */
                    if (!bAppend) {
                        for (i = iCol; i < aoColumns.length; i++) {
                            if (aoColumns[i].bVisible) {
                                iBefore = i;
                                break;
                            }
                        }
                    }

                    for (i = 0, iLen = aoData.length; i < iLen; i++) {
                        if (aoData[i].nTr !== null) {
                            if (bAppend) {
                                aoData[i].nTr.appendChild(
                                    aoData[i]._anHidden[iCol]
                                );
                            }
                            else {
                                aoData[i].nTr.insertBefore(
                                    aoData[i]._anHidden[iCol],
                                    _fnGetTdNodes(oSettings, i)[iBefore]);
                            }
                        }
                    }
                }
                else {
                    /* Remove a column from display */
                    for (i = 0, iLen = aoData.length; i < iLen; i++) {
                        if (aoData[i].nTr !== null) {
                            nTd = _fnGetTdNodes(oSettings, i)[iCol];
                            aoData[i]._anHidden[iCol] = nTd;
                            nTd.parentNode.removeChild(nTd);
                        }
                    }
                }

                /* Clear to set the visible flag */
                aoColumns[iCol].bVisible = bShow;

                /* Redraw the header and footer based on the new column visibility */
                _fnDrawHead(oSettings, oSettings.aoHeader);
                if (oSettings.nTFoot) {
                    _fnDrawHead(oSettings, oSettings.aoFooter);
                }

                /* If there are any 'open' rows, then we need to alter the colspan for this col change */
                for (i = 0, iLen = oSettings.aoOpenRows.length; i < iLen; i++) {
                    oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns(oSettings);
                }

                /* Do a redraw incase anything depending on the table columns needs it 
                 * (built-in: scrolling) 
                 */
                if (bRedraw === undefined || bRedraw) {
                    _fnAdjustColumnSizing(oSettings);
                    _fnDraw(oSettings);
                }

                _fnSaveState(oSettings);
            };


            /**
             * Get the settings for a particular table for external manipulation
             *  @returns {object} DataTables settings object. See
             *    {@link DataTable.models.oSettings}
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *      
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
             */
            this.fnSettings = function () {
                return _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
            };


            /**
             * Sort the table by a particular column
             *  @param {int} iCol the data index to sort on. Note that this will not match the
             *    'display index' if you have hidden data entries
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
             */
            this.fnSort = function (aaSort) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                oSettings.aaSorting = aaSort;
                _fnSort(oSettings);
            };


            /**
             * Attach a sort listener to an element for a given column
             *  @param {node} nNode the element to attach the sort listener to
             *  @param {int} iColumn the column that a click on this node will sort on
             *  @param {function} [fnCallback] callback function when sort is run
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
             */
            this.fnSortListener = function (nNode, iColumn, fnCallback) {
                _fnSortAttachListener(_fnSettingsFromNode(this[DataTable.ext.iApiIndex]), nNode, iColumn,
                    fnCallback);
            };


            /**
             * Update a table cell or row - this method will accept either a single value to
             * update the cell with, an array of values with one element for each column or
             * an object in the same format as the original data source. The function is
             * self-referencing in order to make the multi column updates easier.
             *  @param {object|array|string} mData Data to update the cell/row with
             *  @param {node|int} mRow TR element you want to update or the aoData index
             *  @param {int} [iColumn] The column to update (not used of mData is an array or object)
             *  @param {bool} [bRedraw=true] Redraw the table or not
             *  @param {bool} [bAction=true] Perform pre-draw actions or not
             *  @returns {int} 0 on success, 1 on error
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], 1, 0 ); // Row
		 *    } );
             */
            this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
                var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
                var i, iLen, sDisplay;
                var iRow = (typeof mRow === 'object') ?
                    _fnNodeToDataIndex(oSettings, mRow) : mRow;

                if ($.isArray(mData) && iColumn === undefined) {
                    /* Array update - update the whole row */
                    oSettings.aoData[iRow]._aData = mData.slice();

                    /* Flag to the function that we are recursing */
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false);
                    }
                }
                else if ($.isPlainObject(mData) && iColumn === undefined) {
                    /* Object update - update the whole row - assume the developer gets the object right */
                    oSettings.aoData[iRow]._aData = $.extend(true, {}, mData);

                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false);
                    }
                }
                else {
                    /* Individual cell update */
                    _fnSetCellData(oSettings, iRow, iColumn, mData);
                    sDisplay = _fnGetCellData(oSettings, iRow, iColumn, 'display');

                    var oCol = oSettings.aoColumns[iColumn];
                    if (oCol.fnRender !== null) {
                        sDisplay = _fnRender(oSettings, iRow, iColumn);
                        if (oCol.bUseRendered) {
                            _fnSetCellData(oSettings, iRow, iColumn, sDisplay);
                        }
                    }

                    if (oSettings.aoData[iRow].nTr !== null) {
                        /* Do the actual HTML update */
                        _fnGetTdNodes(oSettings, iRow)[iColumn].innerHTML = sDisplay;
                    }
                }

                /* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
                 * will rebuild the search array - however, the redraw might be disabled by the user)
                 */
                var iDisplayIndex = $.inArray(iRow, oSettings.aiDisplay);
                oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow(
                    oSettings,
                    _fnGetRowData(oSettings, iRow, 'filter', _fnGetColumns(oSettings, 'bSearchable'))
                );

                /* Perform pre-draw actions */
                if (bAction === undefined || bAction) {
                    _fnAdjustColumnSizing(oSettings);
                }

                /* Redraw the table */
                if (bRedraw === undefined || bRedraw) {
                    _fnReDraw(oSettings);
                }
                return 0;
            };


            /**
             * Provide a common method for plug-ins to check the version of DataTables being used, in order
             * to ensure compatibility.
             *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
             *    formats "X" and "X.Y" are also acceptable.
             *  @returns {boolean} true if this version of DataTables is greater or equal to the required
             *    version, or false if this version of DataTales is not suitable
             *  @method
             *  @dtopt API
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
             */
            this.fnVersionCheck = DataTable.ext.fnVersionCheck;


            /*
             * This is really a good bit rubbish this method of exposing the internal methods
             * publicly... - To be fixed in 2.0 using methods on the prototype
             */


            /**
             * Create a wrapper function for exporting an internal functions to an external API.
             *  @param {string} sFunc API function name
             *  @returns {function} wrapped function
             *  @memberof DataTable#oApi
             */
            function _fnExternApiFunc(sFunc) {
                return function () {
                    var aArgs = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
                        Array.prototype.slice.call(arguments));
                    return DataTable.ext.oApi[sFunc].apply(this, aArgs);
                };
            }


            /**
             * Reference to internal functions for use by plug-in developers. Note that these
             * methods are references to internal functions and are considered to be private.
             * If you use these methods, be aware that they are liable to change between versions
             * (check the upgrade notes).
             *  @namespace
             */
            this.oApi = {
                "_fnExternApiFunc": _fnExternApiFunc,
                "_fnInitialise": _fnInitialise,
                "_fnInitComplete": _fnInitComplete,
                "_fnLanguageCompat": _fnLanguageCompat,
                "_fnAddColumn": _fnAddColumn,
                "_fnColumnOptions": _fnColumnOptions,
                "_fnAddData": _fnAddData,
                "_fnCreateTr": _fnCreateTr,
                "_fnGatherData": _fnGatherData,
                "_fnBuildHead": _fnBuildHead,
                "_fnDrawHead": _fnDrawHead,
                "_fnDraw": _fnDraw,
                "_fnReDraw": _fnReDraw,
                "_fnAjaxUpdate": _fnAjaxUpdate,
                "_fnAjaxParameters": _fnAjaxParameters,
                "_fnAjaxUpdateDraw": _fnAjaxUpdateDraw,
                "_fnServerParams": _fnServerParams,
                "_fnAddOptionsHtml": _fnAddOptionsHtml,
                "_fnFeatureHtmlTable": _fnFeatureHtmlTable,
                "_fnScrollDraw": _fnScrollDraw,
                "_fnAdjustColumnSizing": _fnAdjustColumnSizing,
                "_fnFeatureHtmlFilter": _fnFeatureHtmlFilter,
                "_fnFilterComplete": _fnFilterComplete,
                "_fnFilterCustom": _fnFilterCustom,
                "_fnFilterColumn": _fnFilterColumn,
                "_fnFilter": _fnFilter,
                "_fnBuildSearchArray": _fnBuildSearchArray,
                "_fnBuildSearchRow": _fnBuildSearchRow,
                "_fnFilterCreateSearch": _fnFilterCreateSearch,
                "_fnDataToSearch": _fnDataToSearch,
                "_fnSort": _fnSort,
                "_fnSortAttachListener": _fnSortAttachListener,
                "_fnSortingClasses": _fnSortingClasses,
                "_fnFeatureHtmlPaginate": _fnFeatureHtmlPaginate,
                "_fnPageChange": _fnPageChange,
                "_fnFeatureHtmlInfo": _fnFeatureHtmlInfo,
                "_fnUpdateInfo": _fnUpdateInfo,
                "_fnFeatureHtmlLength": _fnFeatureHtmlLength,
                "_fnFeatureHtmlProcessing": _fnFeatureHtmlProcessing,
                "_fnProcessingDisplay": _fnProcessingDisplay,
                "_fnVisibleToColumnIndex": _fnVisibleToColumnIndex,
                "_fnColumnIndexToVisible": _fnColumnIndexToVisible,
                "_fnNodeToDataIndex": _fnNodeToDataIndex,
                "_fnVisbleColumns": _fnVisbleColumns,
                "_fnCalculateEnd": _fnCalculateEnd,
                "_fnConvertToWidth": _fnConvertToWidth,
                "_fnCalculateColumnWidths": _fnCalculateColumnWidths,
                "_fnScrollingWidthAdjust": _fnScrollingWidthAdjust,
                "_fnGetWidestNode": _fnGetWidestNode,
                "_fnGetMaxLenString": _fnGetMaxLenString,
                "_fnStringToCss": _fnStringToCss,
                "_fnDetectType": _fnDetectType,
                "_fnSettingsFromNode": _fnSettingsFromNode,
                "_fnGetDataMaster": _fnGetDataMaster,
                "_fnGetTrNodes": _fnGetTrNodes,
                "_fnGetTdNodes": _fnGetTdNodes,
                "_fnEscapeRegex": _fnEscapeRegex,
                "_fnDeleteIndex": _fnDeleteIndex,
                "_fnReOrderIndex": _fnReOrderIndex,
                "_fnColumnOrdering": _fnColumnOrdering,
                "_fnLog": _fnLog,
                "_fnClearTable": _fnClearTable,
                "_fnSaveState": _fnSaveState,
                "_fnLoadState": _fnLoadState,
                "_fnCreateCookie": _fnCreateCookie,
                "_fnReadCookie": _fnReadCookie,
                "_fnDetectHeader": _fnDetectHeader,
                "_fnGetUniqueThs": _fnGetUniqueThs,
                "_fnScrollBarWidth": _fnScrollBarWidth,
                "_fnApplyToChildren": _fnApplyToChildren,
                "_fnMap": _fnMap,
                "_fnGetRowData": _fnGetRowData,
                "_fnGetCellData": _fnGetCellData,
                "_fnSetCellData": _fnSetCellData,
                "_fnGetObjectDataFn": _fnGetObjectDataFn,
                "_fnSetObjectDataFn": _fnSetObjectDataFn,
                "_fnApplyColumnDefs": _fnApplyColumnDefs,
                "_fnBindAction": _fnBindAction,
                "_fnExtend": _fnExtend,
                "_fnCallbackReg": _fnCallbackReg,
                "_fnCallbackFire": _fnCallbackFire,
                "_fnJsonString": _fnJsonString,
                "_fnRender": _fnRender,
                "_fnNodeToColumnIndex": _fnNodeToColumnIndex,
                "_fnInfoMacros": _fnInfoMacros,
                "_fnBrowserDetect": _fnBrowserDetect,
                "_fnGetColumns": _fnGetColumns
            };

            $.extend(DataTable.ext.oApi, this.oApi);

            for (var sFunc in DataTable.ext.oApi) {
                if (sFunc) {
                    this[sFunc] = _fnExternApiFunc(sFunc);
                }
            }


            var _that = this;
            this.each(function () {
                var i = 0, iLen, j, jLen, k, kLen;
                var sId = this.getAttribute('id');
                var bInitHandedOff = false;
                var bUsePassedData = false;


                /* Sanity check */
                if (this.nodeName.toLowerCase() != 'table') {
                    _fnLog(null, 0, "Attempted to initialise DataTables on a node which is not a " +
                        "table: " + this.nodeName);
                    return;
                }

                /* Check to see if we are re-initialising a table */
                for (i = 0, iLen = DataTable.settings.length; i < iLen; i++) {
                    /* Base check on table node */
                    if (DataTable.settings[i].nTable == this) {
                        if (oInit === undefined || oInit.bRetrieve) {
                            return DataTable.settings[i].oInstance;
                        }
                        else if (oInit.bDestroy) {
                            DataTable.settings[i].oInstance.fnDestroy();
                            break;
                        }
                        else {
                            _fnLog(DataTable.settings[i], 0, "Cannot reinitialise DataTable.\n\n" +
                                "To retrieve the DataTables object for this table, pass no arguments or see " +
                                "the docs for bRetrieve and bDestroy");
                            return;
                        }
                    }

                    /* If the element we are initialising has the same ID as a table which was previously
                     * initialised, but the table nodes don't match (from before) then we destroy the old
                     * instance by simply deleting it. This is under the assumption that the table has been
                     * destroyed by other methods. Anyone using non-id selectors will need to do this manually
                     */
                    if (DataTable.settings[i].sTableId == this.id) {
                        DataTable.settings.splice(i, 1);
                        break;
                    }
                }

                /* Ensure the table has an ID - required for accessibility */
                if (sId === null || sId === "") {
                    sId = "DataTables_Table_" + (DataTable.ext._oExternConfig.iNextUnique++);
                    this.id = sId;
                }

                /* Create the settings object for this table and set some of the default parameters */
                var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
                    "nTable": this,
                    "oApi": _that.oApi,
                    "oInit": oInit,
                    "sDestroyWidth": $(this).width(),
                    "sInstance": sId,
                    "sTableId": sId
                });
                DataTable.settings.push(oSettings);

                // Need to add the instance after the instance after the settings object has been added
                // to the settings array, so we can self reference the table instance if more than one
                oSettings.oInstance = (_that.length === 1) ? _that : $(this).dataTable();

                /* Setting up the initialisation object */
                if (!oInit) {
                    oInit = {};
                }

                // Backwards compatibility, before we apply all the defaults
                if (oInit.oLanguage) {
                    _fnLanguageCompat(oInit.oLanguage);
                }

                oInit = _fnExtend($.extend(true, {}, DataTable.defaults), oInit);

                // Map the initialisation options onto the settings object
                _fnMap(oSettings.oFeatures, oInit, "bPaginate");
                _fnMap(oSettings.oFeatures, oInit, "bLengthChange");
                _fnMap(oSettings.oFeatures, oInit, "bFilter");
                _fnMap(oSettings.oFeatures, oInit, "bSort");
                _fnMap(oSettings.oFeatures, oInit, "bInfo");
                _fnMap(oSettings.oFeatures, oInit, "bProcessing");
                _fnMap(oSettings.oFeatures, oInit, "bAutoWidth");
                _fnMap(oSettings.oFeatures, oInit, "bSortClasses");
                _fnMap(oSettings.oFeatures, oInit, "bServerSide");
                _fnMap(oSettings.oFeatures, oInit, "bDeferRender");
                _fnMap(oSettings.oScroll, oInit, "sScrollX", "sX");
                _fnMap(oSettings.oScroll, oInit, "sScrollXInner", "sXInner");
                _fnMap(oSettings.oScroll, oInit, "sScrollY", "sY");
                _fnMap(oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse");
                _fnMap(oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite");
                _fnMap(oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap");
                _fnMap(oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss");
                _fnMap(oSettings, oInit, "asStripeClasses");
                _fnMap(oSettings, oInit, "asStripClasses", "asStripeClasses"); // legacy
                _fnMap(oSettings, oInit, "fnServerData");
                _fnMap(oSettings, oInit, "fnFormatNumber");
                _fnMap(oSettings, oInit, "sServerMethod");
                _fnMap(oSettings, oInit, "aaSorting");
                _fnMap(oSettings, oInit, "aaSortingFixed");
                _fnMap(oSettings, oInit, "aLengthMenu");
                _fnMap(oSettings, oInit, "sPaginationType");
                _fnMap(oSettings, oInit, "sAjaxSource");
                _fnMap(oSettings, oInit, "sAjaxDataProp");
                _fnMap(oSettings, oInit, "iCookieDuration");
                _fnMap(oSettings, oInit, "sCookiePrefix");
                _fnMap(oSettings, oInit, "sDom");
                _fnMap(oSettings, oInit, "bSortCellsTop");
                _fnMap(oSettings, oInit, "iTabIndex");
                _fnMap(oSettings, oInit, "oSearch", "oPreviousSearch");
                _fnMap(oSettings, oInit, "aoSearchCols", "aoPreSearchCols");
                _fnMap(oSettings, oInit, "iDisplayLength", "_iDisplayLength");
                _fnMap(oSettings, oInit, "bJQueryUI", "bJUI");
                _fnMap(oSettings, oInit, "fnCookieCallback");
                _fnMap(oSettings, oInit, "fnStateLoad");
                _fnMap(oSettings, oInit, "fnStateSave");
                _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

                /* Callback functions which are array driven */
                _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
                _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
                _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
                _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
                _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
                _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
                _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
                _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
                _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

                if (oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
                    oSettings.oFeatures.bSortClasses) {
                    /* Enable sort classes for server-side processing. Safe to do it here, since server-side
                     * processing must be enabled by the developer
                     */
                    _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSortingClasses, 'server_side_sort_classes');
                }
                else if (oSettings.oFeatures.bDeferRender) {
                    _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSortingClasses, 'defer_sort_classes');
                }

                if (oInit.bJQueryUI) {
                    /* Use the JUI classes object for display. You could clone the oStdClasses object if 
                     * you want to have multiple tables with multiple independent classes 
                     */
                    $.extend(oSettings.oClasses, DataTable.ext.oJUIClasses);

                    if (oInit.sDom === DataTable.defaults.sDom && DataTable.defaults.sDom === "lfrtip") {
                        /* Set the DOM to use a layout suitable for jQuery UI's theming */
                        oSettings.sDom = '<"H"lfr>t<"F"ip>';
                    }
                }
                else {
                    $.extend(oSettings.oClasses, DataTable.ext.oStdClasses);
                }
                $(this).addClass(oSettings.oClasses.sTable);

                /* Calculate the scroll bar width and cache it for use later on */
                if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
                    oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
                }

                if (oSettings.iInitDisplayStart === undefined) {
                    /* Display start point, taking into account the save saving */
                    oSettings.iInitDisplayStart = oInit.iDisplayStart;
                    oSettings._iDisplayStart = oInit.iDisplayStart;
                }

                /* Must be done after everything which can be overridden by a cookie! */
                if (oInit.bStateSave) {
                    oSettings.oFeatures.bStateSave = true;
                    _fnLoadState(oSettings, oInit);
                    _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
                }

                if (oInit.iDeferLoading !== null) {
                    oSettings.bDeferLoading = true;
                    var tmp = $.isArray(oInit.iDeferLoading);
                    oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
                    oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
                }

                if (oInit.aaData !== null) {
                    bUsePassedData = true;
                }

                /* Language definitions */
                if (oInit.oLanguage.sUrl !== "") {
                    /* Get the language definitions from a file - because this Ajax call makes the language
                     * get async to the remainder of this function we use bInitHandedOff to indicate that 
                     * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
                     */
                    oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
                    $.getJSON(oSettings.oLanguage.sUrl, null, function (json) {
                        _fnLanguageCompat(json);
                        $.extend(true, oSettings.oLanguage, oInit.oLanguage, json);
                        _fnInitialise(oSettings);
                    });
                    bInitHandedOff = true;
                }
                else {
                    $.extend(true, oSettings.oLanguage, oInit.oLanguage);
                }


                /*
                 * Stripes
                 */
                if (oInit.asStripeClasses === null) {
                    oSettings.asStripeClasses = [
                        oSettings.oClasses.sStripeOdd,
                        oSettings.oClasses.sStripeEven
                    ];
                }

                /* Remove row stripe classes if they are already on the table row */
                iLen = oSettings.asStripeClasses.length;
                oSettings.asDestroyStripes = [];
                if (iLen) {
                    var bStripeRemove = false;
                    var anRows = $(this).children('tbody').children('tr:lt(' + iLen + ')');
                    for (i = 0; i < iLen; i++) {
                        if (anRows.hasClass(oSettings.asStripeClasses[i])) {
                            bStripeRemove = true;

                            /* Store the classes which we are about to remove so they can be re-added on destroy */
                            oSettings.asDestroyStripes.push(oSettings.asStripeClasses[i]);
                        }
                    }

                    if (bStripeRemove) {
                        anRows.removeClass(oSettings.asStripeClasses.join(' '));
                    }
                }

                /*
                 * Columns
                 * See if we should load columns automatically or use defined ones
                 */
                var anThs = [];
                var aoColumnsInit;
                var nThead = this.getElementsByTagName('thead');
                if (nThead.length !== 0) {
                    _fnDetectHeader(oSettings.aoHeader, nThead[0]);
                    anThs = _fnGetUniqueThs(oSettings);
                }

                /* If not given a column array, generate one with nulls */
                if (oInit.aoColumns === null) {
                    aoColumnsInit = [];
                    for (i = 0, iLen = anThs.length; i < iLen; i++) {
                        aoColumnsInit.push(null);
                    }
                }
                else {
                    aoColumnsInit = oInit.aoColumns;
                }

                /* Add the columns */
                for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
                    /* Short cut - use the loop to check if we have column visibility state to restore */
                    if (oInit.saved_aoColumns !== undefined && oInit.saved_aoColumns.length == iLen) {
                        if (aoColumnsInit[i] === null) {
                            aoColumnsInit[i] = {};
                        }
                        aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
                    }

                    _fnAddColumn(oSettings, anThs ? anThs[i] : null);
                }

                /* Apply the column definitions */
                _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
                    _fnColumnOptions(oSettings, iCol, oDef);
                });


                /*
                 * Sorting
                 * Check the aaSorting array
                 */
                for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {
                    if (oSettings.aaSorting[i][0] >= oSettings.aoColumns.length) {
                        oSettings.aaSorting[i][0] = 0;
                    }
                    var oColumn = oSettings.aoColumns[oSettings.aaSorting[i][0]];

                    /* Add a default sorting index */
                    if (oSettings.aaSorting[i][2] === undefined) {
                        oSettings.aaSorting[i][2] = 0;
                    }

                    /* If aaSorting is not defined, then we use the first indicator in asSorting */
                    if (oInit.aaSorting === undefined && oSettings.saved_aaSorting === undefined) {
                        oSettings.aaSorting[i][1] = oColumn.asSorting[0];
                    }

                    /* Set the current sorting index based on aoColumns.asSorting */
                    for (j = 0, jLen = oColumn.asSorting.length; j < jLen; j++) {
                        if (oSettings.aaSorting[i][1] == oColumn.asSorting[j]) {
                            oSettings.aaSorting[i][2] = j;
                            break;
                        }
                    }
                }

                /* Do a first pass on the sorting classes (allows any size changes to be taken into
                 * account, and also will apply sorting disabled classes if disabled
                 */
                _fnSortingClasses(oSettings);


                /*
                 * Final init
                 * Cache the header, body and footer as required, creating them if needed
                 */

                /* Browser support detection */
                _fnBrowserDetect(oSettings);

                // Work around for Webkit bug 83867 - store the caption-side before removing from doc
                var captions = $(this).children('caption').each(function () {
                    this._captionSide = $(this).css('caption-side');
                });

                var thead = $(this).children('thead');
                if (thead.length === 0) {
                    thead = [document.createElement('thead')];
                    this.appendChild(thead[0]);
                }
                oSettings.nTHead = thead[0];

                var tbody = $(this).children('tbody');
                if (tbody.length === 0) {
                    tbody = [document.createElement('tbody')];
                    this.appendChild(tbody[0]);
                }
                oSettings.nTBody = tbody[0];
                oSettings.nTBody.setAttribute("role", "alert");
                oSettings.nTBody.setAttribute("aria-live", "polite");
                oSettings.nTBody.setAttribute("aria-relevant", "all");

                var tfoot = $(this).children('tfoot');
                if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
                    // If we are a scrolling table, and no footer has been given, then we need to create
                    // a tfoot element for the caption element to be appended to
                    tfoot = [document.createElement('tfoot')];
                    this.appendChild(tfoot[0]);
                }

                if (tfoot.length > 0) {
                    oSettings.nTFoot = tfoot[0];
                    _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
                }

                /* Check if there is data passing into the constructor */
                if (bUsePassedData) {
                    for (i = 0; i < oInit.aaData.length; i++) {
                        _fnAddData(oSettings, oInit.aaData[i]);
                    }
                }
                else {
                    /* Grab the data from the page */
                    _fnGatherData(oSettings);
                }

                /* Copy the data index array */
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

                /* Initialisation complete - table can be drawn */
                oSettings.bInitialised = true;

                /* Check if we need to initialise the table (it might not have been handed off to the
                 * language processor)
                 */
                if (bInitHandedOff === false) {
                    _fnInitialise(oSettings);
                }
            });
            _that = null;
            return this;
        };


        /**
         * Provide a common method for plug-ins to check the version of DataTables being used, in order
         * to ensure compatibility.
         *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
         *    formats "X" and "X.Y" are also acceptable.
         *  @returns {boolean} true if this version of DataTables is greater or equal to the required
         *    version, or false if this version of DataTales is not suitable
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    alert( $.fn.dataTable.fnVersionCheck( '1.9.0' ) );
         */
        DataTable.fnVersionCheck = function (sVersion) {
            /* This is cheap, but effective */
            var fnZPad = function (Zpad, count) {
                while (Zpad.length < count) {
                    Zpad += '0';
                }
                return Zpad;
            };
            var aThis = DataTable.ext.sVersion.split('.');
            var aThat = sVersion.split('.');
            var sThis = '', sThat = '';

            for (var i = 0, iLen = aThat.length; i < iLen; i++) {
                sThis += fnZPad(aThis[i], 3);
                sThat += fnZPad(aThat[i], 3);
            }

            return parseInt(sThis, 10) >= parseInt(sThat, 10);
        };


        /**
         * Check if a TABLE node is a DataTable table already or not.
         *  @param {node} nTable The TABLE node to check if it is a DataTable or not (note that other
         *    node types can be passed in, but will always return false).
         *  @returns {boolean} true the table given is a DataTable, or false otherwise
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    var ex = document.getElementById('example');
         *    if ( ! $.fn.DataTable.fnIsDataTable( ex ) ) {
	 *      $(ex).dataTable();
	 *    }
         */
        DataTable.fnIsDataTable = function (nTable) {
            var o = DataTable.settings;

            for (var i = 0; i < o.length; i++) {
                if (o[i].nTable === nTable || o[i].nScrollHead === nTable || o[i].nScrollFoot === nTable) {
                    return true;
                }
            }

            return false;
        };


        /**
         * Get all DataTable tables that have been initialised - optionally you can select to
         * get only currently visible tables.
         *  @param {boolean} [bVisible=false] Flag to indicate if you want all (default) or
         *    visible tables only.
         *  @returns {array} Array of TABLE nodes (not DataTable instances) which are DataTables
         *  @static
         *  @dtopt API-Static
         *
         *  @example
         *    var table = $.fn.dataTable.fnTables(true);
         *    if ( table.length > 0 ) {
	 *      $(table).dataTable().fnAdjustColumnSizing();
	 *    }
         */
        DataTable.fnTables = function (bVisible) {
            var out = [];

            jQuery.each(DataTable.settings, function (i, o) {
                if (!bVisible || (bVisible === true && $(o.nTable).is(':visible'))) {
                    out.push(o.nTable);
                }
            });

            return out;
        };


        /**
         * Version string for plug-ins to check compatibility. Allowed format is
         * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
         * e are optional
         *  @member
         *  @type string
         *  @default Version number
         */
        DataTable.version = "1.9.4";

        /**
         * Private data store, containing all of the settings objects that are created for the
         * tables on a given page.
         *
         * Note that the <i>DataTable.settings</i> object is aliased to <i>jQuery.fn.dataTableExt</i>
         * through which it may be accessed and manipulated, or <i>jQuery.fn.dataTable.settings</i>.
         *  @member
         *  @type array
         *  @default []
         *  @private
         */
        DataTable.settings = [];

        /**
         * Object models container, for the various models that DataTables has available
         * to it. These models define the objects that are used to hold the active state
         * and configuration of the table.
         *  @namespace
         */
        DataTable.models = {};


        /**
         * DataTables extension options and plug-ins. This namespace acts as a collection "area"
         * for plug-ins that can be used to extend the default DataTables behaviour - indeed many
         * of the build in methods use this method to provide their own capabilities (sorting methods
         * for example).
         *
         * Note that this namespace is aliased to jQuery.fn.dataTableExt so it can be readily accessed
         * and modified by plug-ins.
         *  @namespace
         */
        DataTable.models.ext = {
            /**
             * Plug-in filtering functions - this method of filtering is complimentary to the default
             * type based filtering, and a lot more comprehensive as it allows you complete control
             * over the filtering logic. Each element in this array is a function (parameters
             * described below) that is called for every row in the table, and your logic decides if
             * it should be included in the filtered data set or not.
             *   <ul>
             *     <li>
             *       Function input parameters:
             *       <ul>
             *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
             *         <li>{array|object} Data for the row to be processed (same as the original format
             *           that was passed in as the data source, or an array from a DOM data source</li>
             *         <li>{int} Row index in aoData ({@link DataTable.models.oSettings.aoData}), which can
             *           be useful to retrieve the TR element if you need DOM interaction.</li>
             *       </ul>
             *     </li>
             *     <li>
             *       Function return:
             *       <ul>
             *         <li>{boolean} Include the row in the filtered result set (true) or not (false)</li>
             *       </ul>
             *     </il>
             *   </ul>
             *  @type array
             *  @default []
             *
             *  @example
             *    // The following example shows custom filtering being applied to the fourth column (i.e.
             *    // the aData[3] index) based on two input values from the end-user, matching the data in
             *    // a certain range.
             *    $.fn.dataTableExt.afnFiltering.push(
             *      function( oSettings, aData, iDataIndex ) {
		 *        var iMin = document.getElementById('min').value * 1;
		 *        var iMax = document.getElementById('max').value * 1;
		 *        var iVersion = aData[3] == "-" ? 0 : aData[3]*1;
		 *        if ( iMin == "" && iMax == "" ) {
		 *          return true;
		 *        }
		 *        else if ( iMin == "" && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && "" == iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
             *    );
             */
            "afnFiltering": [],


            /**
             * Plug-in sorting functions - this method of sorting is complimentary to the default type
             * based sorting that DataTables does automatically, allowing much greater control over the
             * the data that is being used to sort a column. This is useful if you want to do sorting
             * based on live data (for example the contents of an 'input' element) rather than just the
             * static string that DataTables knows of. The way these plug-ins work is that you create
             * an array of the values you wish to be sorted for the column in question and then return
             * that array. Which pre-sorting function is run here depends on the sSortDataType parameter
             * that is used for the column (if any). This is the corollary of <i>ofnSearch</i> for sort
             * data.
             *   <ul>
             *     <li>
             *       Function input parameters:
             *       <ul>
             *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
             *         <li>{int} Target column index</li>
             *       </ul>
             *     </li>
             *     <li>
             *       Function return:
             *       <ul>
             *         <li>{array} Data for the column to be sorted upon</li>
             *       </ul>
             *     </il>
             *   </ul>
             *
             * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
             * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
             * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
             * prepare the data as required for the different types. As such, this method is deprecated.
             *  @type array
             *  @default []
             *  @deprecated
             *
             *  @example
             *    // Updating the cached sorting information with user entered values in HTML input elements
             *    jQuery.fn.dataTableExt.afnSortData['dom-text'] = function ( oSettings, iColumn )
             *    {
		 *      var aData = [];
		 *      $( 'td:eq('+iColumn+') input', oSettings.oApi._fnGetTrNodes(oSettings) ).each( function () {
		 *        aData.push( this.value );
		 *      } );
		 *      return aData;
		 *    }
             */
            "afnSortData": [],


            /**
             * Feature plug-ins - This is an array of objects which describe the feature plug-ins that are
             * available to DataTables. These feature plug-ins are accessible through the sDom initialisation
             * option. As such, each feature plug-in must describe a function that is used to initialise
             * itself (fnInit), a character so the feature can be enabled by sDom (cFeature) and the name
             * of the feature (sFeature). Thus the objects attached to this method must provide:
             *   <ul>
             *     <li>{function} fnInit Initialisation of the plug-in
             *       <ul>
             *         <li>
             *           Function input parameters:
             *           <ul>
             *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
             *           </ul>
             *         </li>
             *         <li>
             *           Function return:
             *           <ul>
             *             <li>{node|null} The element which contains your feature. Note that the return
             *                may also be void if your plug-in does not require to inject any DOM elements
             *                into DataTables control (sDom) - for example this might be useful when
             *                developing a plug-in which allows table control via keyboard entry.</li>
             *           </ul>
             *         </il>
             *       </ul>
             *     </li>
             *     <li>{character} cFeature Character that will be matched in sDom - case sensitive</li>
             *     <li>{string} sFeature Feature name</li>
             *   </ul>
             *  @type array
             *  @default []
             *
             *  @example
             *    // How TableTools initialises itself.
             *    $.fn.dataTableExt.aoFeatures.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T",
		 *      "sFeature": "TableTools"
		 *    } );
             */
            "aoFeatures": [],


            /**
             * Type detection plug-in functions - DataTables utilises types to define how sorting and
             * filtering behave, and types can be either  be defined by the developer (sType for the
             * column) or they can be automatically detected by the methods in this array. The functions
             * defined in the array are quite simple, taking a single parameter (the data to analyse)
             * and returning the type if it is a known type, or null otherwise.
             *   <ul>
             *     <li>
             *       Function input parameters:
             *       <ul>
             *         <li>{*} Data from the column cell to be analysed</li>
             *       </ul>
             *     </li>
             *     <li>
             *       Function return:
             *       <ul>
             *         <li>{string|null} Data type detected, or null if unknown (and thus pass it
             *           on to the other type detection functions.</li>
             *       </ul>
             *     </il>
             *   </ul>
             *  @type array
             *  @default []
             *
             *  @example
             *    // Currency type detection plug-in:
             *    jQuery.fn.dataTableExt.aTypes.push(
             *      function ( sData ) {
		 *        var sValidChars = "0123456789.-";
		 *        var Char;
		 *        
		 *        // Check the numeric part
		 *        for ( i=1 ; i<sData.length ; i++ ) {
		 *          Char = sData.charAt(i); 
		 *          if (sValidChars.indexOf(Char) == -1) {
		 *            return null;
		 *          }
		 *        }
		 *        
		 *        // Check prefixed by currency
		 *        if ( sData.charAt(0) == '$' || sData.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
             *    );
             */
            "aTypes": [],


            /**
             * Provide a common method for plug-ins to check the version of DataTables being used,
             * in order to ensure compatibility.
             *  @type function
             *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note
             *    that the formats "X" and "X.Y" are also acceptable.
             *  @returns {boolean} true if this version of DataTables is greater or equal to the
             *    required version, or false if this version of DataTales is not suitable
             *
             *  @example
             *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
             */
            "fnVersionCheck": DataTable.fnVersionCheck,


            /**
             * Index for what 'this' index API functions should use
             *  @type int
             *  @default 0
             */
            "iApiIndex": 0,


            /**
             * Pre-processing of filtering data plug-ins - When you assign the sType for a column
             * (or have it automatically detected for you by DataTables or a type detection plug-in),
             * you will typically be using this for custom sorting, but it can also be used to provide
             * custom filtering by allowing you to pre-processing the data and returning the data in
             * the format that should be filtered upon. This is done by adding functions this object
             * with a parameter name which matches the sType for that target column. This is the
             * corollary of <i>afnSortData</i> for filtering data.
             *   <ul>
             *     <li>
             *       Function input parameters:
             *       <ul>
             *         <li>{*} Data from the column cell to be prepared for filtering</li>
             *       </ul>
             *     </li>
             *     <li>
             *       Function return:
             *       <ul>
             *         <li>{string|null} Formatted string that will be used for the filtering.</li>
             *       </ul>
             *     </il>
             *   </ul>
             *
             * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
             * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
             * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
             * prepare the data as required for the different types. As such, this method is deprecated.
             *  @type object
             *  @default {}
             *  @deprecated
             *
             *  @example
             *    $.fn.dataTableExt.ofnSearch['title-numeric'] = function ( sData ) {
		 *      return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
             */
            "ofnSearch": {},


            /**
             * Container for all private functions in DataTables so they can be exposed externally
             *  @type object
             *  @default {}
             */
            "oApi": {},


            /**
             * Storage for the various classes that DataTables uses
             *  @type object
             *  @default {}
             */
            "oStdClasses": {},


            /**
             * Storage for the various classes that DataTables uses - jQuery UI suitable
             *  @type object
             *  @default {}
             */
            "oJUIClasses": {},


            /**
             * Pagination plug-in methods - The style and controls of the pagination can significantly
             * impact on how the end user interacts with the data in your table, and DataTables allows
             * the addition of pagination controls by extending this object, which can then be enabled
             * through the <i>sPaginationType</i> initialisation parameter. Each pagination type that
             * is added is an object (the property name of which is what <i>sPaginationType</i> refers
             * to) that has two properties, both methods that are used by DataTables to update the
             * control's state.
             *   <ul>
             *     <li>
             *       fnInit -  Initialisation of the paging controls. Called only during initialisation
             *         of the table. It is expected that this function will add the required DOM elements
             *         to the page for the paging controls to work. The element pointer
             *         'oSettings.aanFeatures.p' array is provided by DataTables to contain the paging
             *         controls (note that this is a 2D array to allow for multiple instances of each
             *         DataTables DOM element). It is suggested that you add the controls to this element
             *         as children
             *       <ul>
             *         <li>
             *           Function input parameters:
             *           <ul>
             *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
             *             <li>{node} Container into which the pagination controls must be inserted</li>
             *             <li>{function} Draw callback function - whenever the controls cause a page
             *               change, this method must be called to redraw the table.</li>
             *           </ul>
             *         </li>
             *         <li>
             *           Function return:
             *           <ul>
             *             <li>No return required</li>
             *           </ul>
             *         </il>
             *       </ul>
             *     </il>
             *     <li>
             *       fnInit -  This function is called whenever the paging status of the table changes and is
             *         typically used to update classes and/or text of the paging controls to reflex the new
             *         status.
             *       <ul>
             *         <li>
             *           Function input parameters:
             *           <ul>
             *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
             *             <li>{function} Draw callback function - in case you need to redraw the table again
             *               or attach new event listeners</li>
             *           </ul>
             *         </li>
             *         <li>
             *           Function return:
             *           <ul>
             *             <li>No return required</li>
             *           </ul>
             *         </il>
             *       </ul>
             *     </il>
             *   </ul>
             *  @type object
             *  @default {}
             *
             *  @example
             *    $.fn.dataTableExt.oPagination.four_button = {
		 *      "fnInit": function ( oSettings, nPaging, fnCallbackDraw ) {
		 *        nFirst = document.createElement( 'span' );
		 *        nPrevious = document.createElement( 'span' );
		 *        nNext = document.createElement( 'span' );
		 *        nLast = document.createElement( 'span' );
		 *        
		 *        nFirst.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sFirst ) );
		 *        nPrevious.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sPrevious ) );
		 *        nNext.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sNext ) );
		 *        nLast.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sLast ) );
		 *        
		 *        nFirst.className = "paginate_button first";
		 *        nPrevious.className = "paginate_button previous";
		 *        nNext.className="paginate_button next";
		 *        nLast.className = "paginate_button last";
		 *        
		 *        nPaging.appendChild( nFirst );
		 *        nPaging.appendChild( nPrevious );
		 *        nPaging.appendChild( nNext );
		 *        nPaging.appendChild( nLast );
		 *        
		 *        $(nFirst).click( function () {
		 *          oSettings.oApi._fnPageChange( oSettings, "first" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nPrevious).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "previous" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nNext).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "next" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nLast).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "last" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nFirst).bind( 'selectstart', function () { return false; } );
		 *        $(nPrevious).bind( 'selectstart', function () { return false; } );
		 *        $(nNext).bind( 'selectstart', function () { return false; } );
		 *        $(nLast).bind( 'selectstart', function () { return false; } );
		 *      },
		 *      
		 *      "fnUpdate": function ( oSettings, fnCallbackDraw ) {
		 *        if ( !oSettings.aanFeatures.p ) {
		 *          return;
		 *        }
		 *        
		 *        // Loop over each instance of the pager
		 *        var an = oSettings.aanFeatures.p;
		 *        for ( var i=0, iLen=an.length ; i<iLen ; i++ ) {
		 *          var buttons = an[i].getElementsByTagName('span');
		 *          if ( oSettings._iDisplayStart === 0 ) {
		 *            buttons[0].className = "paginate_disabled_previous";
		 *            buttons[1].className = "paginate_disabled_previous";
		 *          }
		 *          else {
		 *            buttons[0].className = "paginate_enabled_previous";
		 *            buttons[1].className = "paginate_enabled_previous";
		 *          }
		 *          
		 *          if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) {
		 *            buttons[2].className = "paginate_disabled_next";
		 *            buttons[3].className = "paginate_disabled_next";
		 *          }
		 *          else {
		 *            buttons[2].className = "paginate_enabled_next";
		 *            buttons[3].className = "paginate_enabled_next";
		 *          }
		 *        }
		 *      }
		 *    };
             */
            "oPagination": {},


            /**
             * Sorting plug-in methods - Sorting in DataTables is based on the detected type of the
             * data column (you can add your own type detection functions, or override automatic
             * detection using sType). With this specific type given to the column, DataTables will
             * apply the required sort from the functions in the object. Each sort type must provide
             * two mandatory methods, one each for ascending and descending sorting, and can optionally
             * provide a pre-formatting method that will help speed up sorting by allowing DataTables
             * to pre-format the sort data only once (rather than every time the actual sort functions
             * are run). The two sorting functions are typical Javascript sort methods:
             *   <ul>
             *     <li>
             *       Function input parameters:
             *       <ul>
             *         <li>{*} Data to compare to the second parameter</li>
             *         <li>{*} Data to compare to the first parameter</li>
             *       </ul>
             *     </li>
             *     <li>
             *       Function return:
             *       <ul>
             *         <li>{int} Sorting match: <0 if first parameter should be sorted lower than
             *           the second parameter, ===0 if the two parameters are equal and >0 if
             *           the first parameter should be sorted height than the second parameter.</li>
             *       </ul>
             *     </il>
             *   </ul>
             *  @type object
             *  @default {}
             *
             *  @example
             *    // Case-sensitive string sorting, with no pre-formatting method
             *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
             *
             *  @example
             *    // Case-insensitive string sorting, with pre-formatting
             *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-pre": function(x) {
		 *        return x.toLowerCase();
		 *      },
		 *      "string-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
             */
            "oSort": {},


            /**
             * Version string for plug-ins to check compatibility. Allowed format is
             * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
             * e are optional
             *  @type string
             *  @default Version number
             */
            "sVersion": DataTable.version,


            /**
             * How should DataTables report an error. Can take the value 'alert' or 'throw'
             *  @type string
             *  @default alert
             */
            "sErrMode": "alert",


            /**
             * Store information for DataTables to access globally about other instances
             *  @namespace
             *  @private
             */
            "_oExternConfig": {
                /* int:iNextUnique - next unique number for an instance */
                "iNextUnique": 0
            }
        };


        /**
         * Template object for the way in which DataTables holds information about
         * search information for the global filter and individual column filters.
         *  @namespace
         */
        DataTable.models.oSearch = {
            /**
             * Flag to indicate if the filtering should be case insensitive or not
             *  @type boolean
             *  @default true
             */
            "bCaseInsensitive": true,

            /**
             * Applied search term
             *  @type string
             *  @default <i>Empty string</i>
             */
            "sSearch": "",

            /**
             * Flag to indicate if the search term should be interpreted as a
             * regular expression (true) or not (false) and therefore and special
             * regex characters escaped.
             *  @type boolean
             *  @default false
             */
            "bRegex": false,

            /**
             * Flag to indicate if DataTables is to use its smart filtering or not.
             *  @type boolean
             *  @default true
             */
            "bSmart": true
        };


        /**
         * Template object for the way in which DataTables holds information about
         * each individual row. This is the object format used for the settings
         * aoData array.
         *  @namespace
         */
        DataTable.models.oRow = {
            /**
             * TR element for the row
             *  @type node
             *  @default null
             */
            "nTr": null,

            /**
             * Data object from the original data source for the row. This is either
             * an array if using the traditional form of DataTables, or an object if
             * using mData options. The exact type will depend on the passed in
             * data from the data source, or will be an array if using DOM a data
             * source.
             *  @type array|object
             *  @default []
             */
            "_aData": [],

            /**
             * Sorting data cache - this array is ostensibly the same length as the
             * number of columns (although each index is generated only as it is
             * needed), and holds the data that is used for sorting each column in the
             * row. We do this cache generation at the start of the sort in order that
             * the formatting of the sort data need be done only once for each cell
             * per sort. This array should not be read from or written to by anything
             * other than the master sorting methods.
             *  @type array
             *  @default []
             *  @private
             */
            "_aSortData": [],

            /**
             * Array of TD elements that are cached for hidden rows, so they can be
             * reinserted into the table if a column is made visible again (or to act
             * as a store if a column is made hidden). Only hidden columns have a
             * reference in the array. For non-hidden columns the value is either
             * undefined or null.
             *  @type array nodes
             *  @default []
             *  @private
             */
            "_anHidden": [],

            /**
             * Cache of the class name that DataTables has applied to the row, so we
             * can quickly look at this variable rather than needing to do a DOM check
             * on className for the nTr property.
             *  @type string
             *  @default <i>Empty string</i>
             *  @private
             */
            "_sRowStripe": ""
        };


        /**
         * Template object for the column information object in DataTables. This object
         * is held in the settings aoColumns array and contains all the information that
         * DataTables needs about each individual column.
         *
         * Note that this object is related to {@link DataTable.defaults.columns}
         * but this one is the internal data store for DataTables's cache of columns.
         * It should NOT be manipulated outside of DataTables. Any configuration should
         * be done through the initialisation options.
         *  @namespace
         */
        DataTable.models.oColumn = {
            /**
             * A list of the columns that sorting should occur on when this column
             * is sorted. That this property is an array allows multi-column sorting
             * to be defined for a column (for example first name / last name columns
             * would benefit from this). The values are integers pointing to the
             * columns to be sorted on (typically it will be a single integer pointing
             * at itself, but that doesn't need to be the case).
             *  @type array
             */
            "aDataSort": null,

            /**
             * Define the sorting directions that are applied to the column, in sequence
             * as the column is repeatedly sorted upon - i.e. the first value is used
             * as the sorting direction when the column if first sorted (clicked on).
             * Sort it again (click again) and it will move on to the next index.
             * Repeat until loop.
             *  @type array
             */
            "asSorting": null,

            /**
             * Flag to indicate if the column is searchable, and thus should be included
             * in the filtering or not.
             *  @type boolean
             */
            "bSearchable": null,

            /**
             * Flag to indicate if the column is sortable or not.
             *  @type boolean
             */
            "bSortable": null,

            /**
             * <code>Deprecated</code> When using fnRender, you have two options for what
             * to do with the data, and this property serves as the switch. Firstly, you
             * can have the sorting and filtering use the rendered value (true - default),
             * or you can have the sorting and filtering us the original value (false).
             *
             * Please note that this option has now been deprecated and will be removed
             * in the next version of DataTables. Please use mRender / mData rather than
             * fnRender.
             *  @type boolean
             *  @deprecated
             */
            "bUseRendered": null,

            /**
             * Flag to indicate if the column is currently visible in the table or not
             *  @type boolean
             */
            "bVisible": null,

            /**
             * Flag to indicate to the type detection method if the automatic type
             * detection should be used, or if a column type (sType) has been specified
             *  @type boolean
             *  @default true
             *  @private
             */
            "_bAutoType": true,

            /**
             * Developer definable function that is called whenever a cell is created (Ajax source,
             * etc) or processed for input (DOM source). This can be used as a compliment to mRender
             * allowing you to modify the DOM element (add background colour for example) when the
             * element is available.
             *  @type function
             *  @param {element} nTd The TD node that has been created
             *  @param {*} sData The Data for the cell
             *  @param {array|object} oData The data for the whole row
             *  @param {int} iRow The row index for the aoData data store
             *  @default null
             */
            "fnCreatedCell": null,

            /**
             * Function to get data from a cell in a column. You should <b>never</b>
             * access data directly through _aData internally in DataTables - always use
             * the method attached to this property. It allows mData to function as
             * required. This function is automatically assigned by the column
             * initialisation method
             *  @type function
             *  @param {array|object} oData The data array/object for the array
             *    (i.e. aoData[]._aData)
             *  @param {string} sSpecific The specific data type you want to get -
             *    'display', 'type' 'filter' 'sort'
             *  @returns {*} The data for the cell from the given row's data
             *  @default null
             */
            "fnGetData": null,

            /**
             * <code>Deprecated</code> Custom display function that will be called for the
             * display of each cell in this column.
             *
             * Please note that this option has now been deprecated and will be removed
             * in the next version of DataTables. Please use mRender / mData rather than
             * fnRender.
             *  @type function
             *  @param {object} o Object with the following parameters:
             *  @param {int}    o.iDataRow The row in aoData
             *  @param {int}    o.iDataColumn The column in question
             *  @param {array}  o.aData The data for the row in question
             *  @param {object} o.oSettings The settings object for this DataTables instance
             *  @returns {string} The string you which to use in the display
             *  @default null
             *  @deprecated
             */
            "fnRender": null,

            /**
             * Function to set data for a cell in the column. You should <b>never</b>
             * set the data directly to _aData internally in DataTables - always use
             * this method. It allows mData to function as required. This function
             * is automatically assigned by the column initialisation method
             *  @type function
             *  @param {array|object} oData The data array/object for the array
             *    (i.e. aoData[]._aData)
             *  @param {*} sValue Value to set
             *  @default null
             */
            "fnSetData": null,

            /**
             * Property to read the value for the cells in the column from the data
             * source array / object. If null, then the default content is used, if a
             * function is given then the return from the function is used.
             *  @type function|int|string|null
             *  @default null
             */
            "mData": null,

            /**
             * Partner property to mData which is used (only when defined) to get
             * the data - i.e. it is basically the same as mData, but without the
             * 'set' option, and also the data fed to it is the result from mData.
             * This is the rendering method to match the data method of mData.
             *  @type function|int|string|null
             *  @default null
             */
            "mRender": null,

            /**
             * Unique header TH/TD element for this column - this is what the sorting
             * listener is attached to (if sorting is enabled.)
             *  @type node
             *  @default null
             */
            "nTh": null,

            /**
             * Unique footer TH/TD element for this column (if there is one). Not used
             * in DataTables as such, but can be used for plug-ins to reference the
             * footer for each column.
             *  @type node
             *  @default null
             */
            "nTf": null,

            /**
             * The class to apply to all TD elements in the table's TBODY for the column
             *  @type string
             *  @default null
             */
            "sClass": null,

            /**
             * When DataTables calculates the column widths to assign to each column,
             * it finds the longest string in each column and then constructs a
             * temporary table and reads the widths from that. The problem with this
             * is that "mmm" is much wider then "iiii", but the latter is a longer
             * string - thus the calculation can go wrong (doing it properly and putting
             * it into an DOM object and measuring that is horribly(!) slow). Thus as
             * a "work around" we provide this option. It will append its value to the
             * text that is found to be the longest string for the column - i.e. padding.
             *  @type string
             */
            "sContentPadding": null,

            /**
             * Allows a default value to be given for a column's data, and will be used
             * whenever a null data source is encountered (this can be because mData
             * is set to null, or because the data source itself is null).
             *  @type string
             *  @default null
             */
            "sDefaultContent": null,

            /**
             * Name for the column, allowing reference to the column by name as well as
             * by index (needs a lookup to work by name).
             *  @type string
             */
            "sName": null,

            /**
             * Custom sorting data type - defines which of the available plug-ins in
             * afnSortData the custom sorting will use - if any is defined.
             *  @type string
             *  @default std
             */
            "sSortDataType": 'std',

            /**
             * Class to be applied to the header element when sorting on this column
             *  @type string
             *  @default null
             */
            "sSortingClass": null,

            /**
             * Class to be applied to the header element when sorting on this column -
             * when jQuery UI theming is used.
             *  @type string
             *  @default null
             */
            "sSortingClassJUI": null,

            /**
             * Title of the column - what is seen in the TH element (nTh).
             *  @type string
             */
            "sTitle": null,

            /**
             * Column sorting and filtering type
             *  @type string
             *  @default null
             */
            "sType": null,

            /**
             * Width of the column
             *  @type string
             *  @default null
             */
            "sWidth": null,

            /**
             * Width of the column when it was first "encountered"
             *  @type string
             *  @default null
             */
            "sWidthOrig": null
        };


        /**
         * Initialisation options that can be given to DataTables at initialisation
         * time.
         *  @namespace
         */
        DataTable.defaults = {
            /**
             * An array of data to use for the table, passed in at initialisation which
             * will be used in preference to any data which is already in the DOM. This is
             * particularly useful for constructing tables purely in Javascript, for
             * example with a custom Ajax call.
             *  @type array
             *  @default null
             *  @dtopt Option
             *
             *  @example
             *    // Using a 2D array data source
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine" },
		 *          { "sTitle": "Browser" },
		 *          { "sTitle": "Platform" },
		 *          { "sTitle": "Version" },
		 *          { "sTitle": "Grade" }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using an array of objects as a data source (mData)
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine",   "mData": "engine" },
		 *          { "sTitle": "Browser",  "mData": "browser" },
		 *          { "sTitle": "Platform", "mData": "platform" },
		 *          { "sTitle": "Version",  "mData": "version" },
		 *          { "sTitle": "Grade",    "mData": "grade" }
		 *        ]
		 *      } );
		 *    } );
             */
            "aaData": null,


            /**
             * If sorting is enabled, then DataTables will perform a first pass sort on
             * initialisation. You can define which column(s) the sort is performed upon,
             * and the sorting direction, with this variable. The aaSorting array should
             * contain an array for each column to be sorted initially containing the
             * column's index and a direction string ('asc' or 'desc').
             *  @type array
             *  @default [[0,'asc']]
             *  @dtopt Option
             *
             *  @example
             *    // Sort by 3rd column first, and then 4th column
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
             *
             *    // No initial sorting
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": []
		 *      } );
		 *    } );
             */
            "aaSorting": [[0, 'asc']],


            /**
             * This parameter is basically identical to the aaSorting parameter, but
             * cannot be overridden by user interaction with the table. What this means
             * is that you could have a column (visible or hidden) which the sorting will
             * always be forced on first - any sorting after that (from the user) will
             * then be performed as required. This can be useful for grouping rows
             * together.
             *  @type array
             *  @default null
             *  @dtopt Option
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSortingFixed": [[0,'asc']]
		 *      } );
		 *    } )
             */
            "aaSortingFixed": null,


            /**
             * This parameter allows you to readily specify the entries in the length drop
             * down menu that DataTables shows when pagination is enabled. It can be
             * either a 1D array of options which will be used for both the displayed
             * option and the value, or a 2D array which will use the array in the first
             * position as the value, and the array in the second position as the
             * displayed options (useful for language strings such as 'All').
             *  @type array
             *  @default [ 10, 25, 50, 100 ]
             *  @dtopt Option
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aLengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Setting the default display length as well as length menu
             *    // This is likely to be wanted if you remove the '10' option which
             *    // is the iDisplayLength default.
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 25,
		 *        "aLengthMenu": [[25, 50, 100, -1], [25, 50, 100, "All"]]
		 *      } );
		 *    } );
             */
            "aLengthMenu": [10, 25, 50, 100],


            /**
             * The aoColumns option in the initialisation parameter allows you to define
             * details about the way individual columns behave. For a full list of
             * column options that can be set, please see
             * {@link DataTable.defaults.columns}. Note that if you use aoColumns to
             * define your columns, you must have an entry in the array for every single
             * column that you have in your table (these can be null if you don't which
             * to specify any options).
             *  @member
             */
            "aoColumns": null,

            /**
             * Very similar to aoColumns, aoColumnDefs allows you to target a specific
             * column, multiple columns, or all columns, using the aTargets property of
             * each object in the array. This allows great flexibility when creating
             * tables, as the aoColumnDefs arrays can be of any length, targeting the
             * columns you specifically want. aoColumnDefs may use any of the column
             * options available: {@link DataTable.defaults.columns}, but it _must_
             * have aTargets defined in each object in the array. Values in the aTargets
             * array may be:
             *   <ul>
             *     <li>a string - class name will be matched on the TH for the column</li>
             *     <li>0 or a positive integer - column index counting from the left</li>
             *     <li>a negative integer - column index counting from the right</li>
             *     <li>the string "_all" - all columns (i.e. assign a default)</li>
             *   </ul>
             *  @member
             */
            "aoColumnDefs": null,


            /**
             * Basically the same as oSearch, this parameter defines the individual column
             * filtering state at initialisation time. The array must be of the same size
             * as the number of columns, and each element be an object with the parameters
             * "sSearch" and "bEscapeRegex" (the latter is optional). 'null' is also
             * accepted and the default will be used.
             *  @type array
             *  @default []
             *  @dtopt Option
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoSearchCols": [
		 *          null,
		 *          { "sSearch": "My filter" },
		 *          null,
		 *          { "sSearch": "^[0-9]", "bEscapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
             */
            "aoSearchCols": [],


            /**
             * An array of CSS classes that should be applied to displayed rows. This
             * array may be of any length, and DataTables will apply each class
             * sequentially, looping when required.
             *  @type array
             *  @default null <i>Will take the values determined by the oClasses.sStripe*
             *    options</i>
             *  @dtopt Option
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "asStripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
             */
            "asStripeClasses": null,


            /**
             * Enable or disable automatic column width calculation. This can be disabled
             * as an optimisation (it takes some time to calculate the widths) if the
             * tables widths are passed in using aoColumns.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bAutoWidth": false
		 *      } );
		 *    } );
             */
            "bAutoWidth": true,


            /**
             * Deferred rendering can provide DataTables with a huge speed boost when you
             * are using an Ajax or JS data source for the table. This option, when set to
             * true, will cause DataTables to defer the creation of the table elements for
             * each row until they are needed for a draw - saving a significant amount of
             * time.
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/arrays.txt",
		 *        "bDeferRender": true
		 *      } );
		 *    } );
             */
            "bDeferRender": false,


            /**
             * Replace a DataTable which matches the given selector and replace it with
             * one which has the properties of the new initialisation object passed. If no
             * table matches the selector, then the new DataTable will be constructed as
             * per normal.
             *  @type boolean
             *  @default false
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "bFilter": false,
		 *        "bDestroy": true
		 *      } );
		 *    } );
             */
            "bDestroy": false,


            /**
             * Enable or disable filtering of data. Filtering in DataTables is "smart" in
             * that it allows the end user to input multiple words (space separated) and
             * will match a row containing those words, even if not in the order that was
             * specified (this allow matching across multiple columns). Note that if you
             * wish to use filtering in DataTables this must remain 'true' - to remove the
             * default filtering input box and retain filtering abilities, please use
             * {@link DataTable.defaults.sDom}.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bFilter": false
		 *      } );
		 *    } );
             */
            "bFilter": true,


            /**
             * Enable or disable the table information display. This shows information
             * about the data that is currently visible on the page, including information
             * about filtered data if that action is being performed.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bInfo": false
		 *      } );
		 *    } );
             */
            "bInfo": true,


            /**
             * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
             * slightly different and additional mark-up from what DataTables has
             * traditionally used).
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bJQueryUI": true
		 *      } );
		 *    } );
             */
            "bJQueryUI": false,


            /**
             * Allows the end user to select the size of a formatted page from a select
             * menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bLengthChange": false
		 *      } );
		 *    } );
             */
            "bLengthChange": true,


            /**
             * Enable or disable pagination.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bPaginate": false
		 *      } );
		 *    } );
             */
            "bPaginate": true,


            /**
             * Enable or disable the display of a 'processing' indicator when the table is
             * being processed (e.g. a sort). This is particularly useful for tables with
             * large amounts of data where it can take a noticeable amount of time to sort
             * the entries.
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true
		 *      } );
		 *    } );
             */
            "bProcessing": false,


            /**
             * Retrieve the DataTables object for the given selector. Note that if the
             * table has already been initialised, this parameter will cause DataTables
             * to simply return the object that has already been set up - it will not take
             * account of any changes you might have made to the initialisation object
             * passed to DataTables (setting this parameter to true is an acknowledgement
             * that you understand this). bDestroy can be used to reinitialise a table if
             * you need.
             *  @type boolean
             *  @default false
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
             *
             *    function initTable ()
             *    {
		 *      return $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false,
		 *        "bRetrieve": true
		 *      } );
		 *    }
             *
             *    function tableActions ()
             *    {
		 *      var oTable = initTable();
		 *      // perform API operations with oTable 
		 *    }
             */
            "bRetrieve": false,


            /**
             * Indicate if DataTables should be allowed to set the padding / margin
             * etc for the scrolling header elements or not. Typically you will want
             * this.
             *  @type boolean
             *  @default true
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollAutoCss": false,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
             */
            "bScrollAutoCss": true,


            /**
             * When vertical (y) scrolling is enabled, DataTables will force the height of
             * the table's viewport to the given height at all times (useful for layout).
             * However, this can look odd when filtering data down to a small data set,
             * and the footer is left "floating" further down. This parameter (when
             * enabled) will cause DataTables to collapse the table's viewport down when
             * the result set will fit within the given Y height.
             *  @type boolean
             *  @default false
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
             */
            "bScrollCollapse": false,


            /**
             * Enable infinite scrolling for DataTables (to be used in combination with
             * sScrollY). Infinite scrolling means that DataTables will continually load
             * data as a user scrolls through a table, which is very useful for large
             * dataset. This cannot be used with pagination, which is automatically
             * disabled. Note - the Scroller extra for DataTables is recommended in
             * in preference to this option.
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
             */
            "bScrollInfinite": false,


            /**
             * Configure DataTables to use server-side processing. Note that the
             * sAjaxSource parameter must also be given in order to give DataTables a
             * source to obtain the required data for each draw.
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *  @dtopt Server-side
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php"
		 *      } );
		 *    } );
             */
            "bServerSide": false,


            /**
             * Enable or disable sorting of columns. Sorting of individual columns can be
             * disabled by the "bSortable" option for each column.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSort": false
		 *      } );
		 *    } );
             */
            "bSort": true,


            /**
             * Allows control over whether DataTables should use the top (true) unique
             * cell that is found for a single column, or the bottom (false - default).
             * This is useful when using complex headers.
             *  @type boolean
             *  @default false
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bSortCellsTop": true
		 *      } );
		 *    } );
             */
            "bSortCellsTop": false,


            /**
             * Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and
             * 'sorting_3' to the columns which are currently being sorted on. This is
             * presented as a feature switch as it can increase processing time (while
             * classes are removed and added) so for large data sets you might want to
             * turn this off.
             *  @type boolean
             *  @default true
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSortClasses": false
		 *      } );
		 *    } );
             */
            "bSortClasses": true,


            /**
             * Enable or disable state saving. When enabled a cookie will be used to save
             * table display information such as pagination information, display length,
             * filtering and sorting. As such when the end user reloads the page the
             * display display will match what thy had previously set up.
             *  @type boolean
             *  @default false
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true
		 *      } );
		 *    } );
             */
            "bStateSave": false,


            /**
             * Customise the cookie and / or the parameters being stored when using
             * DataTables with state saving enabled. This function is called whenever
             * the cookie is modified, and it expects a fully formed cookie string to be
             * returned. Note that the data object passed in is a Javascript object which
             * must be converted to a string (JSON.stringify for example).
             *  @type function
             *  @param {string} sName Name of the cookie defined by DataTables
             *  @param {object} oData Data to be stored in the cookie
             *  @param {string} sExpires Cookie expires string
             *  @param {string} sPath Path of the cookie to set
             *  @returns {string} Cookie formatted string (which should be encoded by
             *    using encodeURIComponent())
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "fnCookieCallback": function (sName, oData, sExpires, sPath) {
		 *          // Customise oData or sName or whatever else here
		 *          return sName + "="+JSON.stringify(oData)+"; expires=" + sExpires +"; path=" + sPath;
		 *        }
		 *      } );
		 *    } );
             */
            "fnCookieCallback": null,


            /**
             * This function is called when a TR element is created (and all TD child
             * elements have been inserted), or registered if using a DOM source, allowing
             * manipulation of the TR element (adding classes etc).
             *  @type function
             *  @param {node} nRow "TR" element for the current row
             *  @param {array} aData Raw data array for this row
             *  @param {int} iDataIndex The index of this row in aoData
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnCreatedRow": function( nRow, aData, iDataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
             */
            "fnCreatedRow": null,


            /**
             * This function is called on every 'draw' event, and allows you to
             * dynamically modify any aspect you want about the created DOM.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnDrawCallback": function( oSettings ) {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
             */
            "fnDrawCallback": null,


            /**
             * Identical to fnHeaderCallback() but for the table footer this function
             * allows you to modify the table footer on every 'draw' even.
             *  @type function
             *  @param {node} nFoot "TR" element for the footer
             *  @param {array} aData Full table data (as derived from the original HTML)
             *  @param {int} iStart Index for the current display starting point in the
             *    display array
             *  @param {int} iEnd Index for the current display ending point in the
             *    display array
             *  @param {array int} aiDisplay Index array to translate the visual position
             *    to the full data array
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFooterCallback": function( nFoot, aData, iStart, iEnd, aiDisplay ) {
		 *          nFoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+iStart;
		 *        }
		 *      } );
		 *    } )
             */
            "fnFooterCallback": null,


            /**
             * When rendering large numbers in the information element for the table
             * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
             * to have a comma separator for the 'thousands' units (e.g. 1 million is
             * rendered as "1,000,000") to help readability for the end user. This
             * function will override the default method DataTables uses.
             *  @type function
             *  @member
             *  @param {int} iIn number to be formatted
             *  @returns {string} formatted string for DataTables to show the number
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFormatNumber": function ( iIn ) {
		 *          if ( iIn &lt; 1000 ) {
		 *            return iIn;
		 *          } else {
		 *            var 
		 *              s=(iIn+""), 
		 *              a=s.split(""), out="", 
		 *              iLen=s.length;
		 *            
		 *            for ( var i=0 ; i&lt;iLen ; i++ ) {
		 *              if ( i%3 === 0 &amp;&amp; i !== 0 ) {
		 *                out = "'"+out;
		 *              }
		 *              out = a[iLen-i-1]+out;
		 *            }
		 *          }
		 *          return out;
		 *        };
		 *      } );
		 *    } );
             */
            "fnFormatNumber": function (iIn) {
                if (iIn < 1000) {
                    // A small optimisation for what is likely to be the majority of use cases
                    return iIn;
                }

                var s = (iIn + ""), a = s.split(""), out = "", iLen = s.length;

                for (var i = 0; i < iLen; i++) {
                    if (i % 3 === 0 && i !== 0) {
                        out = this.oLanguage.sInfoThousands + out;
                    }
                    out = a[iLen - i - 1] + out;
                }
                return out;
            },


            /**
             * This function is called on every 'draw' event, and allows you to
             * dynamically modify the header row. This can be used to calculate and
             * display useful information about the table.
             *  @type function
             *  @param {node} nHead "TR" element for the header
             *  @param {array} aData Full table data (as derived from the original HTML)
             *  @param {int} iStart Index for the current display starting point in the
             *    display array
             *  @param {int} iEnd Index for the current display ending point in the
             *    display array
             *  @param {array int} aiDisplay Index array to translate the visual position
             *    to the full data array
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnHeaderCallback": function( nHead, aData, iStart, iEnd, aiDisplay ) {
		 *          nHead.getElementsByTagName('th')[0].innerHTML = "Displaying "+(iEnd-iStart)+" records";
		 *        }
		 *      } );
		 *    } )
             */
            "fnHeaderCallback": null,


            /**
             * The information element can be used to convey information about the current
             * state of the table. Although the internationalisation options presented by
             * DataTables are quite capable of dealing with most customisations, there may
             * be times where you wish to customise the string further. This callback
             * allows you to do exactly that.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {int} iStart Starting position in data for the draw
             *  @param {int} iEnd End position in data for the draw
             *  @param {int} iMax Total number of rows in the table (regardless of
             *    filtering)
             *  @param {int} iTotal Total number of rows in the data set, after filtering
             *  @param {string} sPre The string that DataTables has formatted using it's
             *    own rules
             *  @returns {string} The string to be displayed in the information element.
             *  @dtopt Callbacks
             *
             *  @example
             *    $('#example').dataTable( {
		 *      "fnInfoCallback": function( oSettings, iStart, iEnd, iMax, iTotal, sPre ) {
		 *        return iStart +" to "+ iEnd;
		 *      }
		 *    } );
             */
            "fnInfoCallback": null,


            /**
             * Called when the table has been initialised. Normally DataTables will
             * initialise sequentially and there will be no need for this function,
             * however, this does not hold true when using external language information
             * since that is obtained using an async XHR call.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {object} json The JSON object request from the server - only
             *    present if client-side Ajax sourced data is used
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnInitComplete": function(oSettings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
             */
            "fnInitComplete": null,


            /**
             * Called at the very start of each table draw and can be used to cancel the
             * draw by returning false, any other return (including undefined) results in
             * the full draw occurring).
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @returns {boolean} False will cancel the draw, anything else (including no
             *    return) will allow it to complete.
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnPreDrawCallback": function( oSettings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
             */
            "fnPreDrawCallback": null,


            /**
             * This function allows you to 'post process' each row after it have been
             * generated for each table draw, but before it is rendered on screen. This
             * function might be used for setting the row class name etc.
             *  @type function
             *  @param {node} nRow "TR" element for the current row
             *  @param {array} aData Raw data array for this row
             *  @param {int} iDisplayIndex The display index for the current table draw
             *  @param {int} iDisplayIndexFull The index of the data in the full list of
             *    rows (after filtering)
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
             */
            "fnRowCallback": null,


            /**
             * This parameter allows you to override the default function which obtains
             * the data from the server ($.getJSON) so something more suitable for your
             * application. For example you could use POST data, or pull information from
             * a Gears or AIR database.
             *  @type function
             *  @member
             *  @param {string} sSource HTTP source to obtain the data from (sAjaxSource)
             *  @param {array} aoData A key/value pair object containing the data to send
             *    to the server
             *  @param {function} fnCallback to be called on completion of the data get
             *    process that will draw the data on the page.
             *  @param {object} oSettings DataTables settings object
             *  @dtopt Callbacks
             *  @dtopt Server-side
             *
             *  @example
             *    // POST data to server
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php",
		 *        "fnServerData": function ( sSource, aoData, fnCallback, oSettings ) {
		 *          oSettings.jqXHR = $.ajax( {
		 *            "dataType": 'json', 
		 *            "type": "POST", 
		 *            "url": sSource, 
		 *            "data": aoData, 
		 *            "success": fnCallback
		 *          } );
		 *        }
		 *      } );
		 *    } );
             */
            "fnServerData": function (sUrl, aoData, fnCallback, oSettings) {
                oSettings.jqXHR = $.ajax({
                    "url": sUrl,
                    "data": aoData,
                    "success": function (json) {
                        if (json.sError) {
                            oSettings.oApi._fnLog(oSettings, 0, json.sError);
                        }

                        $(oSettings.oInstance).trigger('xhr', [oSettings, json]);
                        fnCallback(json);
                    },
                    "dataType": "json",
                    "cache": false,
                    "type": oSettings.sServerMethod,
                    "error": function (xhr, error, thrown) {
                        if (error == "parsererror") {
                            oSettings.oApi._fnLog(oSettings, 0, "DataTables warning: JSON data from " +
                                "server could not be parsed. This is caused by a JSON formatting error.");
                        }
                    }
                });
            },


            /**
             * It is often useful to send extra data to the server when making an Ajax
             * request - for example custom filtering information, and this callback
             * function makes it trivial to send extra information to the server. The
             * passed in parameter is the data set that has been constructed by
             * DataTables, and you can add to this or modify it as you require.
             *  @type function
             *  @param {array} aoData Data array (array of objects which are name/value
             *    pairs) that has been constructed by DataTables and will be sent to the
             *    server. In the case of Ajax sourced data with server-side processing
             *    this will be an empty array, for server-side processing there will be a
             *    significant number of parameters!
             *  @returns {undefined} Ensure that you modify the aoData array passed in,
             *    as this is passed by reference.
             *  @dtopt Callbacks
             *  @dtopt Server-side
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "fnServerParams": function ( aoData ) {
		 *          aoData.push( { "name": "more_data", "value": "my_value" } );
		 *        }
		 *      } );
		 *    } );
             */
            "fnServerParams": null,


            /**
             * Load the table state. With this function you can define from where, and how, the
             * state of a table is loaded. By default DataTables will load from its state saving
             * cookie, but you might wish to use local storage (HTML5) or a server-side database.
             *  @type function
             *  @member
             *  @param {object} oSettings DataTables settings object
             *  @return {object} The DataTables state object to be loaded
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoad": function (oSettings) {
		 *          var o;
		 *          
		 *          // Send an Ajax request to the server to get the data. Note that
		 *          // this is a synchronous request.
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "async": false,
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              o = json;
		 *            }
		 *          } );
		 *          
		 *          return o;
		 *        }
		 *      } );
		 *    } );
             */
            "fnStateLoad": function (oSettings) {
                var sData = this.oApi._fnReadCookie(oSettings.sCookiePrefix + oSettings.sInstance);
                var oData;

                try {
                    oData = (typeof $.parseJSON === 'function') ?
                        $.parseJSON(sData) : eval('(' + sData + ')');
                } catch (e) {
                    oData = null;
                }

                return oData;
            },


            /**
             * Callback which allows modification of the saved state prior to loading that state.
             * This callback is called when the table is loading state from the stored data, but
             * prior to the settings object being modified by the saved state. Note that for
             * plug-in authors, you should use the 'stateLoadParams' event to load parameters for
             * a plug-in.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {object} oData The state object that is to be loaded
             *  @dtopt Callbacks
             *
             *  @example
             *    // Remove a saved filter, so filtering is never loaded
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
             *
             *  @example
             *    // Disallow state loading by returning false
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
             */
            "fnStateLoadParams": null,


            /**
             * Callback that is called when the state has been loaded from the state saving method
             * and the DataTables settings object has been modified as a result of the loaded state.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {object} oData The state object that was loaded
             *  @dtopt Callbacks
             *
             *  @example
             *    // Show an alert with the filtering value that was saved
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoaded": function (oSettings, oData) {
		 *          alert( 'Saved filter was: '+oData.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
             */
            "fnStateLoaded": null,


            /**
             * Save the table state. This function allows you to define where and how the state
             * information for the table is stored - by default it will use a cookie, but you
             * might want to use local storage (HTML5) or a server-side database.
             *  @type function
             *  @member
             *  @param {object} oSettings DataTables settings object
             *  @param {object} oData The state object to be saved
             *  @dtopt Callbacks
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSave": function (oSettings, oData) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": oData,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
             */
            "fnStateSave": function (oSettings, oData) {
                this.oApi._fnCreateCookie(
                    oSettings.sCookiePrefix + oSettings.sInstance,
                    this.oApi._fnJsonString(oData),
                    oSettings.iCookieDuration,
                    oSettings.sCookiePrefix,
                    oSettings.fnCookieCallback
                );
            },


            /**
             * Callback which allows modification of the state to be saved. Called when the table
             * has changed state a new state save is required. This method allows modification of
             * the state saving object prior to actually doing the save, including addition or
             * other state properties or modification. Note that for plug-in authors, you should
             * use the 'stateSaveParams' event to save parameters for a plug-in.
             *  @type function
             *  @param {object} oSettings DataTables settings object
             *  @param {object} oData The state object to be saved
             *  @dtopt Callbacks
             *
             *  @example
             *    // Remove a saved filter, so filtering is never saved
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSaveParams": function (oSettings, oData) {
		 *          oData.oSearch.sSearch = "";
		 *        }
		 *      } );
		 *    } );
             */
            "fnStateSaveParams": null,


            /**
             * Duration of the cookie which is used for storing session information. This
             * value is given in seconds.
             *  @type int
             *  @default 7200 <i>(2 hours)</i>
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iCookieDuration": 60*60*24; // 1 day
		 *      } );
		 *    } )
             */
            "iCookieDuration": 7200,


            /**
             * When enabled DataTables will not make a request to the server for the first
             * page draw - rather it will use the data already on the page (no sorting etc
             * will be applied to it), thus saving on an XHR at load time. iDeferLoading
             * is used to indicate that deferred loading is required, but it is also used
             * to tell DataTables how many records there are in the full table (allowing
             * the information element and pagination to be displayed correctly). In the case
             * where a filtering is applied to the table on initial load, this can be
             * indicated by giving the parameter as an array, where the first element is
             * the number of records available after filtering and the second element is the
             * number of records without filtering (allowing the table information element
             * to be shown correctly).
             *  @type int | array
             *  @default null
             *  @dtopt Options
             *
             *  @example
             *    // 57 records available in the table, no filtering applied
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": 57
		 *      } );
		 *    } );
             *
             *  @example
             *    // 57 records after filtering, 100 without filtering (an initial filter applied)
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": [ 57, 100 ],
		 *        "oSearch": {
		 *          "sSearch": "my_filter"
		 *        }
		 *      } );
		 *    } );
             */
            "iDeferLoading": null,


            /**
             * Number of rows to display on a single page when using pagination. If
             * feature enabled (bLengthChange) then the end user will be able to override
             * this to a custom setting using a pop-up menu.
             *  @type int
             *  @default 10
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 50
		 *      } );
		 *    } )
             */
            "iDisplayLength": 10,


            /**
             * Define the starting point for data display when using DataTables with
             * pagination. Note that this parameter is the number of records, rather than
             * the page number, so if you have 10 records per page and want to start on
             * the third page, it should be "20".
             *  @type int
             *  @default 0
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayStart": 20
		 *      } );
		 *    } )
             */
            "iDisplayStart": 0,


            /**
             * The scroll gap is the amount of scrolling that is left to go before
             * DataTables will load the next 'page' of data automatically. You typically
             * want a gap which is big enough that the scrolling will be smooth for the
             * user, while not so large that it will load more data than need.
             *  @type int
             *  @default 100
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px",
		 *        "iScrollLoadGap": 50
		 *      } );
		 *    } );
             */
            "iScrollLoadGap": 100,


            /**
             * By default DataTables allows keyboard navigation of the table (sorting, paging,
             * and filtering) by adding a tabindex attribute to the required elements. This
             * allows you to tab through the controls and press the enter key to activate them.
             * The tabindex is default 0, meaning that the tab follows the flow of the document.
             * You can overrule this using this parameter if you wish. Use a value of -1 to
             * disable built-in keyboard navigation.
             *  @type int
             *  @default 0
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iTabIndex": 1
		 *      } );
		 *    } );
             */
            "iTabIndex": 0,


            /**
             * All strings that DataTables uses in the user interface that it creates
             * are defined in this object, allowing you to modified them individually or
             * completely replace them all as required.
             *  @namespace
             */
            "oLanguage": {
                /**
                 * Strings that are used for WAI-ARIA labels and controls only (these are not
                 * actually visible on the page, but will be read by screenreaders, and thus
                 * must be internationalised as well).
                 *  @namespace
                 */
                "oAria": {
                    /**
                     * ARIA label that is added to the table headers when the column may be
                     * sorted ascending by activing the column (click or return when focused).
                     * Note that the column header is prefixed to this string.
                     *  @type string
                     *  @default : activate to sort column ascending
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sSortAscending": ": activate to sort column ascending",

                    /**
                     * ARIA label that is added to the table headers when the column may be
                     * sorted descending by activing the column (click or return when focused).
                     * Note that the column header is prefixed to this string.
                     *  @type string
                     *  @default : activate to sort column ascending
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sSortDescending": ": activate to sort column descending"
                },

                /**
                 * Pagination string used by DataTables for the two built-in pagination
                 * control types ("two_button" and "full_numbers")
                 *  @namespace
                 */
                "oPaginate": {
                    /**
                     * Text to use when using the 'full_numbers' type of pagination for the
                     * button to take the user to the first page.
                     *  @type string
                     *  @default First
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sFirst": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sFirst": "First",


                    /**
                     * Text to use when using the 'full_numbers' type of pagination for the
                     * button to take the user to the last page.
                     *  @type string
                     *  @default Last
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sLast": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sLast": "Last",


                    /**
                     * Text to use for the 'next' pagination button (to take the user to the
                     * next page).
                     *  @type string
                     *  @default Next
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sNext": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sNext": "Next",


                    /**
                     * Text to use for the 'previous' pagination button (to take the user to
                     * the previous page).
                     *  @type string
                     *  @default Previous
                     *  @dtopt Language
                     *
                     *  @example
                     *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sPrevious": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
                     */
                    "sPrevious": "Previous"
                },

                /**
                 * This string is shown in preference to sZeroRecords when the table is
                 * empty of data (regardless of filtering). Note that this is an optional
                 * parameter - if it is not given, the value of sZeroRecords will be used
                 * instead (either the default or given value).
                 *  @type string
                 *  @default No data available in table
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sEmptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
                 */
                "sEmptyTable": "No data available in table",


                /**
                 * This string gives information to the end user about the information that
                 * is current on display on the page. The _START_, _END_ and _TOTAL_
                 * variables are all dynamically replaced as the table display updates, and
                 * can be freely moved or removed as the language requirements change.
                 *  @type string
                 *  @default Showing _START_ to _END_ of _TOTAL_ entries
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfo": "Got a total of _TOTAL_ entries to show (_START_ to _END_)"
			 *        }
			 *      } );
			 *    } );
                 */
                "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


                /**
                 * Display information string for when the table is empty. Typically the
                 * format of this string should match sInfo.
                 *  @type string
                 *  @default Showing 0 to 0 of 0 entries
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
                 */
                "sInfoEmpty": "Showing 0 to 0 of 0 entries",


                /**
                 * When a user filters the information in a table, this string is appended
                 * to the information (sInfo) to give an idea of how strong the filtering
                 * is. The variable _MAX_ is dynamically updated.
                 *  @type string
                 *  @default (filtered from _MAX_ total entries)
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
                 */
                "sInfoFiltered": "(filtered from _MAX_ total entries)",


                /**
                 * If can be useful to append extra information to the info string at times,
                 * and this variable does exactly that. This information will be appended to
                 * the sInfo (sInfoEmpty and sInfoFiltered in whatever combination they are
                 * being used) at all times.
                 *  @type string
                 *  @default <i>Empty string</i>
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
                 */
                "sInfoPostFix": "",


                /**
                 * DataTables has a build in number formatter (fnFormatNumber) which is used
                 * to format large numbers that are used in the table information. By
                 * default a comma is used, but this can be trivially changed to any
                 * character you wish with this parameter.
                 *  @type string
                 *  @default ,
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoThousands": "'"
			 *        }
			 *      } );
			 *    } );
                 */
                "sInfoThousands": ",",


                /**
                 * Detail the action that will be taken when the drop down menu for the
                 * pagination length option is changed. The '_MENU_' variable is replaced
                 * with a default select list of 10, 25, 50 and 100, and can be replaced
                 * with a custom select box if required.
                 *  @type string
                 *  @default Show _MENU_ entries
                 *  @dtopt Language
                 *
                 *  @example
                 *    // Language change only
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
                 *
                 *  @example
                 *    // Language and options change
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
                 */
                "sLengthMenu": "Show _MENU_ entries",


                /**
                 * When using Ajax sourced data and during the first draw when DataTables is
                 * gathering the data, this message is shown in an empty row in the table to
                 * indicate to the end user the the data is being loaded. Note that this
                 * parameter is not used when loading data by server-side processing, just
                 * Ajax sourced data with client-side processing.
                 *  @type string
                 *  @default Loading...
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLoadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
                 */
                "sLoadingRecords": "Loading...",


                /**
                 * Text which is displayed when the table is processing a user action
                 * (usually a sort command or similar).
                 *  @type string
                 *  @default Processing...
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sProcessing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
                 */
                "sProcessing": "Processing...",


                /**
                 * Details the actions that will be taken when the user types into the
                 * filtering input text box. The variable "_INPUT_", if used in the string,
                 * is replaced with the HTML text box for the filtering input allowing
                 * control over where it appears in the string. If "_INPUT_" is not given
                 * then the input box is appended to the string automatically.
                 *  @type string
                 *  @default Search:
                 *  @dtopt Language
                 *
                 *  @example
                 *    // Input text box will be appended at the end automatically
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Filter records:"
			 *        }
			 *      } );
			 *    } );
                 *
                 *  @example
                 *    // Specify where the filter should appear
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
                 */
                "sSearch": "Search:",


                /**
                 * All of the language information can be stored in a file on the
                 * server-side, which DataTables will look up if this parameter is passed.
                 * It must store the URL of the language file, which is in a JSON format,
                 * and the object has the same properties as the oLanguage object in the
                 * initialiser object (i.e. the above parameters). Please refer to one of
                 * the example language files to see how this works in action.
                 *  @type string
                 *  @default <i>Empty string - i.e. disabled</i>
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sUrl": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
                 */
                "sUrl": "",


                /**
                 * Text shown inside the table records when the is no information to be
                 * displayed after filtering. sEmptyTable is shown when there is simply no
                 * information in the table at all (regardless of filtering).
                 *  @type string
                 *  @default No matching records found
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sZeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
                 */
                "sZeroRecords": "No matching records found"
            },


            /**
             * This parameter allows you to have define the global filtering state at
             * initialisation time. As an object the "sSearch" parameter must be
             * defined, but all other parameters are optional. When "bRegex" is true,
             * the search string will be treated as a regular expression, when false
             * (default) it will be treated as a straight string. When "bSmart"
             * DataTables will use it's smart filtering methods (to word match at
             * any point in the data), when false this will not be done.
             *  @namespace
             *  @extends DataTable.models.oSearch
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "oSearch": {"sSearch": "Initial search"}
		 *      } );
		 *    } )
             */
            "oSearch": $.extend({}, DataTable.models.oSearch),


            /**
             * By default DataTables will look for the property 'aaData' when obtaining
             * data from an Ajax source or for server-side processing - this parameter
             * allows that property to be changed. You can use Javascript dotted object
             * notation to get a data source for multiple levels of nesting.
             *  @type string
             *  @default aaData
             *  @dtopt Options
             *  @dtopt Server-side
             *
             *  @example
             *    // Get data from { "data": [...] }
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data"
		 *      } );
		 *    } );
             *
             *  @example
             *    // Get data from { "data": { "inner": [...] } }
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data.inner"
		 *      } );
		 *    } );
             */
            "sAjaxDataProp": "aaData",


            /**
             * You can instruct DataTables to load data from an external source using this
             * parameter (use aData if you want to pass data in you already have). Simply
             * provide a url a JSON object can be obtained from. This object must include
             * the parameter 'aaData' which is the data source for the table.
             *  @type string
             *  @default null
             *  @dtopt Options
             *  @dtopt Server-side
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sAjaxSource": "http://www.sprymedia.co.uk/dataTables/json.php"
		 *      } );
		 *    } )
             */
            "sAjaxSource": null,


            /**
             * This parameter can be used to override the default prefix that DataTables
             * assigns to a cookie when state saving is enabled.
             *  @type string
             *  @default SpryMedia_DataTables_
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sCookiePrefix": "my_datatable_",
		 *      } );
		 *    } );
             */
            "sCookiePrefix": "SpryMedia_DataTables_",


            /**
             * This initialisation variable allows you to specify exactly where in the
             * DOM you want DataTables to inject the various controls it adds to the page
             * (for example you might want the pagination controls at the top of the
             * table). DIV elements (with or without a custom class) can also be added to
             * aid styling. The follow syntax is used:
             *   <ul>
             *     <li>The following options are allowed:
             *       <ul>
             *         <li>'l' - Length changing</li
             *         <li>'f' - Filtering input</li>
             *         <li>'t' - The table!</li>
             *         <li>'i' - Information</li>
             *         <li>'p' - Pagination</li>
             *         <li>'r' - pRocessing</li>
             *       </ul>
             *     </li>
             *     <li>The following constants are allowed:
             *       <ul>
             *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
             *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
             *       </ul>
             *     </li>
             *     <li>The following syntax is expected:
             *       <ul>
             *         <li>'&lt;' and '&gt;' - div elements</li>
             *         <li>'&lt;"class" and '&gt;' - div with a class</li>
             *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
             *       </ul>
             *     </li>
             *     <li>Examples:
             *       <ul>
             *         <li>'&lt;"wrapper"flipt&gt;'</li>
             *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
             *       </ul>
             *     </li>
             *   </ul>
             *  @type string
             *  @default lfrtip <i>(when bJQueryUI is false)</i> <b>or</b>
             *    <"H"lfr>t<"F"ip> <i>(when bJQueryUI is true)</i>
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sDom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
		 *      } );
		 *    } );
             */
            "sDom": "lfrtip",


            /**
             * DataTables features two different built-in pagination interaction methods
             * ('two_button' or 'full_numbers') which present different page controls to
             * the end user. Further methods can be added using the API (see below).
             *  @type string
             *  @default two_button
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sPaginationType": "full_numbers"
		 *      } );
		 *    } )
             */
            "sPaginationType": "two_button",


            /**
             * Enable horizontal scrolling. When a table is too wide to fit into a certain
             * layout, or you have a large number of columns in the table, you can enable
             * x-scrolling to show the table in a viewport, which can be scrolled. This
             * property can be any CSS unit, or a number (in which case it will be treated
             * as a pixel measurement).
             *  @type string
             *  @default <i>blank string - i.e. disabled</i>
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
             */
            "sScrollX": "",


            /**
             * This property can be used to force a DataTable to use more width than it
             * might otherwise do when x-scrolling is enabled. For example if you have a
             * table which requires to be well spaced, this parameter is useful for
             * "over-sizing" the table, and thus forcing scrolling. This property can by
             * any CSS unit, or a number (in which case it will be treated as a pixel
             * measurement).
             *  @type string
             *  @default <i>blank string - i.e. disabled</i>
             *  @dtopt Options
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "sScrollXInner": "110%"
		 *      } );
		 *    } );
             */
            "sScrollXInner": "",


            /**
             * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
             * to the given height, and enable scrolling for any data which overflows the
             * current viewport. This can be used as an alternative to paging to display
             * a lot of data in a small area (although paging and scrolling can both be
             * enabled at the same time). This property can be any CSS unit, or a number
             * (in which case it will be treated as a pixel measurement).
             *  @type string
             *  @default <i>blank string - i.e. disabled</i>
             *  @dtopt Features
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *    } );
             */
            "sScrollY": "",


            /**
             * Set the HTTP method that is used to make the Ajax call for server-side
             * processing or Ajax sourced data.
             *  @type string
             *  @default GET
             *  @dtopt Options
             *  @dtopt Server-side
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/post.php",
		 *        "sServerMethod": "POST"
		 *      } );
		 *    } );
             */
            "sServerMethod": "GET"
        };


        /**
         * Column options that can be given to DataTables at initialisation time.
         *  @namespace
         */
        DataTable.defaults.columns = {
            /**
             * Allows a column's sorting to take multiple columns into account when
             * doing a sort. For example first name / last name columns make sense to
             * do a multi-column sort over the two columns.
             *  @type array
             *  @default null <i>Takes the value of the column index automatically</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "aDataSort": [ 0, 1 ], "aTargets": [ 0 ] },
		 *          { "aDataSort": [ 1, 0 ], "aTargets": [ 1 ] },
		 *          { "aDataSort": [ 2, 3, 4 ], "aTargets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          { "aDataSort": [ 0, 1 ] },
		 *          { "aDataSort": [ 1, 0 ] },
		 *          { "aDataSort": [ 2, 3, 4 ] },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "aDataSort": null,


            /**
             * You can control the default sorting direction, and even alter the behaviour
             * of the sort handler (i.e. only allow ascending sorting etc) using this
             * parameter.
             *  @type array
             *  @default [ 'asc', 'desc' ]
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "asSorting": [ "asc" ], "aTargets": [ 1 ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ], "aTargets": [ 2 ] },
		 *          { "asSorting": [ "desc" ], "aTargets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          { "asSorting": [ "asc" ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ] },
		 *          { "asSorting": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "asSorting": ['asc', 'desc'],


            /**
             * Enable or disable filtering on the data in this column.
             *  @type boolean
             *  @default true
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSearchable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSearchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
             */
            "bSearchable": true,


            /**
             * Enable or disable sorting on this column.
             *  @type boolean
             *  @default true
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSortable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSortable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
             */
            "bSortable": true,


            /**
             * <code>Deprecated</code> When using fnRender() for a column, you may wish
             * to use the original data (before rendering) for sorting and filtering
             * (the default is to used the rendered data that the user can see). This
             * may be useful for dates etc.
             *
             * Please note that this option has now been deprecated and will be removed
             * in the next version of DataTables. Please use mRender / mData rather than
             * fnRender.
             *  @type boolean
             *  @default true
             *  @dtopt Columns
             *  @deprecated
             */
            "bUseRendered": true,


            /**
             * Enable or disable the display of this column.
             *  @type boolean
             *  @default true
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bVisible": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bVisible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
             */
            "bVisible": true,


            /**
             * Developer definable function that is called whenever a cell is created (Ajax source,
             * etc) or processed for input (DOM source). This can be used as a compliment to mRender
             * allowing you to modify the DOM element (add background colour for example) when the
             * element is available.
             *  @type function
             *  @param {element} nTd The TD node that has been created
             *  @param {*} sData The Data for the cell
             *  @param {array|object} oData The data for the whole row
             *  @param {int} iRow The row index for the aoData data store
             *  @param {int} iCol The column index for aoColumns
             *  @dtopt Columns
             *
             *  @example
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [3],
		 *          "fnCreatedCell": function (nTd, sData, oData, iRow, iCol) {
		 *            if ( sData == "1.7" ) {
		 *              $(nTd).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
             */
            "fnCreatedCell": null,


            /**
             * <code>Deprecated</code> Custom display function that will be called for the
             * display of each cell in this column.
             *
             * Please note that this option has now been deprecated and will be removed
             * in the next version of DataTables. Please use mRender / mData rather than
             * fnRender.
             *  @type function
             *  @param {object} o Object with the following parameters:
             *  @param {int}    o.iDataRow The row in aoData
             *  @param {int}    o.iDataColumn The column in question
             *  @param {array}  o.aData The data for the row in question
             *  @param {object} o.oSettings The settings object for this DataTables instance
             *  @param {object} o.mDataProp The data property used for this column
             *  @param {*}      val The current cell value
             *  @returns {string} The string you which to use in the display
             *  @dtopt Columns
             *  @deprecated
             */
            "fnRender": null,


            /**
             * The column index (starting from 0!) that you wish a sort to be performed
             * upon when this column is selected for sorting. This can be used for sorting
             * on hidden columns for example.
             *  @type int
             *  @default -1 <i>Use automatically calculated column index</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "iDataSort": 1, "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "iDataSort": 1 },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "iDataSort": -1,


            /**
             * This parameter has been replaced by mData in DataTables to ensure naming
             * consistency. mDataProp can still be used, as there is backwards compatibility
             * in DataTables for this option, but it is strongly recommended that you use
             * mData in preference to mDataProp.
             *  @name DataTable.defaults.columns.mDataProp
             */


            /**
             * This property can be used to read data from any JSON data source property,
             * including deeply nested objects / properties. mData can be given in a
             * number of different ways which effect its behaviour:
             *   <ul>
             *     <li>integer - treated as an array index for the data source. This is the
             *       default that DataTables uses (incrementally increased for each column).</li>
             *     <li>string - read an object property from the data source. Note that you can
             *       use Javascript dotted notation to read deep properties / arrays from the
             *       data source.</li>
             *     <li>null - the sDefaultContent option will be used for the cell (null
             *       by default, so you will need to specify the default content you want -
             *       typically an empty string). This can be useful on generated columns such
             *       as edit / delete action columns.</li>
             *     <li>function - the function given will be executed whenever DataTables
             *       needs to set or get the data for a cell in the column. The function
             *       takes three parameters:
             *       <ul>
             *         <li>{array|object} The data source for the row</li>
             *         <li>{string} The type call data requested - this will be 'set' when
             *           setting data or 'filter', 'display', 'type', 'sort' or undefined when
             *           gathering data. Note that when <i>undefined</i> is given for the type
             *           DataTables expects to get the raw data for the object back</li>
             *         <li>{*} Data to set when the second parameter is 'set'.</li>
             *       </ul>
             *       The return value from the function is not required when 'set' is the type
             *       of call, but otherwise the return is what will be used for the data
             *       requested.</li>
             *    </ul>
             *
             * Note that prior to DataTables 1.9.2 mData was called mDataProp. The name change
             * reflects the flexibility of this property and is consistent with the naming of
             * mRender. If 'mDataProp' is given, then it will still be used by DataTables, as
             * it automatically maps the old name to the new if required.
             *  @type string|int|function|null
             *  @default null <i>Use automatically calculated column index</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Read table data from objects
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          { "mData": "platform.inner" },
		 *          { "mData": "platform.details.0" },
		 *          { "mData": "platform.details.1" }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using mData as a function to provide different information for
             *    // sorting, filtering and display. In this case, currency (price)
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "mData": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort', 'type' and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
             */
            "mData": null,


            /**
             * This property is the rendering partner to mData and it is suggested that
             * when you want to manipulate data for display (including filtering, sorting etc)
             * but not altering the underlying data for the table, use this property. mData
             * can actually do everything this property can and more, but this parameter is
             * easier to use since there is no 'set' option. Like mData is can be given
             * in a number of different ways to effect its behaviour, with the addition of
             * supporting array syntax for easy outputting of arrays (including arrays of
             * objects):
             *   <ul>
             *     <li>integer - treated as an array index for the data source. This is the
             *       default that DataTables uses (incrementally increased for each column).</li>
             *     <li>string - read an object property from the data source. Note that you can
             *       use Javascript dotted notation to read deep properties / arrays from the
             *       data source and also array brackets to indicate that the data reader should
             *       loop over the data source array. When characters are given between the array
             *       brackets, these characters are used to join the data source array together.
             *       For example: "accounts[, ].name" would result in a comma separated list with
             *       the 'name' value from the 'accounts' array of objects.</li>
             *     <li>function - the function given will be executed whenever DataTables
             *       needs to set or get the data for a cell in the column. The function
             *       takes three parameters:
             *       <ul>
             *         <li>{array|object} The data source for the row (based on mData)</li>
             *         <li>{string} The type call data requested - this will be 'filter', 'display',
             *           'type' or 'sort'.</li>
             *         <li>{array|object} The full data source for the row (not based on mData)</li>
             *       </ul>
             *       The return value from the function is what will be used for the data
             *       requested.</li>
             *    </ul>
             *  @type string|int|function|null
             *  @default null <i>Use mData</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Create a comma separated list from an array of objects
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mData": "engine" },
		 *          { "mData": "browser" },
		 *          {
		 *            "mData": "platform",
		 *            "mRender": "[, ].name"
		 *          }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Use as a function to create a link from the data source
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *        {
		 *          "aTargets": [ 0 ],
		 *          "mData": "download_link",
		 *          "mRender": function ( data, type, full ) {
		 *            return '<a href="'+data+'">Download</a>';
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
            "mRender": null,


            /**
             * Change the cell type created for the column - either TD cells or TH cells. This
             * can be useful as TH cells have semantic meaning in the table body, allowing them
             * to act as a header for a row (you may wish to add scope='row' to the TH elements).
             *  @type string
             *  @default td
             *  @dtopt Columns
             *
             *  @example
             *    // Make the first column use TH cells
             *    $(document).ready( function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [ 0 ],
		 *          "sCellType": "th"
		 *        } ]
		 *      } );
		 *    } );
             */
            "sCellType": "td",


            /**
             * Class to give to each cell in this column.
             *  @type string
             *  @default <i>Empty string</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sClass": "my_class", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sClass": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "sClass": "",

            /**
             * When DataTables calculates the column widths to assign to each column,
             * it finds the longest string in each column and then constructs a
             * temporary table and reads the widths from that. The problem with this
             * is that "mmm" is much wider then "iiii", but the latter is a longer
             * string - thus the calculation can go wrong (doing it properly and putting
             * it into an DOM object and measuring that is horribly(!) slow). Thus as
             * a "work around" we provide this option. It will append its value to the
             * text that is found to be the longest string for the column - i.e. padding.
             * Generally you shouldn't need this, and it is not documented on the
             * general DataTables.net documentation
             *  @type string
             *  @default <i>Empty string<i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "sContentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
             */
            "sContentPadding": "",


            /**
             * Allows a default value to be given for a column's data, and will be used
             * whenever a null data source is encountered (this can be because mData
             * is set to null, or because the data source itself is null).
             *  @type string
             *  @default null
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit",
		 *            "aTargets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "mData": null,
		 *            "sDefaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
             */
            "sDefaultContent": null,


            /**
             * This parameter is only used in DataTables' server-side processing. It can
             * be exceptionally useful to know what columns are being displayed on the
             * client side, and to map these to database fields. When defined, the names
             * also allow DataTables to reorder information from the server if it comes
             * back in an unexpected order (i.e. if you switch your columns around on the
             * client-side, your server-side code does not also need updating).
             *  @type string
             *  @default <i>Empty string</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sName": "engine", "aTargets": [ 0 ] },
		 *          { "sName": "browser", "aTargets": [ 1 ] },
		 *          { "sName": "platform", "aTargets": [ 2 ] },
		 *          { "sName": "version", "aTargets": [ 3 ] },
		 *          { "sName": "grade", "aTargets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sName": "engine" },
		 *          { "sName": "browser" },
		 *          { "sName": "platform" },
		 *          { "sName": "version" },
		 *          { "sName": "grade" }
		 *        ]
		 *      } );
		 *    } );
             */
            "sName": "",


            /**
             * Defines a data source type for the sorting which can be used to read
             * real-time information from the table (updating the internally cached
             * version) prior to sorting. This allows sorting to occur on user editable
             * elements such as form inputs.
             *  @type string
             *  @default std
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "sSortDataType": "dom-text", "aTargets": [ 2, 3 ] },
		 *          { "sType": "numeric", "aTargets": [ 3 ] },
		 *          { "sSortDataType": "dom-select", "aTargets": [ 4 ] },
		 *          { "sSortDataType": "dom-checkbox", "aTargets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          null,
		 *          { "sSortDataType": "dom-text" },
		 *          { "sSortDataType": "dom-text", "sType": "numeric" },
		 *          { "sSortDataType": "dom-select" },
		 *          { "sSortDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
             */
            "sSortDataType": "std",


            /**
             * The title of this column.
             *  @type string
             *  @default null <i>Derived from the 'TH' value for this column in the
             *    original HTML table.</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sTitle": "My column title", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sTitle": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "sTitle": null,


            /**
             * The type allows you to specify how the data for this column will be sorted.
             * Four types (string, numeric, date and html (which will strip HTML tags
             * before sorting)) are currently available. Note that only date formats
             * understood by Javascript's Date() object will be accepted as type date. For
             * example: "Mar 26, 2008 5:03 PM". May take the values: 'string', 'numeric',
             * 'date' or 'html' (by default). Further types can be adding through
             * plug-ins.
             *  @type string
             *  @default null <i>Auto-detected from raw data</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sType": "html", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sType": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "sType": null,


            /**
             * Defining the width of the column, this parameter may take any CSS value
             * (3em, 20px etc). DataTables apples 'smart' widths to columns which have not
             * been given a specific width through this interface ensuring that the table
             * remains readable.
             *  @type string
             *  @default null <i>Automatic</i>
             *  @dtopt Columns
             *
             *  @example
             *    // Using aoColumnDefs
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sWidth": "20%", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
             *
             *  @example
             *    // Using aoColumns
             *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sWidth": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
             */
            "sWidth": null
        };


        /**
         * DataTables settings object - this holds all the information needed for a
         * given table, including configuration, data and current application of the
         * table options. DataTables does not have a single instance for each DataTable
         * with the settings attached to that instance, but rather instances of the
         * DataTable "class" are created on-the-fly as needed (typically by a
         * $().dataTable() call) and the settings object is then applied to that
         * instance.
         *
         * Note that this object is related to {@link DataTable.defaults} but this
         * one is the internal data store for DataTables's cache of columns. It should
         * NOT be manipulated outside of DataTables. Any configuration should be done
         * through the initialisation options.
         *  @namespace
         *  @todo Really should attach the settings object to individual instances so we
         *    don't need to create new instances on each $().dataTable() call (if the
         *    table already exists). It would also save passing oSettings around and
         *    into every single function. However, this is a very significant
         *    architecture change for DataTables and will almost certainly break
         *    backwards compatibility with older installations. This is something that
         *    will be done in 2.0.
         */
        DataTable.models.oSettings = {
            /**
             * Primary features of DataTables and their enablement state.
             *  @namespace
             */
            "oFeatures": {

                /**
                 * Flag to say if DataTables should automatically try to calculate the
                 * optimum table and columns widths (true) or not (false).
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bAutoWidth": null,

                /**
                 * Delay the creation of TR and TD elements until they are actually
                 * needed by a driven page draw. This can give a significant speed
                 * increase for Ajax source and Javascript source data, but makes no
                 * difference at all fro DOM and server-side processing tables.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bDeferRender": null,

                /**
                 * Enable filtering on the table or not. Note that if this is disabled
                 * then there is no filtering at all on the table, including fnFilter.
                 * To just remove the filtering input use sDom and remove the 'f' option.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bFilter": null,

                /**
                 * Table information element (the 'Showing x of y records' div) enable
                 * flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bInfo": null,

                /**
                 * Present a user control allowing the end user to change the page size
                 * when pagination is enabled.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bLengthChange": null,

                /**
                 * Pagination enabled or not. Note that if this is disabled then length
                 * changing must also be disabled.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bPaginate": null,

                /**
                 * Processing indicator enable flag whenever DataTables is enacting a
                 * user request - typically an Ajax request for server-side processing.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bProcessing": null,

                /**
                 * Server-side processing enabled flag - when enabled DataTables will
                 * get all data from the server for every draw - there is no filtering,
                 * sorting or paging done on the client-side.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bServerSide": null,

                /**
                 * Sorting enablement flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bSort": null,

                /**
                 * Apply a class to the columns which are being sorted to provide a
                 * visual highlight or not. This can slow things down when enabled since
                 * there is a lot of DOM interaction.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bSortClasses": null,

                /**
                 * State saving enablement flag.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bStateSave": null
            },


            /**
             * Scrolling settings for a table.
             *  @namespace
             */
            "oScroll": {
                /**
                 * Indicate if DataTables should be allowed to set the padding / margin
                 * etc for the scrolling header elements or not. Typically you will want
                 * this.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bAutoCss": null,

                /**
                 * When the table is shorter in height than sScrollY, collapse the
                 * table container down to the height of the table (when true).
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bCollapse": null,

                /**
                 * Infinite scrolling enablement flag. Now deprecated in favour of
                 * using the Scroller plug-in.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type boolean
                 */
                "bInfinite": null,

                /**
                 * Width of the scrollbar for the web-browser's platform. Calculated
                 * during table initialisation.
                 *  @type int
                 *  @default 0
                 */
                "iBarWidth": 0,

                /**
                 * Space (in pixels) between the bottom of the scrolling container and
                 * the bottom of the scrolling viewport before the next page is loaded
                 * when using infinite scrolling.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type int
                 */
                "iLoadGap": null,

                /**
                 * Viewport width for horizontal scrolling. Horizontal scrolling is
                 * disabled if an empty string.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 */
                "sX": null,

                /**
                 * Width to expand the table to when using x-scrolling. Typically you
                 * should not need to use this.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 *  @deprecated
                 */
                "sXInner": null,

                /**
                 * Viewport height for vertical scrolling. Vertical scrolling is disabled
                 * if an empty string.
                 * Note that this parameter will be set by the initialisation routine. To
                 * set a default use {@link DataTable.defaults}.
                 *  @type string
                 */
                "sY": null
            },

            /**
             * Language information for the table.
             *  @namespace
             *  @extends DataTable.defaults.oLanguage
             */
            "oLanguage": {
                /**
                 * Information callback function. See
                 * {@link DataTable.defaults.fnInfoCallback}
                 *  @type function
                 *  @default null
                 */
                "fnInfoCallback": null
            },

            /**
             * Browser support parameters
             *  @namespace
             */
            "oBrowser": {
                /**
                 * Indicate if the browser incorrectly calculates width:100% inside a
                 * scrolling element (IE6/7)
                 *  @type boolean
                 *  @default false
                 */
                "bScrollOversize": false
            },

            /**
             * Array referencing the nodes which are used for the features. The
             * parameters of this object match what is allowed by sDom - i.e.
             *   <ul>
             *     <li>'l' - Length changing</li>
             *     <li>'f' - Filtering input</li>
             *     <li>'t' - The table!</li>
             *     <li>'i' - Information</li>
             *     <li>'p' - Pagination</li>
             *     <li>'r' - pRocessing</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aanFeatures": [],

            /**
             * Store data information - see {@link DataTable.models.oRow} for detailed
             * information.
             *  @type array
             *  @default []
             */
            "aoData": [],

            /**
             * Array of indexes which are in the current display (after filtering etc)
             *  @type array
             *  @default []
             */
            "aiDisplay": [],

            /**
             * Array of indexes for display - no filtering
             *  @type array
             *  @default []
             */
            "aiDisplayMaster": [],

            /**
             * Store information about each column that is in use
             *  @type array
             *  @default []
             */
            "aoColumns": [],

            /**
             * Store information about the table's header
             *  @type array
             *  @default []
             */
            "aoHeader": [],

            /**
             * Store information about the table's footer
             *  @type array
             *  @default []
             */
            "aoFooter": [],

            /**
             * Search data array for regular expression searching
             *  @type array
             *  @default []
             */
            "asDataSearch": [],

            /**
             * Store the applied global search information in case we want to force a
             * research or compare the old search to a new one.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @namespace
             *  @extends DataTable.models.oSearch
             */
            "oPreviousSearch": {},

            /**
             * Store the applied search for each column - see
             * {@link DataTable.models.oSearch} for the format that is used for the
             * filtering information for each column.
             *  @type array
             *  @default []
             */
            "aoPreSearchCols": [],

            /**
             * Sorting that is applied to the table. Note that the inner arrays are
             * used in the following manner:
             * <ul>
             *   <li>Index 0 - column number</li>
             *   <li>Index 1 - current sorting direction</li>
             *   <li>Index 2 - index of asSorting for this column</li>
             * </ul>
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @todo These inner arrays should really be objects
             */
            "aaSorting": null,

            /**
             * Sorting that is always applied to the table (i.e. prefixed in front of
             * aaSorting).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array|null
             *  @default null
             */
            "aaSortingFixed": null,

            /**
             * Classes to use for the striping of a table.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @default []
             */
            "asStripeClasses": null,

            /**
             * If restoring a table - we should restore its striping classes as well
             *  @type array
             *  @default []
             */
            "asDestroyStripes": [],

            /**
             * If restoring a table - we should restore its width
             *  @type int
             *  @default 0
             */
            "sDestroyWidth": 0,

            /**
             * Callback functions array for every time a row is inserted (i.e. on a draw).
             *  @type array
             *  @default []
             */
            "aoRowCallback": [],

            /**
             * Callback functions for the header on each draw.
             *  @type array
             *  @default []
             */
            "aoHeaderCallback": [],

            /**
             * Callback function for the footer on each draw.
             *  @type array
             *  @default []
             */
            "aoFooterCallback": [],

            /**
             * Array of callback functions for draw callback functions
             *  @type array
             *  @default []
             */
            "aoDrawCallback": [],

            /**
             * Array of callback functions for row created function
             *  @type array
             *  @default []
             */
            "aoRowCreatedCallback": [],

            /**
             * Callback functions for just before the table is redrawn. A return of
             * false will be used to cancel the draw.
             *  @type array
             *  @default []
             */
            "aoPreDrawCallback": [],

            /**
             * Callback functions for when the table has been initialised.
             *  @type array
             *  @default []
             */
            "aoInitComplete": [],


            /**
             * Callbacks for modifying the settings to be stored for state saving, prior to
             * saving state.
             *  @type array
             *  @default []
             */
            "aoStateSaveParams": [],

            /**
             * Callbacks for modifying the settings that have been stored for state saving
             * prior to using the stored values to restore the state.
             *  @type array
             *  @default []
             */
            "aoStateLoadParams": [],

            /**
             * Callbacks for operating on the settings object once the saved state has been
             * loaded
             *  @type array
             *  @default []
             */
            "aoStateLoaded": [],

            /**
             * Cache the table ID for quick access
             *  @type string
             *  @default <i>Empty string</i>
             */
            "sTableId": "",

            /**
             * The TABLE node for the main table
             *  @type node
             *  @default null
             */
            "nTable": null,

            /**
             * Permanent ref to the thead element
             *  @type node
             *  @default null
             */
            "nTHead": null,

            /**
             * Permanent ref to the tfoot element - if it exists
             *  @type node
             *  @default null
             */
            "nTFoot": null,

            /**
             * Permanent ref to the tbody element
             *  @type node
             *  @default null
             */
            "nTBody": null,

            /**
             * Cache the wrapper node (contains all DataTables controlled elements)
             *  @type node
             *  @default null
             */
            "nTableWrapper": null,

            /**
             * Indicate if when using server-side processing the loading of data
             * should be deferred until the second draw.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             *  @default false
             */
            "bDeferLoading": false,

            /**
             * Indicate if all required information has been read in
             *  @type boolean
             *  @default false
             */
            "bInitialised": false,

            /**
             * Information about open rows. Each object in the array has the parameters
             * 'nTr' and 'nParent'
             *  @type array
             *  @default []
             */
            "aoOpenRows": [],

            /**
             * Dictate the positioning of DataTables' control elements - see
             * {@link DataTable.model.oInit.sDom}.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default null
             */
            "sDom": null,

            /**
             * Which type of pagination should be used.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default two_button
             */
            "sPaginationType": "two_button",

            /**
             * The cookie duration (for bStateSave) in seconds.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type int
             *  @default 0
             */
            "iCookieDuration": 0,

            /**
             * The cookie name prefix.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default <i>Empty string</i>
             */
            "sCookiePrefix": "",

            /**
             * Callback function for cookie creation.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type function
             *  @default null
             */
            "fnCookieCallback": null,

            /**
             * Array of callback functions for state saving. Each array element is an
             * object with the following parameters:
             *   <ul>
             *     <li>function:fn - function to call. Takes two parameters, oSettings
             *       and the JSON string to save that has been thus far created. Returns
             *       a JSON string to be inserted into a json object
             *       (i.e. '"param": [ 0, 1, 2]')</li>
             *     <li>string:sName - name of callback</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aoStateSave": [],

            /**
             * Array of callback functions for state loading. Each array element is an
             * object with the following parameters:
             *   <ul>
             *     <li>function:fn - function to call. Takes two parameters, oSettings
             *       and the object stored. May return false to cancel state loading</li>
             *     <li>string:sName - name of callback</li>
             *   </ul>
             *  @type array
             *  @default []
             */
            "aoStateLoad": [],

            /**
             * State that was loaded from the cookie. Useful for back reference
             *  @type object
             *  @default null
             */
            "oLoadedState": null,

            /**
             * Source url for AJAX data for the table.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @default null
             */
            "sAjaxSource": null,

            /**
             * Property from a given object from which to read the table data from. This
             * can be an empty string (when not server-side processing), in which case
             * it is  assumed an an array is given directly.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sAjaxDataProp": null,

            /**
             * Note if draw should be blocked while getting data
             *  @type boolean
             *  @default true
             */
            "bAjaxDataGet": true,

            /**
             * The last jQuery XHR object that was used for server-side data gathering.
             * This can be used for working with the XHR information in one of the
             * callbacks
             *  @type object
             *  @default null
             */
            "jqXHR": null,

            /**
             * Function to get the server-side data.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type function
             */
            "fnServerData": null,

            /**
             * Functions which are called prior to sending an Ajax request so extra
             * parameters can easily be sent to the server
             *  @type array
             *  @default []
             */
            "aoServerParams": [],

            /**
             * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
             * required).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sServerMethod": null,

            /**
             * Format numbers for display.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type function
             */
            "fnFormatNumber": null,

            /**
             * List of options that can be used for the user selectable length menu.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type array
             *  @default []
             */
            "aLengthMenu": null,

            /**
             * Counter for the draws that the table does. Also used as a tracker for
             * server-side processing
             *  @type int
             *  @default 0
             */
            "iDraw": 0,

            /**
             * Indicate if a redraw is being done - useful for Ajax
             *  @type boolean
             *  @default false
             */
            "bDrawing": false,

            /**
             * Draw index (iDraw) of the last error when parsing the returned data
             *  @type int
             *  @default -1
             */
            "iDrawError": -1,

            /**
             * Paging display length
             *  @type int
             *  @default 10
             */
            "_iDisplayLength": 10,

            /**
             * Paging start point - aiDisplay index
             *  @type int
             *  @default 0
             */
            "_iDisplayStart": 0,

            /**
             * Paging end point - aiDisplay index. Use fnDisplayEnd rather than
             * this property to get the end point
             *  @type int
             *  @default 10
             *  @private
             */
            "_iDisplayEnd": 10,

            /**
             * Server-side processing - number of records in the result set
             * (i.e. before filtering), Use fnRecordsTotal rather than
             * this property to get the value of the number of records, regardless of
             * the server-side processing setting.
             *  @type int
             *  @default 0
             *  @private
             */
            "_iRecordsTotal": 0,

            /**
             * Server-side processing - number of records in the current display set
             * (i.e. after filtering). Use fnRecordsDisplay rather than
             * this property to get the value of the number of records, regardless of
             * the server-side processing setting.
             *  @type boolean
             *  @default 0
             *  @private
             */
            "_iRecordsDisplay": 0,

            /**
             * Flag to indicate if jQuery UI marking and classes should be used.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bJUI": null,

            /**
             * The classes to use for the table
             *  @type object
             *  @default {}
             */
            "oClasses": {},

            /**
             * Flag attached to the settings object so you can check in the draw
             * callback if filtering has been done in the draw. Deprecated in favour of
             * events.
             *  @type boolean
             *  @default false
             *  @deprecated
             */
            "bFiltered": false,

            /**
             * Flag attached to the settings object so you can check in the draw
             * callback if sorting has been done in the draw. Deprecated in favour of
             * events.
             *  @type boolean
             *  @default false
             *  @deprecated
             */
            "bSorted": false,

            /**
             * Indicate that if multiple rows are in the header and there is more than
             * one unique cell per column, if the top one (true) or bottom one (false)
             * should be used for sorting / title by DataTables.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bSortCellsTop": null,

            /**
             * Initialisation object that is used for the table
             *  @type object
             *  @default null
             */
            "oInit": null,

            /**
             * Destroy callback functions - for plug-ins to attach themselves to the
             * destroy so they can clean up markup and events.
             *  @type array
             *  @default []
             */
            "aoDestroyCallback": [],


            /**
             * Get the number of records in the current record set, before filtering
             *  @type function
             */
            "fnRecordsTotal": function () {
                if (this.oFeatures.bServerSide) {
                    return parseInt(this._iRecordsTotal, 10);
                } else {
                    return this.aiDisplayMaster.length;
                }
            },

            /**
             * Get the number of records in the current record set, after filtering
             *  @type function
             */
            "fnRecordsDisplay": function () {
                if (this.oFeatures.bServerSide) {
                    return parseInt(this._iRecordsDisplay, 10);
                } else {
                    return this.aiDisplay.length;
                }
            },

            /**
             * Set the display end point - aiDisplay index
             *  @type function
             *  @todo Should do away with _iDisplayEnd and calculate it on-the-fly here
             */
            "fnDisplayEnd": function () {
                if (this.oFeatures.bServerSide) {
                    if (this.oFeatures.bPaginate === false || this._iDisplayLength == -1) {
                        return this._iDisplayStart + this.aiDisplay.length;
                    } else {
                        return Math.min(this._iDisplayStart + this._iDisplayLength,
                            this._iRecordsDisplay);
                    }
                } else {
                    return this._iDisplayEnd;
                }
            },

            /**
             * The DataTables object for this table
             *  @type object
             *  @default null
             */
            "oInstance": null,

            /**
             * Unique identifier for each instance of the DataTables object. If there
             * is an ID on the table node, then it takes that value, otherwise an
             * incrementing internal counter is used.
             *  @type string
             *  @default null
             */
            "sInstance": null,

            /**
             * tabindex attribute value that is added to DataTables control elements, allowing
             * keyboard navigation of the table and its controls.
             */
            "iTabIndex": 0,

            /**
             * DIV container for the footer scrolling table if scrolling
             */
            "nScrollHead": null,

            /**
             * DIV container for the footer scrolling table if scrolling
             */
            "nScrollFoot": null
        };

        /**
         * Extension object for DataTables that is used to provide all extension options.
         *
         * Note that the <i>DataTable.ext</i> object is available through
         * <i>jQuery.fn.dataTable.ext</i> where it may be accessed and manipulated. It is
         * also aliased to <i>jQuery.fn.dataTableExt</i> for historic reasons.
         *  @namespace
         *  @extends DataTable.models.ext
         */
        DataTable.ext = $.extend(true, {}, DataTable.models.ext);

        $.extend(DataTable.ext.oStdClasses, {
            "sTable": "dataTable",

            /* Two buttons buttons */
            "sPagePrevEnabled": "paginate_enabled_previous",
            "sPagePrevDisabled": "paginate_disabled_previous",
            "sPageNextEnabled": "paginate_enabled_next",
            "sPageNextDisabled": "paginate_disabled_next",
            "sPageJUINext": "",
            "sPageJUIPrev": "",

            /* Full numbers paging buttons */
            "sPageButton": "paginate_button",
            "sPageButtonActive": "paginate_active",
            "sPageButtonStaticDisabled": "paginate_button paginate_button_disabled",
            "sPageFirst": "first",
            "sPagePrevious": "previous",
            "sPageNext": "next",
            "sPageLast": "last",

            /* Striping classes */
            "sStripeOdd": "odd",
            "sStripeEven": "even",

            /* Empty row */
            "sRowEmpty": "dataTables_empty",

            /* Features */
            "sWrapper": "dataTables_wrapper",
            "sFilter": "dataTables_filter",
            "sInfo": "dataTables_info",
            "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
            "sLength": "dataTables_length",
            "sProcessing": "dataTables_processing",

            /* Sorting */
            "sSortAsc": "sorting_asc",
            "sSortDesc": "sorting_desc",
            "sSortable": "sorting", /* Sortable in both directions */
            "sSortableAsc": "sorting_asc_disabled",
            "sSortableDesc": "sorting_desc_disabled",
            "sSortableNone": "sorting_disabled",
            "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
            "sSortJUIAsc": "",
            "sSortJUIDesc": "",
            "sSortJUI": "",
            "sSortJUIAscAllowed": "",
            "sSortJUIDescAllowed": "",
            "sSortJUIWrapper": "",
            "sSortIcon": "",

            /* Scrolling */
            "sScrollWrapper": "dataTables_scroll",
            "sScrollHead": "dataTables_scrollHead",
            "sScrollHeadInner": "dataTables_scrollHeadInner",
            "sScrollBody": "dataTables_scrollBody",
            "sScrollFoot": "dataTables_scrollFoot",
            "sScrollFootInner": "dataTables_scrollFootInner",

            /* Misc */
            "sFooterTH": "",
            "sJUIHeader": "",
            "sJUIFooter": ""
        });


        $.extend(DataTable.ext.oJUIClasses, DataTable.ext.oStdClasses, {
            /* Two buttons buttons */
            "sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
            "sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
            "sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
            "sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
            "sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
            "sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",

            /* Full numbers paging buttons */
            "sPageButton": "fg-button ui-button ui-state-default",
            "sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
            "sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
            "sPageFirst": "first ui-corner-tl ui-corner-bl",
            "sPageLast": "last ui-corner-tr ui-corner-br",

            /* Features */
            "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " +
            "ui-buttonset-multi paging_", /* Note that the type is postfixed */

            /* Sorting */
            "sSortAsc": "ui-state-default",
            "sSortDesc": "ui-state-default",
            "sSortable": "ui-state-default",
            "sSortableAsc": "ui-state-default",
            "sSortableDesc": "ui-state-default",
            "sSortableNone": "ui-state-default",
            "sSortJUIAsc": "css_right ui-icon ui-icon-triangle-1-n",
            "sSortJUIDesc": "css_right ui-icon ui-icon-triangle-1-s",
            "sSortJUI": "css_right ui-icon ui-icon-carat-2-n-s",
            "sSortJUIAscAllowed": "css_right ui-icon ui-icon-carat-1-n",
            "sSortJUIDescAllowed": "css_right ui-icon ui-icon-carat-1-s",
            "sSortJUIWrapper": "DataTables_sort_wrapper",
            "sSortIcon": "DataTables_sort_icon",

            /* Scrolling */
            "sScrollHead": "dataTables_scrollHead ui-state-default",
            "sScrollFoot": "dataTables_scrollFoot ui-state-default",

            /* Misc */
            "sFooterTH": "ui-state-default",
            "sJUIHeader": "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix",
            "sJUIFooter": "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix"
        });

        /*
         * Variable: oPagination
         * Purpose:  
         * Scope:    jQuery.fn.dataTableExt
         */
        $.extend(DataTable.ext.oPagination, {
            /*
             * Variable: two_button
             * Purpose:  Standard two button (forward/back) pagination
             * Scope:    jQuery.fn.dataTableExt.oPagination
             */
            "two_button": {
                /*
                 * Function: oPagination.two_button.fnInit
                 * Purpose:  Initialise dom elements required for pagination with forward/back buttons only
                 * Returns:  -
                 * Inputs:   object:oSettings - dataTables settings object
                 *           node:nPaging - the DIV which contains this pagination control
                 *           function:fnCallbackDraw - draw function which must be called on update
                 */
                "fnInit": function (oSettings, nPaging, fnCallbackDraw) {
                    var oLang = oSettings.oLanguage.oPaginate;
                    var oClasses = oSettings.oClasses;
                    var fnClickHandler = function (e) {
                        if (oSettings.oApi._fnPageChange(oSettings, e.data.action)) {
                            fnCallbackDraw(oSettings);
                        }
                    };

                    var sAppend = (!oSettings.bJUI) ?
                    '<a class="' + oSettings.oClasses.sPagePrevDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button">' + oLang.sPrevious + '</a>' +
                    '<a class="' + oSettings.oClasses.sPageNextDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button">' + oLang.sNext + '</a>'
                        :
                    '<a class="' + oSettings.oClasses.sPagePrevDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button"><span class="' + oSettings.oClasses.sPageJUIPrev + '"></span></a>' +
                    '<a class="' + oSettings.oClasses.sPageNextDisabled + '" tabindex="' + oSettings.iTabIndex + '" role="button"><span class="' + oSettings.oClasses.sPageJUINext + '"></span></a>';
                    $(nPaging).append(sAppend);

                    var els = $('a', nPaging);
                    var nPrevious = els[0],
                        nNext = els[1];

                    oSettings.oApi._fnBindAction(nPrevious, {action: "previous"}, fnClickHandler);
                    oSettings.oApi._fnBindAction(nNext, {action: "next"}, fnClickHandler);

                    /* ID the first elements only */
                    if (!oSettings.aanFeatures.p) {
                        nPaging.id = oSettings.sTableId + '_paginate';
                        nPrevious.id = oSettings.sTableId + '_previous';
                        nNext.id = oSettings.sTableId + '_next';

                        nPrevious.setAttribute('aria-controls', oSettings.sTableId);
                        nNext.setAttribute('aria-controls', oSettings.sTableId);
                    }
                },

                /*
                 * Function: oPagination.two_button.fnUpdate
                 * Purpose:  Update the two button pagination at the end of the draw
                 * Returns:  -
                 * Inputs:   object:oSettings - dataTables settings object
                 *           function:fnCallbackDraw - draw function to call on page change
                 */
                "fnUpdate": function (oSettings, fnCallbackDraw) {
                    if (!oSettings.aanFeatures.p) {
                        return;
                    }

                    var oClasses = oSettings.oClasses;
                    var an = oSettings.aanFeatures.p;
                    var nNode;

                    /* Loop over each instance of the pager */
                    for (var i = 0, iLen = an.length; i < iLen; i++) {
                        nNode = an[i].firstChild;
                        if (nNode) {
                            /* Previous page */
                            nNode.className = ( oSettings._iDisplayStart === 0 ) ?
                                oClasses.sPagePrevDisabled : oClasses.sPagePrevEnabled;

                            /* Next page */
                            nNode = nNode.nextSibling;
                            nNode.className = ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) ?
                                oClasses.sPageNextDisabled : oClasses.sPageNextEnabled;
                        }
                    }
                }
            },


            /*
             * Variable: iFullNumbersShowPages
             * Purpose:  Change the number of pages which can be seen
             * Scope:    jQuery.fn.dataTableExt.oPagination
             */
            "iFullNumbersShowPages": 5,

            /*
             * Variable: full_numbers
             * Purpose:  Full numbers pagination
             * Scope:    jQuery.fn.dataTableExt.oPagination
             */
            "full_numbers": {
                /*
                 * Function: oPagination.full_numbers.fnInit
                 * Purpose:  Initialise dom elements required for pagination with a list of the pages
                 * Returns:  -
                 * Inputs:   object:oSettings - dataTables settings object
                 *           node:nPaging - the DIV which contains this pagination control
                 *           function:fnCallbackDraw - draw function which must be called on update
                 */
                "fnInit": function (oSettings, nPaging, fnCallbackDraw) {
                    var oLang = oSettings.oLanguage.oPaginate;
                    var oClasses = oSettings.oClasses;
                    var fnClickHandler = function (e) {
                        if (oSettings.oApi._fnPageChange(oSettings, e.data.action)) {
                            fnCallbackDraw(oSettings);
                        }
                    };

                    $(nPaging).append(
                        '<a  tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageFirst + '">' + oLang.sFirst + '</a>' +
                        '<a  tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPagePrevious + '">' + oLang.sPrevious + '</a>' +
                        '<span></span>' +
                        '<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageNext + '">' + oLang.sNext + '</a>' +
                        '<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + " " + oClasses.sPageLast + '">' + oLang.sLast + '</a>'
                    );
                    var els = $('a', nPaging);
                    var nFirst = els[0],
                        nPrev = els[1],
                        nNext = els[2],
                        nLast = els[3];

                    oSettings.oApi._fnBindAction(nFirst, {action: "first"}, fnClickHandler);
                    oSettings.oApi._fnBindAction(nPrev, {action: "previous"}, fnClickHandler);
                    oSettings.oApi._fnBindAction(nNext, {action: "next"}, fnClickHandler);
                    oSettings.oApi._fnBindAction(nLast, {action: "last"}, fnClickHandler);

                    /* ID the first elements only */
                    if (!oSettings.aanFeatures.p) {
                        nPaging.id = oSettings.sTableId + '_paginate';
                        nFirst.id = oSettings.sTableId + '_first';
                        nPrev.id = oSettings.sTableId + '_previous';
                        nNext.id = oSettings.sTableId + '_next';
                        nLast.id = oSettings.sTableId + '_last';
                    }
                },

                /*
                 * Function: oPagination.full_numbers.fnUpdate
                 * Purpose:  Update the list of page buttons shows
                 * Returns:  -
                 * Inputs:   object:oSettings - dataTables settings object
                 *           function:fnCallbackDraw - draw function to call on page change
                 */
                "fnUpdate": function (oSettings, fnCallbackDraw) {
                    if (!oSettings.aanFeatures.p) {
                        return;
                    }

                    var iPageCount = DataTable.ext.oPagination.iFullNumbersShowPages;
                    var iPageCountHalf = Math.floor(iPageCount / 2);
                    var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
                    var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
                    var sList = "";
                    var iStartButton, iEndButton, i, iLen;
                    var oClasses = oSettings.oClasses;
                    var anButtons, anStatic, nPaginateList, nNode;
                    var an = oSettings.aanFeatures.p;
                    var fnBind = function (j) {
                        oSettings.oApi._fnBindAction(this, {"page": j + iStartButton - 1}, function (e) {
                            /* Use the information in the element to jump to the required page */
                            oSettings.oApi._fnPageChange(oSettings, e.data.page);
                            fnCallbackDraw(oSettings);
                            e.preventDefault();
                        });
                    };

                    /* Pages calculation */
                    if (oSettings._iDisplayLength === -1) {
                        iStartButton = 1;
                        iEndButton = 1;
                        iCurrentPage = 1;
                    }
                    else if (iPages < iPageCount) {
                        iStartButton = 1;
                        iEndButton = iPages;
                    }
                    else if (iCurrentPage <= iPageCountHalf) {
                        iStartButton = 1;
                        iEndButton = iPageCount;
                    }
                    else if (iCurrentPage >= (iPages - iPageCountHalf)) {
                        iStartButton = iPages - iPageCount + 1;
                        iEndButton = iPages;
                    }
                    else {
                        iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
                        iEndButton = iStartButton + iPageCount - 1;
                    }


                    /* Build the dynamic list */
                    for (i = iStartButton; i <= iEndButton; i++) {
                        sList += (iCurrentPage !== i) ?
                        '<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButton + '">' + oSettings.fnFormatNumber(i) + '</a>' :
                        '<a tabindex="' + oSettings.iTabIndex + '" class="' + oClasses.sPageButtonActive + '">' + oSettings.fnFormatNumber(i) + '</a>';
                    }

                    /* Loop over each instance of the pager */
                    for (i = 0, iLen = an.length; i < iLen; i++) {
                        nNode = an[i];
                        if (!nNode.hasChildNodes()) {
                            continue;
                        }

                        /* Build up the dynamic list first - html and listeners */
                        $('span:eq(0)', nNode)
                            .html(sList)
                            .children('a').each(fnBind);

                        /* Update the permanent button's classes */
                        anButtons = nNode.getElementsByTagName('a');
                        anStatic = [
                            anButtons[0], anButtons[1],
                            anButtons[anButtons.length - 2], anButtons[anButtons.length - 1]
                        ];

                        $(anStatic).removeClass(oClasses.sPageButton + " " + oClasses.sPageButtonActive + " " + oClasses.sPageButtonStaticDisabled);
                        $([anStatic[0], anStatic[1]]).addClass(
                            (iCurrentPage == 1) ?
                                oClasses.sPageButtonStaticDisabled :
                                oClasses.sPageButton
                        );
                        $([anStatic[2], anStatic[3]]).addClass(
                            (iPages === 0 || iCurrentPage === iPages || oSettings._iDisplayLength === -1) ?
                                oClasses.sPageButtonStaticDisabled :
                                oClasses.sPageButton
                        );
                    }
                }
            }
        });

        $.extend(DataTable.ext.oSort, {
            /*
             * text sorting
             */
            "string-pre": function (a) {
                if (typeof a != 'string') {
                    a = (a !== null && a.toString) ? a.toString() : '';
                }
                return a.toLowerCase();
            },

            "string-asc": function (x, y) {
                return ((x < y) ? -1 : ((x > y) ? 1 : 0));
            },

            "string-desc": function (x, y) {
                return ((x < y) ? 1 : ((x > y) ? -1 : 0));
            },


            /*
             * html sorting (ignore html tags)
             */
            "html-pre": function (a) {
                return a.replace(/<.*?>/g, "").toLowerCase();
            },

            "html-asc": function (x, y) {
                return ((x < y) ? -1 : ((x > y) ? 1 : 0));
            },

            "html-desc": function (x, y) {
                return ((x < y) ? 1 : ((x > y) ? -1 : 0));
            },


            /*
             * date sorting
             */
            "date-pre": function (a) {
                var x = Date.parse(a);

                if (isNaN(x) || x === "") {
                    x = Date.parse("01/01/1970 00:00:00");
                }
                return x;
            },

            "date-asc": function (x, y) {
                return x - y;
            },

            "date-desc": function (x, y) {
                return y - x;
            },


            /*
             * numerical sorting
             */
            "numeric-pre": function (a) {
                return (a == "-" || a === "") ? 0 : a * 1;
            },

            "numeric-asc": function (x, y) {
                return x - y;
            },

            "numeric-desc": function (x, y) {
                return y - x;
            }
        });


        $.extend(DataTable.ext.aTypes, [
            /*
             * Function: -
             * Purpose:  Check to see if a string is numeric
             * Returns:  string:'numeric' or null
             * Inputs:   mixed:sText - string to check
             */
            function (sData) {
                /* Allow zero length strings as a number */
                if (typeof sData === 'number') {
                    return 'numeric';
                }
                else if (typeof sData !== 'string') {
                    return null;
                }

                var sValidFirstChars = "0123456789-";
                var sValidChars = "0123456789.";
                var Char;
                var bDecimal = false;

                /* Check for a valid first char (no period and allow negatives) */
                Char = sData.charAt(0);
                if (sValidFirstChars.indexOf(Char) == -1) {
                    return null;
                }

                /* Check all the other characters are valid */
                for (var i = 1; i < sData.length; i++) {
                    Char = sData.charAt(i);
                    if (sValidChars.indexOf(Char) == -1) {
                        return null;
                    }

                    /* Only allowed one decimal place... */
                    if (Char == ".") {
                        if (bDecimal) {
                            return null;
                        }
                        bDecimal = true;
                    }
                }

                return 'numeric';
            },

            /*
             * Function: -
             * Purpose:  Check to see if a string is actually a formatted date
             * Returns:  string:'date' or null
             * Inputs:   string:sText - string to check
             */
            function (sData) {
                var iParse = Date.parse(sData);
                if ((iParse !== null && !isNaN(iParse)) || (typeof sData === 'string' && sData.length === 0)) {
                    return 'date';
                }
                return null;
            },

            /*
             * Function: -
             * Purpose:  Check to see if a string should be treated as an HTML string
             * Returns:  string:'html' or null
             * Inputs:   string:sText - string to check
             */
            function (sData) {
                if (typeof sData === 'string' && sData.indexOf('<') != -1 && sData.indexOf('>') != -1) {
                    return 'html';
                }
                return null;
            }
        ]);


        // jQuery aliases
        $.fn.DataTable = DataTable;
        $.fn.dataTable = DataTable;
        $.fn.dataTableSettings = DataTable.settings;
        $.fn.dataTableExt = DataTable.ext;


        // Information about events fired by DataTables - for documentation.
        /**
         * Draw event, fired whenever the table is redrawn on the page, at the same point as
         * fnDrawCallback. This may be useful for binding events or performing calculations when
         * the table is altered at all.
         *  @name DataTable#draw
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Filter event, fired when the filtering applied to the table (using the build in global
         * global filter, or column filters) is altered.
         *  @name DataTable#filter
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Page change event, fired when the paging of the table is altered.
         *  @name DataTable#page
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * Sort event, fired when the sorting applied to the table is altered.
         *  @name DataTable#sort
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */

        /**
         * DataTables initialisation complete event, fired when the table is fully drawn,
         * including Ajax data loaded, if Ajax data is required.
         *  @name DataTable#init
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The JSON object request from the server - only
         *    present if client-side Ajax sourced data is used</li></ol>
         */

        /**
         * State save event, fired when the table has changed state a new state save is required.
         * This method allows modification of the state saving object prior to actually doing the
         * save, including addition or other state properties (for plug-ins) or modification
         * of a DataTables core property.
         *  @name DataTable#stateSaveParams
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The state information to be saved
         */

        /**
         * State load event, fired when the table is loading state from the stored data, but
         * prior to the settings object being modified by the saved state - allowing modification
         * of the saved state is required or loading of state for a plug-in.
         *  @name DataTable#stateLoadParams
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The saved state information
         */

        /**
         * State loaded event, fired when state has been loaded from stored data and the settings
         * object has been modified by the loaded data.
         *  @name DataTable#stateLoaded
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The saved state information
         */

        /**
         * Processing event, fired when DataTables is doing some kind of processing (be it,
         * sort, filter or anything else). Can be used to indicate to the end user that
         * there is something happening, or that something has finished.
         *  @name DataTable#processing
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} oSettings DataTables settings object
         *  @param {boolean} bShow Flag for if DataTables is doing processing or not
         */

        /**
         * Ajax (XHR) event, fired whenever an Ajax request is completed from a request to
         * made to the server for new data (note that this trigger is called in fnServerData,
         * if you override fnServerData and which to use this event, you need to trigger it in
         * you success function).
         *  @name DataTable#xhr
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         *  @param {object} json JSON returned from the server
         */

        /**
         * Destroy event, fired when the DataTable is destroyed by calling fnDestroy or passing
         * the bDestroy:true parameter in the initialisation object. This can be used to remove
         * bound events, added DOM nodes, etc.
         *  @name DataTable#destroy
         *  @event
         *  @param {event} e jQuery event object
         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
         */
    }));

}(window, document));


//* http://datatables.net/blog/Twitter_Bootstrap_2
$.extend($.fn.dataTableExt.oStdClasses, {
    sWrapper: "datatable-wrapper form-inline",
    sFilter: "table-global-filter pull-right",
    sInfo: "table-message-info",
    sPaging: "btn-group paging_",
    sLength: "length pull-left",
    //sProcessing: 		"", 
    // Paging two button
    sPagePrevEnabled: "btn previous",
    sPagePrevDisabled: "btn previous disabled",
    sPageNextEnabled: "btn next",
    sPageNextDisabled: "btn next disabled",

    // Paginate full numbers
    sPageButton: "btn btn-boo",
    sPageButtonActive: "btn btn-sky active",
    sPageButtonStaticDisabled: "btn disabled",
    sPageFirst: "btn",
    sPageLast: "btn",
    sPageNext: "btn",
    sPageLast: "btn"
});

$.fn.dataTableExt.oApi.fnResetAllFilters = function (oSettings, bDraw /*default true*/) {
    for (iCol = 0; iCol < oSettings.aoPreSearchCols.length; iCol++) {
        oSettings.aoPreSearchCols[iCol].sSearch = '';
    }
    oSettings.oPreviousSearch.sSearch = '';

    if (typeof bDraw === 'undefined') bDraw = true;
    if (bDraw) this.fnDraw();
};

//usage:
//case 1
//clean all filter and redraw
//oDataTable.fnResetAllFilters();

//case 2
//clean all filter and set new filter and redraw
//oDataTable.fnResetAllFilters(false);     //reset all filter , do not redraw
//oDataTable.fnFilter("newkeyword", 4); //new filter and draw

//* Paging for Twitter Bootstrap 2
$.fn.dataTableExt.oApi.fnPagingInfo = function (b) {
    return {
        iStart: b._iDisplayStart,
        iEnd: b.fnDisplayEnd(),
        iLength: b._iDisplayLength,
        iTotal: b.fnRecordsTotal(),
        iFilteredTotal: b.fnRecordsDisplay(),
        iPage: Math.ceil(b._iDisplayStart / b._iDisplayLength),
        iTotalPages: Math.ceil(b.fnRecordsDisplay() / b._iDisplayLength)
    }
};
$.extend($.fn.dataTableExt.oPagination, {
    bootstrap: {
        fnInit: function (b, e, c) {
            var d = b.oLanguage.oPaginate,
                a = function (a) {
                    a.preventDefault();
                    b.oApi._fnPageChange(b, a.data.action) && c(b)
                };
            $(e).addClass("pagination").append('<ul><li class="prev disabled"><a href="#">&lt; ' + d.sPrevious + '</a></li><li class="next disabled"><a href="#">' + d.sNext + " &gt; </a></li></ul>");
            e = $("a", e);
            $(e[0]).bind("click.DT", {
                action: "previous"
            }, a);
            $(e[1]).bind("click.DT", {
                action: "next"
            }, a)
        },
        fnUpdate: function (b, e) {
            var c = b.oInstance.fnPagingInfo(),
                d = b.aanFeatures.p,
                a, g, i, f, h;
            a = Math.floor(2.5);
            5 > c.iTotalPages ? (f = 1, h = c.iTotalPages) : c.iPage <= a ? (f = 1, h = 5) : c.iPage >= c.iTotalPages - a ? (f = c.iTotalPages - 5 + 1, h = c.iTotalPages) : (f = c.iPage - a + 1, h = f + 5 - 1);
            a = 0;
            for (iLen = d.length; a < iLen; a++) {
                $("li:gt(0)", d[a]).filter(":not(:last)").remove();
                for (g = f; g <= h; g++) i = g == c.iPage + 1 ? 'class="active"' : "", $("<li " + i + '><a href="#">' + g + "</a></li>").insertBefore($("li:last", d[a])[0]).bind("click", function (a) {
                    a.preventDefault();
                    b._iDisplayStart = (parseInt($("a", this).text(), 10) - 1) * c.iLength;
                    e(b)
                });
                0 === c.iPage ? $("li:first", d[a]).addClass("disabled") : $("li:first", d[a]).removeClass("disabled");
                c.iPage === c.iTotalPages - 1 || 0 === c.iTotalPages ? $("li:last", d[a]).addClass("disabled") : $("li:last", d[a]).removeClass("disabled")
            }
        }
    }
});

//Commas for decimal place 
jQuery.fn.dataTableExt.oSort['numeric-comma-asc'] = function (a, b) {
    var x = (a == "-") ? 0 : a.replace(/,/, ".");
    var y = (b == "-") ? 0 : b.replace(/,/, ".");
    x = parseFloat(x);
    y = parseFloat(y);
    return ((x < y) ? -1 : ((x > y) ? 1 : 0));
};

jQuery.fn.dataTableExt.oSort['numeric-comma-desc'] = function (a, b) {
    var x = (a == "-") ? 0 : a.replace(/,/, ".");
    var y = (b == "-") ? 0 : b.replace(/,/, ".");
    x = parseFloat(x);
    y = parseFloat(y);
    return ((x < y) ? 1 : ((x > y) ? -1 : 0));
};

//Formatted numbers
jQuery.fn.dataTableExt.oSort['formatted-num-asc'] = function (x, y) {
    x = x.replace(/[^\d\-\.\/]/g, '');
    y = y.replace(/[^\d\-\.\/]/g, '');
    if (x.indexOf('/') >= 0)x = eval(x);
    if (y.indexOf('/') >= 0)y = eval(y);
    return x / 1 - y / 1;
}
jQuery.fn.dataTableExt.oSort['formatted-num-desc'] = function (x, y) {
    x = x.replace(/[^\d\-\.\/]/g, '');
    y = y.replace(/[^\d\-\.\/]/g, '');
    if (x.indexOf('/') >= 0)x = eval(x);
    if (y.indexOf('/') >= 0)y = eval(y);
    return y / 1 - x / 1;
}

// Date (dd . mm[ . YYYY]) 
function calculate_date(date) {
    var date = date.replace(" ", "");

    if (date.indexOf('.') > 0) {
        /*date a, format dd.mn.(yyyy) ; (year is optional)*/
        var eu_date = date.split('.');
    } else {
        /*date a, format dd/mn/(yyyy) ; (year is optional)*/
        var eu_date = date.split('/');
    }

    /*year (optional)*/
    if (eu_date[2]) {
        var year = eu_date[2];
    } else {
        var year = 0;
    }

    /*month*/
    var month = eu_date[1];
    if (month.length == 1) {
        month = 0 + month;
    }

    /*day*/
    var day = eu_date[0];
    if (day.length == 1) {
        day = 0 + day;
    }

    return (year + month + day) * 1;
}

jQuery.fn.dataTableExt.oSort['eu_date-asc'] = function (a, b) {
    x = calculate_date(a);
    y = calculate_date(b);

    return ((x < y) ? -1 : ((x > y) ? 1 : 0));
};

jQuery.fn.dataTableExt.oSort['eu_date-desc'] = function (a, b) {
    x = calculate_date(a);
    y = calculate_date(b);

    return ((x < y) ? 1 : ((x > y) ? -1 : 0));
};

//Automatic HTML type detection
jQuery.fn.dataTableExt.aTypes.push(
    function (sData) {
        return 'html';
    }
);

//Priority 
function fnPriority(a) {
    if (a == "High") {
        return 1;
    }
    else if (a == "Medium") {
        return 2;
    }
    else if (a == "Low") {
        return 3;
    }
    return 4;
}

jQuery.fn.dataTableExt.oSort['priority-asc'] = function (a, b) {
    var x = fnPriority(a);
    var y = fnPriority(b);

    return ((x < y) ? -1 : ((x > y) ? 1 : 0));
};

jQuery.fn.dataTableExt.oSort['priority-desc'] = function (a, b) {
    var x = fnPriority(a);
    var y = fnPriority(b);

    return ((x < y) ? 1 : ((x > y) ? -1 : 0));
};

/*
 * Natural Sort algorithm for Javascript - Version 0.6 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 * Contributors: Mike Grier (mgrier.com), Clint Priest, Kyle Adams, guillermo
 */
function naturalSort(a, b) {
    var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
        sre = /(^[ ]*|[ ]*$)/g,
        dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
        hre = /^0x[0-9a-f]+$/i,
        ore = /^0/,
    // convert all to strings and trim()
        x = a.toString().replace(sre, '') || '',
        y = b.toString().replace(sre, '') || '',
    // chunk/tokenize
        xN = x.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),
        yN = y.replace(re, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0'),
    // numeric, hex or date detection
        xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
        yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null;
    // first try and sort Hex codes or Dates
    if (yD)
        if (xD < yD) return -1;
        else if (xD > yD)    return 1;
    // natural sorting through split numeric strings and default strings
    for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        // find floats not starting with '0', string or 0 if not defined (Clint Priest)
        oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        // handle numeric vs string comparison - number < string - (Kyle Adams)
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) return (isNaN(oFxNcL)) ? 1 : -1;
        // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
        else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += '';
            oFyNcL += '';
        }
        if (oFxNcL < oFyNcL) return -1;
        if (oFxNcL > oFyNcL) return 1;
    }
    return 0;
}

jQuery.fn.dataTableExt.oSort['natural-asc'] = function (a, b) {
    return naturalSort(a, b);
};

jQuery.fn.dataTableExt.oSort['natural-desc'] = function (a, b) {
    return naturalSort(a, b) * -1;
};


/*
 * File:        dataTables.scroller.min.js
 * Version:     1.1.0
 * Author:      Allan Jardine (www.sprymedia.co.uk)
 * 
 * Copyright 2011 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD (3 point) style license, as supplied with this software.
 * 
 * This source file is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 */
/*
 GPL v2 or BSD 3 point style
 @contact     www.sprymedia.co.uk/contact

 @copyright Copyright 2011-2012 Allan Jardine, all rights reserved.

 This source file is free software, under either the GPL v2 license or a
 BSD style license, available at:
 http://datatables.net/license_gpl2
 http://datatables.net/license_bsd
 */
(function (d, h, g) {
    var e = function (a, b) {
        !this instanceof e ? alert("Scroller warning: Scroller must be initialised with the 'new' keyword.") : ("undefined" == typeof b && (b = {}), this.s = {
            dt: a,
            tableTop: 0,
            tableBottom: 0,
            redrawTop: 0,
            redrawBottom: 0,
            rowHeight: null,
            autoHeight: !0,
            viewportHeight: 0,
            viewportRows: 0,
            stateTO: null,
            drawTO: null
        }, this.s = d.extend(this.s, e.oDefaults, b), this.dom = {
            force: g.createElement("div"),
            scroller: null,
            table: null
        }, this.s.dt.oScroller = this, this._fnConstruct())
    };
    e.prototype = {
        fnRowToPixels: function (a) {
            return a *
                this.s.rowHeight
        }, fnPixelsToRow: function (a) {
            return parseInt(a / this.s.rowHeight, 10)
        }, fnScrollToRow: function (a, b) {
            var c = this.fnRowToPixels(a);
            "undefined" == typeof b || b ? d(this.dom.scroller).animate({scrollTop: c}) : d(this.dom.scroller).scrollTop(c)
        }, fnMeasure: function (a) {
            this.s.autoHeight && this._fnCalcRowHeight();
            this.s.viewportHeight = d(this.dom.scroller).height();
            this.s.viewportRows = parseInt(this.s.viewportHeight / this.s.rowHeight, 10) + 1;
            this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;
            this.s.trace && console.log("Row height: " + this.s.rowHeight + " Viewport height: " + this.s.viewportHeight + " Viewport rows: " + this.s.viewportRows + " Display rows: " + this.s.dt._iDisplayLength);
            ("undefined" == typeof a || a) && this.s.dt.oInstance.fnDraw()
        }, _fnConstruct: function () {
            var a = this;
            this.dom.force.style.position = "absolute";
            this.dom.force.style.top = "0px";
            this.dom.force.style.left = "0px";
            this.dom.force.style.width = "1px";
            this.dom.scroller = d("div." + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];
            this.dom.scroller.appendChild(this.dom.force);
            this.dom.scroller.style.position = "relative";
            this.dom.table = d(">table", this.dom.scroller)[0];
            this.dom.table.style.position = "absolute";
            this.dom.table.style.top = "0px";
            this.dom.table.style.left = "0px";
            d(this.s.dt.nTableWrapper).addClass("DTS");
            this.s.loadingIndicator && d(this.dom.scroller.parentNode).css("position", "relative").append('<div class="DTS_Loading">' + this.s.dt.oLanguage.sLoadingRecords + "</div>");
            this.s.rowHeight && "auto" != this.s.rowHeight && (this.s.autoHeight = !1);
            this.fnMeasure(!1);
            d(this.dom.scroller).scroll(function () {
                a._fnScroll.call(a)
            });
            d(this.dom.scroller).bind("touchstart", function () {
                a._fnScroll.call(a)
            });
            this.s.dt.aoDrawCallback.push({
                fn: function () {
                    a.s.dt.bInitialised && a._fnDrawCallback.call(a)
                }, sName: "Scroller"
            });
            this.s.dt.oApi._fnCallbackReg(this.s.dt, "aoStateSaveParams", function (b, c) {
                c.iScroller = a.dom.scroller.scrollTop
            }, "Scroller_State")
        }, _fnScroll: function () {
            var a = this, b = this.dom.scroller.scrollTop, c;
            if (!this.s.dt.bFiltered && !this.s.dt.bSorted &&
                (this.s.trace && console.log("Scroll: " + b + "px - boundaries: " + this.s.redrawTop + " / " + this.s.redrawBottom + ".  Showing rows " + this.fnPixelsToRow(b) + " to " + this.fnPixelsToRow(b + d(this.dom.scroller).height()) + " in the viewport, with rows " + this.s.dt._iDisplayStart + " to " + this.s.dt._iDisplayEnd + " rendered by the DataTable"), this._fnInfo(), clearTimeout(this.s.stateTO), this.s.stateTO = setTimeout(function () {
                    a.s.dt.oApi._fnSaveState(a.s.dt)
                }, 250), b < this.s.redrawTop || b > this.s.redrawBottom)) {
                var f = (this.s.displayBuffer -
                    1) / 2 * this.s.viewportRows;
                c = parseInt(b / this.s.rowHeight, 10) - f;
                0 > c ? c = 0 : c + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay() ? (c = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength, 0 > c && (c = 0)) : 0 !== c % 2 && c++;
                c != this.s.dt._iDisplayStart && (this.s.tableTop = d(this.s.dt.nTable).offset().top, this.s.tableBottom = d(this.s.dt.nTable).height() + this.s.tableTop, this.s.dt.oFeatures.bServerSide ? (clearTimeout(this.s.drawTO), this.s.drawTO = setTimeout(function () {
                    a.s.dt._iDisplayStart = c;
                    a.s.dt.oApi._fnCalculateEnd(a.s.dt);
                    a.s.dt.oApi._fnDraw(a.s.dt)
                }, this.s.serverWait)) : (this.s.dt._iDisplayStart = c, this.s.dt.oApi._fnCalculateEnd(this.s.dt), this.s.dt.oApi._fnDraw(this.s.dt)), this.s.trace && console.log("Scroll forcing redraw - top DT render row: " + c))
            }
        }, _fnDrawCallback: function () {
            var a = this, b = this.dom.scroller.scrollTop, c = b + this.s.viewportHeight;
            this.dom.force.style.height = this.s.rowHeight * this.s.dt.fnRecordsDisplay() + "px";
            var f = this.s.rowHeight * this.s.dt._iDisplayStart;
            0 === this.s.dt._iDisplayStart ? f = 0 : this.s.dt._iDisplayStart ===
            this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength && (f = this.s.rowHeight * this.s.dt._iDisplayStart);
            this.dom.table.style.top = f + "px";
            this.s.tableTop = f;
            this.s.tableBottom = d(this.s.dt.nTable).height() + this.s.tableTop;
            this.s.redrawTop = b - (b - this.s.tableTop) * this.s.boundaryScale;
            this.s.redrawBottom = b + (this.s.tableBottom - c) * this.s.boundaryScale;
            this.s.trace && console.log("Table redraw. Table top: " + f + "px Table bottom: " + this.s.tableBottom + " Scroll boundary top: " + this.s.redrawTop + " Scroll boundary bottom: " +
                this.s.redrawBottom + " Rows drawn: " + this.s.dt._iDisplayLength);
            setTimeout(function () {
                a._fnInfo.call(a)
            }, 0);
            this.s.dt.oFeatures.bStateSave && null !== this.s.dt.oLoadedState && "undefined" != typeof this.s.dt.oLoadedState.iScroller && (null !== this.s.dt.sAjaxSource && 2 == this.s.dt.iDraw || null === this.s.dt.sAjaxSource && 1 == this.s.dt.iDraw) && setTimeout(function () {
                d(a.dom.scroller).scrollTop(a.s.dt.oLoadedState.iScroller);
                a.s.redrawTop = a.s.dt.oLoadedState.iScroller - a.s.viewportHeight / 2
            }, 0)
        }, _fnCalcRowHeight: function () {
            var a =
                this.s.dt.nTable.cloneNode(!1), b = d('<div class="' + this.s.dt.oClasses.sWrapper + ' DTS"><div class="' + this.s.dt.oClasses.sScrollWrapper + '"><div class="' + this.s.dt.oClasses.sScrollBody + '"></div></div></div>')[0];
            d(a).append("<tbody><tr><td>&nbsp;</td></tr></tbody>");
            d("div." + this.s.dt.oClasses.sScrollBody, b).append(a);
            g.body.appendChild(b);
            this.s.rowHeight = d("tbody tr", a).outerHeight();
            g.body.removeChild(b)
        }, _fnInfo: function () {
            if (this.s.dt.oFeatures.bInfo) {
                var a = this.s.dt, b = this.dom.scroller.scrollTop,
                    c = this.fnPixelsToRow(b) + 1, f = a.fnRecordsTotal(), e = a.fnRecordsDisplay(), b = this.fnPixelsToRow(b + d(this.dom.scroller).height()), b = e < b ? e : b, c = a.fnFormatNumber(c), b = a.fnFormatNumber(b), f = a.fnFormatNumber(f), e = a.fnFormatNumber(e), e = 0 === a.fnRecordsDisplay() && a.fnRecordsDisplay() == a.fnRecordsTotal() ? a.oLanguage.sInfoEmpty + a.oLanguage.sInfoPostFix : 0 === a.fnRecordsDisplay() ? a.oLanguage.sInfoEmpty + " " + a.oLanguage.sInfoFiltered.replace("_MAX_", f) + a.oLanguage.sInfoPostFix : a.fnRecordsDisplay() == a.fnRecordsTotal() ?
                    a.oLanguage.sInfo.replace("_START_", c).replace("_END_", b).replace("_TOTAL_", e) + a.oLanguage.sInfoPostFix : a.oLanguage.sInfo.replace("_START_", c).replace("_END_", b).replace("_TOTAL_", e) + " " + a.oLanguage.sInfoFiltered.replace("_MAX_", a.fnFormatNumber(a.fnRecordsTotal())) + a.oLanguage.sInfoPostFix, a = a.aanFeatures.i;
                if ("undefined" != typeof a) {
                    f = 0;
                    for (c = a.length; f < c; f++)d(a[f]).html(e)
                }
            }
        }
    };
    e.oDefaults = {
        trace: !1,
        rowHeight: "auto",
        serverWait: 200,
        displayBuffer: 9,
        boundaryScale: 0.5,
        loadingIndicator: !1
    };
    e.prototype.CLASS =
        "Scroller";
    e.VERSION = "1.1.0";
    e.prototype.VERSION = e.VERSION;
    "function" == typeof d.fn.dataTable && "function" == typeof d.fn.dataTableExt.fnVersionCheck && d.fn.dataTableExt.fnVersionCheck("1.9.0") ? d.fn.dataTableExt.aoFeatures.push({
        fnInit: function (a) {
            return (new e(a, "undefined" == typeof a.oInit.oScroller ? {} : a.oInit.oScroller)).dom.wrapper
        }, cFeature: "S", sFeature: "Scroller"
    }) : alert("Warning: Scroller requires DataTables 1.9.0 or greater - www.datatables.net/download");
    d.fn.dataTable.Scroller = e
})(jQuery, window,
    document);


﻿/*
 * File:        jquery.dataTables.columnFilter.js
 * Version:     1.5.0.
 * Author:      Jovan Popovic 
 * http://jquery-datatables-column-filter.googlecode.com/svn/trunk/index.htmls
 * http://code.google.com/p/jquery-datatables-column-filter/
 * 
 * Copyright 2011-2012 Jovan Popovic, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, as supplied with this software.
 * 
 * This source file is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. 
 * 
 * Parameters:"
 * @sPlaceHolder                 String      Place where inline filtering function should be placed ("tfoot", "thead:before", "thead:after"). Default is "tfoot"
 * @sRangeSeparator              String      Separator that will be used when range values are sent to the server-side. Default value is "~".
 * @sRangeFormat                 string      Default format of the From ... to ... range inputs. Default is From {from} to {to}
 * @aoColumns                    Array       Array of the filter settings that will be applied on the columns
 */
(function ($) {


    $.fn.columnFilter = function (options) {

        var asInitVals, i, label, th;

        //var sTableId = "table";
        var sRangeFormat = "From {from} to {to}";
        //Array of the functions that will override sSearch_ parameters
        var afnSearch_ = new Array();
        var aiCustomSearch_Indexes = new Array();

        var oFunctionTimeout = null;

        var fnOnFiltered = function () {
        };

        function _fnGetColumnValues(oSettings, iColumn, bUnique, bFiltered, bIgnoreEmpty) {
            ///<summary>
            ///Return values in the column
            ///</summary>
            ///<param name="oSettings" type="Object">DataTables settings</param>
            ///<param name="iColumn" type="int">Id of the column</param>
            ///<param name="bUnique" type="bool">Return only distinct values</param>
            ///<param name="bFiltered" type="bool">Return values only from the filtered rows</param>
            ///<param name="bIgnoreEmpty" type="bool">Ignore empty cells</param>

            // check that we have a column id
            if (typeof iColumn == "undefined") return new Array();

            // by default we only wany unique data
            if (typeof bUnique == "undefined") bUnique = true;

            // by default we do want to only look at filtered data
            if (typeof bFiltered == "undefined") bFiltered = true;

            // by default we do not wany to include empty values
            if (typeof bIgnoreEmpty == "undefined") bIgnoreEmpty = true;

            // list of rows which we're going to loop through
            var aiRows;

            // use only filtered rows
            if (bFiltered == true) aiRows = oSettings.aiDisplay;
            // use all rows
            else aiRows = oSettings.aiDisplayMaster; // all row numbers

            // set up data array	
            var asResultData = new Array();

            for (var i = 0, c = aiRows.length; i < c; i++) {
                var iRow = aiRows[i];
                var aData = oTable.fnGetData(iRow);
                var sValue = aData[iColumn];

                // ignore empty values?
                if (bIgnoreEmpty == true && sValue.length == 0) continue;

                // ignore unique values?
                else if (bUnique == true && jQuery.inArray(sValue, asResultData) > -1) continue;

                // else push the value onto the result data array
                else asResultData.push(sValue);
            }

            return asResultData.sort();
        }

        function _fnColumnIndex(iColumnIndex) {
            if (properties.bUseColVis)
                return iColumnIndex;
            else
                return oTable.fnSettings().oApi._fnVisibleToColumnIndex(oTable.fnSettings(), iColumnIndex);
            //return iColumnIndex;
            //return oTable.fnSettings().oApi._fnColumnIndexToVisible(oTable.fnSettings(), iColumnIndex);
        }

        function fnCreateInput(oTable, regex, smart, bIsNumber, iFilterLength, iMaxLenght) {
            var sCSSClass = "text_filter";
            if (bIsNumber)
                sCSSClass = "number_filter";

            label = label.replace(/(^\s*)|(\s*$)/g, "");
            var currentFilter = oTable.fnSettings().aoPreSearchCols[i].sSearch;
            var search_init = 'search_init ';
            var inputvalue = label;
            if (currentFilter != '' && currentFilter != '^') {
                if (bIsNumber && currentFilter.charAt(0) == '^')
                    inputvalue = currentFilter.substr(1); //ignore trailing ^
                else
                    inputvalue = currentFilter;
                search_init = '';
            }

            var input = $('<input type="text" class="' + search_init + sCSSClass + '" value="' + inputvalue + '"/>');
            if (iMaxLenght != undefined && iMaxLenght != -1) {
                input.attr('maxlength', iMaxLenght);
            }
            th.html(input);
            if (bIsNumber)
                th.wrapInner('<span class="filter_column filter_number" />');
            else
                th.wrapInner('<span class="filter_column filter_text" />');

            asInitVals[i] = label;
            var index = i;

            if (bIsNumber && !oTable.fnSettings().oFeatures.bServerSide) {
                input.keyup(function () {
                    /* Filter on the column all numbers that starts with the entered value */
                    oTable.fnFilter('^' + this.value, _fnColumnIndex(index), true, false); //Issue 37
                    fnOnFiltered();
                });
            } else {
                input.keyup(function () {
                    if (oTable.fnSettings().oFeatures.bServerSide && iFilterLength != 0) {
                        //If filter length is set in the server-side processing mode
                        //Check has the user entered at least iFilterLength new characters

                        var currentFilter = oTable.fnSettings().aoPreSearchCols[index].sSearch;
                        var iLastFilterLength = $(this).data("dt-iLastFilterLength");
                        if (typeof iLastFilterLength == "undefined")
                            iLastFilterLength = 0;
                        var iCurrentFilterLength = this.value.length;
                        if (Math.abs(iCurrentFilterLength - iLastFilterLength) < iFilterLength
                        //&& currentFilter.length == 0 //Why this?
                        ) {
                            //Cancel the filtering
                            return;
                        }
                        else {
                            //Remember the current filter length
                            $(this).data("dt-iLastFilterLength", iCurrentFilterLength);
                        }
                    }
                    /* Filter on the column (the index) of this element */
                    oTable.fnFilter(this.value, _fnColumnIndex(index), regex, smart); //Issue 37
                    fnOnFiltered();
                });
            }

            input.focus(function () {
                if ($(this).hasClass("search_init")) {
                    $(this).removeClass("search_init");
                    this.value = "";
                }
            });
            input.blur(function () {
                if (this.value == "") {
                    $(this).addClass("search_init");
                    this.value = asInitVals[index];
                }
            });
        }

        function fnCreateRangeInput(oTable) {

            //var currentFilter = oTable.fnSettings().aoPreSearchCols[i].sSearch;
            th.html(_fnRangeLabelPart(0));
            var sFromId = oTable.attr("id") + '_range_from_' + i;
            var from = $('<input type="text" class="number_range_filter" id="' + sFromId + '" rel="' + i + '"/>');
            th.append(from);
            th.append(_fnRangeLabelPart(1));
            var sToId = oTable.attr("id") + '_range_to_' + i;
            var to = $('<input type="text" class="number_range_filter" id="' + sToId + '" rel="' + i + '"/>');
            th.append(to);
            th.append(_fnRangeLabelPart(2));
            th.wrapInner('<span class="filter_column filter_number_range" />');
            var index = i;
            aiCustomSearch_Indexes.push(i);


            //------------start range filtering function


            /* 	Custom filtering function which will filter data in column four between two values
             *	Author: 	Allan Jardine, Modified by Jovan Popovic
             */
            //$.fn.dataTableExt.afnFiltering.push(
            oTable.dataTableExt.afnFiltering.push(
                function (oSettings, aData, iDataIndex) {
                    if (oTable.attr("id") != oSettings.sTableId)
                        return true;
                    // Try to handle missing nodes more gracefully
                    if (document.getElementById(sFromId) == null)
                        return true;
                    var iMin = document.getElementById(sFromId).value * 1;
                    var iMax = document.getElementById(sToId).value * 1;
                    var iValue = aData[_fnColumnIndex(index)] == "-" ? 0 : aData[_fnColumnIndex(index)] * 1;
                    if (iMin == "" && iMax == "") {
                        return true;
                    }
                    else if (iMin == "" && iValue <= iMax) {
                        return true;
                    }
                    else if (iMin <= iValue && "" == iMax) {
                        return true;
                    }
                    else if (iMin <= iValue && iValue <= iMax) {
                        return true;
                    }
                    return false;
                }
            );
            //------------end range filtering function


            $('#' + sFromId + ',#' + sToId, th).keyup(function () {

                var iMin = document.getElementById(sFromId).value * 1;
                var iMax = document.getElementById(sToId).value * 1;
                if (iMin != 0 && iMax != 0 && iMin > iMax)
                    return;

                oTable.fnDraw();
                fnOnFiltered();
            });


        }


        function fnCreateDateRangeInput(oTable) {

            var aoFragments = sRangeFormat.split(/[}{]/);

            th.html("");
            //th.html(_fnRangeLabelPart(0));
            var sFromId = oTable.attr("id") + '_range_from_' + i;
            var from = $('<input type="text" class="date_range_filter" id="' + sFromId + '" rel="' + i + '"/>');
            from.datepicker();
            //th.append(from);
            //th.append(_fnRangeLabelPart(1));
            var sToId = oTable.attr("id") + '_range_to_' + i;
            var to = $('<input type="text" class="date_range_filter" id="' + sToId + '" rel="' + i + '"/>');
            //th.append(to);
            //th.append(_fnRangeLabelPart(2));

            for (ti = 0; ti < aoFragments.length; ti++) {

                if (aoFragments[ti] == properties.sDateFromToken) {
                    th.append(from);
                } else {
                    if (aoFragments[ti] == properties.sDateToToken) {
                        th.append(to);
                    } else {
                        th.append(aoFragments[ti]);
                    }
                }


            }


            th.wrapInner('<span class="filter_column filter_date_range" />');
            to.datepicker();
            var index = i;
            aiCustomSearch_Indexes.push(i);


            //------------start date range filtering function

            //$.fn.dataTableExt.afnFiltering.push(
            oTable.dataTableExt.afnFiltering.push(
                function (oSettings, aData, iDataIndex) {
                    if (oTable.attr("id") != oSettings.sTableId)
                        return true;

                    var dStartDate = from.datepicker("getDate");

                    var dEndDate = to.datepicker("getDate");

                    if (dStartDate == null && dEndDate == null) {
                        return true;
                    }

                    var dCellDate = null;
                    try {
                        if (aData[_fnColumnIndex(index)] == null || aData[_fnColumnIndex(index)] == "")
                            return false;
                        dCellDate = $.datepicker.parseDate($.datepicker.regional[""].dateFormat, aData[_fnColumnIndex(index)]);
                    } catch (ex) {
                        return false;
                    }
                    if (dCellDate == null)
                        return false;


                    if (dStartDate == null && dCellDate <= dEndDate) {
                        return true;
                    }
                    else if (dStartDate <= dCellDate && dEndDate == null) {
                        return true;
                    }
                    else if (dStartDate <= dCellDate && dCellDate <= dEndDate) {
                        return true;
                    }
                    return false;
                }
            );
            //------------end date range filtering function

            $('#' + sFromId + ',#' + sToId, th).change(function () {
                oTable.fnDraw();
                fnOnFiltered();
            });


        }

        function fnCreateColumnSelect(oTable, aData, iColumn, nTh, sLabel, bRegex, oSelected) {
            if (aData == null)
                aData = _fnGetColumnValues(oTable.fnSettings(), iColumn, true, false, true);
            var index = iColumn;
            var currentFilter = oTable.fnSettings().aoPreSearchCols[i].sSearch;
            if (currentFilter == null || currentFilter == "")//Issue 81
                currentFilter = oSelected;

            var r = '<select class="search_init select_filter"><option value="" class="search_init">' + sLabel + '</option>';
            var j = 0;
            var iLen = aData.length;
            for (j = 0; j < iLen; j++) {
                if (typeof (aData[j]) != 'object') {
                    var selected = '';
                    if (escape(aData[j]) == currentFilter
                        || escape(aData[j]) == escape(currentFilter)
                    )
                        selected = 'selected '
                    r += '<option ' + selected + ' value="' + escape(aData[j]) + '">' + aData[j] + '</option>';
                }
                else {
                    var selected = '';
                    if (bRegex) {
                        //Do not escape values if they are explicitely set to avoid escaping special characters in the regexp
                        if (aData[j].value == currentFilter) selected = 'selected ';
                        r += '<option ' + selected + 'value="' + aData[j].value + '">' + aData[j].label + '</option>';
                    } else {
                        if (escape(aData[j].value) == currentFilter) selected = 'selected ';
                        r += '<option ' + selected + 'value="' + escape(aData[j].value) + '">' + aData[j].label + '</option>';
                    }
                }
            }

            var select = $(r + '</select>');
            nTh.html(select);
            nTh.wrapInner('<span class="filter_column filter_select" />');
            select.change(function () {
                //var val = $(this).val();
                if ($(this).val() != "") {
                    $(this).removeClass("search_init");
                } else {
                    $(this).addClass("search_init");
                }
                if (bRegex)
                    oTable.fnFilter($(this).val(), iColumn, bRegex); //Issue 41
                else
                    oTable.fnFilter(unescape($(this).val()), iColumn); //Issue 25
                fnOnFiltered();
            });
            if (currentFilter != null && currentFilter != "")//Issue 81
                oTable.fnFilter(unescape(currentFilter), iColumn);
        }

        function fnCreateSelect(oTable, aData, bRegex, oSelected) {
            var oSettings = oTable.fnSettings();
            if (aData == null && oSettings.sAjaxSource != "" && !oSettings.oFeatures.bServerSide) {
                // Add a function to the draw callback, which will check for the Ajax data having 
                // been loaded. Use a closure for the individual column elements that are used to 
                // built the column filter, since 'i' and 'th' (etc) are locally "global".
                oSettings.aoDrawCallback.push({
                    "fn": (function (iColumn, nTh, sLabel) {
                        return function () {
                            // Only rebuild the select on the second draw - i.e. when the Ajax
                            // data has been loaded.
                            if (oSettings.iDraw == 2 && oSettings.sAjaxSource != null && oSettings.sAjaxSource != "" && !oSettings.oFeatures.bServerSide) {
                                return fnCreateColumnSelect(oTable, null, _fnColumnIndex(iColumn), nTh, sLabel, bRegex, oSelected); //Issue 37
                            }
                        };
                    })(i, th, label),
                    "sName": "column_filter_" + i
                });
            }
            // Regardless of the Ajax state, build the select on first pass
            fnCreateColumnSelect(oTable, aData, _fnColumnIndex(i), th, label, bRegex, oSelected); //Issue 37

        }

        function fnCreateCheckbox(oTable, aData) {

            if (aData == null)
                aData = _fnGetColumnValues(oTable.fnSettings(), i, true, true, true);
            var index = i;

            var r = '', j, iLen = aData.length;

            //clean the string
            var localLabel = label.replace('%', 'Perc').replace("&", "AND").replace("$", "DOL").replace("£", "STERL").replace("@", "AT").replace(/\s/g, "_");
            localLabel = localLabel.replace(/[^a-zA-Z 0-9]+/g, '');
            //clean the string

            //button label override
            var labelBtn = label;
            if (properties.sFilterButtonText != null || properties.sFilterButtonText != undefined) {
                labelBtn = properties.sFilterButtonText;
            }

            var relativeDivWidthToggleSize = 10;
            var numRow = 12; //numero di checkbox per colonna
            var numCol = Math.floor(iLen / numRow);
            if (iLen % numRow > 0) {
                numCol = numCol + 1;
            }
            ;

            //count how many column should be generated and split the div size
            var divWidth = 100 / numCol - 2;

            var divWidthToggle = relativeDivWidthToggleSize * numCol;

            if (numCol == 1) {
                divWidth = 20;
            }

            var divRowDef = '<div style="float:left; min-width: ' + divWidth + '%; " >';
            var divClose = '</div>';

            var uniqueId = oTable.attr("id") + localLabel;
            var buttonId = "chkBtnOpen" + uniqueId;
            var checkToggleDiv = uniqueId + "-flt-toggle";
            r += '<button id="' + buttonId + '" class="checkbox_filter" > ' + labelBtn + '</button>'; //filter button witch open dialog
            r += '<div id="' + checkToggleDiv + '" '
                + 'title="' + label + '" '
                + 'class="toggle-check ui-widget-content ui-corner-all"  style="width: ' + (divWidthToggle) + '%; " >'; //dialog div
            //r+= '<div align="center" style="margin-top: 5px; "> <button id="'+buttonId+'Reset" class="checkbox_filter" > reset </button> </div>'; //reset button and its div
            r += divRowDef;

            for (j = 0; j < iLen; j++) {

                //if last check close div
                if (j % numRow == 0 && j != 0) {
                    r += divClose + divRowDef;
                }

                //check button
                r += '<input class="search_init checkbox_filter" type="checkbox" id= "' + aData[j] + '" name= "' + localLabel + '" value="' + aData[j] + '" >' + aData[j] + '<br/>';

                var checkbox = $(r);
                th.html(checkbox);
                th.wrapInner('<span class="filter_column filter_checkbox" />');
                //on every checkbox selection
                checkbox.change(function () {

                    var search = '';
                    var or = '|'; //var for select checks in 'or' into the regex
                    var resSize = $('input:checkbox[name="' + localLabel + '"]:checked').size();
                    $('input:checkbox[name="' + localLabel + '"]:checked').each(function (index) {

                        //search = search + ' ' + $(this).val();
                        //concatenation for selected checks in or
                        if ((index == 0 && resSize == 1)
                            || (index != 0 && index == resSize - 1)) {
                            or = '';
                        }
                        //trim
                        search = search.replace(/^\s+|\s+$/g, "");
                        search = search + $(this).val() + or;
                        or = '|';

                    });

                    for (var jj = 0; jj < iLen; jj++) {
                        if (search != "") {
                            $('#' + aData[jj]).removeClass("search_init");
                        } else {
                            $('#' + aData[jj]).addClass("search_init");
                        }
                    }

                    //execute search
                    oTable.fnFilter(search, index, true, false);
                    fnOnFiltered();
                });
            }

            //filter button
            $('#' + buttonId).button();
            //dialog
            $('#' + checkToggleDiv).dialog({
                //height: 140,
                autoOpen: false,
                //show: "blind",
                hide: "blind",
                buttons: [{
                    text: "Reset",
                    click: function () {
                        //$('#'+buttonId).removeClass("filter_selected"); //LM remove border if filter selected
                        $('input:checkbox[name="' + localLabel + '"]:checked').each(function (index3) {
                            $(this).attr('checked', false);
                            $(this).addClass("search_init");
                        });
                        oTable.fnFilter('', index, true, false);
                        fnOnFiltered();
                        return false;
                    }
                },
                    {
                        text: "Close",
                        click: function () {
                            $(this).dialog("close");
                        }
                    }
                ]
            });


            $('#' + buttonId).click(function () {

                $('#' + checkToggleDiv).dialog('open');
                var target = $(this);
                $('#' + checkToggleDiv).dialog("widget").position({
                    my: 'top',
                    at: 'bottom',
                    of: target
                });

                return false;
            });

            var fnOnFilteredCurrent = fnOnFiltered;

            fnOnFiltered = function () {
                var target = $('#' + buttonId);
                $('#' + checkToggleDiv).dialog("widget").position({
                    my: 'top',
                    at: 'bottom',
                    of: target
                });
                fnOnFilteredCurrent();
            };
            //reset
            /*
             $('#'+buttonId+"Reset").button();
             $('#'+buttonId+"Reset").click(function(){
             $('#'+buttonId).removeClass("filter_selected"); //LM remove border if filter selected
             $('input:checkbox[name="'+localLabel+'"]:checked').each(function(index3) {
             $(this).attr('checked', false);
             $(this).addClass("search_init");
             });
             oTable.fnFilter('', index, true, false);
             return false;
             }); 
             */
        }


        function _fnRangeLabelPart(iPlace) {
            switch (iPlace) {
                case 0:
                    return sRangeFormat.substring(0, sRangeFormat.indexOf("{from}"));
                case 1:
                    return sRangeFormat.substring(sRangeFormat.indexOf("{from}") + 6, sRangeFormat.indexOf("{to}"));
                default:
                    return sRangeFormat.substring(sRangeFormat.indexOf("{to}") + 4);
            }
        }


        var oTable = this;

        var defaults = {
            sPlaceHolder: "foot",
            sRangeSeparator: "~",
            iFilteringDelay: 500,
            aoColumns: null,
            sRangeFormat: "From {from} to {to}",
            sDateFromToken: "from",
            sDateToToken: "to"
        };

        var properties = $.extend(defaults, options);

        return this.each(function () {

            if (!oTable.fnSettings().oFeatures.bFilter)
                return;
            asInitVals = new Array();

            var aoFilterCells = oTable.fnSettings().aoFooter[0];

            var oHost = oTable.fnSettings().nTFoot; //Before fix for ColVis
            var sFilterRow = "tr"; //Before fix for ColVis

            if (properties.sPlaceHolder == "head:after") {
                var tr = $("tr:first", oTable.fnSettings().nTHead).detach();
                //tr.appendTo($(oTable.fnSettings().nTHead));
                if (oTable.fnSettings().bSortCellsTop) {
                    tr.prependTo($(oTable.fnSettings().nTHead));
                    //tr.appendTo($("thead", oTable));
                    aoFilterCells = oTable.fnSettings().aoHeader[1];
                }
                else {
                    tr.appendTo($(oTable.fnSettings().nTHead));
                    //tr.prependTo($("thead", oTable));
                    aoFilterCells = oTable.fnSettings().aoHeader[0];
                }

                sFilterRow = "tr:last";
                oHost = oTable.fnSettings().nTHead;

            } else if (properties.sPlaceHolder == "head:before") {

                if (oTable.fnSettings().bSortCellsTop) {
                    var tr = $("tr:first", oTable.fnSettings().nTHead).detach();
                    tr.appendTo($(oTable.fnSettings().nTHead));
                    aoFilterCells = oTable.fnSettings().aoHeader[1];
                } else {
                    aoFilterCells = oTable.fnSettings().aoHeader[0];
                }
                /*else {
                 //tr.prependTo($("thead", oTable));
                 sFilterRow = "tr:first";
                 }*/

                sFilterRow = "tr:first";

                oHost = oTable.fnSettings().nTHead;


            }

            //$(sFilterRow + " th", oHost).each(function (index) {//bug with ColVis
            $(aoFilterCells).each(function (index) {//fix for ColVis
                i = index;
                var aoColumn = {
                    type: "text",
                    bRegex: false,
                    bSmart: true,
                    iMaxLenght: -1,
                    iFilterLength: 0
                };
                if (properties.aoColumns != null) {
                    if (properties.aoColumns.length < i || properties.aoColumns[i] == null)
                        return;
                    aoColumn = properties.aoColumns[i];
                }
                //label = $(this).text(); //Before fix for ColVis
                label = $($(this)[0].cell).text(); //Fix for ColVis
                if (aoColumn.sSelector == null) {
                    //th = $($(this)[0]);//Before fix for ColVis
                    th = $($(this)[0].cell); //Fix for ColVis
                }
                else {
                    th = $(aoColumn.sSelector);
                    if (th.length == 0)
                        th = $($(this)[0].cell);
                }

                if (aoColumn != null) {
                    if (aoColumn.sRangeFormat != null)
                        sRangeFormat = aoColumn.sRangeFormat;
                    else
                        sRangeFormat = properties.sRangeFormat;
                    switch (aoColumn.type) {
                        case "null":
                            break;
                        case "number":
                            fnCreateInput(oTable, true, false, true, aoColumn.iFilterLength, aoColumn.iMaxLenght);
                            break;
                        case "select":
                            if (aoColumn.bRegex != true)
                                aoColumn.bRegex = false;
                            fnCreateSelect(oTable, aoColumn.values, aoColumn.bRegex, aoColumn.selected);
                            break;
                        case "number-range":
                            fnCreateRangeInput(oTable);
                            break;
                        case "date-range":
                            fnCreateDateRangeInput(oTable);
                            break;
                        case "checkbox":
                            fnCreateCheckbox(oTable, aoColumn.values);
                            break;
                        case "text":
                        default:
                            bRegex = (aoColumn.bRegex == null ? false : aoColumn.bRegex);
                            bSmart = (aoColumn.bSmart == null ? false : aoColumn.bSmart);
                            fnCreateInput(oTable, bRegex, bSmart, false, aoColumn.iFilterLength, aoColumn.iMaxLenght);
                            break;

                    }
                }
            });

            for (j = 0; j < aiCustomSearch_Indexes.length; j++) {
                //var index = aiCustomSearch_Indexes[j];
                var fnSearch_ = function () {
                    var id = oTable.attr("id");
                    return $("#" + id + "_range_from_" + aiCustomSearch_Indexes[j]).val() + properties.sRangeSeparator + $("#" + id + "_range_to_" + aiCustomSearch_Indexes[j]).val()
                }
                afnSearch_.push(fnSearch_);
            }

            if (oTable.fnSettings().oFeatures.bServerSide) {

                var fnServerDataOriginal = oTable.fnSettings().fnServerData;

                oTable.fnSettings().fnServerData = function (sSource, aoData, fnCallback) {

                    for (j = 0; j < aiCustomSearch_Indexes.length; j++) {
                        var index = aiCustomSearch_Indexes[j];

                        for (k = 0; k < aoData.length; k++) {
                            if (aoData[k].name == "sSearch_" + index)
                                aoData[k].value = afnSearch_[j]();
                        }
                    }
                    aoData.push({"name": "sRangeSeparator", "value": properties.sRangeSeparator});

                    if (fnServerDataOriginal != null) {
                        try {
                            fnServerDataOriginal(sSource, aoData, fnCallback, oTable.fnSettings()); //TODO: See Issue 18
                        } catch (ex) {
                            fnServerDataOriginal(sSource, aoData, fnCallback);
                        }
                    }
                    else {
                        $.getJSON(sSource, aoData, function (json) {
                            fnCallback(json)
                        });
                    }
                };

            }

        });

    };


})(jQuery);
/* jquery.sparkline 2.1 - http://omnipotent.net/jquery.sparkline/ 
 ** Licensed under the New BSD License - see above site for details */

(function (a) {
    typeof define == "function" && define.amd ? define(["jquery"], a) : a(jQuery)
})(function (a) {
    "use strict";
    var b = {}, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I = 0;
    c = function () {
        return {
            common: {
                type: "line",
                lineColor: "#00f",
                fillColor: "#cdf",
                defaultPixelsPerValue: 3,
                width: "auto",
                height: "auto",
                composite: !1,
                tagValuesAttribute: "values",
                tagOptionsPrefix: "spark",
                enableTagOptions: !1,
                enableHighlight: !0,
                highlightLighten: 1.4,
                tooltipSkipNull: !0,
                tooltipPrefix: "",
                tooltipSuffix: "",
                disableHiddenCheck: !1,
                numberFormatter: !1,
                numberDigitGroupCount: 3,
                numberDigitGroupSep: ",",
                numberDecimalMark: ".",
                disableTooltips: !1,
                disableInteraction: !1
            },
            line: {
                spotColor: "#f80",
                highlightSpotColor: "#5f5",
                highlightLineColor: "#f22",
                spotRadius: 1.5,
                minSpotColor: "#f80",
                maxSpotColor: "#f80",
                lineWidth: 1,
                normalRangeMin: undefined,
                normalRangeMax: undefined,
                normalRangeColor: "#ccc",
                drawNormalOnTop: !1,
                chartRangeMin: undefined,
                chartRangeMax: undefined,
                chartRangeMinX: undefined,
                chartRangeMaxX: undefined,
                tooltipFormat: new e('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
            },
            bar: {
                barColor: "#3366cc",
                negBarColor: "#f44",
                stackedBarColor: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"],
                zeroColor: undefined,
                nullColor: undefined,
                zeroAxis: !0,
                barWidth: 4,
                barSpacing: 1,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: !1,
                colorMap: undefined,
                tooltipFormat: new e('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
            },
            tristate: {
                barWidth: 4,
                barSpacing: 1,
                posBarColor: "#6f6",
                negBarColor: "#f44",
                zeroBarColor: "#999",
                colorMap: {},
                tooltipFormat: new e('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                tooltipValueLookups: {map: {"-1": "Loss", 0: "Draw", 1: "Win"}}
            },
            discrete: {
                lineHeight: "auto",
                thresholdColor: undefined,
                thresholdValue: 0,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: !1,
                tooltipFormat: new e("{{prefix}}{{value}}{{suffix}}")
            },
            bullet: {
                targetColor: "#f33",
                targetWidth: 3,
                performanceColor: "#33f",
                rangeColors: ["#d3dafe", "#a8b6ff", "#7f94ff"],
                base: undefined,
                tooltipFormat: new e("{{fieldkey:fields}} - {{value}}"),
                tooltipValueLookups: {fields: {r: "Range", p: "Performance", t: "Target"}}
            },
            pie: {
                offset: 0,
                sliceColors: ["#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099"],
                borderWidth: 0,
                borderColor: "#000",
                tooltipFormat: new e('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
            },
            box: {
                raw: !1,
                boxLineColor: "#000",
                boxFillColor: "#cdf",
                whiskerColor: "#000",
                outlierLineColor: "#333",
                outlierFillColor: "#fff",
                medianColor: "#f00",
                showOutliers: !0,
                outlierIQR: 1.5,
                spotRadius: 1.5,
                target: undefined,
                targetColor: "#4a2",
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                tooltipFormat: new e("{{field:fields}}: {{value}}"),
                tooltipFormatFieldlistKey: "field",
                tooltipValueLookups: {
                    fields: {
                        lq: "Lower Quartile",
                        med: "Median",
                        uq: "Upper Quartile",
                        lo: "Left Outlier",
                        ro: "Right Outlier",
                        lw: "Left Whisker",
                        rw: "Right Whisker"
                    }
                }
            }
        }
    }, B = '.jqstooltip { position: absolute;left: 0px;top: 0px;visibility: hidden;background: rgb(0, 0, 0) transparent;background-color: rgba(0,0,0,0.6);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";color: white;font: 10px arial, san serif;text-align: left;white-space: nowrap;padding: 5px;border: 1px solid white;z-index: 10000;}.jqsfield { color: white;font: 10px arial, san serif;text-align: left;}', d = function () {
        var b, c;
        return b = function () {
            this.init.apply(this, arguments)
        }, arguments.length > 1 ? (arguments[0] ? (b.prototype = a.extend(new arguments[0], arguments[arguments.length - 1]), b._super = arguments[0].prototype) : b.prototype = arguments[arguments.length - 1], arguments.length > 2 && (c = Array.prototype.slice.call(arguments, 1, -1), c.unshift(b.prototype), a.extend.apply(a, c))) : b.prototype = arguments[0], b.prototype.cls = b, b
    }, a.SPFormatClass = e = d({
        fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g, precre: /(\w+)\.(\d+)/, init: function (a, b) {
            this.format = a, this.fclass = b
        }, render: function (a, b, c) {
            var d = this, e = a, f, g, h, i, j;
            return this.format.replace(this.fre, function () {
                var a;
                return g = arguments[1], h = arguments[3], f = d.precre.exec(g), f ? (j = f[2], g = f[1]) : j = !1, i = e[g], i === undefined ? "" : h && b && b[h] ? (a = b[h], a.get ? b[h].get(i) || i : b[h][i] || i) : (k(i) && (c.get("numberFormatter") ? i = c.get("numberFormatter")(i) : i = p(i, j, c.get("numberDigitGroupCount"), c.get("numberDigitGroupSep"), c.get("numberDecimalMark"))), i)
            })
        }
    }), a.spformat = function (a, b) {
        return new e(a, b)
    }, f = function (a, b, c) {
        return a < b ? b : a > c ? c : a
    }, g = function (a, b) {
        var c;
        return b === 2 ? (c = Math.floor(a.length / 2), a.length % 2 ? a[c] : (a[c - 1] + a[c]) / 2) : a.length % 2 ? (c = (a.length * b + b) / 4, c % 1 ? (a[Math.floor(c)] + a[Math.floor(c) - 1]) / 2 : a[c - 1]) : (c = (a.length * b + 2) / 4, c % 1 ? (a[Math.floor(c)] + a[Math.floor(c) - 1]) / 2 : a[c - 1])
    }, h = function (a) {
        var b;
        switch (a) {
            case"undefined":
                a = undefined;
                break;
            case"null":
                a = null;
                break;
            case"true":
                a = !0;
                break;
            case"false":
                a = !1;
                break;
            default:
                b = parseFloat(a), a == b && (a = b)
        }
        return a
    }, i = function (a) {
        var b, c = [];
        for (b = a.length; b--;)c[b] = h(a[b]);
        return c
    }, j = function (a, b) {
        var c, d, e = [];
        for (c = 0, d = a.length; c < d; c++)a[c] !== b && e.push(a[c]);
        return e
    }, k = function (a) {
        return !isNaN(parseFloat(a)) && isFinite(a)
    }, p = function (b, c, d, e, f) {
        var g, h;
        b = (c === !1 ? parseFloat(b).toString() : b.toFixed(c)).split(""), g = (g = a.inArray(".", b)) < 0 ? b.length : g, g < b.length && (b[g] = f);
        for (h = g - d; h > 0; h -= d)b.splice(h, 0, e);
        return b.join("")
    }, l = function (a, b, c) {
        var d;
        for (d = b.length; d--;) {
            if (c && b[d] === null)continue;
            if (b[d] !== a)return !1
        }
        return !0
    }, m = function (a) {
        var b = 0, c;
        for (c = a.length; c--;)b += typeof a[c] == "number" ? a[c] : 0;
        return b
    }, o = function (b) {
        return a.isArray(b) ? b : [b]
    }, n = function (a) {
        var b;
        document.createStyleSheet ? document.createStyleSheet().cssText = a : (b = document.createElement("style"), b.type = "text/css", document.getElementsByTagName("head")[0].appendChild(b), b[typeof document.body.style.WebkitAppearance == "string" ? "innerText" : "innerHTML"] = a)
    }, a.fn.simpledraw = function (b, c, d, e) {
        var f, g;
        if (d && (f = this.data("_jqs_vcanvas")))return f;
        b === undefined && (b = a(this).innerWidth()), c === undefined && (c = a(this).innerHeight());
        if (a.browser.hasCanvas)f = new F(b, c, this, e); else {
            if (!a.browser.msie)return !1;
            f = new G(b, c, this)
        }
        return g = a(this).data("_jqs_mhandler"), g && g.registerCanvas(f), f
    }, a.fn.cleardraw = function () {
        var a = this.data("_jqs_vcanvas");
        a && a.reset()
    }, a.RangeMapClass = q = d({
        init: function (a) {
            var b, c, d = [];
            for (b in a)a.hasOwnProperty(b) && typeof b == "string" && b.indexOf(":") > -1 && (c = b.split(":"), c[0] = c[0].length === 0 ? -Infinity : parseFloat(c[0]), c[1] = c[1].length === 0 ? Infinity : parseFloat(c[1]), c[2] = a[b], d.push(c));
            this.map = a, this.rangelist = d || !1
        }, get: function (a) {
            var b = this.rangelist, c, d, e;
            if ((e = this.map[a]) !== undefined)return e;
            if (b)for (c = b.length; c--;) {
                d = b[c];
                if (d[0] <= a && d[1] >= a)return d[2]
            }
            return undefined
        }
    }), a.range_map = function (a) {
        return new q(a)
    }, r = d({
        init: function (b, c) {
            var d = a(b);
            this.$el = d, this.options = c, this.currentPageX = 0, this.currentPageY = 0, this.el = b, this.splist = [], this.tooltip = null, this.over = !1, this.displayTooltips = !c.get("disableTooltips"), this.highlightEnabled = !c.get("disableHighlight")
        }, registerSparkline: function (a) {
            this.splist.push(a), this.over && this.updateDisplay()
        }, registerCanvas: function (b) {
            var c = a(b.canvas);
            this.canvas = b, this.$canvas = c, c.mouseenter(a.proxy(this.mouseenter, this)), c.mouseleave(a.proxy(this.mouseleave, this)), c.click(a.proxy(this.mouseclick, this))
        }, reset: function (a) {
            this.splist = [], this.tooltip && a && (this.tooltip.remove(), this.tooltip = undefined)
        }, mouseclick: function (b) {
            var c = a.Event("sparklineClick");
            c.originalEvent = b, c.sparklines = this.splist, this.$el.trigger(c)
        }, mouseenter: function (b) {
            a(document.body).unbind("mousemove.jqs"), a(document.body).bind("mousemove.jqs", a.proxy(this.mousemove, this)), this.over = !0, this.currentPageX = b.pageX, this.currentPageY = b.pageY, this.currentEl = b.target, !this.tooltip && this.displayTooltips && (this.tooltip = new s(this.options), this.tooltip.updatePosition(b.pageX, b.pageY)), this.updateDisplay()
        }, mouseleave: function () {
            a(document.body).unbind("mousemove.jqs");
            var b = this.splist, c = b.length, d = !1, e, f;
            this.over = !1, this.currentEl = null, this.tooltip && (this.tooltip.remove(), this.tooltip = null);
            for (f = 0; f < c; f++)e = b[f], e.clearRegionHighlight() && (d = !0);
            d && this.canvas.render()
        }, mousemove: function (a) {
            this.currentPageX = a.pageX, this.currentPageY = a.pageY, this.currentEl = a.target, this.tooltip && this.tooltip.updatePosition(a.pageX, a.pageY), this.updateDisplay()
        }, updateDisplay: function () {
            var b = this.splist, c = b.length, d = !1, e = this.$canvas.offset(), f = this.currentPageX - e.left, g = this.currentPageY - e.top, h, i, j, k, l;
            if (!this.over)return;
            for (j = 0; j < c; j++)i = b[j], k = i.setRegionHighlight(this.currentEl, f, g), k && (d = !0);
            if (d) {
                l = a.Event("sparklineRegionChange"), l.sparklines = this.splist, this.$el.trigger(l);
                if (this.tooltip) {
                    h = "";
                    for (j = 0; j < c; j++)i = b[j], h += i.getCurrentRegionTooltip();
                    this.tooltip.setContent(h)
                }
                this.disableHighlight || this.canvas.render()
            }
            k === null && this.mouseleave()
        }
    }), s = d({
        sizeStyle: "position: static !important;display: block !important;visibility: hidden !important;float: left !important;",
        init: function (b) {
            var c = b.get("tooltipClassname", "jqstooltip"), d = this.sizeStyle, e;
            this.container = b.get("tooltipContainer") || document.body, this.tooltipOffsetX = b.get("tooltipOffsetX", 10), this.tooltipOffsetY = b.get("tooltipOffsetY", 12), a("#jqssizetip").remove(), a("#jqstooltip").remove(), this.sizetip = a("<div/>", {
                id: "jqssizetip",
                style: d,
                "class": c
            }), this.tooltip = a("<div/>", {
                id: "jqstooltip",
                "class": c
            }).appendTo(this.container), e = this.tooltip.offset(), this.offsetLeft = e.left, this.offsetTop = e.top, this.hidden = !0, a(window).unbind("resize.jqs scroll.jqs"), a(window).bind("resize.jqs scroll.jqs", a.proxy(this.updateWindowDims, this)), this.updateWindowDims()
        },
        updateWindowDims: function () {
            this.scrollTop = a(window).scrollTop(), this.scrollLeft = a(window).scrollLeft(), this.scrollRight = this.scrollLeft + a(window).width(), this.updatePosition()
        },
        getSize: function (a) {
            this.sizetip.html(a).appendTo(this.container), this.width = this.sizetip.width() + 1, this.height = this.sizetip.height(), this.sizetip.remove()
        },
        setContent: function (a) {
            if (!a) {
                this.tooltip.css("visibility", "hidden"), this.hidden = !0;
                return
            }
            this.getSize(a), this.tooltip.html(a).css({
                width: this.width,
                height: this.height,
                visibility: "visible"
            }), this.hidden && (this.hidden = !1, this.updatePosition())
        },
        updatePosition: function (a, b) {
            if (a === undefined) {
                if (this.mousex === undefined)return;
                a = this.mousex - this.offsetLeft, b = this.mousey - this.offsetTop
            } else this.mousex = a -= this.offsetLeft, this.mousey = b -= this.offsetTop;
            if (!this.height || !this.width || this.hidden)return;
            b -= this.height + this.tooltipOffsetY, a += this.tooltipOffsetX, b < this.scrollTop && (b = this.scrollTop), a < this.scrollLeft ? a = this.scrollLeft : a + this.width > this.scrollRight && (a = this.scrollRight - this.width), this.tooltip.css({
                left: a,
                top: b
            })
        },
        remove: function () {
            this.tooltip.remove(), this.sizetip.remove(), this.sizetip = this.tooltip = undefined, a(window).unbind("resize.jqs scroll.jqs")
        }
    }), C = function () {
        n(B)
    }, a(C), H = [], a.fn.sparkline = function (b, c) {
        return this.each(function () {
            var d = new a.fn.sparkline.options(this, c), e = a(this), f, g;
            f = function () {
                var c, f, g, h, i, j, k;
                if (b === "html" || b === undefined) {
                    k = this.getAttribute(d.get("tagValuesAttribute"));
                    if (k === undefined || k === null)k = e.html();
                    c = k.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, "").split(",")
                } else c = b;
                f = d.get("width") === "auto" ? c.length * d.get("defaultPixelsPerValue") : d.get("width");
                if (d.get("height") === "auto") {
                    if (!d.get("composite") || !a.data(this, "_jqs_vcanvas"))h = document.createElement("span"), h.innerHTML = "a", e.html(h), g = a(h).innerHeight() || a(h).height(), a(h).remove(), h = null
                } else g = d.get("height");
                d.get("disableInteraction") ? i = !1 : (i = a.data(this, "_jqs_mhandler"), i ? d.get("composite") || i.reset() : (i = new r(this, d), a.data(this, "_jqs_mhandler", i)));
                if (d.get("composite") && !a.data(this, "_jqs_vcanvas")) {
                    a.data(this, "_jqs_errnotify") || (alert("Attempted to attach a composite sparkline to an element with no existing sparkline"), a.data(this, "_jqs_errnotify", !0));
                    return
                }
                j = new (a.fn.sparkline[d.get("type")])(this, c, d, f, g), j.render(), i && i.registerSparkline(j)
            };
            if (a(this).html() && !d.get("disableHiddenCheck") && a(this).is(":hidden") || a.fn.jquery < "1.3.0" && a(this).parents().is(":hidden") || !a(this).parents("body").length) {
                if (!d.get("composite") && a.data(this, "_jqs_pending"))for (g = H.length; g; g--)H[g - 1][0] == this && H.splice(g - 1, 1);
                H.push([this, f]), a.data(this, "_jqs_pending", !0)
            } else f.call(this)
        })
    }, a.fn.sparkline.defaults = c(), a.sparkline_display_visible = function () {
        var b, c, d, e = [];
        for (c = 0, d = H.length; c < d; c++)b = H[c][0], a(b).is(":visible") && !a(b).parents().is(":hidden") ? (H[c][1].call(b), a.data(H[c][0], "_jqs_pending", !1), e.push(c)) : !a(b).closest("html").length && !a.data(b, "_jqs_pending") && (a.data(H[c][0], "_jqs_pending", !1), e.push(c));
        for (c = e.length; c; c--)H.splice(e[c - 1], 1)
    }, a.fn.sparkline.options = d({
        init: function (c, d) {
            var e, f, g, h;
            this.userOptions = d = d || {}, this.tag = c, this.tagValCache = {}, f = a.fn.sparkline.defaults, g = f.common, this.tagOptionsPrefix = d.enableTagOptions && (d.tagOptionsPrefix || g.tagOptionsPrefix), h = this.getTagSetting("type"), h === b ? e = f[d.type || g.type] : e = f[h], this.mergedOptions = a.extend({}, g, e, d)
        }, getTagSetting: function (a) {
            var c = this.tagOptionsPrefix, d, e, f, g;
            if (c === !1 || c === undefined)return b;
            if (this.tagValCache.hasOwnProperty(a))d = this.tagValCache.key; else {
                d = this.tag.getAttribute(c + a);
                if (d === undefined || d === null)d = b; else if (d.substr(0, 1) === "[") {
                    d = d.substr(1, d.length - 2).split(",");
                    for (e = d.length; e--;)d[e] = h(d[e].replace(/(^\s*)|(\s*$)/g, ""))
                } else if (d.substr(0, 1) === "{") {
                    f = d.substr(1, d.length - 2).split(","), d = {};
                    for (e = f.length; e--;)g = f[e].split(":", 2), d[g[0].replace(/(^\s*)|(\s*$)/g, "")] = h(g[1].replace(/(^\s*)|(\s*$)/g, ""))
                } else d = h(d);
                this.tagValCache.key = d
            }
            return d
        }, get: function (a, c) {
            var d = this.getTagSetting(a), e;
            return d !== b ? d : (e = this.mergedOptions[a]) === undefined ? c : e
        }
    }), a.fn.sparkline._base = d({
        disabled: !1, init: function (b, c, d, e, f) {
            this.el = b, this.$el = a(b), this.values = c, this.options = d, this.width = e, this.height = f, this.currentRegion = undefined
        }, initTarget: function () {
            var a = !this.options.get("disableInteraction");
            (this.target = this.$el.simpledraw(this.width, this.height, this.options.get("composite"), a)) ? (this.canvasWidth = this.target.pixelWidth, this.canvasHeight = this.target.pixelHeight) : this.disabled = !0
        }, render: function () {
            return this.disabled ? (this.el.innerHTML = "", !1) : !0
        }, getRegion: function (a, b) {
        }, setRegionHighlight: function (a, b, c) {
            var d = this.currentRegion, e = !this.options.get("disableHighlight"), f;
            return b > this.canvasWidth || c > this.canvasHeight || b < 0 || c < 0 ? null : (f = this.getRegion(a, b, c), d !== f ? (d !== undefined && e && this.removeHighlight(), this.currentRegion = f, f !== undefined && e && this.renderHighlight(), !0) : !1)
        }, clearRegionHighlight: function () {
            return this.currentRegion !== undefined ? (this.removeHighlight(), this.currentRegion = undefined, !0) : !1
        }, renderHighlight: function () {
            this.changeHighlight(!0)
        }, removeHighlight: function () {
            this.changeHighlight(!1)
        }, changeHighlight: function (a) {
        }, getCurrentRegionTooltip: function () {
            var b = this.options, c = "", d = [], f, g, h, i, j, k, l, m, n, o, p, q, r, s;
            if (this.currentRegion === undefined)return "";
            f = this.getCurrentRegionFields(), p = b.get("tooltipFormatter");
            if (p)return p(this, b, f);
            b.get("tooltipChartTitle") && (c += '<div class="jqs jqstitle">' + b.get("tooltipChartTitle") + "</div>\n"), g = this.options.get("tooltipFormat");
            if (!g)return "";
            a.isArray(g) || (g = [g]), a.isArray(f) || (f = [f]), l = this.options.get("tooltipFormatFieldlist"), m = this.options.get("tooltipFormatFieldlistKey");
            if (l && m) {
                n = [];
                for (k = f.length; k--;)o = f[k][m], (s = a.inArray(o, l)) != -1 && (n[s] = f[k]);
                f = n
            }
            h = g.length, r = f.length;
            for (k = 0; k < h; k++) {
                q = g[k], typeof q == "string" && (q = new e(q)), i = q.fclass || "jqsfield";
                for (s = 0; s < r; s++)if (!f[s].isNull || !b.get("tooltipSkipNull"))a.extend(f[s], {
                    prefix: b.get("tooltipPrefix"),
                    suffix: b.get("tooltipSuffix")
                }), j = q.render(f[s], b.get("tooltipValueLookups"), b), d.push('<div class="' + i + '">' + j + "</div>")
            }
            return d.length ? c + d.join("\n") : ""
        }, getCurrentRegionFields: function () {
        }, calcHighlightColor: function (a, b) {
            var c = b.get("highlightColor"), d = b.get("highlightLighten"), e, g, h, i;
            if (c)return c;
            if (d) {
                e = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(a);
                if (e) {
                    h = [], g = a.length === 4 ? 16 : 1;
                    for (i = 0; i < 3; i++)h[i] = f(Math.round(parseInt(e[i + 1], 16) * g * d), 0, 255);
                    return "rgb(" + h.join(",") + ")"
                }
            }
            return a
        }
    }), t = {
        changeHighlight: function (b) {
            var c = this.currentRegion, d = this.target, e = this.regionShapes[c], f;
            e && (f = this.renderRegion(c, b), a.isArray(f) || a.isArray(e) ? (d.replaceWithShapes(e, f), this.regionShapes[c] = a.map(f, function (a) {
                return a.id
            })) : (d.replaceWithShape(e, f), this.regionShapes[c] = f.id))
        }, render: function () {
            var b = this.values, c = this.target, d = this.regionShapes, e, f, g, h;
            if (!this.cls._super.render.call(this))return;
            for (g = b.length; g--;) {
                e = this.renderRegion(g);
                if (e)if (a.isArray(e)) {
                    f = [];
                    for (h = e.length; h--;)e[h].append(), f.push(e[h].id);
                    d[g] = f
                } else e.append(), d[g] = e.id; else d[g] = null
            }
            c.render()
        }
    }, a.fn.sparkline.line = u = d(a.fn.sparkline._base, {
        type: "line", init: function (a, b, c, d, e) {
            u._super.init.call(this, a, b, c, d, e), this.vertices = [], this.regionMap = [], this.xvalues = [], this.yvalues = [], this.yminmax = [], this.hightlightSpotId = null, this.lastShapeId = null, this.initTarget()
        }, getRegion: function (a, b, c) {
            var d, e = this.regionMap;
            for (d = e.length; d--;)if (e[d] !== null && b >= e[d][0] && b <= e[d][1])return e[d][2];
            return undefined
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion;
            return {
                isNull: this.yvalues[a] === null,
                x: this.xvalues[a],
                y: this.yvalues[a],
                color: this.options.get("lineColor"),
                fillColor: this.options.get("fillColor"),
                offset: a
            }
        }, renderHighlight: function () {
            var a = this.currentRegion, b = this.target, c = this.vertices[a], d = this.options, e = d.get("spotRadius"), f = d.get("highlightSpotColor"), g = d.get("highlightLineColor"), h, i;
            if (!c)return;
            e && f && (h = b.drawCircle(c[0], c[1], e, undefined, f), this.highlightSpotId = h.id, b.insertAfterShape(this.lastShapeId, h)), g && (i = b.drawLine(c[0], this.canvasTop, c[0], this.canvasTop + this.canvasHeight, g), this.highlightLineId = i.id, b.insertAfterShape(this.lastShapeId, i))
        }, removeHighlight: function () {
            var a = this.target;
            this.highlightSpotId && (a.removeShapeId(this.highlightSpotId), this.highlightSpotId = null), this.highlightLineId && (a.removeShapeId(this.highlightLineId), this.highlightLineId = null)
        }, scanValues: function () {
            var a = this.values, b = a.length, c = this.xvalues, d = this.yvalues, e = this.yminmax, f, g, h, i, j;
            for (f = 0; f < b; f++)g = a[f], h = typeof a[f] == "string", i = typeof a[f] == "object" && a[f]instanceof Array, j = h && a[f].split(":"), h && j.length === 2 ? (c.push(Number(j[0])), d.push(Number(j[1])), e.push(Number(j[1]))) : i ? (c.push(g[0]), d.push(g[1]), e.push(g[1])) : (c.push(f), a[f] === null || a[f] === "null" ? d.push(null) : (d.push(Number(g)), e.push(Number(g))));
            this.options.get("xvalues") && (c = this.options.get("xvalues")), this.maxy = this.maxyorg = Math.max.apply(Math, e), this.miny = this.minyorg = Math.min.apply(Math, e), this.maxx = Math.max.apply(Math, c), this.minx = Math.min.apply(Math, c), this.xvalues = c, this.yvalues = d, this.yminmax = e
        }, processRangeOptions: function () {
            var a = this.options, b = a.get("normalRangeMin"), c = a.get("normalRangeMax");
            b !== undefined && (b < this.miny && (this.miny = b), c > this.maxy && (this.maxy = c)), a.get("chartRangeMin") !== undefined && (a.get("chartRangeClip") || a.get("chartRangeMin") < this.miny) && (this.miny = a.get("chartRangeMin")), a.get("chartRangeMax") !== undefined && (a.get("chartRangeClip") || a.get("chartRangeMax") > this.maxy) && (this.maxy = a.get("chartRangeMax")), a.get("chartRangeMinX") !== undefined && (a.get("chartRangeClipX") || a.get("chartRangeMinX") < this.minx) && (this.minx = a.get("chartRangeMinX")), a.get("chartRangeMaxX") !== undefined && (a.get("chartRangeClipX") || a.get("chartRangeMaxX") > this.maxx) && (this.maxx = a.get("chartRangeMaxX"))
        }, drawNormalRange: function (a, b, c, d, e) {
            var f = this.options.get("normalRangeMin"), g = this.options.get("normalRangeMax"), h = b + Math.round(c - c * ((g - this.miny) / e)), i = Math.round(c * (g - f) / e);
            this.target.drawRect(a, h, d, i, undefined, this.options.get("normalRangeColor")).append()
        }, render: function () {
            var b = this.options, c = this.target, d = this.canvasWidth, e = this.canvasHeight, f = this.vertices, g = b.get("spotRadius"), h = this.regionMap, i, j, k, l, m, n, o, p, r, s, t, v, w, x, y, z, A, B, C, D, E, F, G, H, I;
            if (!u._super.render.call(this))return;
            this.scanValues(), this.processRangeOptions(), G = this.xvalues, H = this.yvalues;
            if (!this.yminmax.length || this.yvalues.length < 2)return;
            l = m = 0, i = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx, j = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny, k = this.yvalues.length - 1, g && (d < g * 4 || e < g * 4) && (g = 0);
            if (g) {
                E = b.get("highlightSpotColor") && !b.get("disableInteraction");
                if (E || b.get("minSpotColor") || b.get("spotColor") && H[k] === this.miny)e -= Math.ceil(g);
                if (E || b.get("maxSpotColor") || b.get("spotColor") && H[k] === this.maxy)e -= Math.ceil(g), l += Math.ceil(g);
                if (E || (b.get("minSpotColor") || b.get("maxSpotColor")) && (H[0] === this.miny || H[0] === this.maxy))m += Math.ceil(g), d -= Math.ceil(g);
                if (E || b.get("spotColor") || b.get("minSpotColor") || b.get("maxSpotColor") && (H[k] === this.miny || H[k] === this.maxy))d -= Math.ceil(g)
            }
            e--, b.get("normalRangeMin") !== undefined && !b.get("drawNormalOnTop") && this.drawNormalRange(m, l, e, d, j), o = [], p = [o], x = y = null, z = H.length;
            for (I = 0; I < z; I++)r = G[I], t = G[I + 1], s = H[I], v = m + Math.round((r - this.minx) * (d / i)), w = I < z - 1 ? m + Math.round((t - this.minx) * (d / i)) : d, y = v + (w - v) / 2, h[I] = [x || 0, y, I], x = y, s === null ? I && (H[I - 1] !== null && (o = [], p.push(o)), f.push(null)) : (s < this.miny && (s = this.miny), s > this.maxy && (s = this.maxy), o.length || o.push([v, l + e]), n = [v, l + Math.round(e - e * ((s - this.miny) / j))], o.push(n), f.push(n));
            A = [], B = [], C = p.length;
            for (I = 0; I < C; I++)o = p[I], o.length && (b.get("fillColor") && (o.push([o[o.length - 1][0], l + e]), B.push(o.slice(0)), o.pop()), o.length > 2 && (o[0] = [o[0][0], o[1][1]]), A.push(o));
            C = B.length;
            for (I = 0; I < C; I++)c.drawShape(B[I], b.get("fillColor"), b.get("fillColor")).append();
            b.get("normalRangeMin") !== undefined && b.get("drawNormalOnTop") && this.drawNormalRange(m, l, e, d, j), C = A.length;
            for (I = 0; I < C; I++)c.drawShape(A[I], b.get("lineColor"), undefined, b.get("lineWidth")).append();
            if (g && b.get("valueSpots")) {
                D = b.get("valueSpots"), D.get === undefined && (D = new q(D));
                for (I = 0; I < z; I++)F = D.get(H[I]), F && c.drawCircle(m + Math.round((G[I] - this.minx) * (d / i)), l + Math.round(e - e * ((H[I] - this.miny) / j)), g, undefined, F).append()
            }
            g && b.get("spotColor") && c.drawCircle(m + Math.round((G[G.length - 1] - this.minx) * (d / i)), l + Math.round(e - e * ((H[k] - this.miny) / j)), g, undefined, b.get("spotColor")).append(), this.maxy !== this.minyorg && (g && b.get("minSpotColor") && (r = G[a.inArray(this.minyorg, H)], c.drawCircle(m + Math.round((r - this.minx) * (d / i)), l + Math.round(e - e * ((this.minyorg - this.miny) / j)), g, undefined, b.get("minSpotColor")).append()), g && b.get("maxSpotColor") && (r = G[a.inArray(this.maxyorg, H)], c.drawCircle(m + Math.round((r - this.minx) * (d / i)), l + Math.round(e - e * ((this.maxyorg - this.miny) / j)), g, undefined, b.get("maxSpotColor")).append())), this.lastShapeId = c.getLastShapeId(), this.canvasTop = l, c.render()
        }
    }), a.fn.sparkline.bar = v = d(a.fn.sparkline._base, t, {
        type: "bar", init: function (b, c, d, e, g) {
            var k = parseInt(d.get("barWidth"), 10), l = parseInt(d.get("barSpacing"), 10), m = d.get("chartRangeMin"), n = d.get("chartRangeMax"), o = d.get("chartRangeClip"), p = Infinity, r = -Infinity, s, t, u, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P;
            v._super.init.call(this, b, c, d, e, g);
            for (y = 0, z = c.length; y < z; y++) {
                M = c[y], s = typeof M == "string" && M.indexOf(":") > -1;
                if (s || a.isArray(M))H = !0, s && (M = c[y] = i(M.split(":"))), M = j(M, null), t = Math.min.apply(Math, M), u = Math.max.apply(Math, M), t < p && (p = t), u > r && (r = u)
            }
            this.stacked = H, this.regionShapes = {}, this.barWidth = k, this.barSpacing = l, this.totalBarWidth = k + l, this.width = e = c.length * k + (c.length - 1) * l, this.initTarget(), o && (F = m === undefined ? -Infinity : m, G = n === undefined ? Infinity : n), x = [], w = H ? [] : x;
            var Q = [], R = [];
            for (y = 0, z = c.length; y < z; y++)if (H) {
                I = c[y], c[y] = L = [], Q[y] = 0, w[y] = R[y] = 0;
                for (J = 0, K = I.length; J < K; J++)M = L[J] = o ? f(I[J], F, G) : I[J], M !== null && (M > 0 && (Q[y] += M), p < 0 && r > 0 ? M < 0 ? R[y] += Math.abs(M) : w[y] += M : w[y] += Math.abs(M - (M < 0 ? r : p)), x.push(M))
            } else M = o ? f(c[y], F, G) : c[y], M = c[y] = h(M), M !== null && x.push(M);
            this.max = E = Math.max.apply(Math, x), this.min = D = Math.min.apply(Math, x), this.stackMax = r = H ? Math.max.apply(Math, Q) : E, this.stackMin = p = H ? Math.min.apply(Math, x) : D, d.get("chartRangeMin") !== undefined && (d.get("chartRangeClip") || d.get("chartRangeMin") < D) && (D = d.get("chartRangeMin")), d.get("chartRangeMax") !== undefined && (d.get("chartRangeClip") || d.get("chartRangeMax") > E) && (E = d.get("chartRangeMax")), this.zeroAxis = B = d.get("zeroAxis", !0), D <= 0 && E >= 0 && B ? C = 0 : B == 0 ? C = D : D > 0 ? C = D : C = E, this.xaxisOffset = C, A = H ? Math.max.apply(Math, w) + Math.max.apply(Math, R) : E - D, this.canvasHeightEf = B && D < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1, D < C ? (O = H && E >= 0 ? r : E, N = (O - C) / A * this.canvasHeight, N !== Math.ceil(N) && (this.canvasHeightEf -= 2, N = Math.ceil(N))) : N = this.canvasHeight, this.yoffset = N, a.isArray(d.get("colorMap")) ? (this.colorMapByIndex = d.get("colorMap"), this.colorMapByValue = null) : (this.colorMapByIndex = null, this.colorMapByValue = d.get("colorMap"), this.colorMapByValue && this.colorMapByValue.get === undefined && (this.colorMapByValue = new q(this.colorMapByValue))), this.range = A
        }, getRegion: function (a, b, c) {
            var d = Math.floor(b / this.totalBarWidth);
            return d < 0 || d >= this.values.length ? undefined : d
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion, b = o(this.values[a]), c = [], d, e;
            for (e = b.length; e--;)d = b[e], c.push({
                isNull: d === null,
                value: d,
                color: this.calcColor(e, d, a),
                offset: a
            });
            return c
        }, calcColor: function (b, c, d) {
            var e = this.colorMapByIndex, f = this.colorMapByValue, g = this.options, h, i;
            return this.stacked ? h = g.get("stackedBarColor") : h = c < 0 ? g.get("negBarColor") : g.get("barColor"), c === 0 && g.get("zeroColor") !== undefined && (h = g.get("zeroColor")), f && (i = f.get(c)) ? h = i : e && e.length > d && (h = e[d]), a.isArray(h) ? h[b % h.length] : h
        }, renderRegion: function (b, c) {
            var d = this.values[b], e = this.options, f = this.xaxisOffset, g = [], h = this.range, i = this.stacked, j = this.target, k = b * this.totalBarWidth, m = this.canvasHeightEf, n = this.yoffset, o, p, q, r, s, t, u, v, w, x;
            d = a.isArray(d) ? d : [d], u = d.length, v = d[0], r = l(null, d), x = l(f, d, !0);
            if (r)return e.get("nullColor") ? (q = c ? e.get("nullColor") : this.calcHighlightColor(e.get("nullColor"), e), o = n > 0 ? n - 1 : n, j.drawRect(k, o, this.barWidth - 1, 0, q, q)) : undefined;
            s = n;
            for (t = 0; t < u; t++) {
                v = d[t];
                if (i && v === f) {
                    if (!x || w)continue;
                    w = !0
                }
                h > 0 ? p = Math.floor(m * (Math.abs(v - f) / h)) + 1 : p = 1, v < f || v === f && n === 0 ? (o = s, s += p) : (o = n - p, n -= p), q = this.calcColor(t, v, b), c && (q = this.calcHighlightColor(q, e)), g.push(j.drawRect(k, o, this.barWidth - 1, p - 1, q, q))
            }
            return g.length === 1 ? g[0] : g
        }
    }), a.fn.sparkline.tristate = w = d(a.fn.sparkline._base, t, {
        type: "tristate", init: function (b, c, d, e, f) {
            var g = parseInt(d.get("barWidth"), 10), h = parseInt(d.get("barSpacing"), 10);
            w._super.init.call(this, b, c, d, e, f), this.regionShapes = {}, this.barWidth = g, this.barSpacing = h, this.totalBarWidth = g + h, this.values = a.map(c, Number), this.width = e = c.length * g + (c.length - 1) * h, a.isArray(d.get("colorMap")) ? (this.colorMapByIndex = d.get("colorMap"), this.colorMapByValue = null) : (this.colorMapByIndex = null, this.colorMapByValue = d.get("colorMap"), this.colorMapByValue && this.colorMapByValue.get === undefined && (this.colorMapByValue = new q(this.colorMapByValue))), this.initTarget()
        }, getRegion: function (a, b, c) {
            return Math.floor(b / this.totalBarWidth)
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion;
            return {
                isNull: this.values[a] === undefined,
                value: this.values[a],
                color: this.calcColor(this.values[a], a),
                offset: a
            }
        }, calcColor: function (a, b) {
            var c = this.values, d = this.options, e = this.colorMapByIndex, f = this.colorMapByValue, g, h;
            return f && (h = f.get(a)) ? g = h : e && e.length > b ? g = e[b] : c[b] < 0 ? g = d.get("negBarColor") : c[b] > 0 ? g = d.get("posBarColor") : g = d.get("zeroBarColor"), g
        }, renderRegion: function (a, b) {
            var c = this.values, d = this.options, e = this.target, f, g, h, i, j, k;
            f = e.pixelHeight, h = Math.round(f / 2), i = a * this.totalBarWidth, c[a] < 0 ? (j = h, g = h - 1) : c[a] > 0 ? (j = 0, g = h - 1) : (j = h - 1, g = 2), k = this.calcColor(c[a], a);
            if (k === null)return;
            return b && (k = this.calcHighlightColor(k, d)), e.drawRect(i, j, this.barWidth - 1, g - 1, k, k)
        }
    }), a.fn.sparkline.discrete = x = d(a.fn.sparkline._base, t, {
        type: "discrete", init: function (b, c, d, e, f) {
            x._super.init.call(this, b, c, d, e, f), this.regionShapes = {}, this.values = c = a.map(c, Number), this.min = Math.min.apply(Math, c), this.max = Math.max.apply(Math, c), this.range = this.max - this.min, this.width = e = d.get("width") === "auto" ? c.length * 2 : this.width, this.interval = Math.floor(e / c.length), this.itemWidth = e / c.length, d.get("chartRangeMin") !== undefined && (d.get("chartRangeClip") || d.get("chartRangeMin") < this.min) && (this.min = d.get("chartRangeMin")), d.get("chartRangeMax") !== undefined && (d.get("chartRangeClip") || d.get("chartRangeMax") > this.max) && (this.max = d.get("chartRangeMax")), this.initTarget(), this.target && (this.lineHeight = d.get("lineHeight") === "auto" ? Math.round(this.canvasHeight * .3) : d.get("lineHeight"))
        }, getRegion: function (a, b, c) {
            return Math.floor(b / this.itemWidth)
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion;
            return {isNull: this.values[a] === undefined, value: this.values[a], offset: a}
        }, renderRegion: function (a, b) {
            var c = this.values, d = this.options, e = this.min, g = this.max, h = this.range, i = this.interval, j = this.target, k = this.canvasHeight, l = this.lineHeight, m = k - l, n, o, p, q;
            return o = f(c[a], e, g), q = a * i, n = Math.round(m - m * ((o - e) / h)), p = d.get("thresholdColor") && o < d.get("thresholdValue") ? d.get("thresholdColor") : d.get("lineColor"), b && (p = this.calcHighlightColor(p, d)), j.drawLine(q, n, q, n + l, p)
        }
    }), a.fn.sparkline.bullet = y = d(a.fn.sparkline._base, {
        type: "bullet", init: function (a, b, c, d, e) {
            var f, g, h;
            y._super.init.call(this, a, b, c, d, e), this.values = b = i(b), h = b.slice(), h[0] = h[0] === null ? h[2] : h[0], h[1] = b[1] === null ? h[2] : h[1], f = Math.min.apply(Math, b), g = Math.max.apply(Math, b), c.get("base") === undefined ? f = f < 0 ? f : 0 : f = c.get("base"), this.min = f, this.max = g, this.range = g - f, this.shapes = {}, this.valueShapes = {}, this.regiondata = {}, this.width = d = c.get("width") === "auto" ? "4.0em" : d, this.target = this.$el.simpledraw(d, e, c.get("composite")), b.length || (this.disabled = !0), this.initTarget()
        }, getRegion: function (a, b, c) {
            var d = this.target.getShapeAt(a, b, c);
            return d !== undefined && this.shapes[d] !== undefined ? this.shapes[d] : undefined
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion;
            return {fieldkey: a.substr(0, 1), value: this.values[a.substr(1)], region: a}
        }, changeHighlight: function (a) {
            var b = this.currentRegion, c = this.valueShapes[b], d;
            delete this.shapes[c];
            switch (b.substr(0, 1)) {
                case"r":
                    d = this.renderRange(b.substr(1), a);
                    break;
                case"p":
                    d = this.renderPerformance(a);
                    break;
                case"t":
                    d = this.renderTarget(a)
            }
            this.valueShapes[b] = d.id, this.shapes[d.id] = b, this.target.replaceWithShape(c, d)
        }, renderRange: function (a, b) {
            var c = this.values[a], d = Math.round(this.canvasWidth * ((c - this.min) / this.range)), e = this.options.get("rangeColors")[a - 2];
            return b && (e = this.calcHighlightColor(e, this.options)), this.target.drawRect(0, 0, d - 1, this.canvasHeight - 1, e, e)
        }, renderPerformance: function (a) {
            var b = this.values[1], c = Math.round(this.canvasWidth * ((b - this.min) / this.range)), d = this.options.get("performanceColor");
            return a && (d = this.calcHighlightColor(d, this.options)), this.target.drawRect(0, Math.round(this.canvasHeight * .3), c - 1, Math.round(this.canvasHeight * .4) - 1, d, d)
        }, renderTarget: function (a) {
            var b = this.values[0], c = Math.round(this.canvasWidth * ((b - this.min) / this.range) - this.options.get("targetWidth") / 2), d = Math.round(this.canvasHeight * .1), e = this.canvasHeight - d * 2, f = this.options.get("targetColor");
            return a && (f = this.calcHighlightColor(f, this.options)), this.target.drawRect(c, d, this.options.get("targetWidth") - 1, e - 1, f, f)
        }, render: function () {
            var a = this.values.length, b = this.target, c, d;
            if (!y._super.render.call(this))return;
            for (c = 2; c < a; c++)d = this.renderRange(c).append(), this.shapes[d.id] = "r" + c, this.valueShapes["r" + c] = d.id;
            this.values[1] !== null && (d = this.renderPerformance().append(), this.shapes[d.id] = "p1", this.valueShapes.p1 = d.id), this.values[0] !== null && (d = this.renderTarget().append(), this.shapes[d.id] = "t0", this.valueShapes.t0 = d.id), b.render()
        }
    }), a.fn.sparkline.pie = z = d(a.fn.sparkline._base, {
        type: "pie", init: function (b, c, d, e, f) {
            var g = 0, h;
            z._super.init.call(this, b, c, d, e, f), this.shapes = {}, this.valueShapes = {}, this.values = c = a.map(c, Number), d.get("width") === "auto" && (this.width = this.height);
            if (c.length > 0)for (h = c.length; h--;)g += c[h];
            this.total = g, this.initTarget(), this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2)
        }, getRegion: function (a, b, c) {
            var d = this.target.getShapeAt(a, b, c);
            return d !== undefined && this.shapes[d] !== undefined ? this.shapes[d] : undefined
        }, getCurrentRegionFields: function () {
            var a = this.currentRegion;
            return {
                isNull: this.values[a] === undefined,
                value: this.values[a],
                percent: this.values[a] / this.total * 100,
                color: this.options.get("sliceColors")[a % this.options.get("sliceColors").length],
                offset: a
            }
        }, changeHighlight: function (a) {
            var b = this.currentRegion, c = this.renderSlice(b, a), d = this.valueShapes[b];
            delete this.shapes[d], this.target.replaceWithShape(d, c), this.valueShapes[b] = c.id, this.shapes[c.id] = b
        }, renderSlice: function (a, b) {
            var c = this.target, d = this.options, e = this.radius, f = d.get("borderWidth"), g = d.get("offset"), h = 2 * Math.PI, i = this.values, j = this.total, k = g ? 2 * Math.PI * (g / 360) : 0, l, m, n, o, p;
            o = i.length;
            for (n = 0; n < o; n++) {
                l = k, m = k, j > 0 && (m = k + h * (i[n] / j));
                if (a === n)return p = d.get("sliceColors")[n % d.get("sliceColors").length], b && (p = this.calcHighlightColor(p, d)), c.drawPieSlice(e, e, e - f, l, m, undefined, p);
                k = m
            }
        }, render: function () {
            var a = this.target, b = this.values, c = this.options, d = this.radius, e = c.get("borderWidth"), f, g;
            if (!z._super.render.call(this))return;
            e && a.drawCircle(d, d, Math.floor(d - e / 2), c.get("borderColor"), undefined, e).append();
            for (g = b.length; g--;)b[g] && (f = this.renderSlice(g).append(), this.valueShapes[g] = f.id, this.shapes[f.id] = g);
            a.render()
        }
    }), a.fn.sparkline.box = A = d(a.fn.sparkline._base, {
        type: "box", init: function (b, c, d, e, f) {
            A._super.init.call(this, b, c, d, e, f), this.values = a.map(c, Number), this.width = d.get("width") === "auto" ? "4.0em" : e, this.initTarget(), this.values.length || (this.disabled = 1)
        }, getRegion: function () {
            return 1
        }, getCurrentRegionFields: function () {
            var a = [{field: "lq", value: this.quartiles[0]}, {field: "med", value: this.quartiles[1]}, {
                field: "uq",
                value: this.quartiles[2]
            }];
            return this.loutlier !== undefined && a.push({
                field: "lo",
                value: this.loutlier
            }), this.routlier !== undefined && a.push({
                field: "ro",
                value: this.routlier
            }), this.lwhisker !== undefined && a.push({
                field: "lw",
                value: this.lwhisker
            }), this.rwhisker !== undefined && a.push({field: "rw", value: this.rwhisker}), a
        }, render: function () {
            var a = this.target, b = this.values, c = b.length, d = this.options, e = this.canvasWidth, f = this.canvasHeight, h = d.get("chartRangeMin") === undefined ? Math.min.apply(Math, b) : d.get("chartRangeMin"), i = d.get("chartRangeMax") === undefined ? Math.max.apply(Math, b) : d.get("chartRangeMax"), j = 0, k, l, m, n, o, p, q, r, s, t, u;
            if (!A._super.render.call(this))return;
            if (d.get("raw"))d.get("showOutliers") && b.length > 5 ? (l = b[0], k = b[1], n = b[2], o = b[3], p = b[4], q = b[5], r = b[6]) : (k = b[0], n = b[1], o = b[2], p = b[3], q = b[4]); else {
                b.sort(function (a, b) {
                    return a - b
                }), n = g(b, 1), o = g(b, 2), p = g(b, 3), m = p - n;
                if (d.get("showOutliers")) {
                    k = q = undefined;
                    for (s = 0; s < c; s++)k === undefined && b[s] > n - m * d.get("outlierIQR") && (k = b[s]), b[s] < p + m * d.get("outlierIQR") && (q = b[s]);
                    l = b[0], r = b[c - 1]
                } else k = b[0], q = b[c - 1]
            }
            this.quartiles = [n, o, p], this.lwhisker = k, this.rwhisker = q, this.loutlier = l, this.routlier = r, u = e / (i - h + 1), d.get("showOutliers") && (j = Math.ceil(d.get("spotRadius")), e -= 2 * Math.ceil(d.get("spotRadius")), u = e / (i - h + 1), l < k && a.drawCircle((l - h) * u + j, f / 2, d.get("spotRadius"), d.get("outlierLineColor"), d.get("outlierFillColor")).append(), r > q && a.drawCircle((r - h) * u + j, f / 2, d.get("spotRadius"), d.get("outlierLineColor"), d.get("outlierFillColor")).append()), a.drawRect(Math.round((n - h) * u + j), Math.round(f * .1), Math.round((p - n) * u), Math.round(f * .8), d.get("boxLineColor"), d.get("boxFillColor")).append(), a.drawLine(Math.round((k - h) * u + j), Math.round(f / 2), Math.round((n - h) * u + j), Math.round(f / 2), d.get("lineColor")).append(), a.drawLine(Math.round((k - h) * u + j), Math.round(f / 4), Math.round((k - h) * u + j), Math.round(f - f / 4), d.get("whiskerColor")).append(), a.drawLine(Math.round((q - h) * u + j), Math.round(f / 2), Math.round((p - h) * u + j), Math.round(f / 2), d.get("lineColor")).append(), a.drawLine(Math.round((q - h) * u + j), Math.round(f / 4), Math.round((q - h) * u + j), Math.round(f - f / 4), d.get("whiskerColor")).append(), a.drawLine(Math.round((o - h) * u + j), Math.round(f * .1), Math.round((o - h) * u + j), Math.round(f * .9), d.get("medianColor")).append(), d.get("target") && (t = Math.ceil(d.get("spotRadius")), a.drawLine(Math.round((d.get("target") - h) * u + j), Math.round(f / 2 - t), Math.round((d.get("target") - h) * u + j), Math.round(f / 2 + t), d.get("targetColor")).append(), a.drawLine(Math.round((d.get("target") - h) * u + j - t), Math.round(f / 2), Math.round((d.get("target") - h) * u + j + t), Math.round(f / 2), d.get("targetColor")).append()), a.render()
        }
    }), a.browser.msie && document.namespaces && !document.namespaces.v && document.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML"), a.browser.hasCanvas === undefined && (a.browser.hasCanvas = document.createElement("canvas").getContext !== undefined), D = d({
        init: function (a, b, c, d) {
            this.target = a, this.id = b, this.type = c, this.args = d
        }, append: function () {
            return this.target.appendShape(this), this
        }
    }), E = d({
        _pxregex: /(\d+)(px)?\s*$/i, init: function (b, c, d) {
            if (!b)return;
            this.width = b, this.height = c, this.target = d, this.lastShapeId = null, d[0] && (d = d[0]), a.data(d, "_jqs_vcanvas", this)
        }, drawLine: function (a, b, c, d, e, f) {
            return this.drawShape([[a, b], [c, d]], e, f)
        }, drawShape: function (a, b, c, d) {
            return this._genShape("Shape", [a, b, c, d])
        }, drawCircle: function (a, b, c, d, e, f) {
            return this._genShape("Circle", [a, b, c, d, e, f])
        }, drawPieSlice: function (a, b, c, d, e, f, g) {
            return this._genShape("PieSlice", [a, b, c, d, e, f, g])
        }, drawRect: function (a, b, c, d, e, f) {
            return this._genShape("Rect", [a, b, c, d, e, f])
        }, getElement: function () {
            return this.canvas
        }, getLastShapeId: function () {
            return this.lastShapeId
        }, reset: function () {
            alert("reset not implemented")
        }, _insert: function (b, c) {
            a(c).html(b)
        }, _calculatePixelDims: function (b, c, d) {
            var e;
            e = this._pxregex.exec(c), e ? this.pixelHeight = e[1] : this.pixelHeight = a(d).height(), e = this._pxregex.exec(b), e ? this.pixelWidth = e[1] : this.pixelWidth = a(d).width()
        }, _genShape: function (a, b) {
            var c = I++;
            return b.unshift(c), new D(this, c, a, b)
        }, appendShape: function (a) {
            alert("appendShape not implemented")
        }, replaceWithShape: function (a, b) {
            alert("replaceWithShape not implemented")
        }, insertAfterShape: function (a, b) {
            alert("insertAfterShape not implemented")
        }, removeShapeId: function (a) {
            alert("removeShapeId not implemented")
        }, getShapeAt: function (a, b, c) {
            alert("getShapeAt not implemented")
        }, render: function () {
            alert("render not implemented")
        }
    }), F = d(E, {
        init: function (b, c, d, e) {
            F._super.init.call(this, b, c, d), this.canvas = document.createElement("canvas"), d[0] && (d = d[0]), a.data(d, "_jqs_vcanvas", this), a(this.canvas).css({
                display: "inline-block",
                width: b,
                height: c,
                verticalAlign: "top"
            }), this._insert(this.canvas, d), this._calculatePixelDims(b, c, this.canvas), this.canvas.width = this.pixelWidth, this.canvas.height = this.pixelHeight, this.interact = e, this.shapes = {}, this.shapeseq = [], this.currentTargetShapeId = undefined, a(this.canvas).css({
                width: this.pixelWidth,
                height: this.pixelHeight
            })
        }, _getContext: function (a, b, c) {
            var d = this.canvas.getContext("2d");
            return a !== undefined && (d.strokeStyle = a), d.lineWidth = c === undefined ? 1 : c, b !== undefined && (d.fillStyle = b), d
        }, reset: function () {
            var a = this._getContext();
            a.clearRect(0, 0, this.pixelWidth, this.pixelHeight), this.shapes = {}, this.shapeseq = [], this.currentTargetShapeId = undefined
        }, _drawShape: function (a, b, c, d, e) {
            var f = this._getContext(c, d, e), g, h;
            f.beginPath(), f.moveTo(b[0][0] + .5, b[0][1] + .5);
            for (g = 1, h = b.length; g < h; g++)f.lineTo(b[g][0] + .5, b[g][1] + .5);
            c !== undefined && f.stroke(), d !== undefined && f.fill(), this.targetX !== undefined && this.targetY !== undefined && f.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a)
        }, _drawCircle: function (a, b, c, d, e, f, g) {
            var h = this._getContext(e, f, g);
            h.beginPath(), h.arc(b, c, d, 0, 2 * Math.PI, !1), this.targetX !== undefined && this.targetY !== undefined && h.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a), e !== undefined && h.stroke(), f !== undefined && h.fill()
        }, _drawPieSlice: function (a, b, c, d, e, f, g, h) {
            var i = this._getContext(g, h);
            i.beginPath(), i.moveTo(b, c), i.arc(b, c, d, e, f, !1), i.lineTo(b, c), i.closePath(), g !== undefined && i.stroke(), h && i.fill(), this.targetX !== undefined && this.targetY !== undefined && i.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a)
        }, _drawRect: function (a, b, c, d, e, f, g) {
            return this._drawShape(a, [[b, c], [b + d, c], [b + d, c + e], [b, c + e], [b, c]], f, g)
        }, appendShape: function (a) {
            return this.shapes[a.id] = a, this.shapeseq.push(a.id), this.lastShapeId = a.id, a.id
        }, replaceWithShape: function (a, b) {
            var c = this.shapeseq, d;
            this.shapes[b.id] = b;
            for (d = c.length; d--;)c[d] == a && (c[d] = b.id);
            delete this.shapes[a]
        }, replaceWithShapes: function (a, b) {
            var c = this.shapeseq, d = {}, e, f, g;
            for (f = a.length; f--;)d[a[f]] = !0;
            for (f = c.length; f--;)e = c[f], d[e] && (c.splice(f, 1), delete this.shapes[e], g = f);
            for (f = b.length; f--;)c.splice(g, 0, b[f].id), this.shapes[b[f].id] = b[f]
        }, insertAfterShape: function (a, b) {
            var c = this.shapeseq, d;
            for (d = c.length; d--;)if (c[d] === a) {
                c.splice(d + 1, 0, b.id), this.shapes[b.id] = b;
                return
            }
        }, removeShapeId: function (a) {
            var b = this.shapeseq, c;
            for (c = b.length; c--;)if (b[c] === a) {
                b.splice(c, 1);
                break
            }
            delete this.shapes[a]
        }, getShapeAt: function (a, b, c) {
            return this.targetX = b, this.targetY = c, this.render(), this.currentTargetShapeId
        }, render: function () {
            var a = this.shapeseq, b = this.shapes, c = a.length, d = this._getContext(), e, f, g;
            d.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            for (g = 0; g < c; g++)e = a[g], f = b[e], this["_draw" + f.type].apply(this, f.args);
            this.interact || (this.shapes = {}, this.shapeseq = [])
        }
    }), G = d(E, {
        init: function (b, c, d) {
            var e;
            G._super.init.call(this, b, c, d), d[0] && (d = d[0]), a.data(d, "_jqs_vcanvas", this), this.canvas = document.createElement("span"), a(this.canvas).css({
                display: "inline-block",
                position: "relative",
                overflow: "hidden",
                width: b,
                height: c,
                margin: "0px",
                padding: "0px",
                verticalAlign: "top"
            }), this._insert(this.canvas, d), this._calculatePixelDims(b, c, this.canvas), this.canvas.width = this.pixelWidth, this.canvas.height = this.pixelHeight, e = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '"' + ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + "px;height=" + this.pixelHeight + 'px;"></v:group>', this.canvas.insertAdjacentHTML("beforeEnd", e), this.group = a(this.canvas).children()[0], this.rendered = !1, this.prerender = ""
        }, _drawShape: function (a, b, c, d, e) {
            var f = [], g, h, i, j, k, l, m;
            for (m = 0, l = b.length; m < l; m++)f[m] = "" + b[m][0] + "," + b[m][1];
            return g = f.splice(0, 1), e = e === undefined ? 1 : e, h = c === undefined ? ' stroked="false" ' : ' strokeWeight="' + e + 'px" strokeColor="' + c + '" ', i = d === undefined ? ' filled="false"' : ' fillColor="' + d + '" filled="true" ', j = f[0] === f[f.length - 1] ? "x " : "", k = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '" ' + ' id="jqsshape' + a + '" ' + h + i + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + "px;width:" + this.pixelWidth + 'px;padding:0px;margin:0px;" ' + ' path="m ' + g + " l " + f.join(", ") + " " + j + 'e">' + " </v:shape>", k
        }, _drawCircle: function (a, b, c, d, e, f, g) {
            var h, i, j;
            return b -= d, c -= d, h = e === undefined ? ' stroked="false" ' : ' strokeWeight="' + g + 'px" strokeColor="' + e + '" ', i = f === undefined ? ' filled="false"' : ' fillColor="' + f + '" filled="true" ', j = '<v:oval  id="jqsshape' + a + '" ' + h + i + ' style="position:absolute;top:' + c + "px; left:" + b + "px; width:" + d * 2 + "px; height:" + d * 2 + 'px"></v:oval>', j
        }, _drawPieSlice: function (a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p;
            if (e === f)return;
            f - e === 2 * Math.PI && (e = 0, f = 2 * Math.PI), j = b + Math.round(Math.cos(e) * d), k = c + Math.round(Math.sin(e) * d), l = b + Math.round(Math.cos(f) * d), m = c + Math.round(Math.sin(f) * d);
            if (j === l && k === m && f - e < Math.PI)return;
            return i = [b - d, c - d, b + d, c + d, j, k, l, m], n = g === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + g + '" ', o = h === undefined ? ' filled="false"' : ' fillColor="' + h + '" filled="true" ', p = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '" ' + ' id="jqsshape' + a + '" ' + n + o + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + "px;width:" + this.pixelWidth + 'px;padding:0px;margin:0px;" ' + ' path="m ' + b + "," + c + " wa " + i.join(", ") + ' x e">' + " </v:shape>", p
        }, _drawRect: function (a, b, c, d, e, f, g) {
            return this._drawShape(a, [[b, c], [b, c + e], [b + d, c + e], [b + d, c], [b, c]], f, g)
        }, reset: function () {
            this.group.innerHTML = ""
        }, appendShape: function (a) {
            var b = this["_draw" + a.type].apply(this, a.args);
            return this.rendered ? this.group.insertAdjacentHTML("beforeEnd", b) : this.prerender += b, this.lastShapeId = a.id, a.id
        }, replaceWithShape: function (b, c) {
            var d = a("#jqsshape" + b), e = this["_draw" + c.type].apply(this, c.args);
            d[0].outerHTML = e
        }, replaceWithShapes: function (b, c) {
            var d = a("#jqsshape" + b[0]), e = "", f = c.length, g;
            for (g = 0; g < f; g++)e += this["_draw" + c[g].type].apply(this, c[g].args);
            d[0].outerHTML = e;
            for (g = 1; g < b.length; g++)a("#jqsshape" + b[g]).remove()
        }, insertAfterShape: function (b, c) {
            var d = a("#jqsshape" + b), e = this["_draw" + c.type].apply(this, c.args);
            d[0].insertAdjacentHTML("afterEnd", e)
        }, removeShapeId: function (b) {
            var c = a("#jqsshape" + b);
            this.group.removeChild(c[0])
        }, getShapeAt: function (a, b, c) {
            var d = a.id.substr(8);
            return d
        }, render: function () {
            this.rendered || (this.group.innerHTML = this.prerender, this.rendered = !0)
        }
    })
});// Generated by CoffeeScript 1.3.3

/*
 Easy pie chart is a jquery plugin to display simple animated pie charts for only one value

 Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.

 Built on top of the jQuery library (http://jquery.com)

 @source: http://github.com/rendro/easy-pie-chart/
 @autor: Robert Fleischmann
 @version: 1.0.1

 Inspired by: http://dribbble.com/shots/631074-Simple-Pie-Charts-II?list=popular&offset=210
 Thanks to Philip Thrasher for the jquery plugin boilerplate for coffee script
 */


(function () {

    (function ($) {
        $.easyPieChart = function (el, options) {
            var addScaleLine, animateLine, drawLine, easeInOutQuad, renderBackground, renderScale, renderTrack,
                _this = this;
            this.el = el;
            this.$el = $(el);
            this.$el.data("easyPieChart", this);
            this.init = function () {
                var percent;
                _this.options = $.extend({}, $.easyPieChart.defaultOptions, options);
                percent = parseInt(_this.$el.data('percent'), 10);
                _this.percentage = 0;
                _this.canvas = $("<canvas width='" + _this.options.size + "' height='" + _this.options.size + "'></canvas>").get(0);
                _this.$el.append(_this.canvas);
                if (typeof G_vmlCanvasManager !== "undefined" && G_vmlCanvasManager !== null) {
                    G_vmlCanvasManager.initElement(_this.canvas);
                }
                _this.ctx = _this.canvas.getContext('2d');
                _this.ctx.translate(_this.options.size / 2, _this.options.size / 2);
                _this.$el.addClass('easyPieChart');
                _this.$el.css({
                    width: _this.options.size,
                    height: _this.options.size,
                    lineHeight: "" + _this.options.size + "px"
                });
                _this.update(percent);
                return _this;
            };
            this.update = function (percent) {
                if (_this.options.animate === false) {
                    return drawLine(percent);
                } else {
                    return animateLine(_this.percentage, percent);
                }
            };
            renderScale = function () {
                var i, _i, _results;
                _this.ctx.fillStyle = _this.options.scaleColor;
                _this.ctx.lineWidth = 1;
                _results = [];
                for (i = _i = 0; _i <= 24; i = ++_i) {
                    _results.push(addScaleLine(i));
                }
                return _results;
            };
            addScaleLine = function (i) {
                var offset;
                offset = i % 6 === 0 ? 0 : _this.options.size * 0.017;
                _this.ctx.save();
                _this.ctx.rotate(i * Math.PI / 12);
                _this.ctx.fillRect(_this.options.size / 2 - offset, 0, -_this.options.size * 0.05 + offset, 1);
                return _this.ctx.restore();
            };
            renderTrack = function () {
                var offset;
                offset = _this.options.size / 2 - _this.options.lineWidth / 2;
                if (_this.options.scaleColor !== false) {
                    offset -= _this.options.size * 0.08;
                }
                _this.ctx.beginPath();
                _this.ctx.arc(0, 0, offset, 0, Math.PI * 2, true);
                _this.ctx.closePath();
                _this.ctx.strokeStyle = _this.options.trackColor;
                _this.ctx.lineWidth = _this.options.lineWidth;
                return _this.ctx.stroke();
            };
            renderBackground = function () {
                if (_this.options.scaleColor !== false) {
                    renderScale();
                }
                if (_this.options.trackColor !== false) {
                    return renderTrack();
                }
            };
            drawLine = function (percent) {
                var offset;
                renderBackground();
                _this.ctx.strokeStyle = $.isFunction(_this.options.barColor) ? _this.options.barColor(percent) : _this.options.barColor;
                _this.ctx.lineCap = _this.options.lineCap;
                offset = _this.options.size / 2 - _this.options.lineWidth / 2;
                if (_this.options.scaleColor !== false) {
                    offset -= _this.options.size * 0.08;
                }
                _this.ctx.save();
                _this.ctx.rotate(-Math.PI / 2);
                _this.ctx.beginPath();
                _this.ctx.arc(0, 0, offset, 0, Math.PI * 2 * percent / 100, false);
                _this.ctx.stroke();
                return _this.ctx.restore();
            };
            animateLine = function (from, to) {
                var currentStep, fps, steps;
                fps = 30;
                steps = fps * _this.options.animate / 1000;
                currentStep = 0;
                _this.options.onStart.call(_this);
                _this.percentage = to;
                if (_this.animation) {
                    clearInterval(_this.animation);
                    _this.animation = false;
                }
                return _this.animation = setInterval(function () {
                    _this.ctx.clearRect(-_this.options.size / 2, -_this.options.size / 2, _this.options.size, _this.options.size);
                    renderBackground.call(_this);
                    drawLine.call(_this, [easeInOutQuad(currentStep, from, to - from, steps)]);
                    currentStep++;
                    if ((currentStep / steps) > 1) {
                        clearInterval(_this.animation);
                        _this.animation = false;
                        return _this.options.onStop.call(_this);
                    }
                }, 1000 / fps);
            };
            easeInOutQuad = function (t, b, c, d) {
                t /= d / 2;
                if (t < 1) {
                    return c / 2 * t * t + b;
                } else {
                    return -c / 2 * ((--t) * (t - 2) - 1) + b;
                }
            };
            return this.init();
        };
        $.easyPieChart.defaultOptions = {
            barColor: '#ef1e25',
            trackColor: '#f2f2f2',
            scaleColor: '#dfe0e0',
            lineCap: 'round',
            size: 110,
            lineWidth: 3,
            animate: false,
            onStart: $.noop,
            onStop: $.noop
        };
        $.fn.easyPieChart = function (options) {
            return $.each(this, function (i, el) {
                var $el;
                $el = $(el);
                if (!$el.data('easyPieChart')) {
                    return $el.data('easyPieChart', new $.easyPieChart(el, options));
                }
            });
        };
        return void 0;
    })(jQuery);

}).call(this);
(function (e) {
    "use strict";
    var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDM4RjdFNzQ5MzAyMTFFMUFFQTdENUVDNDUwOEI2RUYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDM4RjdFNzU5MzAyMTFFMUFFQTdENUVDNDUwOEI2RUYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowMzhGN0U3MjkzMDIxMUUxQUVBN0Q1RUM0NTA4QjZFRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowMzhGN0U3MzkzMDIxMUUxQUVBN0Q1RUM0NTA4QjZFRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv4BSzoAAA+OSURBVHja1F1bkutKEazSdUAErIAdsVaCTfDNAvhgHXCJe8448ciW3I96drdmYGJiwpYl25NZlfXoVjfjn38lJuGHxafsnRB46rw0+BEonqI4AfY5xNLB/QFLB8W3DZ/QPH6cuXXHlB94RyJv4p4Zf5M1P+y+Au9rwntL6B/xeGmL4vs6gkGUvxrZ8Lfj6HeE6HbeY+if+3y8JWy85wArQIf+HJebu2zgYfN3Rc9GvyZgCQdBoL9DhTD/Kq+Q/vpNtrTWX6E8V4DOrgmz7BMcEnd4HxdBf48BUasfFaIBJ/gqnrLmkVYkD/3DA5ZzMIvaV4ds6OZvx15RfOLoU5UFYR0HA3xgmaPYcZVM/Un5wTz6XhDOcpBVm+/ITWE80M0fsUiTRR9+EMYFyoH/RRWa54/y6FMoCGOFEGWV59oYy0a9aph/LjAE0A8HYVwpRCscAKFGlmm/XkMMMfFJoU+JVkScg2xnCZerEZYqDCbQhxUDFnAwndLgC8IACw7BTt2LDEPNhVqIxkgrAuvaOJg2Zix2CATdgs20h72kqHYUKQuaMnyMoIZLlCeKr2f+VnSJeYaRnm4C4rSIg2/FXZEX1hr90DUkLv1iH8kuDhYG4XBATuCOLCtZ5QOH/q2V6LPWjo5wMNNvGLD3uDdwEveY+ccjsI0+9Jb1lgsAiQwHzje6Lu/kaP0VNH8/I+LY/8ptUoRoJTyYccaECItwjwfYANDi6Hy8gwRTdvKVMK3jII3yelqg/UMsH+wv8ft3XcdCq8XMdjSWcpDT1ClHkb8pq70EmAzBy69gir5di60rxLITBL76h2F/C5bI6KQ/iH6qGYe2gl3egTCE6FJ62IkNsAPDDPpsNSRqCYIkFG4Cmrb9fCaP2TAAQ39M8xcDbwp9xEriZmLWhCvEORhwghR37OtPa/4cigQp9F3DVwoxkYZZ/VmH+JdEEWjJaIc+ugfBTlzpTFozDkv153yMQMk/izhsxTfNP4V+a/hspkMNcvx6Q6MZF3YFlV8zIOegz5cPb6A5GCeg9yF89E0AqJukfXwxdusARG0f8UwfaatfNNW3N/8QMdwKjoG+bfh4GT4/PztWBwDWsHtcggwOhrt1SdANoZePdJdXol/IDsijoYNeGhETXaFXpOEwELR6LIJe0h/1ozLoBw2/kfsG+qYOCPQhBmagWBwgpy3i+ZkeXKXj3LbblqAvG/4h93DqgCgNiivAswStwnKT8MyoQHC8xf9MltPNpmqz9KfQHCOR3EL6MzkZCwYAGIfbdx6WCygpE7UqtfJM1jujxeUR6M3xAPdg7wpZDnzNmYrI0b4qy/k+xJCrGD7qaiAIfeEBQcO3achKkBgMoFBoOoc2LQ7smL+AKSufaRp+J/ch6EmYmKXF3rFpcas4SLoBqEo5qLNiWdk19DvZEd5BMXwbeiUNTdh+zBWIrDLGbnnCqw8iU1LN24DfULJVGIMUDiagf/7cXs9Y+SfYPCg8xetmaxzHy3OeByE9xf4vgOsj9UczdUejuJeIC67goa8XwEyx8SctPbu1r7NyHWdoYLy/fol1CTpRi3X/lzQaJNHn9hBEGjz0/SKATqv32z7kzXm5qVbEnkMYNGiuoJHx/vu4yrwkWYK9oxhXobJHP2j4Z02bmIKof7FDglj35wU0cGXvZKvQwYFBmMcHqOoMUy0+qE+LoD8DPbyVC27tsbgEOSpUZDiiKxgqREcwkEGPusNp7JDCQI++moMemoPwwAcFpiRhRIJy5t8p0vNL2R7QM9Qy6i6IwfKzko/OJzT0NeiDJu/OM/EkKMJEnIYzOBseQJ0Qie+mK0/1t0BcRZ+FLLOPtI75J3GvPcCQoHhYbk4TgdNcQeOA2ILekyJIKtR08PUUyILerTMyHmC8Ph8PLBrYykFLDoRvAv1Oa36jzB0NCvqa5kQm5FJyQnNz/KZb+FA8aOAmSc3fIiNlCe0lEM5hte9Ztn0ahakSUJY7Cu0EFnF0ZQ53KQbII0jsu4V4XAsJkOg5FYml7Igs0dcGA07z722/paTKfxzowSHcU+ZvSxAGyWAzJDSecSrS+V4CB1ATm/bzGbX5ixG4UyEOVF6JmouCM5tYJEAjQ3QOwwMMLWoeu4pUctCUeB1YfSJ0Z5mJ/XzWyi570DE+tAHTblBLkOfvMh/sRGM/IOuZDTceyWpxQK2+3xv0hayUzYo33+fxEBcZuvnOwzYfHRm9W9hOwOLMLbYiM0RRZKot/cWBIEGsJD8jg3ga4sHbBW+JwT2/VkB9Anc6o0iQ9qkocs0HkBuqZk3BxEt8+BP0+35ug/69kHsEZj9EDT+GuPHSTX6R5ygRnQNJJs7KmWoO7nzc1XCEgQPBO70M/0kD+HUEh9zbvYdQmOUpuPtzbrn34DwlvXMgtVYVdiaOacRPDtpu56eqvD2AGw/gRv3Vjlv/D3lwz9/teSPKoWGk4SFKhJs1WAjD5d+nYt93Odp2UM+AfIyBPnH/2H+f6B8csJiAGuNc2cySkjNpEJKgrChFnAZaxQuhc99zwEeeuh0n8jGpY7f9D9oJoBcTj7PvUuJP5v3v8Qp2CRkZDxjmySAGouifj7nj4DlufFz8ecLzGn4g/nOjny8C+F6n/6RPQMdqSclee6O1P3GeYNVbR8etHO/lNw2Pl7b9LR5/b/Sx0W8b/XhwwPzRVF4k34E0szzt2vt0bovfbzhoa60OlF3OU3x4T4f2p7/nX3+hXzf+cSSgxuzBtThiDQGX/uCiy48X/o1//Onif+HiH8bf//KlLjeGe3Nz2TPB/AD9Rh//uv/tz3/8A3AD/XKEaq4GInPJRLz9+v8gQQkKYQlz0+S87/rzk+4/Pl/4zx4hfke47WnR85cP3WomDUX4wAVM8EoJmrlxOru0d9tfxmH+hI9XGPhJ9OPzX+Q78Au//GA7ggUXZPRMwGOCpyEOZEFYbeoDK/bZCx2d0D/Rv3+ij8dfvOqIRxq6ty14Pwsbv3JaLjPYenCTofZqx+waQ9dmJWh66wY3AxdsH1Ve+cD9viN/LyrhT5c4tgDCZ7Fw9i9OGoiqB9XMI6RNngMYRHzi5gCzdpV/ZDSHDujpDf2ned/R3sLMn0Fh2/+++n47BxtRSQMV3tBOROJuausQ9JyUan4Nyl9R4QULHtXwUUv/6xdPibm/H5et0rJo27tueJs8v4fd2J0EnFQWnuhh3haXgEjSgK5pKt4FcaJ/PzLSzlFfbZ+jPntysLeLcK/DwEmDPRFbBI8htBIxGh7YyoImm09p24d1G0pp7xDuzoDCwS4mzIcr9DRAaV9pS3mXrXSW0jr22sGdB6xthYwsNge5TVw8wBGHT/MH0ON1RortfPAMD+3g8puGM4xzQGegk6Hx4VJyGxeWsSSHulvDiGwCKvRh3Zb07r6han/e9w0L+biJsYq3nLQ/hQxqnEPPyVn2gKz+BJVHlR2YyY+AvvN1+KXOp6zjiMxbhZkyEUOhgfUJTVpGxAXx1NUcpM4NnfSDxPquHvTUoX9e19TDuh88naD98JoDQXYO8Dg2isHmDJBKfBTnCBRiWKg8nRmYHADoxKWNHWLkRA0NBPzY3t+kuSzrB6LoVwfZ7gXNK74LvccBUN3xiqYzYX61EmQWb+NGoJI96oaUH7CNuxQGblOi7+Q8CN233T1t0YdOp0lDKUQKfkfBFqCBvXnG7M1JE0EalaAx6APiAziLK8LoA8Q7VXyWVCyqFNfBw6BBa+dF3CIvQb4fwJ/cFEQfHdxImAp3rMDyAxJdwaXBdggKHLkti7cR6E0PENCHnr963zlSEDGXgNbCpPlETQN5DuEycZvd99GGnqJLdkBbr6M+GXrT1tg1ANBDaM1Bea6gRQEaKMnEbcLkSeikDukPtLWBECju4nKkqXbF0DHZSL+dWaRhICpIlXAi5CJceTn6A6kXBHk1segulNzVyQQrb+FjBE06S717qqTh/Cdch2iObGKl01WWNfSAdY47uOihP76CGeurjnP7TUH2ak1stge7B2x9hIqlGgMiahPsuOn6I6M/sXQ0knePCw+O9LSa+6gvckFhb9CeRtYNhdB7GVhQ2kaf3NZQZtlKxQlgjz1LfgBjtSZtZSrJG7SndiWM9L3fMRoE9FF84LqpSuIaE9riLRDKtNegjugKTnkseUPvmsrCraLVU2ZnsQj6JFW5SsSOLACuuRzp9z5CG4xobyZgMpaP1t3C9gZpR20DeuQlCFIiH+nHuUlX0g8yncC3CfccJIRIp0HbyC0GvRt7dQsEWVsITG5lq93ioi12HhiPEDiAslJZZAHhcjSuWTUxA/3oZg4wRmOUFr/zamY8wlmsNcyBKEdwoddp2KLQU9IPMuh77zwblHPKE1q8koMeoMrEQUN4+XqM+4GLPiI05BGPrF6I4PsITiMsaZPYwuSgYctBHw8AEd0X5eXifZyRcQXqltCt35PRbQkQUiEhCAcHeJM7yUATkDjc59Bw/BKO+QSHhIj8FQ14UIWsOiBi+F74bdGPiM+X7HuI5N8UB1kViu0pnw+/PvrfhK/rK0EO+rCccgV9A4dU4yGLvpj4m9uc4Gp62CLJqhTlBYU40hEun3pbmORjgIU+rCZTIpKudibXXbT9cW0OXPNfHwNC6I9F4zma7DQ/kstmNhHjiPmT3I6m8RIsij7MytbWn1UrW+R1P8uBLUekbug8GoERLFkxuTfMrEOQ5wQItDQiHBhypDTjJiIw7B4xknoxTU92z42pjc0lDmw5ougmPin0Y125sPnjaldoQedR85c46ORIrQm2yRp4EH33Q3FhwWDsYT5o/t6mtsUt++27xQoxGkJ/UqcvawSNNXn91aS7Tp8WEmhJIeajnzJ/7cphhniIHvYz5IUcYDgIw5UJTD1eHhcwYfUp6DUOxAx1MAjL6JtC9GVL3mT3q9ecYAZ6kQPNFbbscJiPvpH4h1a/xhdTFSTsIg62VCYeQh9zYOaixTU+wekuyTAHkS3NR9FvDuDLrZxzmReUaBxC2R4J0DmIBuER9IO2/B36k3WO+O7sKjFsb+Y5j362EbPwpXW8ISBESDoEKZNT6Z2G+ikQQlOTI+Kz5KpRA18+9DnAQeMKm4s+shPTbb7wfWXxAJQ8IjuRJdhhtSKaZzMztFKozqyB/b08DZShLG7oLKA/UlNhFMT1qPJ0Xs+JeIc8B9ss+su8YfnSjYtZzOagQQ625ehHo+gq4VrKyozcj7W+tmXoT5v4Fe4xIB0RJ1igP9XMOBf9hb2V/4GQOuwN4ZZN4vEWQj8rPt8tOMurYsScYODx5mM4ID6Tw+hr+eC0IQfNPL6zofEm/xVgACau5NQhMGZKAAAAAElFTkSuQmCC", n = new Image;
    n.src = t;
    e.fn.percentageLoader = function (t) {
        var r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D;
        r = {width: 256, height: 256, progress: 0, value: "0kb", controllable: false};
        if (t !== undefined) {
            e.extend(r, t)
        } else {
            t = r
        }
        D = document.createElement("div");
        D.style.width = r.width + "px";
        D.style.height = r.height + "px";
        D.style.position = "relative";
        e(this).append(D);
        i = document.createElement("canvas");
        i.setAttribute("width", r.width);
        i.setAttribute("height", r.height);
        D.appendChild(i);
        s = document.createElement("div");
        s.style.width = r.width.toString() - 2 + "px";
        s.style.textAlign = "center";
        s.style.height = "50px";
        s.style.left = 0;
        s.style.position = "absolute";
        o = document.createElement("div");
        o.style.width = (r.width - 2).toString() + "px";
        o.style.textAlign = "center";
        o.style.height = "0px";
        o.style.overflow = "hidden";
        o.style.left = 0;
        o.style.position = "absolute";
        u = [o, s];
        for (a = 0; a < u.length; a += 1) {
            f = u[a];
            l = ["-webkit-user-select", "-khtml-user-select", "-moz-user-select", "-o-user-select", "user-select"];
            for (c = 0; c < l.length; c += 1) {
                e(f).css(l[c], "none")
            }
        }
        D.appendChild(s);
        D.appendChild(o);
        h = i.getContext("2d");
        v = i.width / 2 - 1;
        m = i.height / 2 - 1;
        g = h.createLinearGradient(v, 0, v, i.height);
        g.addColorStop(0, "#d6eeff");
        g.addColorStop(1, "#b6d8f0");
        y = h.createLinearGradient(v, v * .133333, v, i.height - v * .133333);
        y.addColorStop(0, "#f9fcfe");
        y.addColorStop(1, "#d9ebf7");
        b = h.createLinearGradient(v, 0, v, i.height);
        b.addColorStop(0, "#c1dff4");
        b.addColorStop(1, "#aacee6");
        w = v * .6666;
        x = v - 2;
        E = w + v * .06;
        S = x - v * .06;
        T = 2.1707963267949;
        N = .9707963267949 + Math.PI * 2;
        C = false;
        h.lineWidth = 1;
        O = function (e, t, n) {
            return {x: e.x + Math.cos(t) * n, y: e.y + Math.sin(t) * n}
        };
        M = function () {
            function e(e, t) {
                var n, r, i, s, o, u, a, f;
                n = {x: v, y: m};
                r = O(n, e, E);
                h.moveTo(r.x, r.y);
                a = O(n, t, E);
                f = O(n, t, S);
                i = t + 3.142 / 2;
                s = v * .2 - 4;
                o = O(a, i, s);
                u = O(f, i, s);
                h.arc(v, m, E, e, t, false);
                h.bezierCurveTo(o.x, o.y, u.x, u.y, f.x, f.y);
                h.arc(v, m, S, t, e, true);
                a = O(n, e, E);
                f = O(n, e, S);
                i = e - 3.142 / 2;
                o = O(f, i, s);
                u = O(a, i, s);
                h.bezierCurveTo(o.x, o.y, u.x, u.y, a.x, a.y)
            }

            h.clearRect(0, 0, i.width, i.height);
            h.fillStyle = g;
            h.beginPath();
            h.strokeStyle = "#b2d5ed";
            h.arc(v, m, x, 0, Math.PI * 2, C);
            h.fill();
            h.stroke();
            h.fillStyle = y;
            h.beginPath();
            h.arc(v, m, w, 0, Math.PI * 2, C);
            h.fill();
            h.strokeStyle = "#b2d5edaa";
            h.stroke();
            h.beginPath();
            h.beginPath();
            h.strokeStyle = "#bcd4e5";
            e(T, N);
            h.fillStyle = b;
            h.fill();
            h.stroke();
            k = T + p * (N - T);
            h.beginPath();
            e(T, k);
            h.save();
            h.clip();
            h.drawImage(n, 0, 0, i.width, i.height);
            h.restore();
            h.beginPath();
            e(T, k);
            h.stroke();
            (function () {
                var e, t, n, i;
                e = v / 2;
                s.style.top = (r.height / 2 - e / 2).toString() + "px";
                s.style.color = "#80a9c8";
                s.style.font = e.toString() + "px BebasNeueRegular";
                s.style.textShadow = "0 1px 1px #FFFFFF";
                t = (p * 100).toFixed(0) + "%";
                s.innerHTML = t;
                n = v / 5.5;
                o.style.color = "#80a9c8";
                o.style.font = n.toString() + "px BebasNeueRegular";
                o.style.height = n.toString() + "px";
                o.style.textShadow = "None";
                i = r.height * .16666666 - n;
                o.style.top = (r.height * .8333333 + i / 4).toString() + "px"
            })()
        };
        _ = function () {
            if (p < 0) {
                p = 0
            }
            if (p > 1) {
                p = 1
            }
        };
        L = function (e) {
            p = e;
            _();
            M()
        };
        this.setProgress = L;
        A = function (e) {
            d = e;
            o.innerHTML = d
        };
        this.setValue = A;
        this.setValue(r.value);
        p = r.progress;
        _();
        M();
        if (t.controllable === true) {
            (function () {
                var n, r, i;
                r = function (e, t) {
                    return Math.sqrt(Math.pow(e - v, 2) + Math.pow(t - m, 2))
                };
                n = false;
                i = function (e, n) {
                    var r, i, s, o, u, a;
                    r = e - v;
                    i = n - m;
                    s = Math.atan2(i, r);
                    if (s > Math.PI / 2) {
                        s -= Math.PI * 2
                    }
                    o = T - Math.PI * 2;
                    u = N - T;
                    a = (s - o) / u;
                    L(a);
                    if (t.onProgressUpdate) {
                        t.onProgressUpdate(p)
                    }
                };
                e(D).mousedown(function (t) {
                    var s, o, u, a;
                    s = e(this).offset();
                    o = t.pageX - s.left;
                    u = t.pageY - s.top;
                    a = r(o, u);
                    if (a > w && a < x) {
                        n = true;
                        i(o, u)
                    }
                }).mouseup(function () {
                    n = false
                }).mousemove(function (t) {
                    var r, s, o;
                    if (n) {
                        r = e(D).offset();
                        s = t.pageX - r.left;
                        o = t.pageY - r.top;
                        i(s, o)
                    }
                }).mouseleave(function () {
                    n = false
                })
            })()
        }
        return this
    }
})(jQuery);

/*!jQuery Knob*/
/**
 * Downward compatible, touchable dial
 *
 * Version: 1.2.0 (15/07/2012)
 * Requires: jQuery v1.7+
 *
 * Copyright (c) 2012 Anthony Terrien
 * Under MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to vor, eskimoblood, spiffistan, FabrizioC
 */
(function ($) {

    /**
     * Kontrol library
     */
    "use strict";

    /**
     * Definition of globals and core
     */
    var k = {}, // kontrol
        max = Math.max,
        min = Math.min;

    k.c = {};
    k.c.d = $(document);
    k.c.t = function (e) {
        return e.originalEvent.touches.length - 1;
    };

    /**
     * Kontrol Object
     *
     * Definition of an abstract UI control
     *
     * Each concrete component must call this one.
     * <code>
     * k.o.call(this);
     * </code>
     */
    k.o = function () {
        var s = this;

        this.o = null; // array of options
        this.$ = null; // jQuery wrapped element
        this.i = null; // mixed HTMLInputElement or array of HTMLInputElement
        this.g = null; // 2D graphics context for 'pre-rendering'
        this.v = null; // value ; mixed array or integer
        this.cv = null; // change value ; not commited value
        this.x = 0; // canvas x position
        this.y = 0; // canvas y position
        this.$c = null; // jQuery canvas element
        this.c = null; // rendered canvas context
        this.t = 0; // touches index
        this.isInit = false;
        this.fgColor = null; // main color
        this.pColor = null; // previous color
        this.dH = null; // draw hook
        this.cH = null; // change hook
        this.eH = null; // cancel hook
        this.rH = null; // release hook

        this.run = function () {
            var cf = function (e, conf) {
                var k;
                for (k in conf) {
                    s.o[k] = conf[k];
                }
                s.init();
                s._configure()
                    ._draw();
            };

            if (this.$.data('kontroled')) return;
            this.$.data('kontroled', true);

            this.extend();
            this.o = $.extend(
                {
                    // Config
                    min: this.$.data('min') || 0,
                    max: this.$.data('max') || 100,
                    stopper: true,
                    readOnly: this.$.data('readonly'),

                    // UI
                    cursor: (this.$.data('cursor') === true && 30)
                    || this.$.data('cursor')
                    || 0,
                    thickness: this.$.data('thickness') || 0.35,
                    width: this.$.data('width') || 200,
                    height: this.$.data('height') || 200,
                    displayInput: this.$.data('displayinput') == null || this.$.data('displayinput'),
                    displayPrevious: this.$.data('displayprevious'),
                    fgColor: this.$.data('fgcolor') || '#87CEEB',
                    inline: false,

                    // Hooks
                    draw: null, // function () {}
                    change: null, // function (value) {}
                    cancel: null, // function () {}
                    release: null // function (value) {}
                }, this.o
            );

            // routing value
            if (this.$.is('fieldset')) {

                // fieldset = array of integer
                this.v = {};
                this.i = this.$.find('input')
                this.i.each(function (k) {
                    var $this = $(this);
                    s.i[k] = $this;
                    s.v[k] = $this.val();

                    $this.bind(
                        'change'
                        , function () {
                            var val = {};
                            val[k] = $this.val();
                            s.val(val);
                        }
                    );
                });
                this.$.find('legend').remove();

            } else {
                // input = integer
                this.i = this.$;
                this.v = this.$.val();
                (this.v == '') && (this.v = this.o.min);

                this.$.bind(
                    'change'
                    , function () {
                        s.val(s.$.val());
                    }
                );
            }

            (!this.o.displayInput) && this.$.hide();

            this.$c = $('<canvas width="' +
                this.o.width + 'px" height="' +
                this.o.height + 'px"></canvas>');
            this.c = this.$c[0].getContext("2d");

            this.$
                .wrap($('<div style="' + (this.o.inline ? 'display:inline;' : '') +
                    'width:' + this.o.width + 'px;height:' +
                    this.o.height + 'px;"></div>'))
                .before(this.$c);

            if (this.v instanceof Object) {
                this.cv = {};
                this.copy(this.v, this.cv);
            } else {
                this.cv = this.v;
            }

            this.$
                .bind("configure", cf)
                .parent()
                .bind("configure", cf);

            this._listen()
                ._configure()
                ._xy()
                .init();

            this.isInit = true;

            this._draw();

            return this;
        };

        this._draw = function () {

            // canvas pre-rendering
            var d = true,
                c = document.createElement('canvas');

            c.width = s.o.width;
            c.height = s.o.height;
            s.g = c.getContext('2d');

            s.clear();

            s.dH
            && (d = s.dH());

            (d !== false) && s.draw();

            s.c.drawImage(c, 0, 0);
            c = null;
        };

        this._touch = function (e) {

            var touchMove = function (e) {

                var v = s.xy2val(
                    e.originalEvent.touches[s.t].pageX,
                    e.originalEvent.touches[s.t].pageY
                );

                if (v == s.cv) return;

                if (
                    s.cH
                    && (s.cH(v) === false)
                ) return;


                s.change(v);
                s._draw();
            };

            // get touches index
            this.t = k.c.t(e);

            // First touch
            touchMove(e);

            // Touch events listeners
            k.c.d
                .bind("touchmove.k", touchMove)
                .bind(
                "touchend.k"
                , function () {
                    k.c.d.unbind('touchmove.k touchend.k');

                    if (
                        s.rH
                        && (s.rH(s.cv) === false)
                    ) return;

                    s.val(s.cv);
                }
            );

            return this;
        };

        this._mouse = function (e) {

            var mouseMove = function (e) {
                var v = s.xy2val(e.pageX, e.pageY);
                if (v == s.cv) return;

                if (
                    s.cH
                    && (s.cH(v) === false)
                ) return;

                s.change(v);
                s._draw();
            };

            // First click
            mouseMove(e);

            // Mouse events listeners
            k.c.d
                .bind("mousemove.k", mouseMove)
                .bind(
                // Escape key cancel current change
                "keyup.k"
                , function (e) {
                    if (e.keyCode === 27) {
                        k.c.d.unbind("mouseup.k mousemove.k keyup.k");

                        if (
                            s.eH
                            && (s.eH() === false)
                        ) return;

                        s.cancel();
                    }
                }
            )
                .bind(
                "mouseup.k"
                , function (e) {
                    k.c.d.unbind('mousemove.k mouseup.k keyup.k');

                    if (
                        s.rH
                        && (s.rH(s.cv) === false)
                    ) return;

                    s.val(s.cv);
                }
            );

            return this;
        };

        this._xy = function () {
            var o = this.$c.offset();
            this.x = o.left;
            this.y = o.top;
            return this;
        };

        this._listen = function () {

            if (!this.o.readOnly) {
                this.$c
                    .bind(
                    "mousedown"
                    , function (e) {
                        e.preventDefault();
                        s._xy()._mouse(e);
                    }
                )
                    .bind(
                    "touchstart"
                    , function (e) {
                        e.preventDefault();
                        s._xy()._touch(e);
                    }
                );
                this.listen();
            } else {
                this.$.attr('readonly', 'readonly');
            }

            return this;
        };

        this._configure = function () {

            // Hooks
            if (this.o.draw) this.dH = this.o.draw;
            if (this.o.change) this.cH = this.o.change;
            if (this.o.cancel) this.eH = this.o.cancel;
            if (this.o.release) this.rH = this.o.release;

            if (this.o.displayPrevious) {
                this.pColor = this.h2rgba(this.o.fgColor, "0.4");
                this.fgColor = this.h2rgba(this.o.fgColor, "0.6");
            } else {
                this.fgColor = this.o.fgColor;
            }

            return this;
        };

        this._clear = function () {
            this.$c[0].width = this.$c[0].width;
        };

        // Abstract methods
        this.listen = function () {
        }; // on start, one time
        this.extend = function () {
        }; // each time configure triggered
        this.init = function () {
        }; // each time configure triggered
        this.change = function (v) {
        }; // on change
        this.val = function (v) {
        }; // on release
        this.xy2val = function (x, y) {
        }; //
        this.draw = function () {
        }; // on change / on release
        this.clear = function () {
            this._clear();
        };

        // Utils
        this.h2rgba = function (h, a) {
            var rgb;
            h = h.substring(1, 7)
            rgb = [parseInt(h.substring(0, 2), 16)
                , parseInt(h.substring(2, 4), 16)
                , parseInt(h.substring(4, 6), 16)];
            return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + a + ")";
        };

        this.copy = function (f, t) {
            for (var i in f) {
                t[i] = f[i];
            }
        };
    };


    /**
     * k.Dial
     */
    k.Dial = function () {
        k.o.call(this);

        this.startAngle = null;
        this.xy = null;
        this.radius = null;
        this.lineWidth = null;
        this.cursorExt = null;
        this.w2 = null;
        this.PI2 = 2 * Math.PI;

        this.extend = function () {
            this.o = $.extend(
                {
                    bgColor: this.$.data('bgcolor') || '#EEEEEE',
                    angleOffset: this.$.data('angleoffset') || 0,
                    angleArc: this.$.data('anglearc') || 360,
                    inline: true
                }, this.o
            );
        };

        this.val = function (v) {
            if (null != v) {
                this.cv = this.o.stopper ? max(min(v, this.o.max), this.o.min) : v;
                this.v = this.cv;
                this.$.val(this.v);
                this._draw();
            } else {
                return this.v;
            }
        };

        this.xy2val = function (x, y) {
            var a, ret;

            a = Math.atan2(
                    x - (this.x + this.w2)
                    , -(y - this.y - this.w2)
                ) - this.angleOffset;

            if (this.angleArc != this.PI2 && (a < 0) && (a > -0.5)) {
                // if isset angleArc option, set to min if .5 under min
                a = 0;
            } else if (a < 0) {
                a += this.PI2;
            }

            ret = ~~(0.5 + (a * (this.o.max - this.o.min) / this.angleArc))
                + this.o.min;

            this.o.stopper
            && (ret = max(min(ret, this.o.max), this.o.min));

            return ret;
        };

        this.listen = function () {
            // bind MouseWheel
            var s = this,
                mw = function (e) {
                    e.preventDefault();

                    var ori = e.originalEvent
                        , deltaX = ori.detail || ori.wheelDeltaX
                        , deltaY = ori.detail || ori.wheelDeltaY
                        , v = parseInt(s.$.val()) + (deltaX > 0 || deltaY > 0 ? 1 : deltaX < 0 || deltaY < 0 ? -1 : 0);

                    if (
                        s.cH
                        && (s.cH(v) === false)
                    ) return;

                    s.val(v);
                }
                , kval, to, m = 1, kv = {37: -1, 38: 1, 39: 1, 40: -1};

            this.$
                .bind(
                "keydown"
                , function (e) {
                    var kc = e.keyCode;

                    // numpad support
                    if (kc >= 96 && kc <= 105) {
                        kc = e.keyCode = kc - 48;
                    }

                    kval = parseInt(String.fromCharCode(kc));

                    if (isNaN(kval)) {

                        (kc !== 13)         // enter
                        && (kc !== 8)       // bs
                        && (kc !== 9)       // tab
                        && (kc !== 189)     // -
                        && e.preventDefault();

                        // arrows
                        if ($.inArray(kc, [37, 38, 39, 40]) > -1) {
                            e.preventDefault();

                            var v = parseInt(s.$.val()) + kv[kc] * m;

                            s.o.stopper
                            && (v = max(min(v, s.o.max), s.o.min));

                            s.change(v);
                            s._draw();

                            // long time keydown speed-up
                            to = window.setTimeout(
                                function () {
                                    m *= 2;
                                }
                                , 30
                            );
                        }
                    }
                }
            )
                .bind(
                "keyup"
                , function (e) {
                    if (isNaN(kval)) {
                        if (to) {
                            window.clearTimeout(to);
                            to = null;
                            m = 1;
                            s.val(s.$.val());
                        }
                    } else {
                        // kval postcond
                        (s.$.val() > s.o.max && s.$.val(s.o.max))
                        || (s.$.val() < s.o.min && s.$.val(s.o.min));
                    }

                }
            );

            this.$c.bind("mousewheel DOMMouseScroll", mw);
            this.$.bind("mousewheel DOMMouseScroll", mw)
        };

        this.init = function () {

            if (
                this.v < this.o.min
                || this.v > this.o.max
            ) this.v = this.o.min;

            this.$.val(this.v);
            this.w2 = this.o.width / 2;
            this.cursorExt = this.o.cursor / 100;
            this.xy = this.w2;
            this.lineWidth = this.xy * this.o.thickness;
            this.radius = this.xy - this.lineWidth / 2;

            this.o.angleOffset
            && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset);

            this.o.angleArc
            && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc);

            // deg to rad
            this.angleOffset = this.o.angleOffset * Math.PI / 180;
            this.angleArc = this.o.angleArc * Math.PI / 180;

            // compute start and end angles
            this.startAngle = 1.5 * Math.PI + this.angleOffset;
            this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;

            var s = max(
                    String(Math.abs(this.o.max)).length
                    , String(Math.abs(this.o.min)).length
                    , 2
                ) + 2;

            this.o.displayInput
            && this.i.css({
                'width': ((this.o.width / 2 + 4) >> 0) + 'px'
                , 'height': ((this.o.width / 3) >> 0) + 'px'
                , 'position': 'absolute'
                , 'vertical-align': 'middle'
                , 'margin-top': ((this.o.width / 3) >> 0) + 'px'
                , 'margin-left': '-' + ((this.o.width * 3 / 4 + 2) >> 0) + 'px'
                , 'border': 0
                , 'background': 'none'
                , 'font': 'bold ' + ((this.o.width / s) >> 0) + 'px Arial'
                , 'text-align': 'center'
                , 'color': this.o.fgColor
                , 'padding': '0px'
                , '-webkit-appearance': 'none'
            })
            || this.i.css({
                'width': '0px'
                , 'visibility': 'hidden'
            });
        };

        this.change = function (v) {
            this.cv = v;
            this.$.val(v);
        };

        this.angle = function (v) {
            return (v - this.o.min) * this.angleArc / (this.o.max - this.o.min);
        };

        this.draw = function () {

            var c = this.g,                 // context
                a = this.angle(this.cv)    // Angle
                , sat = this.startAngle     // Start angle
                , eat = sat + a             // End angle
                , sa, ea                    // Previous angles
                , r = 1;

            c.lineWidth = this.lineWidth;

            this.o.cursor
            && (sat = eat - this.cursorExt)
            && (eat = eat + this.cursorExt);

            c.beginPath();
            c.strokeStyle = this.o.bgColor;
            c.arc(this.xy, this.xy, this.radius, this.endAngle, this.startAngle, true);
            c.stroke();

            if (this.o.displayPrevious) {
                ea = this.startAngle + this.angle(this.v);
                sa = this.startAngle;
                this.o.cursor
                && (sa = ea - this.cursorExt)
                && (ea = ea + this.cursorExt);

                c.beginPath();
                c.strokeStyle = this.pColor;
                c.arc(this.xy, this.xy, this.radius, sa, ea, false);
                c.stroke();
                r = (this.cv == this.v);
            }

            c.beginPath();
            c.strokeStyle = r ? this.o.fgColor : this.fgColor;
            c.arc(this.xy, this.xy, this.radius, sat, eat, false);
            c.stroke();
        };

        this.cancel = function () {
            this.val(this.v);
        };
    };

    $.fn.dial = $.fn.knob = function (o) {
        return this.each(
            function () {
                var d = new k.Dial();
                d.o = o;
                d.$ = $(this);
                d.run();
            }
        ).parent();
    };

})(jQuery);
/*! Javascript plotting library for jQuery, version 0.8 alpha.
 *
 * Released under the MIT license by IOLA, December 2007.
 *
 */

// first an inline dependency, jquery.colorhelpers.js, we inline it here
// for convenience

/* Plugin for jQuery for working with colors.
 * 
 * Version 1.1.
 * 
 * Inspiration from jQuery color animation plugin by John Resig.
 *
 * Released under the MIT license by Ole Laursen, October 2009.
 *
 * Examples:
 *
 *   $.color.parse("#fff").scale('rgb', 0.25).add('a', -0.5).toString()
 *   var c = $.color.extract($("#mydiv"), 'background-color');
 *   console.log(c.r, c.g, c.b, c.a);
 *   $.color.make(100, 50, 25, 0.4).toString() // returns "rgba(100,50,25,0.4)"
 *
 * Note that .scale() and .add() return the same modified object
 * instead of making a new one.
 *
 * V. 1.1: Fix error handling so e.g. parsing an empty string does
 * produce a color rather than just crashing.
 */
(function (B) {
    B.color = {};
    B.color.make = function (F, E, C, D) {
        var G = {};
        G.r = F || 0;
        G.g = E || 0;
        G.b = C || 0;
        G.a = D != null ? D : 1;
        G.add = function (J, I) {
            for (var H = 0; H < J.length; ++H) {
                G[J.charAt(H)] += I
            }
            return G.normalize()
        };
        G.scale = function (J, I) {
            for (var H = 0; H < J.length; ++H) {
                G[J.charAt(H)] *= I
            }
            return G.normalize()
        };
        G.toString = function () {
            if (G.a >= 1) {
                return "rgb(" + [G.r, G.g, G.b].join(",") + ")"
            } else {
                return "rgba(" + [G.r, G.g, G.b, G.a].join(",") + ")"
            }
        };
        G.normalize = function () {
            function H(J, K, I) {
                return K < J ? J : (K > I ? I : K)
            }

            G.r = H(0, parseInt(G.r), 255);
            G.g = H(0, parseInt(G.g), 255);
            G.b = H(0, parseInt(G.b), 255);
            G.a = H(0, G.a, 1);
            return G
        };
        G.clone = function () {
            return B.color.make(G.r, G.b, G.g, G.a)
        };
        return G.normalize()
    };
    B.color.extract = function (D, C) {
        var E;
        do {
            E = D.css(C).toLowerCase();
            if (E != "" && E != "transparent") {
                break
            }
            D = D.parent()
        } while (!B.nodeName(D.get(0), "body"));
        if (E == "rgba(0, 0, 0, 0)") {
            E = "transparent"
        }
        return B.color.parse(E)
    };
    B.color.parse = function (F) {
        var E, C = B.color.make;
        if (E = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(F)) {
            return C(parseInt(E[1], 10), parseInt(E[2], 10), parseInt(E[3], 10))
        }
        if (E = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(F)) {
            return C(parseInt(E[1], 10), parseInt(E[2], 10), parseInt(E[3], 10), parseFloat(E[4]))
        }
        if (E = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(F)) {
            return C(parseFloat(E[1]) * 2.55, parseFloat(E[2]) * 2.55, parseFloat(E[3]) * 2.55)
        }
        if (E = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(F)) {
            return C(parseFloat(E[1]) * 2.55, parseFloat(E[2]) * 2.55, parseFloat(E[3]) * 2.55, parseFloat(E[4]))
        }
        if (E = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(F)) {
            return C(parseInt(E[1], 16), parseInt(E[2], 16), parseInt(E[3], 16))
        }
        if (E = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(F)) {
            return C(parseInt(E[1] + E[1], 16), parseInt(E[2] + E[2], 16), parseInt(E[3] + E[3], 16))
        }
        var D = B.trim(F).toLowerCase();
        if (D == "transparent") {
            return C(255, 255, 255, 0)
        } else {
            E = A[D] || [0, 0, 0];
            return C(E[0], E[1], E[2])
        }
    };
    var A = {
        aqua: [0, 255, 255],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        black: [0, 0, 0],
        blue: [0, 0, 255],
        brown: [165, 42, 42],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgrey: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkviolet: [148, 0, 211],
        fuchsia: [255, 0, 255],
        gold: [255, 215, 0],
        green: [0, 128, 0],
        indigo: [75, 0, 130],
        khaki: [240, 230, 140],
        lightblue: [173, 216, 230],
        lightcyan: [224, 255, 255],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        navy: [0, 0, 128],
        olive: [128, 128, 0],
        orange: [255, 165, 0],
        pink: [255, 192, 203],
        purple: [128, 0, 128],
        violet: [128, 0, 128],
        red: [255, 0, 0],
        silver: [192, 192, 192],
        white: [255, 255, 255],
        yellow: [255, 255, 0]
    }
})(jQuery);

// the actual Flot code
(function ($) {
    function Plot(placeholder, data_, options_, plugins) {
        // data is on the form:
        //   [ series1, series2 ... ]
        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
        // or { data: [ [x1, y1], [x2, y2], ... ], label: "some label", ... }

        var series = [],
            options = {
                // the color theme used for graphs
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                legend: {
                    show: true,
                    noColumns: 1, // number of colums in legend table
                    labelFormatter: null, // fn: string -> string
                    labelBoxBorderColor: "#ccc", // border color for the little label boxes
                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                    position: "ne", // position of default legend container within plot
                    margin: 5, // distance from grid edge to default legend container within plot
                    backgroundColor: null, // null means auto-detect
                    backgroundOpacity: 0.85, // set to 0 to avoid background
                    sorted: null    // default to no legend sorting
                },
                xaxis: {
                    show: null, // null = auto-detect, true = always, false = never
                    position: "bottom", // or "top"
                    mode: null, // null or "time"
                    timezone: null, // "browser" for local to the client or timezone for timezone-js
                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, style: "italic", weight: "bold", family: "sans-serif", variant: "small-caps" }
                    color: null, // base color, labels, ticks
                    tickColor: null, // possibly different color of ticks, e.g. "rgba(0,0,0,0.15)"
                    transform: null, // null or f: number -> number to transform axis
                    inverseTransform: null, // if transform is set, this should be the inverse function
                    min: null, // min. value to show, null means set automatically
                    max: null, // max. value to show, null means set automatically
                    autoscaleMargin: null, // margin in % to add if auto-setting min/max
                    ticks: null, // either [1, 3] or [[1, "a"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks
                    tickFormatter: null, // fn: number -> string
                    labelWidth: null, // size of tick labels in pixels
                    labelHeight: null,
                    reserveSpace: null, // whether to reserve space even if axis isn't shown
                    tickLength: null, // size in pixels of ticks, or "full" for whole line
                    alignTicksWithAxis: null, // axis number or null for no sync

                    // mode specific options
                    tickDecimals: null, // no. of decimals, null means auto
                    tickSize: null, // number or [number, "unit"]
                    minTickSize: null, // number or [number, "unit"]
                    monthNames: null, // list of names of months
                    timeformat: null, // format string to use
                    twelveHourClock: false // 12 or 24 time in time mode
                },
                yaxis: {
                    autoscaleMargin: 0.02,
                    position: "left" // or "right"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2, // in pixels
                        fill: true,
                        fillColor: "#ffffff",
                        symbol: "circle" // or callback
                    },
                    lines: {
                        // we don't put in show: false so we can see
                        // whether lines were actively disabled 
                        lineWidth: 2, // in pixels
                        fill: false,
                        fillColor: null,
                        steps: false
                    },
                    bars: {
                        show: false,
                        lineWidth: 2, // in pixels
                        barWidth: 1, // in units of the x axis
                        fill: true,
                        fillColor: null,
                        align: "left", // "left", "right", or "center"
                        horizontal: false
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454", // primary color used for outline and labels
                    backgroundColor: null, // null for transparent, else color
                    borderColor: null, // set if different from the grid color
                    tickColor: null, // color for the ticks, e.g. "rgba(0,0,0,0.15)"
                    margin: 0, // distance from the canvas edge to the grid
                    labelMargin: 5, // in pixels
                    axisMargin: 8, // in pixels
                    borderWidth: 2, // in pixels
                    minBorderMargin: null, // in pixels, null means taken from points radius
                    markings: null, // array of ranges or fn: axes -> array of ranges
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    // interactive stuff
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true, // highlight in case mouse is near
                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item
                },
                interaction: {
                    redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow
                },
                hooks: {}
            },
            canvas = null,      // the canvas for the plot itself
            overlay = null,     // canvas for interactive stuff on top of plot
            eventHolder = null, // jQuery object that events should be bound to
            ctx = null, octx = null,
            xaxes = [], yaxes = [],
            plotOffset = {left: 0, right: 0, top: 0, bottom: 0},
            canvasWidth = 0, canvasHeight = 0,
            plotWidth = 0, plotHeight = 0,
            hooks = {
                processOptions: [],
                processRawData: [],
                processDatapoints: [],
                processOffset: [],
                drawBackground: [],
                drawSeries: [],
                draw: [],
                bindEvents: [],
                drawOverlay: [],
                shutdown: []
            },
            plot = this;

        // public functions
        plot.setData = setData;
        plot.setupGrid = setupGrid;
        plot.draw = draw;
        plot.getPlaceholder = function () {
            return placeholder;
        };
        plot.getCanvas = function () {
            return canvas;
        };
        plot.getPlotOffset = function () {
            return plotOffset;
        };
        plot.width = function () {
            return plotWidth;
        };
        plot.height = function () {
            return plotHeight;
        };
        plot.offset = function () {
            var o = eventHolder.offset();
            o.left += plotOffset.left;
            o.top += plotOffset.top;
            return o;
        };
        plot.getData = function () {
            return series;
        };
        plot.getAxes = function () {
            var res = {}, i;
            $.each(xaxes.concat(yaxes), function (_, axis) {
                if (axis)
                    res[axis.direction + (axis.n != 1 ? axis.n : "") + "axis"] = axis;
            });
            return res;
        };
        plot.getXAxes = function () {
            return xaxes;
        };
        plot.getYAxes = function () {
            return yaxes;
        };
        plot.c2p = canvasToAxisCoords;
        plot.p2c = axisToCanvasCoords;
        plot.getOptions = function () {
            return options;
        };
        plot.highlight = highlight;
        plot.unhighlight = unhighlight;
        plot.triggerRedrawOverlay = triggerRedrawOverlay;
        plot.pointOffset = function (point) {
            return {
                left: parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x) + plotOffset.left),
                top: parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y) + plotOffset.top)
            };
        };
        plot.shutdown = shutdown;
        plot.resize = function () {
            getCanvasDimensions();
            resizeCanvas(canvas);
            resizeCanvas(overlay);
        };

        // public attributes
        plot.hooks = hooks;

        // initialize
        initPlugins(plot);
        parseOptions(options_);
        setupCanvases();
        setData(data_);
        setupGrid();
        draw();
        bindEvents();


        function executeHooks(hook, args) {
            args = [plot].concat(args);
            for (var i = 0; i < hook.length; ++i)
                hook[i].apply(this, args);
        }

        function initPlugins() {
            for (var i = 0; i < plugins.length; ++i) {
                var p = plugins[i];
                p.init(plot);
                if (p.options)
                    $.extend(true, options, p.options);
            }
        }

        function parseOptions(opts) {
            var i;

            $.extend(true, options, opts);

            if (options.xaxis.color == null)
                options.xaxis.color = options.grid.color;
            if (options.yaxis.color == null)
                options.yaxis.color = options.grid.color;

            if (options.xaxis.tickColor == null) // backwards-compatibility
                options.xaxis.tickColor = options.grid.tickColor;
            if (options.yaxis.tickColor == null) // backwards-compatibility
                options.yaxis.tickColor = options.grid.tickColor;

            if (options.grid.borderColor == null)
                options.grid.borderColor = options.grid.color;
            if (options.grid.tickColor == null)
                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();

            // fill in defaults in axes, copy at least always the
            // first as the rest of the code assumes it'll be there
            for (i = 0; i < Math.max(1, options.xaxes.length); ++i)
                options.xaxes[i] = $.extend(true, {}, options.xaxis, options.xaxes[i]);
            for (i = 0; i < Math.max(1, options.yaxes.length); ++i)
                options.yaxes[i] = $.extend(true, {}, options.yaxis, options.yaxes[i]);

            // backwards compatibility, to be removed in future
            if (options.xaxis.noTicks && options.xaxis.ticks == null)
                options.xaxis.ticks = options.xaxis.noTicks;
            if (options.yaxis.noTicks && options.yaxis.ticks == null)
                options.yaxis.ticks = options.yaxis.noTicks;
            if (options.x2axis) {
                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
                options.xaxes[1].position = "top";
            }
            if (options.y2axis) {
                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
                options.yaxes[1].position = "right";
            }
            if (options.grid.coloredAreas)
                options.grid.markings = options.grid.coloredAreas;
            if (options.grid.coloredAreasColor)
                options.grid.markingsColor = options.grid.coloredAreasColor;
            if (options.lines)
                $.extend(true, options.series.lines, options.lines);
            if (options.points)
                $.extend(true, options.series.points, options.points);
            if (options.bars)
                $.extend(true, options.series.bars, options.bars);
            if (options.shadowSize != null)
                options.series.shadowSize = options.shadowSize;
            if (options.highlightColor != null)
                options.series.highlightColor = options.highlightColor;

            // save options on axes for future reference
            for (i = 0; i < options.xaxes.length; ++i)
                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
            for (i = 0; i < options.yaxes.length; ++i)
                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];

            // add hooks from options
            for (var n in hooks)
                if (options.hooks[n] && options.hooks[n].length)
                    hooks[n] = hooks[n].concat(options.hooks[n]);

            executeHooks(hooks.processOptions, [options]);
        }

        function setData(d) {
            series = parseData(d);
            fillInSeriesOptions();
            processData();
        }

        function parseData(d) {
            var res = [];
            for (var i = 0; i < d.length; ++i) {
                var s = $.extend(true, {}, options.series);

                if (d[i].data != null) {
                    s.data = d[i].data; // move the data instead of deep-copy
                    delete d[i].data;

                    $.extend(true, s, d[i]);

                    d[i].data = s.data;
                }
                else
                    s.data = d[i];
                res.push(s);
            }

            return res;
        }

        function axisNumber(obj, coord) {
            var a = obj[coord + "axis"];
            if (typeof a == "object") // if we got a real axis, extract number
                a = a.n;
            if (typeof a != "number")
                a = 1; // default to first axis
            return a;
        }

        function allAxes() {
            // return flat array without annoying null entries
            return $.grep(xaxes.concat(yaxes), function (a) {
                return a;
            });
        }

        function canvasToAxisCoords(pos) {
            // return an object with x/y corresponding to all used axes 
            var res = {}, i, axis;
            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used)
                    res["x" + axis.n] = axis.c2p(pos.left);
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used)
                    res["y" + axis.n] = axis.c2p(pos.top);
            }

            if (res.x1 !== undefined)
                res.x = res.x1;
            if (res.y1 !== undefined)
                res.y = res.y1;

            return res;
        }

        function axisToCanvasCoords(pos) {
            // get canvas coords from the first pair of x/y found in pos
            var res = {}, i, axis, key;

            for (i = 0; i < xaxes.length; ++i) {
                axis = xaxes[i];
                if (axis && axis.used) {
                    key = "x" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "x";

                    if (pos[key] != null) {
                        res.left = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            for (i = 0; i < yaxes.length; ++i) {
                axis = yaxes[i];
                if (axis && axis.used) {
                    key = "y" + axis.n;
                    if (pos[key] == null && axis.n == 1)
                        key = "y";

                    if (pos[key] != null) {
                        res.top = axis.p2c(pos[key]);
                        break;
                    }
                }
            }

            return res;
        }

        function getOrCreateAxis(axes, number) {
            if (!axes[number - 1])
                axes[number - 1] = {
                    n: number, // save the number for future reference
                    direction: axes == xaxes ? "x" : "y",
                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
                };

            return axes[number - 1];
        }

        function fillInSeriesOptions() {

            var neededColors = series.length, maxIndex = 0, i;

            // Subtract the number of series that already have fixed
            // colors from the number we need to generate.

            for (i = 0; i < series.length; ++i) {
                var sc = series[i].color;
                if (sc != null) {
                    neededColors--;
                    if (typeof sc == "number" && sc > maxIndex) {
                        maxIndex = sc;
                    }
                }
            }

            // If any of the user colors are numeric indexes, then we
            // need to generate at least as many as the highest index.

            if (maxIndex > neededColors) {
                neededColors = maxIndex + 1;
            }

            // Generate the needed colors, based on the option colors

            var c, colors = [], colorPool = options.colors,
                colorPoolSize = colorPool.length, variation = 0;

            for (i = 0; i < neededColors; i++) {

                c = $.color.parse(colorPool[i % colorPoolSize] || "#666");

                // Each time we exhaust the colors in the pool we adjust
                // a scaling factor used to produce more variations on
                // those colors. The factor alternates negative/positive
                // to produce lighter/darker colors.

                // Reset the variation after every few cycles, or else
                // it will end up producing only white or black colors.

                if (i % colorPoolSize == 0 && i) {
                    if (variation >= 0) {
                        if (variation < 0.5) {
                            variation = -variation - 0.2;
                        } else variation = 0;
                    } else variation = -variation;
                }

                colors[i] = c.scale('rgb', 1 + variation);
            }

            // Finalize the series options, filling in their colors

            var colori = 0, s;
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                // assign colors
                if (s.color == null) {
                    s.color = colors[colori].toString();
                    ++colori;
                }
                else if (typeof s.color == "number")
                    s.color = colors[s.color].toString();

                // turn on lines automatically in case nothing is set
                if (s.lines.show == null) {
                    var v, show = true;
                    for (v in s)
                        if (s[v] && s[v].show) {
                            show = false;
                            break;
                        }
                    if (show)
                        s.lines.show = true;
                }

                // setup axes
                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"));
            }
        }

        function processData() {
            var topSentry = Number.POSITIVE_INFINITY,
                bottomSentry = Number.NEGATIVE_INFINITY,
                fakeInfinity = Number.MAX_VALUE,
                i, j, k, m, length,
                s, points, ps, x, y, axis, val, f, p;

            function updateAxis(axis, min, max) {
                if (min < axis.datamin && min != -fakeInfinity)
                    axis.datamin = min;
                if (max > axis.datamax && max != fakeInfinity)
                    axis.datamax = max;
            }

            $.each(allAxes(), function (_, axis) {
                // init axis
                axis.datamin = topSentry;
                axis.datamax = bottomSentry;
                axis.used = false;
            });

            for (i = 0; i < series.length; ++i) {
                s = series[i];
                s.datapoints = {points: []};

                executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);
            }

            // first pass: clean and copy data
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                var data = s.data, format = s.datapoints.format;

                if (!format) {
                    format = [];
                    // find out how to copy
                    format.push({x: true, number: true, required: true});
                    format.push({y: true, number: true, required: true});

                    if (s.bars.show || (s.lines.show && s.lines.fill)) {
                        format.push({y: true, number: true, required: false, defaultValue: 0});
                        if (s.bars.horizontal) {
                            delete format[format.length - 1].y;
                            format[format.length - 1].x = true;
                        }
                    }

                    s.datapoints.format = format;
                }

                if (s.datapoints.pointsize != null)
                    continue; // already filled in

                s.datapoints.pointsize = format.length;

                ps = s.datapoints.pointsize;
                points = s.datapoints.points;

                insertSteps = s.lines.show && s.lines.steps;
                s.xaxis.used = s.yaxis.used = true;

                for (j = k = 0; j < data.length; ++j, k += ps) {
                    p = data[j];

                    var nullify = p == null;
                    if (!nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = p[m];
                            f = format[m];

                            if (f) {
                                if (f.number && val != null) {
                                    val = +val; // convert to number
                                    if (isNaN(val))
                                        val = null;
                                    else if (val == Infinity)
                                        val = fakeInfinity;
                                    else if (val == -Infinity)
                                        val = -fakeInfinity;
                                }

                                if (val == null) {
                                    if (f.required)
                                        nullify = true;

                                    if (f.defaultValue != null)
                                        val = f.defaultValue;
                                }
                            }

                            points[k + m] = val;
                        }
                    }

                    if (nullify) {
                        for (m = 0; m < ps; ++m) {
                            val = points[k + m];
                            if (val != null) {
                                f = format[m];
                                // extract min/max info
                                if (f.x)
                                    updateAxis(s.xaxis, val, val);
                                if (f.y)
                                    updateAxis(s.yaxis, val, val);
                            }
                            points[k + m] = null;
                        }
                    }
                    else {
                        // a little bit of line specific stuff that
                        // perhaps shouldn't be here, but lacking
                        // better means...
                        if (insertSteps && k > 0
                            && points[k - ps] != null
                            && points[k - ps] != points[k]
                            && points[k - ps + 1] != points[k + 1]) {
                            // copy the point to make room for a middle point
                            for (m = 0; m < ps; ++m)
                                points[k + ps + m] = points[k + m];

                            // middle point has same y
                            points[k + 1] = points[k - ps + 1];

                            // we've added a point, better reflect that
                            k += ps;
                        }
                    }
                }
            }

            // give the hooks a chance to run
            for (i = 0; i < series.length; ++i) {
                s = series[i];

                executeHooks(hooks.processDatapoints, [s, s.datapoints]);
            }

            // second pass: find datamax/datamin for auto-scaling
            for (i = 0; i < series.length; ++i) {
                s = series[i];
                points = s.datapoints.points,
                    ps = s.datapoints.pointsize;
                format = s.datapoints.format;

                var xmin = topSentry, ymin = topSentry,
                    xmax = bottomSentry, ymax = bottomSentry;

                for (j = 0; j < points.length; j += ps) {
                    if (points[j] == null)
                        continue;

                    for (m = 0; m < ps; ++m) {
                        val = points[j + m];
                        f = format[m];
                        if (!f || val == fakeInfinity || val == -fakeInfinity)
                            continue;

                        if (f.x) {
                            if (val < xmin)
                                xmin = val;
                            if (val > xmax)
                                xmax = val;
                        }
                        if (f.y) {
                            if (val < ymin)
                                ymin = val;
                            if (val > ymax)
                                ymax = val;
                        }
                    }
                }

                if (s.bars.show) {
                    // make sure we got room for the bar on the dancing floor
                    var delta;

                    switch (s.bars.align) {
                        case "left":
                            delta = 0;
                            break;
                        case "right":
                            delta = -s.bars.barWidth;
                            break;
                        case "center":
                            delta = -s.bars.barWidth / 2;
                            break;
                        default:
                            throw new Error("Invalid bar alignment: " + s.bars.align);
                    }

                    if (s.bars.horizontal) {
                        ymin += delta;
                        ymax += delta + s.bars.barWidth;
                    }
                    else {
                        xmin += delta;
                        xmax += delta + s.bars.barWidth;
                    }
                }

                updateAxis(s.xaxis, xmin, xmax);
                updateAxis(s.yaxis, ymin, ymax);
            }

            $.each(allAxes(), function (_, axis) {
                if (axis.datamin == topSentry)
                    axis.datamin = null;
                if (axis.datamax == bottomSentry)
                    axis.datamax = null;
            });
        }

        //////////////////////////////////////////////////////////////////////////////////
        // Returns the display's ratio between physical and device-independent pixels.
        //
        // This is the ratio between the width that the browser advertises and the number
        // of pixels actually available in that space.  The iPhone 4, for example, has a
        // device-independent width of 320px, but its screen is actually 640px wide.  It
        // therefore has a pixel ratio of 2, while most normal devices have a ratio of 1.

        function getPixelRatio(cctx) {
            if (window.devicePixelRatio > 1 &&
                (cctx.webkitBackingStorePixelRatio === undefined ||
                cctx.webkitBackingStorePixelRatio < 2))
                return window.devicePixelRatio;

            return 1;
        }

        function makeCanvas(skipPositioning, cls) {

            var c = document.createElement('canvas');
            c.className = cls;

            if (!skipPositioning)
                $(c).css({position: 'absolute', left: 0, top: 0});

            $(c).appendTo(placeholder);

            if (!c.getContext) // excanvas hack
                c = window.G_vmlCanvasManager.initElement(c);

            var cctx = c.getContext("2d");

            // Increase the canvas density based on the display's pixel ratio; basically
            // giving the canvas more pixels without increasing the size of its element,
            // to take advantage of the fact that retina displays have that many more
            // pixels than they actually use for page & element widths.

            var pixelRatio = getPixelRatio(cctx);

            c.width = canvasWidth * pixelRatio;
            c.height = canvasHeight * pixelRatio;
            c.style.width = canvasWidth + "px";
            c.style.height = canvasHeight + "px";

            // Save the context so we can reset in case we get replotted

            cctx.save();

            // Scale the coordinate space to match the display density; so even though we
            // may have twice as many pixels, we still want lines and other drawing to
            // appear at the same size; the extra pixels will just make them crisper.

            cctx.scale(pixelRatio, pixelRatio);

            return c;
        }

        function getCanvasDimensions() {
            canvasWidth = placeholder.width();
            canvasHeight = placeholder.height();

            if (canvasWidth <= 0 || canvasHeight <= 0)
                throw new Error("Invalid dimensions for plot, width = " + canvasWidth + ", height = " + canvasHeight);
        }

        function resizeCanvas(c) {

            var cctx = c.getContext("2d");

            // Handle pixel ratios > 1 for retina displays, as explained in makeCanvas

            var pixelRatio = getPixelRatio(cctx);

            // Resizing should reset the state (excanvas seems to be buggy though)

            if (c.style.width != canvasWidth) {
                c.width = canvasWidth * pixelRatio;
                c.style.width = canvasWidth + "px";
            }

            if (c.style.height != canvasHeight) {
                c.height = canvasHeight * pixelRatio;
                c.style.height = canvasHeight + "px";
            }

            // so try to get back to the initial state (even if it's
            // gone now, this should be safe according to the spec)
            cctx.restore();

            // and save again
            cctx.save();

            // Apply scaling for retina displays, as explained in makeCanvas

            cctx.scale(pixelRatio, pixelRatio);
        }

        function setupCanvases() {
            var reused,
                existingCanvas = placeholder.children("canvas.flot-base"),
                existingOverlay = placeholder.children("canvas.flot-overlay");

            if (existingCanvas.length == 0 || existingOverlay == 0) {
                // init everything

                placeholder.html(""); // make sure placeholder is clear

                placeholder.css({padding: 0}); // padding messes up the positioning

                if (placeholder.css("position") == 'static')
                    placeholder.css("position", "relative"); // for positioning labels and overlay

                getCanvasDimensions();

                canvas = makeCanvas(true, "flot-base");
                overlay = makeCanvas(false, "flot-overlay"); // overlay canvas for interactive features

                reused = false;
            }
            else {
                // reuse existing elements

                canvas = existingCanvas.get(0);
                overlay = existingOverlay.get(0);

                reused = true;
            }

            ctx = canvas.getContext("2d");
            octx = overlay.getContext("2d");

            // define which element we're listening for events on
            eventHolder = $(overlay);

            if (reused) {
                // run shutdown in the old plot object
                placeholder.data("plot").shutdown();

                // reset reused canvases
                plot.resize();

                // make sure overlay pixels are cleared (canvas is cleared when we redraw)
                octx.clearRect(0, 0, canvasWidth, canvasHeight);

                // then whack any remaining obvious garbage left
                eventHolder.unbind();
                placeholder.children().not([canvas, overlay]).remove();
            }

            // save in case we get replotted
            placeholder.data("plot", plot);
        }

        function bindEvents() {
            // bind events
            if (options.grid.hoverable) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.mouseleave(onMouseLeave);
            }

            if (options.grid.clickable)
                eventHolder.click(onClick);

            executeHooks(hooks.bindEvents, [eventHolder]);
        }

        function shutdown() {
            if (redrawTimeout)
                clearTimeout(redrawTimeout);

            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mouseleave", onMouseLeave);
            eventHolder.unbind("click", onClick);

            executeHooks(hooks.shutdown, [eventHolder]);
        }

        function setTransformationHelpers(axis) {
            // set helper functions on the axis, assumes plot area
            // has been computed already

            function identity(x) {
                return x;
            }

            var s, m, t = axis.options.transform || identity,
                it = axis.options.inverseTransform;

            // precompute how much the axis is scaling a point
            // in canvas space
            if (axis.direction == "x") {
                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
                m = Math.min(t(axis.max), t(axis.min));
            }
            else {
                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
                s = -s;
                m = Math.max(t(axis.max), t(axis.min));
            }

            // data point to canvas coordinate
            if (t == identity) // slight optimization
                axis.p2c = function (p) {
                    return (p - m) * s;
                };
            else
                axis.p2c = function (p) {
                    return (t(p) - m) * s;
                };
            // canvas coordinate to data point
            if (!it)
                axis.c2p = function (c) {
                    return m + c / s;
                };
            else
                axis.c2p = function (c) {
                    return it(m + c / s);
                };
        }

        function measureTickLabels(axis) {
            var opts = axis.options, ticks = axis.ticks || [],
                axisw = opts.labelWidth || 0, axish = opts.labelHeight || 0,
                f = axis.font;

            ctx.save();
            ctx.font = f.style + " " + f.variant + " " + f.weight + " " + f.size + "px '" + f.family + "'";

            for (var i = 0; i < ticks.length; ++i) {
                var t = ticks[i];

                t.lines = [];
                t.width = t.height = 0;

                if (!t.label)
                    continue;

                // accept various kinds of newlines, including HTML ones
                // (you can actually split directly on regexps in Javascript,
                // but IE is unfortunately broken)
                var lines = (t.label + "").replace(/<br ?\/?>|\r\n|\r/g, "\n").split("\n");
                for (var j = 0; j < lines.length; ++j) {
                    var line = {text: lines[j]},
                        m = ctx.measureText(line.text);

                    line.width = m.width;
                    // m.height might not be defined, not in the
                    // standard yet
                    line.height = m.height != null ? m.height : f.size;

                    // add a bit of margin since font rendering is
                    // not pixel perfect and cut off letters look
                    // bad, this also doubles as spacing between
                    // lines
                    line.height += Math.round(f.size * 0.15);

                    t.width = Math.max(line.width, t.width);
                    t.height += line.height;

                    t.lines.push(line);
                }

                if (opts.labelWidth == null)
                    axisw = Math.max(axisw, t.width);
                if (opts.labelHeight == null)
                    axish = Math.max(axish, t.height);
            }
            ctx.restore();

            axis.labelWidth = Math.ceil(axisw);
            axis.labelHeight = Math.ceil(axish);
        }

        function allocateAxisBoxFirstPhase(axis) {
            // find the bounding box of the axis by looking at label
            // widths/heights and ticks, make room by diminishing the
            // plotOffset; this first phase only looks at one
            // dimension per axis, the other dimension depends on the
            // other axes so will have to wait

            var lw = axis.labelWidth,
                lh = axis.labelHeight,
                pos = axis.options.position,
                tickLength = axis.options.tickLength,
                axisMargin = options.grid.axisMargin,
                padding = options.grid.labelMargin,
                all = axis.direction == "x" ? xaxes : yaxes,
                index;

            // determine axis margin
            var samePosition = $.grep(all, function (a) {
                return a && a.options.position == pos && a.reserveSpace;
            });
            if ($.inArray(axis, samePosition) == samePosition.length - 1)
                axisMargin = 0; // outermost

            // determine tick length - if we're innermost, we can use "full"
            if (tickLength == null) {
                var sameDirection = $.grep(all, function (a) {
                    return a && a.reserveSpace;
                });

                var innermost = $.inArray(axis, sameDirection) == 0;
                if (innermost)
                    tickLength = "full";
                else
                    tickLength = 5;
            }

            if (!isNaN(+tickLength))
                padding += +tickLength;

            // compute box
            if (axis.direction == "x") {
                lh += padding;

                if (pos == "bottom") {
                    plotOffset.bottom += lh + axisMargin;
                    axis.box = {top: canvasHeight - plotOffset.bottom, height: lh};
                }
                else {
                    axis.box = {top: plotOffset.top + axisMargin, height: lh};
                    plotOffset.top += lh + axisMargin;
                }
            }
            else {
                lw += padding;

                if (pos == "left") {
                    axis.box = {left: plotOffset.left + axisMargin, width: lw};
                    plotOffset.left += lw + axisMargin;
                }
                else {
                    plotOffset.right += lw + axisMargin;
                    axis.box = {left: canvasWidth - plotOffset.right, width: lw};
                }
            }

            // save for future reference
            axis.position = pos;
            axis.tickLength = tickLength;
            axis.box.padding = padding;
            axis.innermost = innermost;
        }

        function allocateAxisBoxSecondPhase(axis) {
            // now that all axis boxes have been placed in one
            // dimension, we can set the remaining dimension coordinates
            if (axis.direction == "x") {
                axis.box.left = plotOffset.left - axis.labelWidth / 2;
                axis.box.width = canvasWidth - plotOffset.left - plotOffset.right + axis.labelWidth;
            }
            else {
                axis.box.top = plotOffset.top - axis.labelHeight / 2;
                axis.box.height = canvasHeight - plotOffset.bottom - plotOffset.top + axis.labelHeight;
            }
        }

        function adjustLayoutForThingsStickingOut() {
            // possibly adjust plot offset to ensure everything stays
            // inside the canvas and isn't clipped off

            var minMargin = options.grid.minBorderMargin,
                margins = {x: 0, y: 0}, i, axis;

            // check stuff from the plot (FIXME: this should just read
            // a value from the series, otherwise it's impossible to
            // customize)
            if (minMargin == null) {
                minMargin = 0;
                for (i = 0; i < series.length; ++i)
                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));
            }

            margins.x = margins.y = Math.ceil(minMargin);

            // check axis labels, note we don't check the actual
            // labels but instead use the overall width/height to not
            // jump as much around with replots
            $.each(allAxes(), function (_, axis) {
                var dir = axis.direction;
                if (axis.reserveSpace)
                    margins[dir] = Math.ceil(Math.max(margins[dir], (dir == "x" ? axis.labelWidth : axis.labelHeight) / 2));
            });

            plotOffset.left = Math.max(margins.x, plotOffset.left);
            plotOffset.right = Math.max(margins.x, plotOffset.right);
            plotOffset.top = Math.max(margins.y, plotOffset.top);
            plotOffset.bottom = Math.max(margins.y, plotOffset.bottom);
        }

        function setupGrid() {
            var i, axes = allAxes(), showGrid = options.grid.show;

            // Initialize the plot's offset from the edge of the canvas

            for (var a in plotOffset) {
                var margin = options.grid.margin || 0;
                plotOffset[a] = typeof margin == "number" ? margin : margin[a] || 0;
            }

            executeHooks(hooks.processOffset, [plotOffset]);

            // If the grid is visible, add its border width to the offset

            for (var a in plotOffset)
                plotOffset[a] += showGrid ? options.grid.borderWidth : 0;

            // init axes
            $.each(axes, function (_, axis) {
                axis.show = axis.options.show;
                if (axis.show == null)
                    axis.show = axis.used; // by default an axis is visible if it's got data

                axis.reserveSpace = axis.show || axis.options.reserveSpace;

                setRange(axis);
            });

            if (showGrid) {
                // determine from the placeholder the font size ~ height of font ~ 1 em
                var fontDefaults = {
                    style: placeholder.css("font-style"),
                    size: Math.round(0.8 * (+placeholder.css("font-size").replace("px", "") || 13)),
                    variant: placeholder.css("font-variant"),
                    weight: placeholder.css("font-weight"),
                    family: placeholder.css("font-family")
                };

                var allocatedAxes = $.grep(axes, function (axis) {
                    return axis.reserveSpace;
                });

                $.each(allocatedAxes, function (_, axis) {
                    // make the ticks
                    setupTickGeneration(axis);
                    setTicks(axis);
                    snapRangeToTicks(axis, axis.ticks);

                    // find labelWidth/Height for axis
                    axis.font = $.extend({}, fontDefaults, axis.options.font);
                    measureTickLabels(axis);
                });

                // with all dimensions calculated, we can compute the
                // axis bounding boxes, start from the outside
                // (reverse order)
                for (i = allocatedAxes.length - 1; i >= 0; --i)
                    allocateAxisBoxFirstPhase(allocatedAxes[i]);

                // make sure we've got enough space for things that
                // might stick out
                adjustLayoutForThingsStickingOut();

                $.each(allocatedAxes, function (_, axis) {
                    allocateAxisBoxSecondPhase(axis);
                });
            }

            plotWidth = canvasWidth - plotOffset.left - plotOffset.right;
            plotHeight = canvasHeight - plotOffset.bottom - plotOffset.top;

            // now we got the proper plot dimensions, we can compute the scaling
            $.each(axes, function (_, axis) {
                setTransformationHelpers(axis);
            });

            insertLegend();
        }

        function setRange(axis) {
            var opts = axis.options,
                min = +(opts.min != null ? opts.min : axis.datamin),
                max = +(opts.max != null ? opts.max : axis.datamax),
                delta = max - min;

            if (delta == 0.0) {
                // degenerate case
                var widen = max == 0 ? 1 : 0.01;

                if (opts.min == null)
                    min -= widen;
                // always widen max if we couldn't widen min to ensure we
                // don't fall into min == max which doesn't work
                if (opts.max == null || opts.min != null)
                    max += widen;
            }
            else {
                // consider autoscaling
                var margin = opts.autoscaleMargin;
                if (margin != null) {
                    if (opts.min == null) {
                        min -= delta * margin;
                        // make sure we don't go below zero if all values
                        // are positive
                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)
                            min = 0;
                    }
                    if (opts.max == null) {
                        max += delta * margin;
                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)
                            max = 0;
                    }
                }
            }
            axis.min = min;
            axis.max = max;
        }

        function setupTickGeneration(axis) {
            var opts = axis.options;

            // estimate number of ticks
            var noTicks;
            if (typeof opts.ticks == "number" && opts.ticks > 0)
                noTicks = opts.ticks;
            else
            // heuristic based on the model a*sqrt(x) fitted to
            // some data points that seemed reasonable
                noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? canvasWidth : canvasHeight);

            axis.delta = (axis.max - axis.min) / noTicks;

            // Time mode was moved to a plug-in in 0.8, but since so many people use this
            // we'll add an especially friendly make sure they remembered to include it.

            if (opts.mode == "time" && !axis.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }

            // Flot supports base-10 axes; any other mode else is handled by a plug-in,
            // like flot.time.js.

            if (!axis.tickGenerator) {

                var maxDec = opts.tickDecimals;
                var dec = -Math.floor(Math.log(axis.delta) / Math.LN10);
                if (maxDec != null && dec > maxDec)
                    dec = maxDec;

                var magn = Math.pow(10, -dec);
                var norm = axis.delta / magn; // norm is between 1.0 and 10.0
                var size;

                if (norm < 1.5)
                    size = 1;
                else if (norm < 3) {
                    size = 2;
                    // special case for 2.5, requires an extra decimal
                    if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
                        size = 2.5;
                        ++dec;
                    }
                }
                else if (norm < 7.5)
                    size = 5;
                else size = 10;

                size *= magn;

                if (opts.minTickSize != null && size < opts.minTickSize)
                    size = opts.minTickSize;

                axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
                axis.tickSize = opts.tickSize || size;

                axis.tickGenerator = function (axis) {
                    var ticks = [], start = floorInBase(axis.min, axis.tickSize),
                        i = 0, v = Number.NaN, prev;
                    do {
                        prev = v;
                        v = start + i * axis.tickSize;
                        ticks.push(v);
                        ++i;
                    } while (v < axis.max && v != prev);
                    return ticks;
                };

                axis.tickFormatter = function (v, axis) {
                    var factor = Math.pow(10, axis.tickDecimals);
                    return "" + Math.round(v * factor) / factor;
                };
            }

            if ($.isFunction(opts.tickFormatter))
                axis.tickFormatter = function (v, axis) {
                    return "" + opts.tickFormatter(v, axis);
                };

            if (opts.alignTicksWithAxis != null) {
                var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
                if (otherAxis && otherAxis.used && otherAxis != axis) {
                    // consider snapping min/max to outermost nice ticks
                    var niceTicks = axis.tickGenerator(axis);
                    if (niceTicks.length > 0) {
                        if (opts.min == null)
                            axis.min = Math.min(axis.min, niceTicks[0]);
                        if (opts.max == null && niceTicks.length > 1)
                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                    }

                    axis.tickGenerator = function (axis) {
                        // copy ticks, scaled to this axis
                        var ticks = [], v, i;
                        for (i = 0; i < otherAxis.ticks.length; ++i) {
                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                            v = axis.min + v * (axis.max - axis.min);
                            ticks.push(v);
                        }
                        return ticks;
                    };

                    // we might need an extra decimal since forced
                    // ticks don't necessarily fit naturally
                    if (!axis.mode && opts.tickDecimals == null) {
                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                            ts = axis.tickGenerator(axis);

                        // only proceed if the tick interval rounded
                        // with an extra decimal doesn't give us a
                        // zero at end
                        if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                            axis.tickDecimals = extraDec;
                    }
                }
            }
        }

        function setTicks(axis) {
            var oticks = axis.options.ticks, ticks = [];
            if (oticks == null || (typeof oticks == "number" && oticks > 0))
                ticks = axis.tickGenerator(axis);
            else if (oticks) {
                if ($.isFunction(oticks))
                // generate the ticks
                    ticks = oticks(axis);
                else
                    ticks = oticks;
            }

            // clean up/labelify the supplied ticks, copy them over
            var i, v;
            axis.ticks = [];
            for (i = 0; i < ticks.length; ++i) {
                var label = null;
                var t = ticks[i];
                if (typeof t == "object") {
                    v = +t[0];
                    if (t.length > 1)
                        label = t[1];
                }
                else
                    v = +t;
                if (label == null)
                    label = axis.tickFormatter(v, axis);
                if (!isNaN(v))
                    axis.ticks.push({v: v, label: label});
            }
        }

        function snapRangeToTicks(axis, ticks) {
            if (axis.options.autoscaleMargin && ticks.length > 0) {
                // snap to ticks
                if (axis.options.min == null)
                    axis.min = Math.min(axis.min, ticks[0].v);
                if (axis.options.max == null && ticks.length > 1)
                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            executeHooks(hooks.drawBackground, [ctx]);

            var grid = options.grid;

            // draw background, if any
            if (grid.show && grid.backgroundColor)
                drawBackground();

            if (grid.show && !grid.aboveData) {
                drawGrid();
                drawAxisLabels();
            }

            for (var i = 0; i < series.length; ++i) {
                executeHooks(hooks.drawSeries, [ctx, series[i]]);
                drawSeries(series[i]);
            }

            executeHooks(hooks.draw, [ctx]);

            if (grid.show && grid.aboveData) {
                drawGrid();
                drawAxisLabels();
            }
        }

        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = allAxes();

            for (var i = 0; i < axes.length; ++i) {
                axis = axes[i];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? xaxes[0] : yaxes[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return {from: from, to: to, axis: axis};
        }

        function drawBackground() {
            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, "rgba(255, 255, 255, 0)");
            ctx.fillRect(0, 0, plotWidth, plotHeight);
            ctx.restore();
        }

        function drawGrid() {
            var i;

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // draw markings
            var markings = options.grid.markings;
            if (markings) {
                if ($.isFunction(markings)) {
                    var axes = plot.getAxes();
                    // xmin etc. is backwards compatibility, to be
                    // removed in the future
                    axes.xmin = axes.xaxis.min;
                    axes.xmax = axes.xaxis.max;
                    axes.ymin = axes.yaxis.min;
                    axes.ymax = axes.yaxis.max;

                    markings = markings(axes);
                }

                for (i = 0; i < markings.length; ++i) {
                    var m = markings[i],
                        xrange = extractRange(m, "x"),
                        yrange = extractRange(m, "y");

                    // fill in missing
                    if (xrange.from == null)
                        xrange.from = xrange.axis.min;
                    if (xrange.to == null)
                        xrange.to = xrange.axis.max;
                    if (yrange.from == null)
                        yrange.from = yrange.axis.min;
                    if (yrange.to == null)
                        yrange.to = yrange.axis.max;

                    // clip
                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||
                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)
                        continue;

                    xrange.from = Math.max(xrange.from, xrange.axis.min);
                    xrange.to = Math.min(xrange.to, xrange.axis.max);
                    yrange.from = Math.max(yrange.from, yrange.axis.min);
                    yrange.to = Math.min(yrange.to, yrange.axis.max);

                    if (xrange.from == xrange.to && yrange.from == yrange.to)
                        continue;

                    // then draw
                    xrange.from = xrange.axis.p2c(xrange.from);
                    xrange.to = xrange.axis.p2c(xrange.to);
                    yrange.from = yrange.axis.p2c(yrange.from);
                    yrange.to = yrange.axis.p2c(yrange.to);

                    if (xrange.from == xrange.to || yrange.from == yrange.to) {
                        // draw line
                        ctx.beginPath();
                        ctx.strokeStyle = m.color || options.grid.markingsColor;
                        ctx.lineWidth = m.lineWidth || options.grid.markingsLineWidth;
                        ctx.moveTo(xrange.from, yrange.from);
                        ctx.lineTo(xrange.to, yrange.to);
                        ctx.stroke();
                    }
                    else {
                        // fill area
                        ctx.fillStyle = m.color || options.grid.markingsColor;
                        ctx.fillRect(xrange.from, yrange.to,
                            xrange.to - xrange.from,
                            yrange.from - yrange.to);
                    }
                }
            }

            // draw the ticks
            var axes = allAxes(), bw = options.grid.borderWidth;

            for (var j = 0; j < axes.length; ++j) {
                var axis = axes[j], box = axis.box,
                    t = axis.tickLength, x, y, xoff, yoff;
                if (!axis.show || axis.ticks.length == 0)
                    continue;

                ctx.strokeStyle = axis.options.tickColor || $.color.parse(axis.options.color).scale('a', 0.22).toString();
                ctx.lineWidth = 1;

                // find the edges
                if (axis.direction == "x") {
                    x = 0;
                    if (t == "full")
                        y = (axis.position == "top" ? 0 : plotHeight);
                    else
                        y = box.top - plotOffset.top + (axis.position == "top" ? box.height : 0);
                }
                else {
                    y = 0;
                    if (t == "full")
                        x = (axis.position == "left" ? 0 : plotWidth);
                    else
                        x = box.left - plotOffset.left + (axis.position == "left" ? box.width : 0);
                }

                // draw tick bar
                if (!axis.innermost) {
                    ctx.beginPath();
                    xoff = yoff = 0;
                    if (axis.direction == "x")
                        xoff = plotWidth;
                    else
                        yoff = plotHeight;

                    if (ctx.lineWidth == 1) {
                        x = Math.floor(x) + 0.5;
                        y = Math.floor(y) + 0.5;
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                    ctx.stroke();
                }

                // draw ticks
                ctx.beginPath();
                for (i = 0; i < axis.ticks.length; ++i) {
                    var v = axis.ticks[i].v;

                    xoff = yoff = 0;

                    if (v < axis.min || v > axis.max
                            // skip those lying on the axes if we got a border
                        || (t == "full" && bw > 0
                        && (v == axis.min || v == axis.max)))
                        continue;

                    if (axis.direction == "x") {
                        x = axis.p2c(v);
                        yoff = t == "full" ? -plotHeight : t;

                        if (axis.position == "top")
                            yoff = -yoff;
                    }
                    else {
                        y = axis.p2c(v);
                        xoff = t == "full" ? -plotWidth : t;

                        if (axis.position == "left")
                            xoff = -xoff;
                    }

                    if (ctx.lineWidth == 1) {
                        if (axis.direction == "x")
                            x = Math.floor(x) + 0.5;
                        else
                            y = Math.floor(y) + 0.5;
                    }

                    ctx.moveTo(x, y);
                    ctx.lineTo(x + xoff, y + yoff);
                }

                ctx.stroke();
            }


            // draw border
            if (bw) {
                ctx.lineWidth = bw;
                ctx.strokeStyle = options.grid.borderColor;
                ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);
            }

            ctx.restore();
        }

        function drawAxisLabels() {
            ctx.save();

            $.each(allAxes(), function (_, axis) {
                if (!axis.show || axis.ticks.length == 0)
                    return;

                var box = axis.box, f = axis.font;
                // placeholder.append('<div style="position:absolute;opacity:0.10;background-color:red;left:' + box.left + 'px;top:' + box.top + 'px;width:' + box.width +  'px;height:' + box.height + 'px"></div>') // debug

                ctx.fillStyle = axis.options.color;
                // Important: Don't use quotes around axis.font.family! Just around single 
                // font names like 'Times New Roman' that have a space or special character in it.
                ctx.font = f.style + " " + f.variant + " " + f.weight + " " + f.size + "px " + f.family;
                ctx.textAlign = "start";
                // middle align the labels - top would be more
                // natural, but browsers can differ a pixel or two in
                // where they consider the top to be, so instead we
                // middle align to minimize variation between browsers
                // and compensate when calculating the coordinates
                ctx.textBaseline = "middle";

                for (var i = 0; i < axis.ticks.length; ++i) {
                    var tick = axis.ticks[i];
                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)
                        continue;

                    var x, y, offset = 0, line;
                    for (var k = 0; k < tick.lines.length; ++k) {
                        line = tick.lines[k];

                        if (axis.direction == "x") {
                            x = plotOffset.left + axis.p2c(tick.v) - line.width / 2;
                            if (axis.position == "bottom")
                                y = box.top + box.padding;
                            else
                                y = box.top + box.height - box.padding - tick.height;
                        }
                        else {
                            y = plotOffset.top + axis.p2c(tick.v) - tick.height / 2;
                            if (axis.position == "left")
                                x = box.left + box.width - box.padding - line.width;
                            else
                                x = box.left + box.padding;
                        }

                        // account for middle aligning and line number
                        y += line.height / 2 + offset;
                        offset += line.height;

                        if ($.browser.opera) {
                            // FIXME: UGLY BROWSER DETECTION
                            // round the coordinates since Opera
                            // otherwise switches to more ugly
                            // rendering (probably non-hinted) and
                            // offset the y coordinates since it seems
                            // to be off pretty consistently compared
                            // to the other browsers
                            x = Math.floor(x);
                            y = Math.ceil(y - 2);
                        }
                        ctx.fillText(line.text, x, y);
                    }
                }
            });

            ctx.restore();
        }

        function drawSeries(series) {
            if (series.lines.show)
                drawSeriesLines(series);
            if (series.bars.show)
                drawSeriesBars(series);
            if (series.points.show)
                drawSeriesPoints(series);
        }

        function drawSeriesLines(series) {
            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    prevx = null, prevy = null;

                ctx.beginPath();
                for (var i = ps; i < points.length; i += ps) {
                    var x1 = points[i - ps], y1 = points[i - ps + 1],
                        x2 = points[i], y2 = points[i + 1];

                    if (x1 == null || x2 == null)
                        continue;

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min) {
                        if (y2 < axisy.min)
                            continue;   // line segment is outside
                        // compute new intersection point
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min) {
                        if (y1 < axisy.min)
                            continue;
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max) {
                        if (y2 > axisy.max)
                            continue;
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max) {
                        if (y1 > axisy.max)
                            continue;
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (x1 != prevx || y1 != prevy)
                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);

                    prevx = x2;
                    prevy = y2;
                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
                }
                ctx.stroke();
            }

            function plotLineArea(datapoints, axisx, axisy) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                    i = 0, top, areaOpen = false,
                    ypos = 1, segmentStart = 0, segmentEnd = 0;

                // we process each segment in two turns, first forward
                // direction to sketch out top, then once we hit the
                // end we go backwards to sketch the bottom
                while (true) {
                    if (ps > 0 && i > points.length + ps)
                        break;

                    i += ps; // ps is negative if going backwards

                    var x1 = points[i - ps],
                        y1 = points[i - ps + ypos],
                        x2 = points[i], y2 = points[i + ypos];

                    if (areaOpen) {
                        if (ps > 0 && x1 != null && x2 == null) {
                            // at turning point
                            segmentEnd = i;
                            ps = -ps;
                            ypos = 2;
                            continue;
                        }

                        if (ps < 0 && i == segmentStart + ps) {
                            // done with the reverse sweep
                            ctx.fill();
                            areaOpen = false;
                            ps = -ps;
                            ypos = 1;
                            i = segmentStart = segmentEnd + ps;
                            continue;
                        }
                    }

                    if (x1 == null || x2 == null)
                        continue;

                    // clip x values

                    // clip with xmin
                    if (x1 <= x2 && x1 < axisx.min) {
                        if (x2 < axisx.min)
                            continue;
                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.min;
                    }
                    else if (x2 <= x1 && x2 < axisx.min) {
                        if (x1 < axisx.min)
                            continue;
                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.min;
                    }

                    // clip with xmax
                    if (x1 >= x2 && x1 > axisx.max) {
                        if (x2 > axisx.max)
                            continue;
                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x1 = axisx.max;
                    }
                    else if (x2 >= x1 && x2 > axisx.max) {
                        if (x1 > axisx.max)
                            continue;
                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                        x2 = axisx.max;
                    }

                    if (!areaOpen) {
                        // open area
                        ctx.beginPath();
                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                        areaOpen = true;
                    }

                    // now first check the case where both is outside
                    if (y1 >= axisy.max && y2 >= axisy.max) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                        continue;
                    }
                    else if (y1 <= axisy.min && y2 <= axisy.min) {
                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                        continue;
                    }

                    // else it's a bit more complicated, there might
                    // be a flat maxed out rectangle first, then a
                    // triangular cutout or reverse; to find these
                    // keep track of the current x values
                    var x1old = x1, x2old = x2;

                    // clip the y values, without shortcutting, we
                    // go through all cases in turn

                    // clip with ymin
                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.min;
                    }
                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.min;
                    }

                    // clip with ymax
                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y1 = axisy.max;
                    }
                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                        y2 = axisy.max;
                    }

                    // if the x value was changed we got a rectangle
                    // to fill
                    if (x1 != x1old) {
                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                        // it goes to (x1, y1), but we fill that below
                    }

                    // fill triangular section, this sometimes result
                    // in redundant points if (x1, y1) hasn't changed
                    // from previous line to, but we just ignore that
                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));

                    // fill the other rectangle if it's there
                    if (x2 != x2old) {
                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                    }
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);
            ctx.lineJoin = "round";

            var lw = series.lines.lineWidth,
                sw = series.shadowSize;
            // FIXME: consider another form of shadow when filling is turned on
            if (lw > 0 && sw > 0) {
                // draw shadow as a thick and thin line with transparency
                ctx.lineWidth = sw;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                // position shadow at angle from the mid of line
                var angle = Math.PI / 18;
                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);
                ctx.lineWidth = sw / 2;
                plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                plotLineArea(series.datapoints, series.xaxis, series.yaxis);
            }

            if (lw > 0)
                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function drawSeriesPoints(series) {
            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    var x = points[i], y = points[i + 1];
                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                        continue;

                    ctx.beginPath();
                    x = axisx.p2c(x);
                    y = axisy.p2c(y) + offset;
                    if (symbol == "circle")
                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                    else
                        symbol(ctx, x, y, radius, shadow);
                    ctx.closePath();

                    if (fillStyle) {
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            var lw = series.points.lineWidth,
                sw = series.shadowSize,
                radius = series.points.radius,
                symbol = series.points.symbol;
            if (lw > 0 && sw > 0) {
                // draw shadow in two steps
                var w = sw / 2;
                ctx.lineWidth = w;
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                plotPoints(series.datapoints, radius, null, w + w / 2, true,
                    series.xaxis, series.yaxis, symbol);

                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                plotPoints(series.datapoints, radius, null, w / 2, true,
                    series.xaxis, series.yaxis, symbol);
            }

            ctx.lineWidth = lw;
            ctx.strokeStyle = series.color;
            plotPoints(series.datapoints, radius,
                getFillStyle(series.points, series.color), 0, false,
                series.xaxis, series.yaxis, symbol);
            ctx.restore();
        }

        function drawBar(x, y, b, barLeft, barRight, offset, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
            var left, right, bottom, top,
                drawLeft, drawRight, drawTop, drawBottom,
                tmp;

            // in horizontal mode, we start the bar from the left
            // instead of from the bottom so it appears to be
            // horizontal rather than vertical
            if (horizontal) {
                drawBottom = drawRight = drawTop = true;
                drawLeft = false;
                left = b;
                right = x;
                top = y + barLeft;
                bottom = y + barRight;

                // account for negative bars
                if (right < left) {
                    tmp = right;
                    right = left;
                    left = tmp;
                    drawLeft = true;
                    drawRight = false;
                }
            }
            else {
                drawLeft = drawRight = drawTop = true;
                drawBottom = false;
                left = x + barLeft;
                right = x + barRight;
                bottom = b;
                top = y;

                // account for negative bars
                if (top < bottom) {
                    tmp = top;
                    top = bottom;
                    bottom = tmp;
                    drawBottom = true;
                    drawTop = false;
                }
            }

            // clip
            if (right < axisx.min || left > axisx.max ||
                top < axisy.min || bottom > axisy.max)
                return;

            if (left < axisx.min) {
                left = axisx.min;
                drawLeft = false;
            }

            if (right > axisx.max) {
                right = axisx.max;
                drawRight = false;
            }

            if (bottom < axisy.min) {
                bottom = axisy.min;
                drawBottom = false;
            }

            if (top > axisy.max) {
                top = axisy.max;
                drawTop = false;
            }

            left = axisx.p2c(left);
            bottom = axisy.p2c(bottom);
            right = axisx.p2c(right);
            top = axisy.p2c(top);

            // fill the bar
            if (fillStyleCallback) {
                c.beginPath();
                c.moveTo(left, bottom);
                c.lineTo(left, top);
                c.lineTo(right, top);
                c.lineTo(right, bottom);
                c.fillStyle = fillStyleCallback(bottom, top);
                c.fill();
            }

            // draw outline
            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {
                c.beginPath();

                // FIXME: inline moveTo is buggy with excanvas
                c.moveTo(left, bottom + offset);
                if (drawLeft)
                    c.lineTo(left, top + offset);
                else
                    c.moveTo(left, top + offset);
                if (drawTop)
                    c.lineTo(right, top + offset);
                else
                    c.moveTo(right, top + offset);
                if (drawRight)
                    c.lineTo(right, bottom + offset);
                else
                    c.moveTo(right, bottom + offset);
                if (drawBottom)
                    c.lineTo(left, bottom + offset);
                else
                    c.moveTo(left, bottom + offset);
                c.stroke();
            }
        }

        function drawSeriesBars(series) {
            function plotBars(datapoints, barLeft, barRight, offset, fillStyleCallback, axisx, axisy) {
                var points = datapoints.points, ps = datapoints.pointsize;

                for (var i = 0; i < points.length; i += ps) {
                    if (points[i] == null)
                        continue;
                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, offset, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
                }
            }

            ctx.save();
            ctx.translate(plotOffset.left, plotOffset.top);

            // FIXME: figure out a way to add shadows (for instance along the right edge)
            ctx.lineWidth = series.bars.lineWidth;
            ctx.strokeStyle = series.color;

            var barLeft;

            switch (series.bars.align) {
                case "left":
                    barLeft = 0;
                    break;
                case "right":
                    barLeft = -series.bars.barWidth;
                    break;
                case "center":
                    barLeft = -series.bars.barWidth / 2;
                    break;
                default:
                    throw new Error("Invalid bar alignment: " + series.bars.align);
            }

            var fillStyleCallback = series.bars.fill ? function (bottom, top) {
                return getFillStyle(series.bars, series.color, bottom, top);
            } : null;
            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, 0, fillStyleCallback, series.xaxis, series.yaxis);
            ctx.restore();
        }

        function getFillStyle(filloptions, seriesColor, bottom, top) {
            var fill = filloptions.fill;
            if (!fill)
                return null;

            if (filloptions.fillColor)
                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);

            var c = $.color.parse(seriesColor);
            c.a = typeof fill == "number" ? fill : 0.4;
            c.normalize();
            return c.toString();
        }

        function insertLegend() {

            placeholder.find(".legend").remove();

            if (!options.legend.show)
                return;

            var fragments = [], entries = [], rowStarted = false,
                lf = options.legend.labelFormatter, s, label;

            // Build a list of legend entries, with each having a label and a color

            for (var i = 0; i < series.length; ++i) {
                s = series[i];
                if (s.label) {
                    label = lf ? lf(s.label, s) : s.label;
                    if (label) {
                        entries.push({
                            label: label,
                            color: s.color
                        });
                    }
                }
            }

            // Sort the legend using either the default or a custom comparator

            if (options.legend.sorted) {
                if ($.isFunction(options.legend.sorted)) {
                    entries.sort(options.legend.sorted);
                } else {
                    var ascending = options.legend.sorted != "descending";
                    entries.sort(function (a, b) {
                        return a.label == b.label ? 0 : (
                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR
                        );
                    });
                }
            }

            // Generate markup for the list of entries, in their final order

            for (var i = 0; i < entries.length; ++i) {

                entry = entries[i];

                if (i % options.legend.noColumns == 0) {
                    if (rowStarted)
                        fragments.push('</tr>');
                    fragments.push('<tr>');
                    rowStarted = true;
                }

                fragments.push(
                    '<td class="legendColorBox"><div style="border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden"></div></div></td>' +
                    '<td class="legendLabel">' + entry.label + '</td>'
                );
            }

            if (rowStarted)
                fragments.push('</tr>');

            if (fragments.length == 0)
                return;

            var table = '<table style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join("") + '</table>';
            if (options.legend.container != null)
                $(options.legend.container).html(table);
            else {
                var pos = "",
                    p = options.legend.position,
                    m = options.legend.margin;
                if (m[0] == null)
                    m = [m, m];
                if (p.charAt(0) == "n")
                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
                else if (p.charAt(0) == "s")
                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
                if (p.charAt(1) == "e")
                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
                else if (p.charAt(1) == "w")
                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
                var legend = $('<div class="legend">' + table.replace('style="', 'style="position:absolute;' + pos + ';') + '</div>').appendTo(placeholder);
                if (options.legend.backgroundOpacity != 0.0) {
                    // put in the transparent background
                    // separately to avoid blended labels and
                    // label boxes
                    var c = options.legend.backgroundColor;
                    if (c == null) {
                        c = options.grid.backgroundColor;
                        if (c && typeof c == "string")
                            c = $.color.parse(c);
                        else
                            c = $.color.extract(legend, 'background-color');
                        c.a = 1;
                        c = c.toString();
                    }
                    var div = legend.children();
                    $('<div style="position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos + 'background-color:' + c + ';"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
                }
            }
        }


        // interactive features

        var highlights = [],
            redrawTimeout = null;

        // returns the data item the mouse is over, or null if none is found
        function findNearbyItem(mouseX, mouseY, seriesFilter) {
            var maxDistance = options.grid.mouseActiveRadius,
                smallestDistance = maxDistance * maxDistance + 1,
                item = null, foundPoint = false, i, j;

            for (i = series.length - 1; i >= 0; --i) {
                if (!seriesFilter(series[i]))
                    continue;

                var s = series[i],
                    axisx = s.xaxis,
                    axisy = s.yaxis,
                    points = s.datapoints.points,
                    ps = s.datapoints.pointsize,
                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                    my = axisy.c2p(mouseY),
                    maxx = maxDistance / axisx.scale,
                    maxy = maxDistance / axisy.scale;

                // with inverse transforms, we can't use the maxx/maxy
                // optimization, sadly
                if (axisx.options.inverseTransform)
                    maxx = Number.MAX_VALUE;
                if (axisy.options.inverseTransform)
                    maxy = Number.MAX_VALUE;

                if (s.lines.show || s.points.show) {
                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1];
                        if (x == null)
                            continue;

                        // For points and lines, the cursor must be within a
                        // certain distance to the data point
                        if (x - mx > maxx || x - mx < -maxx ||
                            y - my > maxy || y - my < -maxy)
                            continue;

                        // We have to calculate distances in pixels, not in
                        // data units, because the scales of the axes may be different
                        var dx = Math.abs(axisx.p2c(x) - mouseX),
                            dy = Math.abs(axisy.p2c(y) - mouseY),
                            dist = dx * dx + dy * dy; // we save the sqrt

                        // use <= to ensure last point takes precedence
                        // (last generally means on top of)
                        if (dist < smallestDistance) {
                            smallestDistance = dist;
                            item = [i, j / ps];
                        }
                    }
                }

                if (s.bars.show && !item) { // no other point can be nearby
                    var barLeft = s.bars.align == "left" ? 0 : -s.bars.barWidth / 2,
                        barRight = barLeft + s.bars.barWidth;

                    for (j = 0; j < points.length; j += ps) {
                        var x = points[j], y = points[j + 1], b = points[j + 2];
                        if (x == null)
                            continue;

                        // for a bar graph, the cursor must be inside the bar
                        if (series[i].bars.horizontal ?
                                (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&
                                my >= y + barLeft && my <= y + barRight) :
                                (mx >= x + barLeft && mx <= x + barRight &&
                                my >= Math.min(b, y) && my <= Math.max(b, y)))
                            item = [i, j / ps];
                    }
                }
            }

            if (item) {
                i = item[0];
                j = item[1];
                ps = series[i].datapoints.pointsize;

                return {
                    datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                    dataIndex: j,
                    series: series[i],
                    seriesIndex: i
                };
            }

            return null;
        }

        function onMouseMove(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                    function (s) {
                        return s["hoverable"] != false;
                    });
        }

        function onMouseLeave(e) {
            if (options.grid.hoverable)
                triggerClickHoverEvent("plothover", e,
                    function (s) {
                        return false;
                    });
        }

        function onClick(e) {
            triggerClickHoverEvent("plotclick", e,
                function (s) {
                    return s["clickable"] != false;
                });
        }

        // trigger click or hover event (they send the same parameters
        // so we share their code)
        function triggerClickHoverEvent(eventname, event, seriesFilter) {
            var offset = eventHolder.offset(),
                canvasX = event.pageX - offset.left - plotOffset.left,
                canvasY = event.pageY - offset.top - plotOffset.top,
                pos = canvasToAxisCoords({left: canvasX, top: canvasY});

            pos.pageX = event.pageX;
            pos.pageY = event.pageY;

            var item = findNearbyItem(canvasX, canvasY, seriesFilter);

            if (item) {
                // fill in mouse pos for any listeners out there
                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left);
                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top);
            }

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname && !(item && h.series == item.series &&
                        h.point[0] == item.datapoint[0] &&
                        h.point[1] == item.datapoint[1]))
                        unhighlight(h.series, h.point);
                }

                if (item)
                    highlight(item.series, item.datapoint, eventname);
            }

            placeholder.trigger(eventname, [pos, item]);
        }

        function triggerRedrawOverlay() {
            var t = options.interaction.redrawOverlayInterval;
            if (t == -1) {      // skip event queue
                drawOverlay();
                return;
            }

            if (!redrawTimeout)
                redrawTimeout = setTimeout(drawOverlay, t);
        }

        function drawOverlay() {
            redrawTimeout = null;

            // draw highlights
            octx.save();
            octx.clearRect(0, 0, canvasWidth, canvasHeight);
            octx.translate(plotOffset.left, plotOffset.top);

            var i, hi;
            for (i = 0; i < highlights.length; ++i) {
                hi = highlights[i];

                if (hi.series.bars.show)
                    drawBarHighlight(hi.series, hi.point);
                else
                    drawPointHighlight(hi.series, hi.point);
            }
            octx.restore();

            executeHooks(hooks.drawOverlay, [octx]);
        }

        function highlight(s, point, auto) {
            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number") {
                var ps = s.datapoints.pointsize;
                point = s.datapoints.points.slice(ps * point, ps * (point + 1));
            }

            var i = indexOfHighlight(s, point);
            if (i == -1) {
                highlights.push({series: s, point: point, auto: auto});

                triggerRedrawOverlay();
            }
            else if (!auto)
                highlights[i].auto = false;
        }

        function unhighlight(s, point) {
            if (s == null && point == null) {
                highlights = [];
                triggerRedrawOverlay();
            }

            if (typeof s == "number")
                s = series[s];

            if (typeof point == "number")
                point = s.data[point];

            var i = indexOfHighlight(s, point);
            if (i != -1) {
                highlights.splice(i, 1);

                triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s, p) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s && h.point[0] == p[0]
                    && h.point[1] == p[1])
                    return i;
            }
            return -1;
        }

        function drawPointHighlight(series, point) {
            var x = point[0], y = point[1],
                axisx = series.xaxis, axisy = series.yaxis;
            highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();

            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)
                return;

            var pointRadius = series.points.radius + series.points.lineWidth / 2;
            octx.lineWidth = pointRadius;
            octx.strokeStyle = highlightColor;
            var radius = 1.5 * pointRadius,
                x = axisx.p2c(x),
                y = axisy.p2c(y);

            octx.beginPath();
            if (series.points.symbol == "circle")
                octx.arc(x, y, radius, 0, 2 * Math.PI, false);
            else
                series.points.symbol(octx, x, y, radius, false);
            octx.closePath();
            octx.stroke();
        }

        function drawBarHighlight(series, point) {
            var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
                fillStyle = highlightColor,
                barLeft = series.bars.align == "left" ? 0 : -series.bars.barWidth / 2;

            octx.lineWidth = series.bars.lineWidth;
            octx.strokeStyle = highlightColor;

            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                0, function () {
                    return fillStyle;
                }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
        }

        function getColorOrGradient(spec, bottom, top, defaultColor) {
            if (typeof spec == "string")
                return spec;
            else {
                // assume this is a gradient spec; IE currently only
                // supports a simple vertical gradient properly, so that's
                // what we support too
                var gradient = ctx.createLinearGradient(0, top, 0, bottom);

                for (var i = 0, l = spec.colors.length; i < l; ++i) {
                    var c = spec.colors[i];
                    if (typeof c != "string") {
                        var co = $.color.parse(defaultColor);
                        if (c.brightness != null)
                            co = co.scale('rgb', c.brightness);
                        if (c.opacity != null)
                            co.a *= c.opacity;
                        c = co.toString();
                    }
                    gradient.addColorStop(i / (l - 1), c);
                }

                return gradient;
            }
        }
    }

    $.plot = function (placeholder, data, options) {
        //var t0 = new Date();
        var plot = new Plot($(placeholder), data, options, $.plot.plugins);
        //(window.console ? console.log : alert)("time used (msecs): " + ((new Date()).getTime() - t0.getTime()));
        return plot;
    };

    $.plot.version = "0.7";

    $.plot.plugins = [];

    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }

})(jQuery);
/*
 Flot plugin for plotting textual data or categories. Consider a
 dataset like [["February", 34], ["March", 20], ...]. This plugin
 allows you to plot such a dataset directly.

 To enable it, you must specify mode: "categories" on the axis with the
 textual labels, e.g.

 $.plot("#placeholder", data, { xaxis: { mode: "categories" } });

 By default, the labels are ordered as they are met in the data series.
 If you need a different ordering, you can specify "categories" on the
 axis options and list the categories there:

 xaxis: {
 mode: "categories",
 categories: ["February", "March", "April"]
 }

 If you need to customize the distances between the categories, you can
 specify "categories" as an object mapping labels to values

 xaxis: {
 mode: "categories",
 categories: { "February": 1, "March": 3, "April": 4 }
 }

 If you don't specify all categories, the remaining encountered
 categories will be numbered from the max value plus 1 (with a spacing
 of 1 between each).


 Internally, the plugin works by transforming the input data through an
 auto-generated mapping where the first category becomes 0, the second
 1, etc. Hence, a point like ["February", 34] becomes [0, 34]
 internally in Flot (this is visible in hover and click events that
 return numbers rather than the category labels). The plugin also
 overrides the tick generator to spit out the categories as ticks
 instead of the values.

 If you need to map a value back to its label, the mapping is always
 accessible as "categories" on the axis object, e.g.
 plot.getAxes().xaxis.categories.
 */

(function ($) {
    var options = {
        xaxis: {
            categories: null
        },
        yaxis: {
            categories: null
        }
    };

    function processRawData(plot, series, data, datapoints) {
        // if categories are enabled, we need to disable
        // auto-transformation to numbers so the strings are intact
        // for later processing

        var xCategories = series.xaxis.options.mode == "categories",
            yCategories = series.yaxis.options.mode == "categories";

        if (!(xCategories || yCategories))
            return;

        var format = datapoints.format;

        if (!format) {
            // FIXME: auto-detection should really not be defined here
            var s = series;
            format = [];
            format.push({x: true, number: true, required: true});
            format.push({y: true, number: true, required: true});

            if (s.bars.show || (s.lines.show && s.lines.fill)) {
                format.push({y: true, number: true, required: false, defaultValue: 0});
                if (s.bars.horizontal) {
                    delete format[format.length - 1].y;
                    format[format.length - 1].x = true;
                }
            }

            datapoints.format = format;
        }

        for (var m = 0; m < format.length; ++m) {
            if (format[m].x && xCategories)
                format[m].number = false;

            if (format[m].y && yCategories)
                format[m].number = false;
        }
    }

    function getNextIndex(categories) {
        var index = -1;

        for (var v in categories)
            if (categories[v] > index)
                index = categories[v];

        return index + 1;
    }

    function categoriesTickGenerator(axis) {
        var res = [];
        for (var label in axis.categories) {
            var v = axis.categories[label];
            if (v >= axis.min && v <= axis.max)
                res.push([v, label]);
        }

        res.sort(function (a, b) {
            return a[0] - b[0];
        });

        return res;
    }

    function setupCategoriesForAxis(series, axis, datapoints) {
        if (series[axis].options.mode != "categories")
            return;

        if (!series[axis].categories) {
            // parse options
            var c = {}, o = series[axis].options.categories || {};
            if ($.isArray(o)) {
                for (var i = 0; i < o.length; ++i)
                    c[o[i]] = i;
            }
            else {
                for (var v in o)
                    c[v] = o[v];
            }

            series[axis].categories = c;
        }

        // fix ticks
        if (!series[axis].options.ticks)
            series[axis].options.ticks = categoriesTickGenerator;

        transformPointsOnAxis(datapoints, axis, series[axis].categories);
    }

    function transformPointsOnAxis(datapoints, axis, categories) {
        // go through the points, transforming them
        var points = datapoints.points,
            ps = datapoints.pointsize,
            format = datapoints.format,
            formatColumn = axis.charAt(0),
            index = getNextIndex(categories);

        for (var i = 0; i < points.length; i += ps) {
            if (points[i] == null)
                continue;

            for (var m = 0; m < ps; ++m) {
                var val = points[i + m];

                if (val == null || !format[m][formatColumn])
                    continue;

                if (!(val in categories)) {
                    categories[val] = index;
                    ++index;
                }

                points[i + m] = categories[val];
            }
        }
    }

    function processDatapoints(plot, series, datapoints) {
        setupCategoriesForAxis(series, "xaxis", datapoints);
        setupCategoriesForAxis(series, "yaxis", datapoints);
    }

    function init(plot) {
        plot.hooks.processRawData.push(processRawData);
        plot.hooks.processDatapoints.push(processDatapoints);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'categories',
        version: '1.0'
    });
})(jQuery);
/*
 * The MIT License

 Copyright (c) 2010 by Juergen Marsch

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

(function ($) {
    var options =
    {
        series: {
            grow: {
                active: true,
                valueIndex: 1,
                stepDelay: 20,
                steps: 100,
                stepMode: "linear",
                stepDirection: "up"
            }
        }
    };

    function init(plot) {
        var done = false;
        var growfunc;
        var plt = plot;
        var data = null;
        var opt = null;
        var valueIndex;
        plot.hooks.bindEvents.push(processbindEvents);
        plot.hooks.drawSeries.push(processSeries);
        function processSeries(plot, canvascontext, series) {
            opt = plot.getOptions();
            valueIndex = opt.series.grow.valueIndex;
            if (opt.series.grow.active == true) {
                if (done == false) {
                    data = plot.getData();
                    data.actualStep = 0;
                    for (var j = 0; j < data.length; j++) {
                        data[j].dataOrg = clone(data[j].data);
                        for (var i = 0; i < data[j].data.length; i++)
                            data[j].data[i][valueIndex] = 0;
                    }
                    plot.setData(data);
                    done = true;
                }
            }
        }

        function processbindEvents(plot, eventHolder) {
            opt = plot.getOptions();
            if (opt.series.grow.active == true) {
                var d = plot.getData();
                for (var j = 0; j < data.length; j++) {
                    opt.series.grow.steps = Math.max(opt.series.grow.steps, d[j].grow.steps);
                }
                if (opt.series.grow.stepDelay == 0) opt.series.grow.stepDelay++;
                growfunc = window.setInterval(growing, opt.series.grow.stepDelay);
            }
        }

        function growing() {
            if (data.actualStep < opt.series.grow.steps) {
                data.actualStep++;
                for (var j = 0; j < data.length; j++) {
                    if (typeof data[j].grow.stepMode == "function") {
                        data[j].grow.stepMode(data[j], data.actualStep, valueIndex);
                    }
                    else {
                        if (data[j].grow.stepMode == "linear") growLinear();
                        else if (data[j].grow.stepMode == "maximum") growMaximum();
                        else if (data[j].grow.stepMode == "delay") growDelay();
                        else growNone();
                    }
                }
                plt.setData(data);
                plt.draw();
            }
            else {
                window.clearInterval(growfunc);
            }
            function growNone() {
                if (data.actualStep == 1) {
                    for (var i = 0; i < data[j].data.length; i++) {
                        data[j].data[i][valueIndex] = data[j].dataOrg[i][valueIndex];
                    }
                }
            }

            function growLinear() {
                if (data.actualStep <= data[j].grow.steps) {
                    for (var i = 0; i < data[j].data.length; i++) {
                        if (data[j].grow.stepDirection == "up") {
                            data[j].data[i][valueIndex] = data[j].dataOrg[i][valueIndex] / data[j].grow.steps * data.actualStep;
                        }
                        else if (data[j].grow.stepDirection == "down") {
                            data[j].data[i][valueIndex] = data[j].dataOrg[i][valueIndex] + (data[j].yaxis.max - data[j].dataOrg[i][valueIndex]) / data[j].grow.steps * (data[j].grow.steps - data.actualStep);
                        }
                    }
                }
            }

            function growMaximum() {
                if (data.actualStep <= data[j].grow.steps) {
                    for (var i = 0; i < data[j].data.length; i++) {
                        if (data[j].grow.stepDirection == "up") {
                            data[j].data[i][valueIndex] = Math.min(data[j].dataOrg[i][valueIndex], data[j].yaxis.max / data[j].grow.steps * data.actualStep);
                        }
                        else if (data[j].grow.stepDirection == "down") {
                            data[j].data[i][valueIndex] = Math.max(data[j].dataOrg[i][valueIndex], data[j].yaxis.max / data[j].grow.steps * (data[j].grow.steps - data.actualStep));
                        }
                    }
                }
            }

            function growDelay() {
                if (data.actualStep == data[j].grow.steps) {
                    for (var i = 0; i < data[j].data.length; i++) {
                        data[j].data[i][valueIndex] = data[j].dataOrg[i][valueIndex];
                    }
                }
            }
        }

        function clone(obj) {
            if (obj == null || typeof(obj) != 'object') return obj;
            var temp = new obj.constructor();
            for (var key in obj)    temp[key] = clone(obj[key]);
            return temp;
        }
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'grow',
        version: '0.2'
    });
})(jQuery);
/*
 * Flot plugin to order bars side by side.
 * 
 * Released under the MIT license by Benjamin BUFFET, 20-Sep-2010.
 *
 * This plugin is an alpha version.
 *
 * To activate the plugin you must specify the parameter "order" for the specific serie :
 *
 *  $.plot($("#placeholder"), [{ data: [ ... ], bars :{ order = null or integer }])
 *
 * If 2 series have the same order param, they are ordered by the position in the array;
 *
 * The plugin adjust the point by adding a value depanding of the barwidth
 * Exemple for 3 series (barwidth : 0.1) :
 *
 *          first bar décalage : -0.15
 *          second bar décalage : -0.05
 *          third bar décalage : 0.05
 *
 */

(function ($) {
    function init(plot) {
        var orderedBarSeries;
        var nbOfBarsToOrder;
        var borderWidth;
        var borderWidthInXabsWidth;
        var pixelInXWidthEquivalent = 1;
        var isHorizontal = false;

        /*
         * This method add shift to x values
         */
        function reOrderBars(plot, serie, datapoints) {
            var shiftedPoints = null;

            if (serieNeedToBeReordered(serie)) {
                checkIfGraphIsHorizontal(serie);
                calculPixel2XWidthConvert(plot);
                retrieveBarSeries(plot);
                calculBorderAndBarWidth(serie);

                if (nbOfBarsToOrder >= 2) {
                    var position = findPosition(serie);
                    var decallage = 0;

                    var centerBarShift = calculCenterBarShift();

                    if (isBarAtLeftOfCenter(position)) {
                        decallage = -1 * (sumWidth(orderedBarSeries, position - 1, Math.floor(nbOfBarsToOrder / 2) - 1)) - centerBarShift;
                    } else {
                        decallage = sumWidth(orderedBarSeries, Math.ceil(nbOfBarsToOrder / 2), position - 2) + centerBarShift + borderWidthInXabsWidth * 2;
                    }

                    shiftedPoints = shiftPoints(datapoints, serie, decallage);
                    datapoints.points = shiftedPoints;
                }
            }
            return shiftedPoints;
        }

        function serieNeedToBeReordered(serie) {
            return serie.bars != null
                && serie.bars.show
                && serie.bars.order != null;
        }

        function calculPixel2XWidthConvert(plot) {
            var gridDimSize = isHorizontal ? plot.getPlaceholder().innerHeight() : plot.getPlaceholder().innerWidth();
            var minMaxValues = isHorizontal ? getAxeMinMaxValues(plot.getData(), 1) : getAxeMinMaxValues(plot.getData(), 0);
            var AxeSize = minMaxValues[1] - minMaxValues[0];
            pixelInXWidthEquivalent = AxeSize / gridDimSize;
        }

        function getAxeMinMaxValues(series, AxeIdx) {
            var minMaxValues = new Array();
            for (var i = 0; i < series.length; i++) {
                minMaxValues[0] = series[i].data[0][AxeIdx];
                minMaxValues[1] = series[i].data[series[i].data.length - 1][AxeIdx];
            }
            return minMaxValues;
        }

        function retrieveBarSeries(plot) {
            orderedBarSeries = findOthersBarsToReOrders(plot.getData());
            nbOfBarsToOrder = orderedBarSeries.length;
        }

        function findOthersBarsToReOrders(series) {
            var retSeries = new Array();

            for (var i = 0; i < series.length; i++) {
                if (series[i].bars.order != null && series[i].bars.show) {
                    retSeries.push(series[i]);
                }
            }

            return retSeries.sort(sortByOrder);
        }

        function sortByOrder(serie1, serie2) {
            var x = serie1.bars.order;
            var y = serie2.bars.order;
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        }

        function calculBorderAndBarWidth(serie) {
            borderWidth = serie.bars.lineWidth ? serie.bars.lineWidth : 2;
            borderWidthInXabsWidth = borderWidth * pixelInXWidthEquivalent;
        }

        function checkIfGraphIsHorizontal(serie) {
            if (serie.bars.horizontal) {
                isHorizontal = true;
            }
        }

        function findPosition(serie) {
            var pos = 0
            for (var i = 0; i < orderedBarSeries.length; ++i) {
                if (serie == orderedBarSeries[i]) {
                    pos = i;
                    break;
                }
            }

            return pos + 1;
        }

        function calculCenterBarShift() {
            var width = 0;

            if (nbOfBarsToOrder % 2 != 0)
                width = (orderedBarSeries[Math.ceil(nbOfBarsToOrder / 2)].bars.barWidth) / 2;

            return width;
        }

        function isBarAtLeftOfCenter(position) {
            return position <= Math.ceil(nbOfBarsToOrder / 2);
        }

        function sumWidth(series, start, end) {
            var totalWidth = 0;

            for (var i = start; i <= end; i++) {
                totalWidth += series[i].bars.barWidth + borderWidthInXabsWidth * 2;
            }

            return totalWidth;
        }

        function shiftPoints(datapoints, serie, dx) {
            var ps = datapoints.pointsize;
            var points = datapoints.points;
            var j = 0;
            for (var i = isHorizontal ? 1 : 0; i < points.length; i += ps) {
                points[i] += dx;
                //Adding the new x value in the serie to be abble to display the right tooltip value,
                //using the index 3 to not overide the third index.
                serie.data[j][3] = points[i];
                j++;
            }

            return points;
        }

        plot.hooks.processDatapoints.push(reOrderBars);

    }

    var options = {
        series: {
            bars: {order: null} // or number/string
        }
    };

    $.plot.plugins.push({
        init: init,
        options: options,
        name: "orderBars",
        version: "0.2"
    });

})(jQuery);

/*
 Flot plugin for rendering pie charts. The plugin assumes the data is 
 coming is as a single data value for each series, and each of those 
 values is a positive value or zero (negative numbers don't make 
 any sense and will cause strange effects). The data values do 
 NOT need to be passed in as percentage values because it 
 internally calculates the total and percentages.

 * Created by Brian Medendorp, June 2009
 * Updated November 2009 with contributions from: btburnett3, Anthony Aragues and Xavi Ivars

 * Changes:
 2009-10-22: lineJoin set to round
 2009-10-23: IE full circle fix, donut
 2009-11-11: Added basic hover from btburnett3 - does not work in IE, and center is off in Chrome and Opera
 2009-11-17: Added IE hover capability submitted by Anthony Aragues
 2009-11-18: Added bug fix submitted by Xavi Ivars (issues with arrays when other JS libraries are included as well)


 Available options are:
 series: {
 pie: {
 show: true/false
 radius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'
 innerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect
 startAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result
 tilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)
 offset: {
 top: integer value to move the pie up or down
 left: integer value to move the pie left or right, or 'auto'
 },
 stroke: {
 color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')
 width: integer pixel width of the stroke
 },
 label: {
 show: true/false, or 'auto'
 formatter:  a user-defined function that modifies the text/style of the label text
 radius: 0-1 for percentage of fullsize, or a specified pixel length
 background: {
 color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')
 opacity: 0-1
 },
 threshold: 0-1 for the percentage value at which to hide labels (if they're too small)
 },
 combine: {
 threshold: 0-1 for the percentage value at which to combine slices (if they're too small)
 color: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined
 label: any text value of what the combined slice should be labeled
 }
 highlight: {
 opacity: 0-1
 }
 }
 }

 More detail and specific examples can be found in the included HTML file.

 */

(function ($) {
    function init(plot) // this is the "body" of the plugin
    {
        var canvas = null;
        var target = null;
        var maxRadius = null;
        var centerLeft = null;
        var centerTop = null;
        var total = 0;
        var redraw = true;
        var redrawAttempts = 10;
        var shrink = 0.95;
        var legendWidth = 0;
        var processed = false;
        var raw = false;

        // interactive variables	
        var highlights = [];

        // add hook to determine if pie plugin in enabled, and then perform necessary operations
        plot.hooks.processOptions.push(checkPieEnabled);
        plot.hooks.bindEvents.push(bindEvents);

        // check to see if the pie plugin is enabled
        function checkPieEnabled(plot, options) {
            if (options.series.pie.show) {
                //disable grid
                options.grid.show = false;

                // set labels.show
                if (options.series.pie.label.show == 'auto')
                    if (options.legend.show)
                        options.series.pie.label.show = false;
                    else
                        options.series.pie.label.show = true;

                // set radius
                if (options.series.pie.radius == 'auto')
                    if (options.series.pie.label.show)
                        options.series.pie.radius = 3 / 4;
                    else
                        options.series.pie.radius = 1;

                // ensure sane tilt
                if (options.series.pie.tilt > 1)
                    options.series.pie.tilt = 1;
                if (options.series.pie.tilt < 0)
                    options.series.pie.tilt = 0;

                // add processData hook to do transformations on the data
                plot.hooks.processDatapoints.push(processDatapoints);
                plot.hooks.drawOverlay.push(drawOverlay);

                // add draw hook
                plot.hooks.draw.push(draw);
            }
        }

        // bind hoverable events
        function bindEvents(plot, eventHolder) {
            var options = plot.getOptions();

            if (options.series.pie.show && options.grid.hoverable)
                eventHolder.unbind('mousemove').mousemove(onMouseMove);

            if (options.series.pie.show && options.grid.clickable)
                eventHolder.unbind('click').click(onClick);
        }


        // debugging function that prints out an object
        function alertObject(obj) {
            var msg = '';

            function traverse(obj, depth) {
                if (!depth)
                    depth = 0;
                for (var i = 0; i < obj.length; ++i) {
                    for (var j = 0; j < depth; j++)
                        msg += '\t';

                    if (typeof obj[i] == "object") {	// its an object
                        msg += '' + i + ':\n';
                        traverse(obj[i], depth + 1);
                    }
                    else {	// its a value
                        msg += '' + i + ': ' + obj[i] + '\n';
                    }
                }
            }

            traverse(obj);
            alert(msg);
        }

        function calcTotal(data) {
            for (var i = 0; i < data.length; ++i) {
                var item = parseFloat(data[i].data[0][1]);
                if (item)
                    total += item;
            }
        }

        function processDatapoints(plot, series, data, datapoints) {
            if (!processed) {
                processed = true;

                canvas = plot.getCanvas();
                target = $(canvas).parent();
                options = plot.getOptions();

                plot.setData(combine(plot.getData()));
            }
        }

        function setupPie() {
            legendWidth = target.children().filter('.legend').children().width();

            // calculate maximum radius and center point
            maxRadius = Math.min(canvas.width, (canvas.height / options.series.pie.tilt)) / 2;
            centerTop = (canvas.height / 2) + options.series.pie.offset.top;
            centerLeft = (canvas.width / 2);

            if (options.series.pie.offset.left == 'auto')
                if (options.legend.position.match('w'))
                    centerLeft += legendWidth / 2;
                else
                    centerLeft -= legendWidth / 2;
            else
                centerLeft += options.series.pie.offset.left;

            if (centerLeft < maxRadius)
                centerLeft = maxRadius;
            else if (centerLeft > canvas.width - maxRadius)
                centerLeft = canvas.width - maxRadius;
        }

        function fixData(data) {
            for (var i = 0; i < data.length; ++i) {
                if (typeof(data[i].data) == 'number')
                    data[i].data = [[1, data[i].data]];
                else if (typeof(data[i].data) == 'undefined' || typeof(data[i].data[0]) == 'undefined') {
                    if (typeof(data[i].data) != 'undefined' && typeof(data[i].data.label) != 'undefined')
                        data[i].label = data[i].data.label; // fix weirdness coming from flot
                    data[i].data = [[1, 0]];

                }
            }
            return data;
        }

        function combine(data) {
            data = fixData(data);
            calcTotal(data);
            var combined = 0;
            var numCombined = 0;
            var color = options.series.pie.combine.color;

            var newdata = [];
            for (var i = 0; i < data.length; ++i) {
                // make sure its a number
                data[i].data[0][1] = parseFloat(data[i].data[0][1]);
                if (!data[i].data[0][1])
                    data[i].data[0][1] = 0;

                if (data[i].data[0][1] / total <= options.series.pie.combine.threshold) {
                    combined += data[i].data[0][1];
                    numCombined++;
                    if (!color)
                        color = data[i].color;
                }
                else {
                    newdata.push({
                        data: [[1, data[i].data[0][1]]],
                        color: data[i].color,
                        label: data[i].label,
                        angle: (data[i].data[0][1] * (Math.PI * 2)) / total,
                        percent: (data[i].data[0][1] / total * 100)
                    });
                }
            }
            if (numCombined > 0)
                newdata.push({
                    data: [[1, combined]],
                    color: color,
                    label: options.series.pie.combine.label,
                    angle: (combined * (Math.PI * 2)) / total,
                    percent: (combined / total * 100)
                });
            return newdata;
        }

        function draw(plot, newCtx) {
            if (!target) return; // if no series were passed
            ctx = newCtx;

            setupPie();
            var slices = plot.getData();

            var attempts = 0;
            while (redraw && attempts < redrawAttempts) {
                redraw = false;
                if (attempts > 0)
                    maxRadius *= shrink;
                attempts += 1;
                clear();
                if (options.series.pie.tilt <= 0.8)
                    drawShadow();
                drawPie();
            }
            if (attempts >= redrawAttempts) {
                clear();
                target.prepend('<div class="error">Could not draw pie with labels contained inside canvas</div>');
            }

            if (plot.setSeries && plot.insertLegend) {
                plot.setSeries(slices);
                plot.insertLegend();
            }

            // we're actually done at this point, just defining internal functions at this point

            function clear() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                target.children().filter('.pieLabel, .pieLabelBackground').remove();
            }

            function drawShadow() {
                var shadowLeft = options.series.pie.shadow.left;
                var shadowTop = options.series.pie.shadow.top;
                var edge = 10;
                var alpha = options.series.pie.shadow.alpha;

                // set radius
                if (options.series.pie.radius > 1)
                    var radius = options.series.pie.radius;
                else
                    var radius = maxRadius * options.series.pie.radius;

                if (radius >= (canvas.width / 2) - shadowLeft || radius * options.series.pie.tilt >= (canvas.height / 2) - shadowTop || radius <= edge)
                    return;	// shadow would be outside canvas, so don't draw it

                ctx.save();
                ctx.translate(shadowLeft, shadowTop);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#000';

                // center and rotate to starting position
                ctx.translate(centerLeft, centerTop);
                ctx.scale(1, options.series.pie.tilt);

                //radius -= edge;
                for (var i = 1; i <= edge; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
                    ctx.fill();
                    radius -= i;
                }

                ctx.restore();
            }

            function drawPie() {
                var startAngle = Math.PI * options.series.pie.startAngle;
                var radius;

                // set radius
                if (options.series.pie.radius > 1)
                    radius = options.series.pie.radius;
                else radius = maxRadius * options.series.pie.radius;

                // center and rotate to starting position
                ctx.save();
                ctx.translate(centerLeft, centerTop);
                ctx.scale(1, options.series.pie.tilt);
                //ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera

                // draw slices
                ctx.save();
                var currentAngle = startAngle;
                for (var i = 0; i < slices.length; ++i) {
                    slices[i].startAngle = currentAngle;
                    drawSlice(slices[i].angle, slices[i].color, true);
                }
                ctx.restore();

                // draw slice outlines

                if (options.series.pie.stroke.width > 0) {
                    ctx.save();
                    ctx.lineWidth = options.series.pie.stroke.width;
                    currentAngle = startAngle;
                    for (var i = 0; i < slices.length; ++i)
                        drawSlice(slices[i].angle, options.series.pie.stroke.color, false);
                    ctx.restore();
                }

                // draw donut hole
                drawDonutHole(ctx);

                // draw labels
                if (options.series.pie.label.show)
                    drawLabels();

                // restore to original state
                ctx.restore();

                function drawSlice(angle, color, fill) {
                    if (angle <= 0 || isNaN(angle))
                        return;

                    if (fill)
                        ctx.fillStyle = color;
                    else {
                        ctx.strokeStyle = color;
                        ctx.lineJoin = 'round';
                    }

                    ctx.beginPath();
                    if (Math.abs(angle - Math.PI * 2) > 0.000000001)
                        ctx.moveTo(0, 0); // Center of the pie
                    else if ($.browser.msie)
                        angle -= 0.0001;
                    //ctx.arc(0,0,radius,0,angle,false); // This doesn't work properly in Opera
                    ctx.arc(0, 0, radius, currentAngle, currentAngle + angle, false);
                    ctx.closePath();
                    //ctx.rotate(angle); // This doesn't work properly in Opera
                    currentAngle += angle;

                    if (fill)
                        ctx.fill();
                    else
                        ctx.stroke();
                }

                function drawLabels() {
                    var currentAngle = startAngle;

                    // set radius
                    if (options.series.pie.label.radius > 1)
                        var radius = options.series.pie.label.radius;
                    else
                        var radius = maxRadius * options.series.pie.label.radius;

                    for (var i = 0; i < slices.length; ++i) {
                        if (slices[i].percent >= options.series.pie.label.threshold * 100)
                            drawLabel(slices[i], currentAngle, i);
                        currentAngle += slices[i].angle;
                    }

                    function drawLabel(slice, startAngle, index) {
                        if (slice.data[0][1] == 0)
                            return;

                        // format label text
                        var lf = options.legend.labelFormatter, text, plf = options.series.pie.label.formatter;
                        if (lf)
                            text = lf(slice.label, slice);
                        else
                            text = slice.label;
                        if (plf)
                            text = plf(text, slice);

                        var halfAngle = ((startAngle + slice.angle) + startAngle) / 2;
                        var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);
                        var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;

                        var html = '<span class="pieLabel" id="pieLabel' + index + '" style="position:absolute;top:' + y + 'px;left:' + x + 'px;">' + text + "</span>";
                        target.append(html);
                        var label = target.children('#pieLabel' + index);
                        var labelTop = (y - label.height() / 2);
                        var labelLeft = (x - label.width() / 2);
                        label.css('top', labelTop);
                        label.css('left', labelLeft);

                        // check to make sure that the label is not outside the canvas
                        if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvas.height - (labelTop + label.height()) < 0 || canvas.width - (labelLeft + label.width()) < 0)
                            redraw = true;

                        if (options.series.pie.label.background.opacity != 0) {
                            // put in the transparent background separately to avoid blended labels and label boxes
                            var c = options.series.pie.label.background.color;
                            if (c == null) {
                                c = slice.color;
                            }
                            var pos = 'top:' + labelTop + 'px;left:' + labelLeft + 'px;';
                            $('<div class="pieLabelBackground" style="position:absolute;width:' + label.width() + 'px;height:' + label.height() + 'px;' + pos + 'background-color:' + c + ';"> </div>').insertBefore(label).css('opacity', options.series.pie.label.background.opacity);
                        }
                    } // end individual label function
                } // end drawLabels function
            } // end drawPie function
        } // end draw function

        // Placed here because it needs to be accessed from multiple locations 
        function drawDonutHole(layer) {
            // draw donut hole
            if (options.series.pie.innerRadius > 0) {
                // subtract the center
                layer.save();
                innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;
                layer.globalCompositeOperation = 'destination-out'; // this does not work with excanvas, but it will fall back to using the stroke color
                layer.beginPath();
                layer.fillStyle = options.series.pie.stroke.color;
                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
                layer.fill();
                layer.closePath();
                layer.restore();

                // add inner stroke
                layer.save();
                layer.beginPath();
                layer.strokeStyle = options.series.pie.stroke.color;
                layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);
                layer.stroke();
                layer.closePath();
                layer.restore();
                // TODO: add extra shadow inside hole (with a mask) if the pie is tilted.
            }
        }

        //-- Additional Interactive related functions --

        function isPointInPoly(poly, pt) {
            for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
                ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1] < poly[i][1]))
                && (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0])
                && (c = !c);
            return c;
        }

        function findNearbySlice(mouseX, mouseY) {
            var slices = plot.getData(),
                options = plot.getOptions(),
                radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

            for (var i = 0; i < slices.length; ++i) {
                var s = slices[i];

                if (s.pie.show) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(0, 0); // Center of the pie
                    //ctx.scale(1, options.series.pie.tilt);	// this actually seems to break everything when here.
                    ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle, false);
                    ctx.closePath();
                    x = mouseX - centerLeft;
                    y = mouseY - centerTop;
                    if (ctx.isPointInPath) {
                        if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {
                            //alert('found slice!');
                            ctx.restore();
                            return {datapoint: [s.percent, s.data], dataIndex: 0, series: s, seriesIndex: i};
                        }
                    }
                    else {
                        // excanvas for IE doesn;t support isPointInPath, this is a workaround. 
                        p1X = (radius * Math.cos(s.startAngle));
                        p1Y = (radius * Math.sin(s.startAngle));
                        p2X = (radius * Math.cos(s.startAngle + (s.angle / 4)));
                        p2Y = (radius * Math.sin(s.startAngle + (s.angle / 4)));
                        p3X = (radius * Math.cos(s.startAngle + (s.angle / 2)));
                        p3Y = (radius * Math.sin(s.startAngle + (s.angle / 2)));
                        p4X = (radius * Math.cos(s.startAngle + (s.angle / 1.5)));
                        p4Y = (radius * Math.sin(s.startAngle + (s.angle / 1.5)));
                        p5X = (radius * Math.cos(s.startAngle + s.angle));
                        p5Y = (radius * Math.sin(s.startAngle + s.angle));
                        arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]];
                        arrPoint = [x, y];
                        // TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?
                        if (isPointInPoly(arrPoly, arrPoint)) {
                            ctx.restore();
                            return {datapoint: [s.percent, s.data], dataIndex: 0, series: s, seriesIndex: i};
                        }
                    }
                    ctx.restore();
                }
            }

            return null;
        }

        function onMouseMove(e) {
            triggerClickHoverEvent('plothover', e);
        }

        function onClick(e) {
            triggerClickHoverEvent('plotclick', e);
        }

        // trigger click or hover event (they send the same parameters so we share their code)
        function triggerClickHoverEvent(eventname, e) {
            var offset = plot.offset(),
                canvasX = parseInt(e.pageX - offset.left),
                canvasY = parseInt(e.pageY - offset.top),
                item = findNearbySlice(canvasX, canvasY);

            if (options.grid.autoHighlight) {
                // clear auto-highlights
                for (var i = 0; i < highlights.length; ++i) {
                    var h = highlights[i];
                    if (h.auto == eventname && !(item && h.series == item.series))
                        unhighlight(h.series);
                }
            }

            // highlight the slice
            if (item)
                highlight(item.series, eventname);

            // trigger any hover bind events
            var pos = {pageX: e.pageX, pageY: e.pageY};
            target.trigger(eventname, [pos, item]);
        }

        function highlight(s, auto) {
            if (typeof s == "number")
                s = series[s];

            var i = indexOfHighlight(s);
            if (i == -1) {
                highlights.push({series: s, auto: auto});
                plot.triggerRedrawOverlay();
            }
            else if (!auto)
                highlights[i].auto = false;
        }

        function unhighlight(s) {
            if (s == null) {
                highlights = [];
                plot.triggerRedrawOverlay();
            }

            if (typeof s == "number")
                s = series[s];

            var i = indexOfHighlight(s);
            if (i != -1) {
                highlights.splice(i, 1);
                plot.triggerRedrawOverlay();
            }
        }

        function indexOfHighlight(s) {
            for (var i = 0; i < highlights.length; ++i) {
                var h = highlights[i];
                if (h.series == s)
                    return i;
            }
            return -1;
        }

        function drawOverlay(plot, octx) {
            //alert(options.series.pie.radius);
            var options = plot.getOptions();
            //alert(options.series.pie.radius);

            var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;

            octx.save();
            octx.translate(centerLeft, centerTop);
            octx.scale(1, options.series.pie.tilt);

            for (i = 0; i < highlights.length; ++i)
                drawHighlight(highlights[i].series);

            drawDonutHole(octx);

            octx.restore();

            function drawHighlight(series) {
                if (series.angle <= 0 || isNaN(series.angle))
                    return;

                //octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();
                octx.fillStyle = "rgba(255, 255, 255, " + options.series.pie.highlight.opacity + ")"; // this is temporary until we have access to parseColor

                octx.beginPath();
                if (Math.abs(series.angle - Math.PI * 2) > 0.000000001)
                    octx.moveTo(0, 0); // Center of the pie
                octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle, false);
                octx.closePath();
                octx.fill();
            }

        }

    } // end init (plugin body)

    // define pie specific options and their default values
    var options = {
        series: {
            pie: {
                show: false,
                radius: 'auto',	// actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)
                innerRadius: 0, /* for donut */
                startAngle: 3 / 2,
                tilt: 1,
                shadow: {
                    left: 5,     // shadow left offset
                    top: 15,     // shadow top offset
                    alpha: 0.02, // shadow alpha
                },
                offset: {
                    top: 0,
                    left: 'auto'
                },
                stroke: {
                    color: '#FFF',
                    width: 1
                },
                label: {
                    show: 'auto',
                    formatter: function (label, slice) {
                        return '<div style="font-size:x-small;text-align:center;padding:2px;color:' + slice.color + ';">' + label + '<br/>' + Math.round(slice.percent) + '%</div>';
                    },	// formatter function
                    radius: 1,	// radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)
                    background: {
                        color: null,
                        opacity: 0
                    },
                    threshold: 0	// percentage at which to hide the label (i.e. the slice is too narrow)
                },
                combine: {
                    threshold: -1,	// percentage at which to combine little slices into one larger slice
                    color: null,	// color to give the new slice (auto-generated if null)
                    label: 'Other'	// label to give the new slice
                },
                highlight: {
                    //color: '#FFF',		// will add this functionality once parseColor is available
                    opacity: 0.5
                }
            }
        }
    };

    $.plot.plugins.push({
        init: init,
        options: options,
        name: "pie",
        version: "1.0"
    });
})(jQuery);

/*
 Flot plugin for automatically redrawing plots when the placeholder
 size changes, e.g. on window resizes.

 It works by listening for changes on the placeholder div (through the
 jQuery resize event plugin) - if the size changes, it will redraw the
 plot.

 There are no options. If you need to disable the plugin for some
 plots, you can just fix the size of their placeholders.
 */


/* Inline dependency: 
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function ($, h, c) {
    var a = $([]), e = $.resize = $.extend($.resize, {}), i, k = "setTimeout", j = "resize", d = j + "-special-event", b = "delay", f = "throttleWindow";
    e[b] = 250;
    e[f] = true;
    $.event.special[j] = {
        setup: function () {
            if (!e[f] && this[k]) {
                return false
            }
            var l = $(this);
            a = a.add(l);
            $.data(this, d, {w: l.width(), h: l.height()});
            if (a.length === 1) {
                g()
            }
        }, teardown: function () {
            if (!e[f] && this[k]) {
                return false
            }
            var l = $(this);
            a = a.not(l);
            l.removeData(d);
            if (!a.length) {
                clearTimeout(i)
            }
        }, add: function (l) {
            if (!e[f] && this[k]) {
                return false
            }
            var n;

            function m(s, o, p) {
                var q = $(this), r = $.data(this, d);
                r.w = o !== c ? o : q.width();
                r.h = p !== c ? p : q.height();
                n.apply(this, arguments)
            }

            if ($.isFunction(l)) {
                n = l;
                return m
            } else {
                n = l.handler;
                l.handler = m
            }
        }
    };
    function g() {
        i = h[k](function () {
            a.each(function () {
                var n = $(this), m = n.width(), l = n.height(), o = $.data(this, d);
                if (m !== o.w || l !== o.h) {
                    n.trigger(j, [o.w = m, o.h = l])
                }
            });
            g()
        }, e[b])
    }
})(jQuery, this);


(function ($) {
    var options = {}; // no options

    function init(plot) {
        function onResize() {
            var placeholder = plot.getPlaceholder();

            // somebody might have hidden us and we can't plot
            // when we don't have the dimensions
            if (placeholder.width() == 0 || placeholder.height() == 0)
                return;

            plot.resize();
            plot.setupGrid();
            plot.draw();
        }

        function bindEvents(plot, eventHolder) {
            plot.getPlaceholder().resize(onResize);
        }

        function shutdown(plot, eventHolder) {
            plot.getPlaceholder().unbind("resize", onResize);
        }

        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'resize',
        version: '1.0'
    });
})(jQuery);

/*
 Flot plugin for selecting regions.

 The plugin defines the following options:

 selection: {
 mode: null or "x" or "y" or "xy",
 color: color
 }

 Selection support is enabled by setting the mode to one of "x", "y" or
 "xy". In "x" mode, the user will only be able to specify the x range,
 similarly for "y" mode. For "xy", the selection becomes a rectangle
 where both ranges can be specified. "color" is color of the selection
 (if you need to change the color later on, you can get to it with
 plot.getOptions().selection.color).

 When selection support is enabled, a "plotselected" event will be
 emitted on the DOM element you passed into the plot function. The
 event handler gets a parameter with the ranges selected on the axes,
 like this:

 placeholder.bind("plotselected", function(event, ranges) {
 alert("You selected " + ranges.xaxis.from + " to " + ranges.xaxis.to)
 // similar for yaxis - with multiple axes, the extra ones are in
 // x2axis, x3axis, ...
 });

 The "plotselected" event is only fired when the user has finished
 making the selection. A "plotselecting" event is fired during the
 process with the same parameters as the "plotselected" event, in case
 you want to know what's happening while it's happening,

 A "plotunselected" event with no arguments is emitted when the user
 clicks the mouse to remove the selection.

 The plugin allso adds the following methods to the plot object:

 - setSelection(ranges, preventEvent)

 Set the selection rectangle. The passed in ranges is on the same
 form as returned in the "plotselected" event. If the selection mode
 is "x", you should put in either an xaxis range, if the mode is "y"
 you need to put in an yaxis range and both xaxis and yaxis if the
 selection mode is "xy", like this:

 setSelection({ xaxis: { from: 0, to: 10 }, yaxis: { from: 40, to: 60 } });

 setSelection will trigger the "plotselected" event when called. If
 you don't want that to happen, e.g. if you're inside a
 "plotselected" handler, pass true as the second parameter. If you
 are using multiple axes, you can specify the ranges on any of those,
 e.g. as x2axis/x3axis/... instead of xaxis, the plugin picks the
 first one it sees.

 - clearSelection(preventEvent)

 Clear the selection rectangle. Pass in true to avoid getting a
 "plotunselected" event.

 - getSelection()

 Returns the current selection in the same format as the
 "plotselected" event. If there's currently no selection, the
 function returns null.

 */

(function ($) {
    function init(plot) {
        var selection = {
            first: {x: -1, y: -1}, second: {x: -1, y: -1},
            show: false,
            active: false
        };

        // FIXME: The drag handling implemented here should be
        // abstracted out, there's some similar code from a library in
        // the navigation plugin, this should be massaged a bit to fit
        // the Flot cases here better and reused. Doing this would
        // make this plugin much slimmer.
        var savedhandlers = {};

        var mouseUpHandler = null;

        function onMouseMove(e) {
            if (selection.active) {
                updateSelection(e);

                plot.getPlaceholder().trigger("plotselecting", [getSelection()]);
            }
        }

        function onMouseDown(e) {
            if (e.which != 1)  // only accept left-click
                return;

            // cancel out any text selections
            document.body.focus();

            // prevent text selection and drag in old-school browsers
            if (document.onselectstart !== undefined && savedhandlers.onselectstart == null) {
                savedhandlers.onselectstart = document.onselectstart;
                document.onselectstart = function () {
                    return false;
                };
            }
            if (document.ondrag !== undefined && savedhandlers.ondrag == null) {
                savedhandlers.ondrag = document.ondrag;
                document.ondrag = function () {
                    return false;
                };
            }

            setSelectionPos(selection.first, e);

            selection.active = true;

            // this is a bit silly, but we have to use a closure to be
            // able to whack the same handler again
            mouseUpHandler = function (e) {
                onMouseUp(e);
            };

            $(document).one("mouseup", mouseUpHandler);
        }

        function onMouseUp(e) {
            mouseUpHandler = null;

            // revert drag stuff for old-school browsers
            if (document.onselectstart !== undefined)
                document.onselectstart = savedhandlers.onselectstart;
            if (document.ondrag !== undefined)
                document.ondrag = savedhandlers.ondrag;

            // no more dragging
            selection.active = false;
            updateSelection(e);

            if (selectionIsSane())
                triggerSelectedEvent();
            else {
                // this counts as a clear
                plot.getPlaceholder().trigger("plotunselected", []);
                plot.getPlaceholder().trigger("plotselecting", [null]);
            }

            return false;
        }

        function getSelection() {
            if (!selectionIsSane())
                return null;

            var r = {}, c1 = selection.first, c2 = selection.second;
            $.each(plot.getAxes(), function (name, axis) {
                if (axis.used) {
                    var p1 = axis.c2p(c1[axis.direction]), p2 = axis.c2p(c2[axis.direction]);
                    r[name] = {from: Math.min(p1, p2), to: Math.max(p1, p2)};
                }
            });
            return r;
        }

        function triggerSelectedEvent() {
            var r = getSelection();

            plot.getPlaceholder().trigger("plotselected", [r]);

            // backwards-compat stuff, to be removed in future
            if (r.xaxis && r.yaxis)
                plot.getPlaceholder().trigger("selected", [{
                    x1: r.xaxis.from,
                    y1: r.yaxis.from,
                    x2: r.xaxis.to,
                    y2: r.yaxis.to
                }]);
        }

        function clamp(min, value, max) {
            return value < min ? min : (value > max ? max : value);
        }

        function setSelectionPos(pos, e) {
            var o = plot.getOptions();
            var offset = plot.getPlaceholder().offset();
            var plotOffset = plot.getPlotOffset();
            pos.x = clamp(0, e.pageX - offset.left - plotOffset.left, plot.width());
            pos.y = clamp(0, e.pageY - offset.top - plotOffset.top, plot.height());

            if (o.selection.mode == "y")
                pos.x = pos == selection.first ? 0 : plot.width();

            if (o.selection.mode == "x")
                pos.y = pos == selection.first ? 0 : plot.height();
        }

        function updateSelection(pos) {
            if (pos.pageX == null)
                return;

            setSelectionPos(selection.second, pos);
            if (selectionIsSane()) {
                selection.show = true;
                plot.triggerRedrawOverlay();
            }
            else
                clearSelection(true);
        }

        function clearSelection(preventEvent) {
            if (selection.show) {
                selection.show = false;
                plot.triggerRedrawOverlay();
                if (!preventEvent)
                    plot.getPlaceholder().trigger("plotunselected", []);
            }
        }

        // function taken from markings support in Flot
        function extractRange(ranges, coord) {
            var axis, from, to, key, axes = plot.getAxes();

            for (var k in axes) {
                axis = axes[k];
                if (axis.direction == coord) {
                    key = coord + axis.n + "axis";
                    if (!ranges[key] && axis.n == 1)
                        key = coord + "axis"; // support x1axis as xaxis
                    if (ranges[key]) {
                        from = ranges[key].from;
                        to = ranges[key].to;
                        break;
                    }
                }
            }

            // backwards-compat stuff - to be removed in future
            if (!ranges[key]) {
                axis = coord == "x" ? plot.getXAxes()[0] : plot.getYAxes()[0];
                from = ranges[coord + "1"];
                to = ranges[coord + "2"];
            }

            // auto-reverse as an added bonus
            if (from != null && to != null && from > to) {
                var tmp = from;
                from = to;
                to = tmp;
            }

            return {from: from, to: to, axis: axis};
        }

        function setSelection(ranges, preventEvent) {
            var axis, range, o = plot.getOptions();

            if (o.selection.mode == "y") {
                selection.first.x = 0;
                selection.second.x = plot.width();
            }
            else {
                range = extractRange(ranges, "x");

                selection.first.x = range.axis.p2c(range.from);
                selection.second.x = range.axis.p2c(range.to);
            }

            if (o.selection.mode == "x") {
                selection.first.y = 0;
                selection.second.y = plot.height();
            }
            else {
                range = extractRange(ranges, "y");

                selection.first.y = range.axis.p2c(range.from);
                selection.second.y = range.axis.p2c(range.to);
            }

            selection.show = true;
            plot.triggerRedrawOverlay();
            if (!preventEvent && selectionIsSane())
                triggerSelectedEvent();
        }

        function selectionIsSane() {
            var minSize = 5;
            return Math.abs(selection.second.x - selection.first.x) >= minSize &&
                Math.abs(selection.second.y - selection.first.y) >= minSize;
        }

        plot.clearSelection = clearSelection;
        plot.setSelection = setSelection;
        plot.getSelection = getSelection;

        plot.hooks.bindEvents.push(function (plot, eventHolder) {
            var o = plot.getOptions();
            if (o.selection.mode != null) {
                eventHolder.mousemove(onMouseMove);
                eventHolder.mousedown(onMouseDown);
            }
        });


        plot.hooks.drawOverlay.push(function (plot, ctx) {
            // draw selection
            if (selection.show && selectionIsSane()) {
                var plotOffset = plot.getPlotOffset();
                var o = plot.getOptions();

                ctx.save();
                ctx.translate(plotOffset.left, plotOffset.top);

                var c = $.color.parse(o.selection.color);

                ctx.strokeStyle = c.scale('a', 0.8).toString();
                ctx.lineWidth = 1;
                ctx.lineJoin = "round";
                ctx.fillStyle = c.scale('a', 0.4).toString();

                var x = Math.min(selection.first.x, selection.second.x),
                    y = Math.min(selection.first.y, selection.second.y),
                    w = Math.abs(selection.second.x - selection.first.x),
                    h = Math.abs(selection.second.y - selection.first.y);

                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);

                ctx.restore();
            }
        });

        plot.hooks.shutdown.push(function (plot, eventHolder) {
            eventHolder.unbind("mousemove", onMouseMove);
            eventHolder.unbind("mousedown", onMouseDown);

            if (mouseUpHandler)
                $(document).unbind("mouseup", mouseUpHandler);
        });

    }

    $.plot.plugins.push({
        init: init,
        options: {
            selection: {
                mode: null, // one of null, "x", "y" or "xy"
                color: "#e8cfac"
            }
        },
        name: 'selection',
        version: '1.1'
    });
})(jQuery);

/*
 Flot plugin for stacking data sets, i.e. putting them on top of each
 other, for accumulative graphs.

 The plugin assumes the data is sorted on x (or y if stacking
 horizontally). For line charts, it is assumed that if a line has an
 undefined gap (from a null point), then the line above it should have
 the same gap - insert zeros instead of "null" if you want another
 behaviour. This also holds for the start and end of the chart. Note
 that stacking a mix of positive and negative values in most instances
 doesn't make sense (so it looks weird).

 Two or more series are stacked when their "stack" attribute is set to
 the same key (which can be any number or string or just "true"). To
 specify the default stack, you can set

 series: {
 stack: null or true or key (number/string)
 }

 or specify it for a specific series

 $.plot($("#placeholder"), [{ data: [ ... ], stack: true }])

 The stacking order is determined by the order of the data series in
 the array (later series end up on top of the previous).

 Internally, the plugin modifies the datapoints in each series, adding
 an offset to the y value. For line series, extra data points are
 inserted through interpolation. If there's a second y value, it's also
 adjusted (e.g for bar charts or filled areas).
 */

(function ($) {
    var options = {
        series: {stack: null} // or number/string
    };

    function init(plot) {
        function findMatchingSeries(s, allseries) {
            var res = null
            for (var i = 0; i < allseries.length; ++i) {
                if (s == allseries[i])
                    break;

                if (allseries[i].stack == s.stack)
                    res = allseries[i];
            }

            return res;
        }

        function stackData(plot, s, datapoints) {
            if (s.stack == null)
                return;

            var other = findMatchingSeries(s, plot.getData());
            if (!other)
                return;

            var ps = datapoints.pointsize,
                points = datapoints.points,
                otherps = other.datapoints.pointsize,
                otherpoints = other.datapoints.points,
                newpoints = [],
                px, py, intery, qx, qy, bottom,
                withlines = s.lines.show,
                horizontal = s.bars.horizontal,
                withbottom = ps > 2 && (horizontal ? datapoints.format[2].x : datapoints.format[2].y),
                withsteps = withlines && s.lines.steps,
                fromgap = true,
                keyOffset = horizontal ? 1 : 0,
                accumulateOffset = horizontal ? 0 : 1,
                i = 0, j = 0, l;

            while (true) {
                if (i >= points.length)
                    break;

                l = newpoints.length;

                if (points[i] == null) {
                    // copy gaps
                    for (m = 0; m < ps; ++m)
                        newpoints.push(points[i + m]);
                    i += ps;
                }
                else if (j >= otherpoints.length) {
                    // for lines, we can't use the rest of the points
                    if (!withlines) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);
                    }
                    i += ps;
                }
                else if (otherpoints[j] == null) {
                    // oops, got a gap
                    for (m = 0; m < ps; ++m)
                        newpoints.push(null);
                    fromgap = true;
                    j += otherps;
                }
                else {
                    // cases where we actually got two points
                    px = points[i + keyOffset];
                    py = points[i + accumulateOffset];
                    qx = otherpoints[j + keyOffset];
                    qy = otherpoints[j + accumulateOffset];
                    bottom = 0;

                    if (px == qx) {
                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        newpoints[l + accumulateOffset] += qy;
                        bottom = qy;

                        i += ps;
                        j += otherps;
                    }
                    else if (px > qx) {
                        // we got past point below, might need to
                        // insert interpolated extra point
                        if (withlines && i > 0 && points[i - ps] != null) {
                            intery = py + (points[i - ps + accumulateOffset] - py) * (qx - px) / (points[i - ps + keyOffset] - px);
                            newpoints.push(qx);
                            newpoints.push(intery + qy);
                            for (m = 2; m < ps; ++m)
                                newpoints.push(points[i + m]);
                            bottom = qy;
                        }

                        j += otherps;
                    }
                    else { // px < qx
                        if (fromgap && withlines) {
                            // if we come from a gap, we just skip this point
                            i += ps;
                            continue;
                        }

                        for (m = 0; m < ps; ++m)
                            newpoints.push(points[i + m]);

                        // we might be able to interpolate a point below,
                        // this can give us a better y
                        if (withlines && j > 0 && otherpoints[j - otherps] != null)
                            bottom = qy + (otherpoints[j - otherps + accumulateOffset] - qy) * (px - qx) / (otherpoints[j - otherps + keyOffset] - qx);

                        newpoints[l + accumulateOffset] += bottom;

                        i += ps;
                    }

                    fromgap = false;

                    if (l != newpoints.length && withbottom)
                        newpoints[l + 2] += bottom;
                }

                // maintain the line steps invariant
                if (withsteps && l != newpoints.length && l > 0
                    && newpoints[l] != null
                    && newpoints[l] != newpoints[l - ps]
                    && newpoints[l + 1] != newpoints[l - ps + 1]) {
                    for (m = 0; m < ps; ++m)
                        newpoints[l + ps + m] = newpoints[l + m];
                    newpoints[l + 1] = newpoints[l - ps + 1];
                }
            }

            datapoints.points = newpoints;
        }

        plot.hooks.processDatapoints.push(stackData);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stack',
        version: '1.2'
    });
})(jQuery);

/**
 This plugin is based on jQuery.flot.stack.js to provide support for stacked percentage
 Modified on it by skeleton9@github

 It can work with the tooltip plugin modified by skeleton9.

 You may need to set yaxis:{max:1000} to show proper yaxis

 find it on http://github.com/skeleton9/flot.stackpercent

 ------------------------------------------------------------------------------
 Flot plugin for stacking data sets, i.e. putting them on top of each
 other, for accumulative graphs. Note that the plugin assumes the data
 is sorted on x. Also note that stacking a mix of positive and negative
 values in most instances doesn't make sense (so it looks weird).

 Two or more series are stacked when their "stack" attribute is set to
 the same key (which can be any number or string or just "true"). To
 specify the default stack, you can set

 series: {
		stackpercent: null or true
	}

 or specify it for a specific series

 $.plot($("#placeholder"), [{ data: [ ... ], stackpercent: true ])

The stacking order is determined by the order of the data series in
the array (later series end up on top of the previous).

Internally, the plugin modifies the datapoints in each series, adding
an offset to the y value. For line series, extra data points are
inserted through interpolation. For bar charts, the second y value is
also adjusted.


Modified by skeleton9 2012-5-3 to support percentage stack

*/

(function ($) {
    var options = {
        series: {stackpercent: null} // or number/string
    };

    function init(plot) {

        // will be built up dynamically as a hash from x-value, or y-value if horizontal
        var stackBases = {};
        var processed = false;
        var stackSums = {};

        //set percentage for stacked chart
        function processRawData(plot, series, data, datapoints) {
            if (!processed) {
                processed = true;
                stackSums = getStackSums(plot.getData());
            }
            var num = data.length;
            series.percents = [];
            for (var j = 0; j < num; j++) {
                var sum = stackSums[data[j][0] + ""];
                if (sum > 0) {
                    series.percents.push(data[j][1] * 100 / sum);
                }
            }
        }

        //calculate summary
        function getStackSums(_data) {
            var data_len = _data.length;
            var sums = {};
            if (data_len > 0) {
                //caculate summary
                for (var i = 0; i < data_len; i++) {
                    var num = _data[i].data.length;
                    for (var j = 0; j < num; j++) {
                        var value = 0;
                        if (_data[i].data[j][1] != null) {
                            value = _data[i].data[j][1];
                        }
                        if (sums[_data[i].data[j][0] + ""]) {
                            sums[_data[i].data[j][0] + ""] += value;
                        }
                        else {
                            sums[_data[i].data[j][0] + ""] = value;
                        }

                    }
                }
            }
            return sums;
        }

        function stackData(plot, s, datapoints) {
            if (!s.stackpercent)
                return;
            if (!processed) {
                stackSums = getStackSums(plot.getData());
            }
            var newPoints = [];


            for (var i = 0; i < datapoints.points.length; i += 3) {
                // note that the values need to be turned into absolute y-values.
                // in other words, if you were to stack (x, y1), (x, y2), and (x, y3),
                // (each from different series, which is where stackBases comes in),
                // you'd want the new points to be (x, y1, 0), (x, y1+y2, y1), (x, y1+y2+y3, y1+y2)
                // generally, (x, thisValue + (base up to this point), + (base up to this point))
                if (!stackBases[datapoints.points[i]]) {
                    stackBases[datapoints.points[i]] = 0;
                }
                newPoints[i] = datapoints.points[i];
                newPoints[i + 1] = datapoints.points[i + 1] + stackBases[datapoints.points[i]];
                newPoints[i + 2] = stackBases[datapoints.points[i]];
                stackBases[datapoints.points[i]] += datapoints.points[i + 1];
                // change points to percentage values
                // you may need to set yaxis:{ max = 100 }
                newPoints[i + 1] = newPoints[i + 1] * 100 / stackSums[newPoints[i] + ""];
                newPoints[i + 2] = newPoints[i + 2] * 100 / stackSums[newPoints[i] + ""];
            }

            datapoints.points = newPoints;
        }

        plot.hooks.processDatapoints.push(stackData);
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'stackpercent',
        version: '0.1'
    });
})(jQuery);

/*
 Pretty handling of time axes.

 Set axis.mode to "time" to enable. See the section "Time series data" in API.txt
 for details.
 */
(function ($) {
    var options = {};

    // round to nearby lower multiple of base
    function floorInBase(n, base) {
        return base * Math.floor(n / base);
    }

    // Returns a string with the date d formatted according to fmt.
    // A subset of the Open Group's strftime format is supported.
    function formatDate(d, fmt, monthNames, dayNames) {
        if (typeof d.strftime == "function") {
            return d.strftime(fmt);
        }
        var leftPad = function (n, pad) {
            n = "" + n;
            pad = "" + (pad == null ? "0" : pad);
            return n.length == 1 ? pad + n : n;
        };

        var r = [];
        var escape = false;
        var hours = d.getHours();
        var isAM = hours < 12;
        if (monthNames == null)
            monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        if (dayNames == null)
            dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        var hours12;
        if (hours > 12) {
            hours12 = hours - 12;
        } else if (hours == 0) {
            hours12 = 12;
        } else {
            hours12 = hours;
        }

        for (var i = 0; i < fmt.length; ++i) {
            var c = fmt.charAt(i);

            if (escape) {
                switch (c) {
                    case 'a':
                        c = "" + dayNames[d.getDay()];
                        break;
                    case 'b':
                        c = "" + monthNames[d.getMonth()];
                        break;
                    case 'd':
                        c = leftPad(d.getDate());
                        break;
                    case 'e':
                        c = leftPad(d.getDate(), " ");
                        break;
                    case 'H':
                        c = leftPad(hours);
                        break;
                    case 'I':
                        c = leftPad(hours12);
                        break;
                    case 'l':
                        c = leftPad(hours12, " ");
                        break;
                    case 'm':
                        c = leftPad(d.getMonth() + 1);
                        break;
                    case 'M':
                        c = leftPad(d.getMinutes());
                        break;
                    case 'S':
                        c = leftPad(d.getSeconds());
                        break;
                    case 'y':
                        c = leftPad(d.getFullYear() % 100);
                        break;
                    case 'Y':
                        c = "" + d.getFullYear();
                        break;
                    case 'p':
                        c = (isAM) ? ("" + "am") : ("" + "pm");
                        break;
                    case 'P':
                        c = (isAM) ? ("" + "AM") : ("" + "PM");
                        break;
                    case 'w':
                        c = "" + d.getDay();
                        break;
                }
                r.push(c);
                escape = false;
            }
            else {
                if (c == "%")
                    escape = true;
                else
                    r.push(c);
            }
        }
        return r.join("");
    }

    // To have a consistent view of time-based data independent of which time
    // zone the client happens to be in we need a date-like object independent
    // of time zones.  This is done through a wrapper that only calls the UTC
    // versions of the accessor methods.
    function makeUtcWrapper(d) {
        function addProxyMethod(sourceObj, sourceMethod, targetObj,
                                targetMethod) {
            sourceObj[sourceMethod] = function () {
                return targetObj[targetMethod].apply(targetObj, arguments);
            };
        };
        var utc = {
            date: d
        };
        // support strftime, if found
        if (d.strftime != undefined)
            addProxyMethod(utc, "strftime", d, "strftime");
        addProxyMethod(utc, "getTime", d, "getTime");
        addProxyMethod(utc, "setTime", d, "setTime");
        var props = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];
        for (var p = 0; p < props.length; p++) {
            addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
            addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p]);
        }
        return utc;
    };

    // select time zone strategy.  This returns a date-like object tied to the
    // desired timezone
    function dateGenerator(ts, opts) {
        if (opts.timezone == "browser") {
            return new Date(ts);
        } else if (!opts.timezone || opts.timezone == "utc") {
            return makeUtcWrapper(new Date(ts));
        } else if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
            var d = new timezoneJS.Date();
            // timezone-js is fickle, so be sure to set the time zone before
            // setting the time.
            d.setTimezone(opts.timezone);
            d.setTime(ts);
            return d;
        } else {
            return makeUtcWrapper(new Date(ts));
        }
    }

    // map of app. size of time units in milliseconds
    var timeUnitSize = {
        "second": 1000,
        "minute": 60 * 1000,
        "hour": 60 * 60 * 1000,
        "day": 24 * 60 * 60 * 1000,
        "month": 30 * 24 * 60 * 60 * 1000,
        "year": 365.2425 * 24 * 60 * 60 * 1000
    };

    // the allowed tick sizes, after 1 year we use
    // an integer algorithm
    var spec = [
        [1, "second"], [2, "second"], [5, "second"], [10, "second"],
        [30, "second"],
        [1, "minute"], [2, "minute"], [5, "minute"], [10, "minute"],
        [30, "minute"],
        [1, "hour"], [2, "hour"], [4, "hour"],
        [8, "hour"], [12, "hour"],
        [1, "day"], [2, "day"], [3, "day"],
        [0.25, "month"], [0.5, "month"], [1, "month"],
        [2, "month"], [3, "month"], [6, "month"],
        [1, "year"]
    ];

    function init(plot) {
        plot.hooks.processDatapoints.push(function (plot, series, datapoints) {
            $.each(plot.getAxes(), function (axisName, axis) {
                var opts = axis.options;
                if (opts.mode == "time") {
                    axis.tickGenerator = function (axis) {
                        var ticks = [],
                            d = dateGenerator(axis.min, opts),
                            minSize = 0;

                        if (opts.minTickSize != null) {
                            if (typeof opts.tickSize == "number")
                                minSize = opts.tickSize;
                            else
                                minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];
                        }

                        for (var i = 0; i < spec.length - 1; ++i)
                            if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]
                                + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2
                                && spec[i][0] * timeUnitSize[spec[i][1]] >= minSize)
                                break;
                        var size = spec[i][0];
                        var unit = spec[i][1];

                        // special-case the possibility of several years
                        if (unit == "year") {
                            // if given a minTickSize in years, just use it,
                            // ensuring that it's an integer
                            if (opts.minTickSize != null && opts.minTickSize[1] == "year") {
                                size = Math.floor(opts.minTickSize[0]);
                            } else {
                                var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));
                                var norm = (axis.delta / timeUnitSize.year) / magn;
                                if (norm < 1.5)
                                    size = 1;
                                else if (norm < 3)
                                    size = 2;
                                else if (norm < 7.5)
                                    size = 5;
                                else
                                    size = 10;

                                size *= magn;
                            }

                            // minimum size for years is 1
                            if (size < 1)
                                size = 1;
                        }

                        axis.tickSize = opts.tickSize || [size, unit];
                        var tickSize = axis.tickSize[0];
                        unit = axis.tickSize[1];

                        var step = tickSize * timeUnitSize[unit];

                        if (unit == "second")
                            d.setSeconds(floorInBase(d.getSeconds(), tickSize));
                        if (unit == "minute")
                            d.setMinutes(floorInBase(d.getMinutes(), tickSize));
                        if (unit == "hour")
                            d.setHours(floorInBase(d.getHours(), tickSize));
                        if (unit == "month")
                            d.setMonth(floorInBase(d.getMonth(), tickSize));
                        if (unit == "year")
                            d.setFullYear(floorInBase(d.getFullYear(), tickSize));

                        // reset smaller components
                        d.setMilliseconds(0);
                        if (step >= timeUnitSize.minute)
                            d.setSeconds(0);
                        if (step >= timeUnitSize.hour)
                            d.setMinutes(0);
                        if (step >= timeUnitSize.day)
                            d.setHours(0);
                        if (step >= timeUnitSize.day * 4)
                            d.setDate(1);
                        if (step >= timeUnitSize.year)
                            d.setMonth(0);


                        var carry = 0, v = Number.NaN, prev;
                        do {
                            prev = v;
                            v = d.getTime();
                            ticks.push(v);
                            if (unit == "month") {
                                if (tickSize < 1) {
                                    // a bit complicated - we'll divide the month
                                    // up but we need to take care of fractions
                                    // so we don't end up in the middle of a day
                                    d.setDate(1);
                                    var start = d.getTime();
                                    d.setMonth(d.getMonth() + 1);
                                    var end = d.getTime();
                                    d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);
                                    carry = d.getHours();
                                    d.setHours(0);
                                }
                                else
                                    d.setMonth(d.getMonth() + tickSize);
                            }
                            else if (unit == "year") {
                                d.setFullYear(d.getFullYear() + tickSize);
                            }
                            else
                                d.setTime(v + step);
                        } while (v < axis.max && v != prev);

                        return ticks;
                    };

                    axis.tickFormatter = function (v, axis) {
                        var d = dateGenerator(v, axis.options);

                        // first check global format
                        if (opts.timeformat != null)
                            return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);

                        var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];
                        var span = axis.max - axis.min;
                        var suffix = (opts.twelveHourClock) ? " %p" : "";
                        var hourCode = (opts.twelveHourClock) ? "%I" : "%H";

                        if (t < timeUnitSize.minute)
                            fmt = hourCode + ":%M:%S" + suffix;
                        else if (t < timeUnitSize.day) {
                            if (span < 2 * timeUnitSize.day)
                                fmt = hourCode + ":%M" + suffix;
                            else
                                fmt = "%b %d " + hourCode + ":%M" + suffix;
                        }
                        else if (t < timeUnitSize.month)
                            fmt = "%b %d";
                        else if (t < timeUnitSize.year) {
                            if (span < timeUnitSize.year)
                                fmt = "%b";
                            else
                                fmt = "%b %Y";
                        }
                        else
                            fmt = "%Y";

                        var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);
                        return rt;
                    };
                }
            });
        });
    }

    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'time',
        version: '1.0'
    });
})(jQuery);

var gbks = gbks || {};
gbks.common = gbks.common || {};

gbks.common.scroller = gbks.common.scroller || {};
gbks.common.scroller.scrollToPosition = function (position) {
    gbks.common.scroller.scrollInfo = {
        startTime: new Date().getTime(),
        startValue: window.pageYOffset,
        endValue: position,
        duration: 1500,
        lastUpdate: new Date().getTime()
    }

    $(window).unbind('mousewheel', gbks.common.scroller.mousewheelFunction);
    $(window).bind('mousewheel', gbks.common.scroller.mousewheelFunction);

    clearTimeout(gbks.common.scroller.scrollInterval);
    gbks.common.scroller.scrollInterval = setTimeout($.proxy(gbks.common.scroller.onScrollInterval, gbks.common.scroller), 25);
};

gbks.common.scroller.onScrollInterval = function (event) {
    var info = gbks.common.scroller.scrollInfo;
    var delta = new Date().getTime() - info.startTime;
    delta = Math.min(delta, info.duration);
    var pos = gbks.common.scroller.easeInOutCubic(null, delta, info.startValue, info.endValue - info.startValue, info.duration);

    window.scrollTo(0, pos);

    if (Math.abs(delta) < info.duration) {
        var timePassed = new Date().getTime() - info.lastUpdate;
        var timer = Math.max(5, 25 - timePassed);

        clearTimeout(gbks.common.scroller.scrollInterval);
        gbks.common.scroller.scrollInterval = setTimeout($.proxy(gbks.common.scroller.onScrollInterval, gbks.common.scroller), timer);
    }
    else {
        $(window).unbind('mousewheel', gbks.common.scroller.mousewheelFunction);
    }

    info.lastUpdate = new Date().getTime();
};
gbks.common.scroller.onMouseWheel = function (event) {
    $(window).unbind('mousewheel', gbks.common.scroller.mousewheelFunction);
    clearInterval(gbks.common.scroller.scrollInterval);
};
gbks.common.scroller.easeInOutCubic = function (x, t, b, c, d) {
    if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
    return c / 2 * ((t -= 2) * t * t + 2) + b;
};
gbks.common.scroller.mousewheelFunction = $.proxy(gbks.common.scroller.onMouseWheel, gbks.common.scroller);


(function ($, window, document, undefined) {

    // REMOVE CSS FROM ELEMENT
    // ------------------------------------------------------------------------------------------------ * --> 
    $.fn.extend({
        removeCss: function (cssName) {
            return this.each(function () {
                var curDom = $(this);
                jQuery.grep(cssName.split(","),

                    function (cssToBeRemoved) {
                        curDom.css(cssToBeRemoved, '');
                    });
                return curDom;
            });
        }
    });

    // SIDEBAR RESIZE - CONVERT NAV
    // ------------------------------------------------------------------------------------------------ * --> 
    $(window).resize(function () {
        if ($(window).width() < 767) {
            $('.sidebar').addClass('collapse')
            $('.sidebar, .footer-sidebar').removeCss('display');
        }
        if ($(window).width() > 767) {
            $('.sidebar').removeClass('collapse');
            $('.sidebar').removeCss('height');

            if (!$('body').hasClass('sidebar-hidden')) {
                $('.sidebar, .footer-sidebar').css({
                    'display': 'block'
                });
            } else {
                $('.sidebar, .footer-sidebar').css({
                    'display': 'none'
                });
            }
        }
    });
    $(function () {
        if ($(window).width() < 767) {
            $('.sidebar').addClass('collapse');
        }
        if ($(window).width() > 767) {
            $('.sidebar').removeClass('collapse');
            $('.sidebar').removeCss('height');
        }
    });

    // SIDEBAR - SHOW OR HIDDEN
    // ------------------------------------------------------------------------------------------------ * -->        
    function showSidebar() {
        $('body').removeClass('sidebar-hidden');
        $.cookie('sidebar-pref', null, {
            expires: 30
        });
    };

    function hideSidebar() {
        $('body').addClass('sidebar-hidden');
        $.cookie('sidebar-pref', 'sidebar-hidden', {
            expires: 30
        });
    };

    $("#btnToggleSidebar").click(function () {
        $(this).toggleClass('fontello-icon-resize-full-2 fontello-icon-resize-small-2');
        $(this).toggleClass('active');
        $('#main-sidebar, #footer-sidebar').animate({
            width: 'toggle'
        }, 0);
        //$('body').toggleClass('sidebar-display sidebar-hidden');
        if ($('body').hasClass('sidebar-hidden')) {
            showSidebar();
        } else {
            hideSidebar();
        }
    });

    // auto-load preference
    $('body').addClass($.cookie('sidebar-pref'));

    // SIDEBAR - CHANGE SIDEBAR
    // ------------------------------------------------------------------------------------------------ * -->
    $("#btnChangeSidebar").click(function () {
        $(this).toggleClass('fontello-icon-login fontello-icon-logout');
        $('body').toggleClass('sidebar-left sidebar-right');
        $('#mainSideMenu .chevron').toggleClass('fontello-icon-right-open-3 fontello-icon-left-open-3');
        $(this).toggleClass('active');
    });

    // SIDEBAR - CHANGE SIDEBAR COLOR
    // ------------------------------------------------------------------------------------------------ * -->
    $("#btnChangeSidebarColor").click(function () {
        $('#main-sidebar').toggleClass('sidebar-inverse');
    });

    // SCROLL - NICESCROLL
    // ------------------------------------------------------------------------------------------------ * -->
    // The document page (body)
    /*$("html").niceScroll({
     cursoropacitymin:0.1,
     cursoropacitymax:0.9,
     cursorcolor:"#adafb5",
     cursorwidth:"8px",
     cursorborder:"",
     cursorminheight:100,
     cursorborderradius:"8px",
     usetransition:600,
     background:"",
     railoffset:{top:10,left:-3},
     bouncescroll: true	
     }); */

    $("#main-sidebar").niceScroll({
        cursoropacitymin: 0.1,
        cursoropacitymax: 0.4,
        cursorcolor: "#adafb5",
        cursorwidth: "6px",
        cursorborder: "",
        cursorborderradius: "6px",
        usetransition: 600,
        background: "",
        railoffset: {top: 10, left: -1},
        bouncescroll: true
    });

    $(".scrollBox").niceScroll({
        cursoropacitymin: 0.1,
        cursoropacitymax: 0.4,
        cursorcolor: "#adafb5",
        cursorwidth: "6px",
        cursorborder: "",
        cursorborderradius: "6px",
        usetransition: 600,
        background: "",
        railoffset: {top: 10, left: -1},
        bouncescroll: true
    });

    // SCROLL TOP PAGE
    // ------------------------------------------------------------------------------------------------ * -->
    $(window).scroll(function () {
        if ($(this).scrollTop() > 100) {
            $('#btnScrollup').fadeIn('slow');
        } else {
            $('#btnScrollup').fadeOut(600);
        }
    });

    $('#btnScrollup').click(function () {
        $("html, body").animate({
            scrollTop: 0
        }, 500);
        return false;
    });

})(jQuery, this, document);

(function ($, window, document, undefined) {

    // MAKE CODE PRETTY
    // ------------------------------------------------------------------------------------------------ * -->
    var $window = $(window)
    window.prettyPrint && prettyPrint();

    // CHANGE wrapper to table - ONLY DEMO
    // ------------------------------------------------------------------------------------------------ * -->
    $("#btnChangeWrapper1, #btnChangeWrapper2").click(function () {
        $('.widget').toggleClass('widget-simple widget-box');
    });

    // COLLAPSE - WIDGET HEADER
    // ------------------------------------------------------------------------------------------------ * -->
    // Collapsible widget	
    $('.widget-content.collapse')
        .on('shown', function (e) {
            $(e.target)
                .parent('.widget-collapsible')
                .children('.widget-header')
                .removeClass('collapsed');
            $(e.target)
                .prev('.widget-header')
                .find('.widget-toggle')
                .toggleClass('fontello-icon-publish fontello-icon-window');
        });

    $('.widget-content.collapse')
        .on('hidden', function (e) {
            $(e.target)
                .parent('.widget-collapsible')
                .children('.widget-header')
                .addClass('collapsed');
            $(e.target)
                .prev('.widget-header')
                .find('.widget-toggle')
                .toggleClass('fontello-icon-window fontello-icon-publish');
        });

    // BREADCRUMBS
    // ------------------------------------------------------------------------------------------------ * -->
    $('#breadcrumbs').xBreadcrumbs();

    // FORM - BOOTSTRAP SELECTPICKER
    // ------------------------------------------------------------------------------------------------ * -->
    $(function () {
        $('.selectpicker').selectpicker();
    });

    // FORM - SELECT 2
    // ------------------------------------------------------------------------------------------------ * -->
    // select2 demo
    $(".selecttwo").select2({
        minimumResultsForSearch: 6,
        width: "off"
    });
    $(".selecttwo-s").select2();

    $(".selecttwo-full").select2({
        minimumResultsForSearch: 6,
        width: "100%"
    });

    $(".selecttwo-full-s").select2({
        width: "100%"
    });

    // selec2 tagging support demo	
    $("#customerTag").select2({
        tags: [{
            'id': 1,
            'text': 'Customer'
        }, {
            'id': 16,
            'text': 'Managing'
        }, {
            'id': 23,
            'text': 'Marketing'
        }, {
            'id': 7,
            'text': 'Support24'
        }, {
            'id': 12,
            'text': 'Supplier'
        }],
        tokenSeparators: [",", " "]
    })
        .select2("val", [1, 7])
        .on('change', function (event) {
            console.log(event.val.toString());
        });

    // selec2 tagging support demo	
    $("#articleTags, #metaArticleKeywords").select2({
        tags: [{
            'id': 1,
            'text': 'Design'
        }, {
            'id': 16,
            'text': 'Css'
        }, {
            'id': 23,
            'text': 'Bootstrap'
        }, {
            'id': 7,
            'text': 'Framework'
        }],
        tokenSeparators: [",", " "]
    });

    var accountGroupData = [{
        id: "wholesaler",
        text: "Wholesaler"
    }, {
        id: "retailer",
        text: "Retailer"
    }, {
        id: "suppliers",
        text: "Suppliers"
    }, {
        id: "manager",
        text: "Manager"
    }, {
        id: "wholesalecustomer",
        text: "Wholesale Customer"
    }, {
        id: "powers",
        text: "Powers"
    }]
    $("#accountGroup").select2({
        tags: accountGroupData,
        createSearchChoice: function (term, data) {
            if ($(data).filter(function () {
                    return this.text.localeCompare(term) === 0;
                }).length === 0) {
                return {
                    id: term,
                    text: term
                };
            }
        },
        width: "100%",
        multiple: true,
        placeholder: "Choose or enter group for account...",
        tokenSeparators: [",", " "]
    });

    // selec2 tagging support demo
    $("#taskTags, #taskTagsModal").select2({
        tags: ["one", "two", "three"],
        placeholder: "Select or Enter tag"
    });

    // FORM - UNIFORM PLUGIN 
    // ------------------------------------------------------------------------------------------------ * -->
    $("input.checkbox, input.radio, input:file.input-file").uniform({
        radioClass: 'radios' // edited class - the original radio
    });

    // FORM - INPUTMASK PLUGIN
    // ------------------------------------------------------------------------------------------------ * -->
    $("input.maskDate").inputmask("99/99/9999", {
        placeholder: "dd/mm/yyyy"
    });
    $("input.maskPhone").inputmask("(999) 999-9999", {
        completed: function () {
            alert("Callback when completed");
        }
    });
    $("input.maskPhoneExt").inputmask("(999) 999-9999? x99999");
    $("input.maskPhoneInt").inputmask("+43 999 999 999");
    $("input.maskZipcode").inputmask("99999");
    $("input.maskTid").inputmask("99-9999999");
    $("input.maskSsn").inputmask("999-99-9999");
    $("input.maskProd").inputmask("a*-999-a999-a999");
    $("input.maskEye").inputmask("~9.99 ~9.99 999");
    $("input.maskPo").inputmask("MM: aaa-999-*****-9999");
    $("input.maskPct").inputmask("99%");
    $("input.maskAcid").inputmask("FP009-99999-2012");

    // FORM - ELASTIC TEXTAREA
    // ------------------------------------------------------------------------------------------------ * -->
    $('textarea.auto').elastic();
    $('textarea.auto').trigger('update');

    // BOOTSTRAP DATEPICKER
    // ------------------------------------------------------------------------------------------------ * -->
    $('.datepickers').datepicker();
    $('#articleCreated, #articleCreatedDate, #articlePublishingStart, #articlePublishingFinish, #datePickerVia').datepicker();

    // bootstrap datepicker demo
    $('#datePicker').datepicker({
        format: 'mm-dd-yyyy'
    });

    // bootstrap datepicker demo
    $('#DPV').click(function (e) {
        e.stopPropagation();
        $('#datePickerVia').datepicker('update', '10/10/12');
    });

    // bootstrap datepicker demo
    $('#datePickerComponent').datepicker();

    var startDate = new Date(2012, 1, 20);
    var endDate = new Date(2012, 1, 25);
    $('#DTP1').datepicker()
        .on('changeDate', function (ev) {
            if (ev.date.valueOf() > endDate.valueOf()) {
                $('#alert').show().find('.msg').text('The start date can not be greater then the end date');
            } else {
                $('#alert').hide();
                startDate = new Date(ev.date);
                $('#startDate').text($('#DTP1').data('date'));
            }
            $('#DTP1').datepicker('hide');
        });

    // bootstrap datepicker demo
    $('#DTP2').datepicker()
        .on('changeDate', function (ev) {
            if (ev.date.valueOf() < startDate.valueOf()) {
                $('#alert').show().find('.msg').text('The end date can not be less then the start date');
            } else {
                $('#alert').hide();
                endDate = new Date(ev.date);
                $('#endDate').text($('#DTP2').data('date'));
            }
            $('#DTP2').datepicker('hide');
        });

    // bootstrap datepicker demo
    $('#datePickerToDiv').datepicker()
        .on('changeDate', function (ev) {
            showDate = new Date(ev.date);
            $('#showDate').text($('#datePickerToDiv').data('date'));
        });

    // bootstrap datepicker demo
    $('#DPTD').click(function () {
        $('#datePickerToDiv').datepicker('update', '01-09-1969');
        $('#showDate').text($('#datePickerToDiv').data('date'));
    });

    // BOOTSTRAP DATERANGEPICKER
    // ------------------------------------------------------------------------------------------------ * -->

    $('.datepicker-range').daterangepicker();

    // bootstrap daterangepicker direction the dropdown expands
    $('#accountForce').daterangepicker({
        opens: 'left'
    });
    /*
     // bootstrap daterangepicker demo
     $('#articlePostFromTo').daterangepicker({
     opens: 'right'
     });*/

    // bootstrap daterangepicker pre-defined Ranges
    $('#customRange').daterangepicker({
        opens: 'left',
        format: 'dd/MM/yyyy',
        ranges: {
            'Today': ['today', 'today'],
            'Yesterday': ['yesterday', 'yesterday'],
            'Last 7 Days': [Date.today().add({
                days: -6
            }), 'today'],
            'Last 30 Days': [Date.today().add({
                days: -29
            }), 'today'],
            'This Month': [Date.today().moveToFirstDayOfMonth(), Date.today().moveToLastDayOfMonth()],
            'Last Month': [Date.today().moveToFirstDayOfMonth().add({
                months: -1
            }), Date.today().moveToFirstDayOfMonth().add({
                days: -1
            })]
        }

    });

    // bootstrap daterangepicker demo
    $('#selectrange').daterangepicker();

    // bootstrap daterangepicker demo
    $('#reportdate').daterangepicker({
            ranges: {
                'Today': ['today', 'today'],
                'Yesterday': ['yesterday', 'yesterday'],
                'Last 7 Days': [Date.today().add({
                    days: -6
                }), 'today'],
                'Last 30 Days': [Date.today().add({
                    days: -29
                }), 'today'],
                'This Month': [Date.today().moveToFirstDayOfMonth(), Date.today().moveToLastDayOfMonth()],
                'Last Month': [Date.today().moveToFirstDayOfMonth().add({
                    months: -1
                }), Date.today().moveToFirstDayOfMonth().add({
                    days: -1
                })]
            }
        },

        function (start, end) {
            $('#reportdate span').html(start.toString('MMMM d, yyyy') + ' - ' + end.toString('MMMM d, yyyy'));
        });

    // bootstrap daterangepicker demo
    $('#reportSelect').daterangepicker({
            changed: true,
            opens: 'left',
            ranges: {
                'Today': ['today', 'today'],
                'Yesterday': ['yesterday', 'yesterday'],
                'Last 7 Days': [Date.today().add({
                    days: -6
                }), 'today'],
                'Last 30 Days': [Date.today().add({
                    days: -29
                }), 'today'],
                'This Month': [Date.today().moveToFirstDayOfMonth(), Date.today().moveToLastDayOfMonth()],
                'Last Month': [Date.today().moveToFirstDayOfMonth().add({
                    months: -1
                }), Date.today().moveToFirstDayOfMonth().add({
                    days: -1
                })]
            }
        },

        function (start, end) {
            $('#reportView').val(start.toString('dd-MM-yyyy') + ' - ' + end.toString('dd-MM-yyyy'));
        });

    // BOOTSTRAP TIMEPICKER
    // ------------------------------------------------------------------------------------------------ * -->
    $('.timepicker').timepicker({
        minuteStep: 5,
        showInputs: false,
    });


    $.configureBoxes();
    $.configureBoxes({
        box1View: 'box3View',
        box1Storage: 'box3Storage',
        box1Filter: 'box3Filter',
        box1Clear: 'box3Clear',
        box1Counter: 'box3Counter',
        box2View: 'box4View',
        box2Storage: 'box4Storage',
        box2Filter: 'box4Filter',
        box2Clear: 'box4Clear',
        box2Counter: 'box4Counter',
        to1: 'to3',
        to2: 'to4',
        allTo1: 'allTo3',
        allTo2: 'allTo4',
        selectOnSubmit: false
    });
    $.configureBoxes({
        box1View: 'box5View',
        box1Storage: 'box5Storage',
        box1Filter: 'box5Filter',
        box1Clear: 'box5Clear',
        box1Counter: 'box5Counter',
        box2View: 'box6View',
        box2Storage: 'box6Storage',
        box2Filter: 'box6Filter',
        box2Clear: 'box6Clear',
        box2Counter: 'box6Counter',
        to1: 'to5',
        to2: 'to6',
        allTo1: 'allTo5',
        allTo2: 'allTo6',
        selectOnSubmit: false
    });
    /**/


    // BOOTSTRAP COLORPICKER
    // ------------------------------------------------------------------------------------------------ * -->
    $(function () {
        $('.colorpicker').colorpicker();

        $('.cpHEX').colorpicker({
            format: 'hex'
        });

        $('#cpComponent').colorpicker();

        /*var divStyle = $('#colored')[0].style;
         $('#cpCHANGE').colorpicker().on('changeColor', function (ev) {
         divStyle.backgroundColor = ev.color.toHex();
         });*/
    });


    // BOOTSTRAP BUTTON TOGGLE CHANGE COLOR ON ACTIVE
    // ------------------------------------------------------------------------------------------------ * -->
    $('.btn-group > .btn, .btn[data-toggle="button"]').click(function () {

        if ($(this).attr('class-toggle') != undefined && !$(this).hasClass('disabled')) {
            var btnGroup = $(this).parent('.btn-group');

            if (btnGroup.attr('data-toggle') == 'buttons-radio') {
                btnGroup.find('.btn').each(function () {
                    $(this).removeClass($(this).attr('class-toggle'));
                });
                $(this).addClass($(this).attr('class-toggle'));
            }

            if (btnGroup.attr('data-toggle') == 'buttons-checkbox' || $(this).attr('data-toggle') == 'button') {
                if ($(this).hasClass('active')) {
                    $(this).removeClass($(this).attr('class-toggle'));
                } else {
                    $(this).addClass($(this).attr('class-toggle'));
                }
            }
        }
    });

    // FORM - LIMITER
    // ------------------------------------------------------------------------------------------------ * -->		
    $(".limiteChar15").counter({
        goal: 15
    });
    $(".limiteChar140").counter({
        goal: 140
    });
    $(".limiteWords15").counter({
        goal: 15,
        type: 'word',
        msg: 'words left before you fall into a pit of emptiness.'
    });
    $(".countingChar").counter({
        goal: 'sky',
        msg: 'have written'
    });

    // FORM - CLEAR FIELD
    // ------------------------------------------------------------------------------------------------ * -->
    $.fn.clearicon = function (options) {
        // default settings
        var config = {
            "in": 'fadeIn',
            "out": 'fadeOut',
            "speed": 'fast',
            "css": {
                "right": "-3px",
                "top": "-6px"
            },
            "html": '<i class="fontello-icon-cancel-circle f14 opaci45"></i>',
            "click": function () {
                // general purposes functionality for clearing a field element
                $(this).val('').removeAttr('checked').removeAttr('selected').keyup();
            }
        };
        if (options) $.extend(config, options);
        // do the magic
        $(this).each(function () {
            // the current element
            var self = $(this);
            var ctr = $('<span style="position: relative; width:auto; overflow: hidden;" class="clear-icon-wrap"/>');
            $(this).wrap(ctr);
            var btn = $('<a style="position: absolute;" class="btn btn-glyph btn-link clear-icon-btn" href="javascript:;"/>');
            btn.css(config.css).html(config.html);
            self.after(btn);
            // handle clicking of button
            if (config.click) btn.click(function () {
                config.click.apply(self);
            });
            // handle value changes of input
            self.keyup(function () {
                if (self.val().length > 0) {
                    btn[config['in']](config.speed);
                } else {
                    btn[config['out']](config.speed);
                }
            });
            // trigger initial state
            self.keyup();
        });
        return this;
    };

    $('.clear-field').clearicon();
    $('.clear-textarea').clearicon({
        'css': {
            'right': '-3px',
            'top': '0'
        },
    });

    // BOOTSTRAP TOOLTIP
    // ------------------------------------------------------------------------------------------------ * -->
    $("a[rel=tooltip], input[rel=tooltip] ").tooltip()

    $('.Ttip').tooltip({
        placement: 'top'
    });
    $('.Rtip').tooltip({
        placement: 'right'
    });
    $('.Btip').tooltip({
        placement: 'bottom'
    });
    $('.Ltip').tooltip({
        placement: 'left'
    });

    // GTIP - TOOLTIP
    // ------------------------------------------------------------------------------------------------ * -->
    var shared = {
        position: {
            viewport: $(window)
        },
        style: {
            tip: true,
            classes: 'ui-tooltip-shadow ui-tooltip-tipsy'
        }
    };

    $('.tip-tl').qtip($.extend({}, shared, {
        position: {
            my: 'bottom right',
            at: 'top left'
        }
    }));
    $('.tip-tc, .tip').qtip($.extend({}, shared, {
        position: {
            my: 'bottom center',
            at: 'top center'
        }
    }));
    $('.tip-tr').qtip($.extend({}, shared, {
        position: {
            my: 'bottom left',
            at: 'top right'
        }
    }));
    $('.tip-bl').qtip($.extend({}, shared, {
        position: {
            my: 'top right',
            at: 'bottom left'
        }
    }));
    $('.tip-bc').qtip($.extend({}, shared, {
        position: {
            my: 'top center',
            at: 'bottom center'
        }
    }));
    $('.tip-br').qtip($.extend({}, shared, {
        position: {
            my: 'top left',
            at: 'bottom right'
        }
    }));
    $('.tip-rt').qtip($.extend({}, shared, {
        position: {
            my: 'left bottom',
            at: 'right top'
        }
    }));
    $('.tip-rc').qtip($.extend({}, shared, {
        position: {
            my: 'left center',
            at: 'right center'
        }
    }));
    $('.tip-rb').qtip($.extend({}, shared, {
        position: {
            my: 'left top',
            at: 'right bottom'
        }
    }));
    $('.tip-lt').qtip($.extend({}, shared, {
        position: {
            my: 'right bottom',
            at: 'left top'
        }
    }));
    $('.tip-lc').qtip($.extend({}, shared, {
        position: {
            my: 'right center',
            at: 'left center'
        }
    }));
    $('.tip-lb').qtip($.extend({}, shared, {
        position: {
            my: 'right top',
            at: 'left bottom'
        }
    }));

    // BOOTSTRAP POPOVER
    // ------------------------------------------------------------------------------------------------ * -->
    // popover demo
    $('.popover').popover()
    $("[rel=popover]")
        .popover({
            html: true
        });

    // popover hover
    $("[rel=popover-hover]")
        .popover({
            html: true,
            trigger: 'hover',
            delay: {
                hide: 500
            }
        });

    // Popover hide click to element
    $('[rel=popover-click]')
        .popover({
            html: true,
            delay: {
                show: 100,
                hide: 300
            }
        })
        .click(function (e) {
            $(this).popover('toggle');
            e.stopPropagation();
        });

    // SPARKLINE 
    // ------------------------------------------------------------------------------------------------ * -->
    // Change class for tooltip 
    $.fn.sparkline.defaults.common.tooltipClassname = 'sparktip';


    // Bootstrap Hack for button radio to hidden input 
    // ------------------------------------------------------------------------------------------------ * -->
    var _old_toggle = $.fn.button.prototype.constructor.Constructor.prototype.toggle;
    $.fn.button.prototype.constructor.Constructor.prototype.toggle = function () {
        _old_toggle.apply(this);
        var $parent = this.$element.parent('[data-toggle="buttons-radio"]')
        var target = $parent ? $parent.data('target') : undefined;
        var value = this.$element.attr('value');
        if (target && value) {
            $('#' + target).val(value);
        }
    };

})(jQuery, this, document);

if (!AmCharts)var AmCharts = {};
AmCharts.inheriting = {};
AmCharts.Class = function (a) {
    var b = function () {
        arguments[0] !== AmCharts.inheriting && (this.events = {}, this.construct.apply(this, arguments))
    };
    a.inherits ? (b.prototype = new a.inherits(AmCharts.inheriting), b.base = a.inherits.prototype, delete a.inherits) : (b.prototype.createEvents = function () {
        for (var a = 0, b = arguments.length; a < b; a++)this.events[arguments[a]] = []
    }, b.prototype.listenTo = function (a, b, c) {
        a.events[b].push({handler: c, scope: this})
    }, b.prototype.addListener = function (a, b, c) {
        this.events[a].push({handler: b, scope: c})
    },
        b.prototype.removeListener = function (a, b, c) {
            a = a.events[b];
            for (b = a.length - 1; 0 <= b; b--)a[b].handler === c && a.splice(b, 1)
        }, b.prototype.fire = function (a, b) {
        for (var c = this.events[a], g = 0, h = c.length; g < h; g++) {
            var k = c[g];
            k.handler.call(k.scope, b)
        }
    });
    for (var c in a)b.prototype[c] = a[c];
    return b
};
AmCharts.charts = [];
AmCharts.addChart = function (a) {
    AmCharts.charts.push(a)
};
AmCharts.removeChart = function (a) {
    for (var b = AmCharts.charts, c = b.length - 1; 0 <= c; c--)b[c] == a && b.splice(c, 1)
};
AmCharts.IEversion = 0;
-1 != navigator.appVersion.indexOf("MSIE") && document.documentMode && (AmCharts.IEversion = Number(document.documentMode));
if (document.addEventListener || window.opera)AmCharts.isNN = !0, AmCharts.isIE = !1, AmCharts.dx = 0.5, AmCharts.dy = 0.5;
document.attachEvent && (AmCharts.isNN = !1, AmCharts.isIE = !0, 9 > AmCharts.IEversion && (AmCharts.dx = 0, AmCharts.dy = 0));
window.chrome && (AmCharts.chrome = !0);
AmCharts.handleResize = function () {
    for (var a = AmCharts.charts, b = 0; b < a.length; b++) {
        var c = a[b];
        c && c.div && c.handleResize()
    }
};
AmCharts.handleMouseUp = function (a) {
    for (var b = AmCharts.charts, c = 0; c < b.length; c++) {
        var d = b[c];
        d && d.handleReleaseOutside(a)
    }
};
AmCharts.handleMouseMove = function (a) {
    for (var b = AmCharts.charts, c = 0; c < b.length; c++) {
        var d = b[c];
        d && d.handleMouseMove(a)
    }
};
AmCharts.resetMouseOver = function () {
    for (var a = AmCharts.charts, b = 0; b < a.length; b++) {
        var c = a[b];
        c && (c.mouseIsOver = !1)
    }
};
AmCharts.onReadyArray = [];
AmCharts.ready = function (a) {
    AmCharts.onReadyArray.push(a)
};
AmCharts.handleLoad = function () {
    for (var a = AmCharts.onReadyArray, b = 0; b < a.length; b++)(0, a[b])()
};
AmCharts.useUTC = !1;
AmCharts.updateRate = 40;
AmCharts.uid = 0;
AmCharts.getUniqueId = function () {
    AmCharts.uid++;
    return "AmChartsEl-" + AmCharts.uid
};
AmCharts.isNN && (document.addEventListener("mousemove", AmCharts.handleMouseMove, !0), window.addEventListener("resize", AmCharts.handleResize, !0), document.addEventListener("mouseup", AmCharts.handleMouseUp, !0), window.addEventListener("load", AmCharts.handleLoad, !0));
AmCharts.isIE && (document.attachEvent("onmousemove", AmCharts.handleMouseMove), window.attachEvent("onresize", AmCharts.handleResize), document.attachEvent("onmouseup", AmCharts.handleMouseUp), window.attachEvent("onload", AmCharts.handleLoad));
AmCharts.clear = function () {
    var a = AmCharts.charts;
    if (a)for (var b = 0; b < a.length; b++)a[b].clear();
    AmCharts.charts = null;
    AmCharts.isNN && (document.removeEventListener("mousemove", AmCharts.handleMouseMove, !0), window.removeEventListener("resize", AmCharts.handleResize, !0), document.removeEventListener("mouseup", AmCharts.handleMouseUp, !0), window.removeEventListener("load", AmCharts.handleLoad, !0));
    AmCharts.isIE && (document.detachEvent("onmousemove", AmCharts.handleMouseMove), window.detachEvent("onresize", AmCharts.handleResize),
        document.detachEvent("onmouseup", AmCharts.handleMouseUp), window.detachEvent("onload", AmCharts.handleLoad))
};
AmCharts.AmChart = AmCharts.Class({
    construct: function () {
        this.version = "2.10.7";
        AmCharts.addChart(this);
        this.createEvents("dataUpdated", "init", "rendered");
        this.height = this.width = "100%";
        this.dataChanged = !0;
        this.chartCreated = !1;
        this.previousWidth = this.previousHeight = 0;
        this.backgroundColor = "#FFFFFF";
        this.borderAlpha = this.backgroundAlpha = 0;
        this.color = this.borderColor = "#000000";
        this.fontFamily = "Verdana";
        this.fontSize = 11;
        this.numberFormatter = {precision: -1, decimalSeparator: ".", thousandsSeparator: ","};
        this.percentFormatter =
        {precision: 2, decimalSeparator: ".", thousandsSeparator: ","};
        this.labels = [];
        this.allLabels = [];
        this.titles = [];
        this.marginRight = this.marginLeft = this.autoMarginOffset = 0;
        this.timeOuts = [];
        var a = document.createElement("div"), b = a.style;
        b.overflow = "hidden";
        b.position = "relative";
        b.textAlign = "left";
        this.chartDiv = a;
        a = document.createElement("div");
        b = a.style;
        b.overflow = "hidden";
        b.position = "relative";
        b.textAlign = "left";
        this.legendDiv = a;
        this.balloon = new AmCharts.AmBalloon;
        this.balloon.chart = this;
        this.titleHeight = 0;
        this.prefixesOfBigNumbers = [{number: 1E3, prefix: "k"}, {number: 1E6, prefix: "M"}, {
            number: 1E9,
            prefix: "G"
        }, {number: 1E12, prefix: "T"}, {number: 1E15, prefix: "P"}, {number: 1E18, prefix: "E"}, {
            number: 1E21,
            prefix: "Z"
        }, {number: 1E24, prefix: "Y"}];
        this.prefixesOfSmallNumbers = [{number: 1E-24, prefix: "y"}, {number: 1E-21, prefix: "z"}, {
            number: 1E-18,
            prefix: "a"
        }, {number: 1E-15, prefix: "f"}, {number: 1E-12, prefix: "p"}, {number: 1E-9, prefix: "n"}, {
            number: 1E-6,
            prefix: "\u03bc"
        }, {number: 0.001, prefix: "m"}];
        this.panEventsEnabled = !1;
        AmCharts.bezierX =
            3;
        AmCharts.bezierY = 6;
        this.product = "amcharts"
    }, drawChart: function () {
        this.drawBackground();
        this.redrawLabels();
        this.drawTitles()
    }, drawBackground: function () {
        AmCharts.remove(this.background);
        var a = this.container, b = this.backgroundColor, c = this.backgroundAlpha, d = this.set, e = this.updateWidth();
        this.realWidth = e;
        var f = this.updateHeight();
        this.realHeight = f;
        this.background = b = AmCharts.polygon(a, [0, e - 1, e - 1, 0], [0, 0, f - 1, f - 1], b, c, 1, this.borderColor, this.borderAlpha);
        d.push(b);
        if (b = this.backgroundImage)this.path && (b =
            this.path + b), this.bgImg = a = a.image(b, 0, 0, e, f), d.push(a)
    }, drawTitles: function () {
        var a = this.titles;
        if (AmCharts.ifArray(a)) {
            var b = 20, c;
            for (c = 0; c < a.length; c++) {
                var d = a[c], e = d.color;
                void 0 === e && (e = this.color);
                var f = d.size;
                isNaN(d.alpha);
                var g = this.marginLeft, e = AmCharts.text(this.container, d.text, e, this.fontFamily, f);
                e.translate(g + (this.realWidth - this.marginRight - g) / 2, b);
                g = !0;
                void 0 !== d.bold && (g = d.bold);
                g && e.attr({"font-weight": "bold"});
                b += f + 6;
                this.freeLabelsSet.push(e)
            }
        }
    }, write: function (a) {
        var b = this.balloon;
        b && !b.chart && (b.chart = this);
        a = "object" != typeof a ? document.getElementById(a) : a;
        a.innerHTML = "";
        this.div = a;
        a.style.overflow = "hidden";
        a.style.textAlign = "left";
        var b = this.chartDiv, c = this.legendDiv, d = this.legend, e = c.style, f = b.style;
        this.measure();
        var g, h;
        if (d)switch (d.position) {
            case "bottom":
                a.appendChild(b);
                a.appendChild(c);
                break;
            case "top":
                a.appendChild(c);
                a.appendChild(b);
                break;
            case "absolute":
                g = document.createElement("div");
                h = g.style;
                h.position = "relative";
                h.width = a.style.width;
                h.height = a.style.height;
                a.appendChild(g);
                e.position = "absolute";
                f.position = "absolute";
                void 0 !== d.left && (e.left = d.left + "px");
                void 0 !== d.right && (e.right = d.right + "px");
                void 0 !== d.top && (e.top = d.top + "px");
                void 0 !== d.bottom && (e.bottom = d.bottom + "px");
                d.marginLeft = 0;
                d.marginRight = 0;
                g.appendChild(b);
                g.appendChild(c);
                break;
            case "right":
                g = document.createElement("div");
                h = g.style;
                h.position = "relative";
                h.width = a.style.width;
                h.height = a.style.height;
                a.appendChild(g);
                e.position = "relative";
                f.position = "absolute";
                g.appendChild(b);
                g.appendChild(c);
                break;
            case "left":
                g = document.createElement("div");
                h = g.style;
                h.position = "relative";
                h.width = a.style.width;
                h.height = a.style.height;
                a.appendChild(g);
                e.position = "absolute";
                f.position = "relative";
                g.appendChild(b);
                g.appendChild(c);
                break;
            case "outside":
                a.appendChild(b)
        } else a.appendChild(b);
        this.listenersAdded || (this.addListeners(), this.listenersAdded = !0);
        this.initChart()
    }, createLabelsSet: function () {
        AmCharts.remove(this.labelsSet);
        this.labelsSet = this.container.set();
        this.freeLabelsSet.push(this.labelsSet)
    },
    initChart: function () {
        this.divIsFixed = AmCharts.findIfFixed(this.chartDiv);
        this.previousHeight = this.divRealHeight;
        this.previousWidth = this.divRealWidth;
        this.destroy();
        var a = 0;
        document.attachEvent && !window.opera && (a = 1);
        this.dmouseX = this.dmouseY = 0;
        var b = document.getElementsByTagName("html")[0];
        b && window.getComputedStyle && (b = window.getComputedStyle(b, null)) && (this.dmouseY = AmCharts.removePx(b.getPropertyValue("margin-top")), this.dmouseX = AmCharts.removePx(b.getPropertyValue("margin-left")));
        this.mouseMode =
            a;
        this.container = new AmCharts.AmDraw(this.chartDiv, this.realWidth, this.realHeight);
        if (AmCharts.VML || AmCharts.SVG)a = this.container, this.set = a.set(), this.gridSet = a.set(), this.graphsBehindSet = a.set(), this.bulletBehindSet = a.set(), this.columnSet = a.set(), this.graphsSet = a.set(), this.trendLinesSet = a.set(), this.axesLabelsSet = a.set(), this.axesSet = a.set(), this.cursorSet = a.set(), this.scrollbarsSet = a.set(), this.bulletSet = a.set(), this.freeLabelsSet = a.set(), this.balloonsSet = a.set(), this.balloonsSet.setAttr("id",
            "balloons"), this.zoomButtonSet = a.set(), this.linkSet = a.set(), this.drb(), this.renderFix()
    }, measure: function () {
        var a = this.div, b = this.chartDiv, c = a.offsetWidth, d = a.offsetHeight, e = this.container;
        a.clientHeight && (c = a.clientWidth, d = a.clientHeight);
        var f = AmCharts.removePx(AmCharts.getStyle(a, "padding-left")), g = AmCharts.removePx(AmCharts.getStyle(a, "padding-right")), h = AmCharts.removePx(AmCharts.getStyle(a, "padding-top")), k = AmCharts.removePx(AmCharts.getStyle(a, "padding-bottom"));
        isNaN(f) || (c -= f);
        isNaN(g) ||
        (c -= g);
        isNaN(h) || (d -= h);
        isNaN(k) || (d -= k);
        f = a.style;
        a = f.width;
        f = f.height;
        -1 != a.indexOf("px") && (c = AmCharts.removePx(a));
        -1 != f.indexOf("px") && (d = AmCharts.removePx(f));
        a = AmCharts.toCoordinate(this.width, c);
        f = AmCharts.toCoordinate(this.height, d);
        if (a != this.previousWidth || f != this.previousHeight)b.style.width = a + "px", b.style.height = f + "px", e && e.setSize(a, f), this.balloon.setBounds(2, 2, a - 2, f);
        this.realWidth = a;
        this.realHeight = f;
        this.divRealWidth = c;
        this.divRealHeight = d
    }, destroy: function () {
        this.chartDiv.innerHTML =
            "";
        this.clearTimeOuts()
    }, clearTimeOuts: function () {
        var a = this.timeOuts;
        if (a) {
            var b;
            for (b = 0; b < a.length; b++)clearTimeout(a[b])
        }
        this.timeOuts = []
    }, clear: function (a) {
        AmCharts.callMethod("clear", [this.chartScrollbar, this.scrollbarV, this.scrollbarH, this.chartCursor]);
        this.chartCursor = this.scrollbarH = this.scrollbarV = this.chartScrollbar = null;
        this.clearTimeOuts();
        this.container && (this.container.remove(this.chartDiv), this.container.remove(this.legendDiv));
        a || AmCharts.removeChart(this)
    }, setMouseCursor: function (a) {
        "auto" ==
        a && AmCharts.isNN && (a = "default");
        this.chartDiv.style.cursor = a;
        this.legendDiv.style.cursor = a
    }, redrawLabels: function () {
        this.labels = [];
        var a = this.allLabels;
        this.createLabelsSet();
        var b;
        for (b = 0; b < a.length; b++)this.drawLabel(a[b])
    }, drawLabel: function (a) {
        if (this.container) {
            var b = a.y, c = a.text, d = a.align, e = a.size, f = a.color, g = a.rotation, h = a.alpha, k = a.bold, l = AmCharts.toCoordinate(a.x, this.realWidth), b = AmCharts.toCoordinate(b, this.realHeight);
            l || (l = 0);
            b || (b = 0);
            void 0 === f && (f = this.color);
            isNaN(e) && (e = this.fontSize);
            d || (d = "start");
            "left" == d && (d = "start");
            "right" == d && (d = "end");
            "center" == d && (d = "middle", g ? b = this.realHeight - b + b / 2 : l = this.realWidth / 2 - l);
            void 0 === h && (h = 1);
            void 0 === g && (g = 0);
            b += e / 2;
            c = AmCharts.text(this.container, c, f, this.fontFamily, e, d, k, h);
            c.translate(l, b);
            0 !== g && c.rotate(g);
            a.url && (c.setAttr("cursor", "pointer"), c.click(function () {
                AmCharts.getURL(a.url)
            }));
            this.labelsSet.push(c);
            this.labels.push(c)
        }
    }, addLabel: function (a, b, c, d, e, f, g, h, k, l) {
        a = {
            x: a, y: b, text: c, align: d, size: e, color: f, alpha: h, rotation: g, bold: k,
            url: l
        };
        this.container && this.drawLabel(a);
        this.allLabels.push(a)
    }, clearLabels: function () {
        var a = this.labels, b;
        for (b = a.length - 1; 0 <= b; b--)a[b].remove();
        this.labels = [];
        this.allLabels = []
    }, updateHeight: function () {
        var a = this.divRealHeight, b = this.legend;
        if (b) {
            var c = this.legendDiv.offsetHeight, b = b.position;
            if ("top" == b || "bottom" == b)a -= c, 0 > a && (a = 0), this.chartDiv.style.height = a + "px"
        }
        return a
    }, updateWidth: function () {
        var a = this.divRealWidth, b = this.divRealHeight, c = this.legend;
        if (c) {
            var d = this.legendDiv, e = d.offsetWidth,
                f = d.offsetHeight, d = d.style, g = this.chartDiv.style, c = c.position;
            if ("right" == c || "left" == c)a -= e, 0 > a && (a = 0), g.width = a + "px", "left" == c ? g.left = e + "px" : d.left = a + "px", d.top = (b - f) / 2 + "px"
        }
        return a
    }, getTitleHeight: function () {
        var a = 0, b = this.titles;
        if (0 < b.length) {
            var a = 15, c;
            for (c = 0; c < b.length; c++)a += b[c].size + 6
        }
        return a
    }, addTitle: function (a, b, c, d, e) {
        isNaN(b) && (b = this.fontSize + 2);
        a = {text: a, size: b, color: c, alpha: d, bold: e};
        this.titles.push(a);
        return a
    }, addListeners: function () {
        var a = this, b = a.chartDiv;
        AmCharts.isNN && (a.panEventsEnabled &&
        "ontouchstart"in document.documentElement && (b.addEventListener("touchstart", function (b) {
            a.handleTouchMove.call(a, b);
            a.handleTouchStart.call(a, b)
        }, !0), b.addEventListener("touchmove", function (b) {
            a.handleTouchMove.call(a, b)
        }, !0), b.addEventListener("touchend", function (b) {
            a.handleTouchEnd.call(a, b)
        }, !0)), b.addEventListener("mousedown", function (b) {
            a.handleMouseDown.call(a, b)
        }, !0), b.addEventListener("mouseover", function (b) {
            a.handleMouseOver.call(a, b)
        }, !0), b.addEventListener("mouseout", function (b) {
            a.handleMouseOut.call(a,
                b)
        }, !0));
        AmCharts.isIE && (b.attachEvent("onmousedown", function (b) {
            a.handleMouseDown.call(a, b)
        }), b.attachEvent("onmouseover", function (b) {
            a.handleMouseOver.call(a, b)
        }), b.attachEvent("onmouseout", function (b) {
            a.handleMouseOut.call(a, b)
        }))
    }, dispDUpd: function () {
        var a;
        this.dispatchDataUpdated && (this.dispatchDataUpdated = !1, a = "dataUpdated", this.fire(a, {
            type: a,
            chart: this
        }));
        this.chartCreated || (a = "init", this.fire(a, {type: a, chart: this}));
        this.chartRendered || (a = "rendered", this.fire(a, {type: a, chart: this}), this.chartRendered = !0)
    }, drb: function () {
        var a = this.product, b = a + ".com", c = window.location.hostname.split("."), d;
        2 <= c.length && (d = c[c.length - 2] + "." + c[c.length - 1]);
        AmCharts.remove(this.bbset);
        if (d != b) {
            var b = b + "/?utm_source=swf&utm_medium=demo&utm_campaign=jsDemo" + a, e = "chart by ", c = 145;
            "ammap" == a && (e = "tool by ", c = 125);
            d = AmCharts.rect(this.container, c, 20, "#FFFFFF", 1);
            e = AmCharts.text(this.container, e + a + ".com", "#000000", "Verdana", 11, "start");
            e.translate(7, 9);
            d = this.container.set([d, e]);
            "ammap" == a && d.translate(this.realWidth -
                c, 0);
            this.bbset = d;
            this.linkSet.push(d);
            d.setAttr("cursor", "pointer");
            d.click(function () {
                window.location.href = "http://" + b
            });
            for (a = 0; a < d.length; a++)d[a].attr({cursor: "pointer"})
        }
    }, validateSize: function () {
        var a = this;
        a.measure();
        var b = a.legend;
        if ((a.realWidth != a.previousWidth || a.realHeight != a.previousHeight) && 0 < a.realWidth && 0 < a.realHeight) {
            a.sizeChanged = !0;
            if (b) {
                clearTimeout(a.legendInitTO);
                var c = setTimeout(function () {
                    b.invalidateSize()
                }, 100);
                a.timeOuts.push(c);
                a.legendInitTO = c
            }
            a.marginsUpdated = "xy" !=
            a.chartType ? !1 : !0;
            clearTimeout(a.initTO);
            c = setTimeout(function () {
                a.initChart()
            }, 150);
            a.timeOuts.push(c);
            a.initTO = c
        }
        a.renderFix();
        b && b.renderFix()
    }, invalidateSize: function () {
        this.previousHeight = this.previousWidth = NaN;
        this.invalidateSizeReal()
    }, invalidateSizeReal: function () {
        var a = this;
        a.marginsUpdated = !1;
        clearTimeout(a.validateTO);
        var b = setTimeout(function () {
            a.validateSize()
        }, 5);
        a.timeOuts.push(b);
        a.validateTO = b
    }, validateData: function (a) {
        this.chartCreated && (this.dataChanged = !0, this.marginsUpdated = "xy" !=
        this.chartType ? !1 : !0, this.initChart(a))
    }, validateNow: function () {
        this.listenersAdded = !1;
        this.write(this.div)
    }, showItem: function (a) {
        a.hidden = !1;
        this.initChart()
    }, hideItem: function (a) {
        a.hidden = !0;
        this.initChart()
    }, hideBalloon: function () {
        var a = this;
        a.hoverInt = setTimeout(function () {
            a.hideBalloonReal.call(a)
        }, 80)
    }, cleanChart: function () {
    }, hideBalloonReal: function () {
        var a = this.balloon;
        a && a.hide()
    }, showBalloon: function (a, b, c, d, e) {
        var f = this;
        clearTimeout(f.balloonTO);
        f.balloonTO = setTimeout(function () {
            f.showBalloonReal.call(f,
                a, b, c, d, e)
        }, 1)
    }, showBalloonReal: function (a, b, c, d, e) {
        this.handleMouseMove();
        var f = this.balloon;
        f.enabled && (f.followCursor(!1), f.changeColor(b), c || f.setPosition(d, e), f.followCursor(c), a && f.showBalloon(a))
    }, handleTouchMove: function (a) {
        this.hideBalloon();
        var b = this.chartDiv;
        a.touches && (a = a.touches.item(0), this.mouseX = a.pageX - AmCharts.findPosX(b), this.mouseY = a.pageY - AmCharts.findPosY(b))
    }, handleMouseOver: function (a) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = !0
    }, handleMouseOut: function (a) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = !1
    }, handleMouseMove: function (a) {
        if (this.mouseIsOver) {
            var b = this.chartDiv;
            a || (a = window.event);
            var c, d;
            if (a) {
                this.posX = AmCharts.findPosX(b);
                this.posY = AmCharts.findPosY(b);
                switch (this.mouseMode) {
                    case 1:
                        c = a.clientX - this.posX;
                        d = a.clientY - this.posY;
                        if (!this.divIsFixed) {
                            var b = document.body, e, f;
                            b && (e = b.scrollLeft, y1 = b.scrollTop);
                            if (b = document.documentElement)f = b.scrollLeft, y2 = b.scrollTop;
                            e = Math.max(e, f);
                            f = Math.max(y1, y2);
                            c += e;
                            d += f
                        }
                        break;
                    case 0:
                        this.divIsFixed ? (c = a.clientX - this.posX, d = a.clientY -
                            this.posY) : (c = a.pageX - this.posX, d = a.pageY - this.posY)
                }
                a.touches && (a = a.touches.item(0), c = a.pageX - this.posX, d = a.pageY - this.posY);
                this.mouseX = c - this.dmouseX;
                this.mouseY = d - this.dmouseY
            }
        }
    }, handleTouchStart: function (a) {
        this.handleMouseDown(a)
    }, handleTouchEnd: function (a) {
        AmCharts.resetMouseOver();
        this.handleReleaseOutside(a)
    }, handleReleaseOutside: function (a) {
    }, handleMouseDown: function (a) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = !0;
        a && a.preventDefault && a.preventDefault()
    }, addLegend: function (a, b) {
        AmCharts.extend(a,
            new AmCharts.AmLegend);
        var c;
        c = "object" != typeof b ? document.getElementById(b) : b;
        this.legend = a;
        a.chart = this;
        c ? (a.div = c, a.position = "outside", a.autoMargins = !1) : a.div = this.legendDiv;
        c = this.handleLegendEvent;
        this.listenTo(a, "showItem", c);
        this.listenTo(a, "hideItem", c);
        this.listenTo(a, "clickMarker", c);
        this.listenTo(a, "rollOverItem", c);
        this.listenTo(a, "rollOutItem", c);
        this.listenTo(a, "rollOverMarker", c);
        this.listenTo(a, "rollOutMarker", c);
        this.listenTo(a, "clickLabel", c)
    }, removeLegend: function () {
        this.legend = void 0;
        this.legendDiv.innerHTML = ""
    }, handleResize: function () {
        (AmCharts.isPercents(this.width) || AmCharts.isPercents(this.height)) && this.invalidateSizeReal();
        this.renderFix()
    }, renderFix: function () {
        if (!AmCharts.VML) {
            var a = this.container;
            a && a.renderFix()
        }
    }, getSVG: function () {
        if (AmCharts.hasSVG)return this.container
    }
});
AmCharts.Slice = AmCharts.Class({
    construct: function () {
    }
});
AmCharts.SerialDataItem = AmCharts.Class({
    construct: function () {
    }
});
AmCharts.GraphDataItem = AmCharts.Class({
    construct: function () {
    }
});
AmCharts.Guide = AmCharts.Class({
    construct: function () {
    }
});
AmCharts.toBoolean = function (a, b) {
    if (void 0 === a)return b;
    switch (String(a).toLowerCase()) {
        case "true":
        case "yes":
        case "1":
            return !0;
        case "false":
        case "no":
        case "0":
        case null:
            return !1;
        default:
            return Boolean(a)
    }
};
AmCharts.removeFromArray = function (a, b) {
    var c;
    for (c = a.length - 1; 0 <= c; c--)a[c] == b && a.splice(c, 1)
};
AmCharts.getStyle = function (a, b) {
    var c = "";
    document.defaultView && document.defaultView.getComputedStyle ? c = document.defaultView.getComputedStyle(a, "").getPropertyValue(b) : a.currentStyle && (b = b.replace(/\-(\w)/g, function (a, b) {
        return b.toUpperCase()
    }), c = a.currentStyle[b]);
    return c
};
AmCharts.removePx = function (a) {
    return Number(a.substring(0, a.length - 2))
};
AmCharts.getURL = function (a, b) {
    if (a)if ("_self" != b && b)if ("_top" == b && window.top)window.top.location.href = a; else if ("_parent" == b && window.parent)window.parent.location.href = a; else {
        var c = document.getElementsByName(b)[0];
        c ? c.src = a : window.open(a)
    } else window.location.href = a
};
AmCharts.formatMilliseconds = function (a, b) {
    if (-1 != a.indexOf("fff")) {
        var c = b.getMilliseconds(), d = String(c);
        10 > c && (d = "00" + c);
        10 <= c && 100 > c && (d = "0" + c);
        a = a.replace(/fff/g, d)
    }
    return a
};
AmCharts.ifArray = function (a) {
    return a && 0 < a.length ? !0 : !1
};
AmCharts.callMethod = function (a, b) {
    var c;
    for (c = 0; c < b.length; c++) {
        var d = b[c];
        if (d) {
            if (d[a])d[a]();
            var e = d.length;
            if (0 < e) {
                var f;
                for (f = 0; f < e; f++) {
                    var g = d[f];
                    if (g && g[a])g[a]()
                }
            }
        }
    }
};
AmCharts.toNumber = function (a) {
    return "number" == typeof a ? a : Number(String(a).replace(/[^0-9\-.]+/g, ""))
};
AmCharts.toColor = function (a) {
    if ("" !== a && void 0 !== a)if (-1 != a.indexOf(",")) {
        a = a.split(",");
        var b;
        for (b = 0; b < a.length; b++) {
            var c = a[b].substring(a[b].length - 6, a[b].length);
            a[b] = "#" + c
        }
    } else a = a.substring(a.length - 6, a.length), a = "#" + a;
    return a
};
AmCharts.toCoordinate = function (a, b, c) {
    var d;
    void 0 !== a && (a = String(a), c && c < b && (b = c), d = Number(a), -1 != a.indexOf("!") && (d = b - Number(a.substr(1))), -1 != a.indexOf("%") && (d = b * Number(a.substr(0, a.length - 1)) / 100));
    return d
};
AmCharts.fitToBounds = function (a, b, c) {
    a < b && (a = b);
    a > c && (a = c);
    return a
};
AmCharts.isDefined = function (a) {
    return void 0 === a ? !1 : !0
};
AmCharts.stripNumbers = function (a) {
    return a.replace(/[0-9]+/g, "")
};
AmCharts.extractPeriod = function (a) {
    var b = AmCharts.stripNumbers(a), c = 1;
    b != a && (c = Number(a.slice(0, a.indexOf(b))));
    return {period: b, count: c}
};
AmCharts.resetDateToMin = function (a, b, c, d) {
    void 0 === d && (d = 1);
    var e, f, g, h, k, l, m;
    AmCharts.useUTC ? (e = a.getUTCFullYear(), f = a.getUTCMonth(), g = a.getUTCDate(), h = a.getUTCHours(), k = a.getUTCMinutes(), l = a.getUTCSeconds(), m = a.getUTCMilliseconds(), a = a.getUTCDay()) : (e = a.getFullYear(), f = a.getMonth(), g = a.getDate(), h = a.getHours(), k = a.getMinutes(), l = a.getSeconds(), m = a.getMilliseconds(), a = a.getDay());
    switch (b) {
        case "YYYY":
            e = Math.floor(e / c) * c;
            f = 0;
            g = 1;
            m = l = k = h = 0;
            break;
        case "MM":
            f = Math.floor(f / c) * c;
            g = 1;
            m = l = k = h = 0;
            break;
        case "WW":
            0 ===
            a && 0 < d && (a = 7);
            g = g - a + d;
            m = l = k = h = 0;
            break;
        case "DD":
            m = l = k = h = 0;
            break;
        case "hh":
            h = Math.floor(h / c) * c;
            m = l = k = 0;
            break;
        case "mm":
            k = Math.floor(k / c) * c;
            m = l = 0;
            break;
        case "ss":
            l = Math.floor(l / c) * c;
            m = 0;
            break;
        case "fff":
            m = Math.floor(m / c) * c
    }
    AmCharts.useUTC ? (a = new Date, a.setUTCFullYear(e), a.setUTCMonth(f), a.setUTCDate(g), a.setUTCHours(h), a.setUTCMinutes(k), a.setUTCSeconds(l), a.setUTCMilliseconds(m)) : a = new Date(e, f, g, h, k, l, m);
    return a
};
AmCharts.getPeriodDuration = function (a, b) {
    void 0 === b && (b = 1);
    var c;
    switch (a) {
        case "YYYY":
            c = 316224E5;
            break;
        case "MM":
            c = 26784E5;
            break;
        case "WW":
            c = 6048E5;
            break;
        case "DD":
            c = 864E5;
            break;
        case "hh":
            c = 36E5;
            break;
        case "mm":
            c = 6E4;
            break;
        case "ss":
            c = 1E3;
            break;
        case "fff":
            c = 1
    }
    return c * b
};
AmCharts.roundTo = function (a, b) {
    if (0 > b)return a;
    var c = Math.pow(10, b);
    return Math.round(a * c) / c
};
AmCharts.toFixed = function (a, b) {
    var c = String(Math.round(a * Math.pow(10, b)));
    if (0 < b) {
        var d = c.length;
        if (d < b) {
            var e;
            for (e = 0; e < b - d; e++)c = "0" + c
        }
        d = c.substring(0, c.length - b);
        "" === d && (d = 0);
        return d + "." + c.substring(c.length - b, c.length)
    }
    return String(c)
};
AmCharts.intervals = {
    s: {nextInterval: "ss", contains: 1E3},
    ss: {nextInterval: "mm", contains: 60, count: 0},
    mm: {nextInterval: "hh", contains: 60, count: 1},
    hh: {nextInterval: "DD", contains: 24, count: 2},
    DD: {nextInterval: "", contains: Infinity, count: 3}
};
AmCharts.getMaxInterval = function (a, b) {
    var c = AmCharts.intervals;
    return a >= c[b].contains ? (a = Math.round(a / c[b].contains), b = c[b].nextInterval, AmCharts.getMaxInterval(a, b)) : "ss" == b ? c[b].nextInterval : b
};
AmCharts.formatDuration = function (a, b, c, d, e, f) {
    var g = AmCharts.intervals, h = f.decimalSeparator;
    if (a >= g[b].contains) {
        var k = a - Math.floor(a / g[b].contains) * g[b].contains;
        "ss" == b && (k = AmCharts.formatNumber(k, f), 1 == k.split(h)[0].length && (k = "0" + k));
        ("mm" == b || "hh" == b) && 10 > k && (k = "0" + k);
        c = k + "" + d[b] + "" + c;
        a = Math.floor(a / g[b].contains);
        b = g[b].nextInterval;
        return AmCharts.formatDuration(a, b, c, d, e, f)
    }
    "ss" == b && (a = AmCharts.formatNumber(a, f), 1 == a.split(h)[0].length && (a = "0" + a));
    ("mm" == b || "hh" == b) && 10 > a && (a = "0" + a);
    c = a + "" +
        d[b] + "" + c;
    if (g[e].count > g[b].count)for (a = g[b].count; a < g[e].count; a++)b = g[b].nextInterval, "ss" == b || "mm" == b || "hh" == b ? c = "00" + d[b] + "" + c : "DD" == b && (c = "0" + d[b] + "" + c);
    ":" == c.charAt(c.length - 1) && (c = c.substring(0, c.length - 1));
    return c
};
AmCharts.formatNumber = function (a, b, c, d, e) {
    a = AmCharts.roundTo(a, b.precision);
    isNaN(c) && (c = b.precision);
    var f = b.decimalSeparator;
    b = b.thousandsSeparator;
    var g;
    g = 0 > a ? "-" : "";
    a = Math.abs(a);
    var h = String(a), k = !1;
    -1 != h.indexOf("e") && (k = !0);
    0 <= c && !k && (h = AmCharts.toFixed(a, c));
    var l = "";
    if (k)l = h; else {
        var h = h.split("."), k = String(h[0]), m;
        for (m = k.length; 0 <= m; m -= 3)l = m != k.length ? 0 !== m ? k.substring(m - 3, m) + b + l : k.substring(m - 3, m) + l : k.substring(m - 3, m);
        void 0 !== h[1] && (l = l + f + h[1]);
        void 0 !== c && (0 < c && "0" != l) && (l = AmCharts.addZeroes(l,
            f, c))
    }
    l = g + l;
    "" === g && (!0 === d && 0 !== a) && (l = "+" + l);
    !0 === e && (l += "%");
    return l
};
AmCharts.addZeroes = function (a, b, c) {
    a = a.split(b);
    void 0 === a[1] && 0 < c && (a[1] = "0");
    return a[1].length < c ? (a[1] += "0", AmCharts.addZeroes(a[0] + b + a[1], b, c)) : void 0 !== a[1] ? a[0] + b + a[1] : a[0]
};
AmCharts.scientificToNormal = function (a) {
    var b;
    a = String(a).split("e");
    var c;
    if ("-" == a[1].substr(0, 1)) {
        b = "0.";
        for (c = 0; c < Math.abs(Number(a[1])) - 1; c++)b += "0";
        b += a[0].split(".").join("")
    } else {
        var d = 0;
        b = a[0].split(".");
        b[1] && (d = b[1].length);
        b = a[0].split(".").join("");
        for (c = 0; c < Math.abs(Number(a[1])) - d; c++)b += "0"
    }
    return b
};
AmCharts.toScientific = function (a, b) {
    if (0 === a)return "0";
    var c = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E);
    Math.pow(10, c);
    mantissa = String(mantissa).split(".").join(b);
    return String(mantissa) + "e" + c
};
AmCharts.randomColor = function () {
    return "#" + ("00000" + (16777216 * Math.random() << 0).toString(16)).substr(-6)
};
AmCharts.hitTest = function (a, b, c) {
    var d = !1, e = a.x, f = a.x + a.width, g = a.y, h = a.y + a.height, k = AmCharts.isInRectangle;
    d || (d = k(e, g, b));
    d || (d = k(e, h, b));
    d || (d = k(f, g, b));
    d || (d = k(f, h, b));
    d || !0 === c || (d = AmCharts.hitTest(b, a, !0));
    return d
};
AmCharts.isInRectangle = function (a, b, c) {
    return a >= c.x - 5 && a <= c.x + c.width + 5 && b >= c.y - 5 && b <= c.y + c.height + 5 ? !0 : !1
};
AmCharts.isPercents = function (a) {
    if (-1 != String(a).indexOf("%"))return !0
};
AmCharts.dayNames = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ");
AmCharts.shortDayNames = "Sun Mon Tue Wed Thu Fri Sat".split(" ");
AmCharts.monthNames = "January February March April May June July August September October November December".split(" ");
AmCharts.shortMonthNames = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ");
AmCharts.getWeekNumber = function (a) {
    a = new Date(a);
    a.setHours(0, 0, 0);
    a.setDate(a.getDate() + 4 - (a.getDay() || 7));
    var b = new Date(a.getFullYear(), 0, 1);
    return Math.ceil(((a - b) / 864E5 + 1) / 7)
};
AmCharts.formatDate = function (a, b) {
    var c, d, e, f, g, h, k, l, m = AmCharts.getWeekNumber(a);
    AmCharts.useUTC ? (c = a.getUTCFullYear(), d = a.getUTCMonth(), e = a.getUTCDate(), f = a.getUTCDay(), g = a.getUTCHours(), h = a.getUTCMinutes(), k = a.getUTCSeconds(), l = a.getUTCMilliseconds()) : (c = a.getFullYear(), d = a.getMonth(), e = a.getDate(), f = a.getDay(), g = a.getHours(), h = a.getMinutes(), k = a.getSeconds(), l = a.getMilliseconds());
    var n = String(c).substr(2, 2), s = d + 1;
    9 > d && (s = "0" + s);
    var q = e;
    10 > e && (q = "0" + e);
    var t = "0" + f;
    b = b.replace(/W/g, m);
    m = g;
    24 ==
    m && (m = 0);
    var p = m;
    10 > p && (p = "0" + p);
    b = b.replace(/JJ/g, p);
    b = b.replace(/J/g, m);
    m = g;
    0 === m && (m = 24);
    p = m;
    10 > p && (p = "0" + p);
    b = b.replace(/HH/g, p);
    b = b.replace(/H/g, m);
    m = g;
    11 < m && (m -= 12);
    p = m;
    10 > p && (p = "0" + p);
    b = b.replace(/KK/g, p);
    b = b.replace(/K/g, m);
    m = g;
    0 === m && (m = 12);
    12 < m && (m -= 12);
    p = m;
    10 > p && (p = "0" + p);
    b = b.replace(/LL/g, p);
    b = b.replace(/L/g, m);
    m = h;
    10 > m && (m = "0" + m);
    b = b.replace(/NN/g, m);
    b = b.replace(/N/g, h);
    h = k;
    10 > h && (h = "0" + h);
    b = b.replace(/SS/g, h);
    b = b.replace(/S/g, k);
    k = l;
    10 > k && (k = "00" + k);
    100 > k && (k = "0" + k);
    h = l;
    10 > h && (h = "00" +
        h);
    b = b.replace(/QQQ/g, k);
    b = b.replace(/QQ/g, h);
    b = b.replace(/Q/g, l);
    b = 12 > g ? b.replace(/A/g, "am") : b.replace(/A/g, "pm");
    b = b.replace(/YYYY/g, "@IIII@");
    b = b.replace(/YY/g, "@II@");
    b = b.replace(/MMMM/g, "@XXXX@");
    b = b.replace(/MMM/g, "@XXX@");
    b = b.replace(/MM/g, "@XX@");
    b = b.replace(/M/g, "@X@");
    b = b.replace(/DD/g, "@RR@");
    b = b.replace(/D/g, "@R@");
    b = b.replace(/EEEE/g, "@PPPP@");
    b = b.replace(/EEE/g, "@PPP@");
    b = b.replace(/EE/g, "@PP@");
    b = b.replace(/E/g, "@P@");
    b = b.replace(/@IIII@/g, c);
    b = b.replace(/@II@/g, n);
    b = b.replace(/@XXXX@/g,
        AmCharts.monthNames[d]);
    b = b.replace(/@XXX@/g, AmCharts.shortMonthNames[d]);
    b = b.replace(/@XX@/g, s);
    b = b.replace(/@X@/g, d + 1);
    b = b.replace(/@RR@/g, q);
    b = b.replace(/@R@/g, e);
    b = b.replace(/@PPPP@/g, AmCharts.dayNames[f]);
    b = b.replace(/@PPP@/g, AmCharts.shortDayNames[f]);
    b = b.replace(/@PP@/g, t);
    return b = b.replace(/@P@/g, f)
};
AmCharts.findPosX = function (a) {
    var b = a, c = a.offsetLeft;
    if (a.offsetParent) {
        for (; a = a.offsetParent;)c += a.offsetLeft;
        for (; (b = b.parentNode) && b != document.body;)c -= b.scrollLeft || 0
    }
    return c
};
AmCharts.findPosY = function (a) {
    var b = a, c = a.offsetTop;
    if (a.offsetParent) {
        for (; a = a.offsetParent;)c += a.offsetTop;
        for (; (b = b.parentNode) && b != document.body;)c -= b.scrollTop || 0
    }
    return c
};
AmCharts.findIfFixed = function (a) {
    if (a.offsetParent)for (; a = a.offsetParent;)if ("fixed" == AmCharts.getStyle(a, "position"))return !0;
    return !1
};
AmCharts.findIfAuto = function (a) {
    return a.style && "auto" == AmCharts.getStyle(a, "overflow") ? !0 : a.parentNode ? AmCharts.findIfAuto(a.parentNode) : !1
};
AmCharts.findScrollLeft = function (a, b) {
    a.scrollLeft && (b += a.scrollLeft);
    return a.parentNode ? AmCharts.findScrollLeft(a.parentNode, b) : b
};
AmCharts.findScrollTop = function (a, b) {
    a.scrollTop && (b += a.scrollTop);
    return a.parentNode ? AmCharts.findScrollTop(a.parentNode, b) : b
};
AmCharts.formatValue = function (a, b, c, d, e, f, g, h) {
    if (b) {
        void 0 === e && (e = "");
        var k;
        for (k = 0; k < c.length; k++) {
            var l = c[k], m = b[l];
            void 0 !== m && (m = f ? AmCharts.addPrefix(m, h, g, d) : AmCharts.formatNumber(m, d), a = a.replace(RegExp("\\[\\[" + e + "" + l + "\\]\\]", "g"), m))
        }
    }
    return a
};
AmCharts.formatDataContextValue = function (a, b) {
    if (a) {
        var c = a.match(/\[\[.*?\]\]/g), d;
        for (d = 0; d < c.length; d++) {
            var e = c[d], e = e.substr(2, e.length - 4);
            void 0 !== b[e] && (a = a.replace(RegExp("\\[\\[" + e + "\\]\\]", "g"), b[e]))
        }
    }
    return a
};
AmCharts.massReplace = function (a, b) {
    for (var c in b)if (b.hasOwnProperty(c)) {
        var d = b[c];
        void 0 === d && (d = "");
        a = a.replace(c, d)
    }
    return a
};
AmCharts.cleanFromEmpty = function (a) {
    return a.replace(/\[\[[^\]]*\]\]/g, "")
};
AmCharts.addPrefix = function (a, b, c, d, e) {
    var f = AmCharts.formatNumber(a, d), g = "", h, k, l;
    if (0 === a)return "0";
    0 > a && (g = "-");
    a = Math.abs(a);
    if (1 < a)for (h = b.length - 1; -1 < h; h--) {
        if (a >= b[h].number && (k = a / b[h].number, l = Number(d.precision), 1 > l && (l = 1), c = AmCharts.roundTo(k, l), !e || k == c)) {
            f = g + "" + c + "" + b[h].prefix;
            break
        }
    } else for (h = 0; h < c.length; h++)if (a <= c[h].number) {
        k = a / c[h].number;
        l = Math.abs(Math.round(Math.log(k) * Math.LOG10E));
        k = AmCharts.roundTo(k, l);
        f = g + "" + k + "" + c[h].prefix;
        break
    }
    return f
};
AmCharts.remove = function (a) {
    a && a.remove()
};
AmCharts.copyProperties = function (a, b) {
    for (var c in a)a.hasOwnProperty(c) && "events" != c && (void 0 !== a[c] && "function" != typeof a[c]) && (b[c] = a[c])
};
AmCharts.recommended = function () {
    var a = "js";
    document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") || swfobject && swfobject.hasFlashPlayerVersion("8") && (a = "flash");
    return a
};
AmCharts.getEffect = function (a) {
    ">" == a && (a = "easeOutSine");
    "<" == a && (a = "easeInSine");
    "elastic" == a && (a = "easeOutElastic");
    return a
};
AmCharts.extend = function (a, b) {
    for (var c in b)void 0 !== b[c] && (a.hasOwnProperty(c) || (a[c] = b[c]))
};
AmCharts.fixNewLines = function (a) {
    if (9 > AmCharts.IEversion && 0 < AmCharts.IEversion) {
        var b = RegExp("\\n", "g");
        a && (a = a.replace(b, "<br />"))
    }
    return a
};
AmCharts.deleteObject = function (a, b) {
    if (a) {
        if (void 0 === b || null === b)b = 20;
        if (0 != b)if ("[object Array]" === Object.prototype.toString.call(a))for (var c = 0; c < a.length; c++)AmCharts.deleteObject(a[c], b - 1), a[c] = null; else try {
            for (c in a)a[c] && ("object" == typeof a[c] && AmCharts.deleteObject(a[c], b - 1), "function" != typeof a[c] && (a[c] = null))
        } catch (d) {
        }
    }
};
AmCharts.changeDate = function (a, b, c, d, e) {
    var f = -1;
    void 0 === d && (d = !0);
    void 0 === e && (e = !1);
    !0 === d && (f = 1);
    switch (b) {
        case "YYYY":
            a.setFullYear(a.getFullYear() + c * f);
            d || e || a.setDate(a.getDate() + 1);
            break;
        case "MM":
            a.setMonth(a.getMonth() + c * f);
            d || e || a.setDate(a.getDate() + 1);
            break;
        case "DD":
            a.setDate(a.getDate() + c * f);
            break;
        case "WW":
            a.setDate(a.getDate() + 7 * c * f + 1);
            break;
        case "hh":
            a.setHours(a.getHours() + c * f);
            break;
        case "mm":
            a.setMinutes(a.getMinutes() + c * f);
            break;
        case "ss":
            a.setSeconds(a.getSeconds() + c * f);
            break;
        case "fff":
            a.setMilliseconds(a.getMilliseconds() + c * f)
    }
    return a
};
AmCharts.Bezier = AmCharts.Class({
    construct: function (a, b, c, d, e, f, g, h, k, l) {
        "object" == typeof g && (g = g[0]);
        "object" == typeof h && (h = h[0]);
        f = {fill: g, "fill-opacity": h, "stroke-width": f};
        void 0 !== k && 0 < k && (f["stroke-dasharray"] = k);
        isNaN(e) || (f["stroke-opacity"] = e);
        d && (f.stroke = d);
        d = "M" + Math.round(b[0]) + "," + Math.round(c[0]);
        e = [];
        for (k = 0; k < b.length; k++)e.push({x: Number(b[k]), y: Number(c[k])});
        1 < e.length && (b = this.interpolate(e), d += this.drawBeziers(b));
        l ? d += l : AmCharts.VML || (d += "M0,0 L0,0");
        this.path = a.path(d).attr(f)
    },
    interpolate: function (a) {
        var b = [];
        b.push({x: a[0].x, y: a[0].y});
        var c = a[1].x - a[0].x, d = a[1].y - a[0].y, e = AmCharts.bezierX, f = AmCharts.bezierY;
        b.push({x: a[0].x + c / e, y: a[0].y + d / f});
        var g;
        for (g = 1; g < a.length - 1; g++) {
            var h = a[g - 1], k = a[g], d = a[g + 1], c = d.x - k.x, d = d.y - h.y, h = k.x - h.x;
            h > c && (h = c);
            b.push({x: k.x - h / e, y: k.y - d / f});
            b.push({x: k.x, y: k.y});
            b.push({x: k.x + h / e, y: k.y + d / f})
        }
        d = a[a.length - 1].y - a[a.length - 2].y;
        c = a[a.length - 1].x - a[a.length - 2].x;
        b.push({x: a[a.length - 1].x - c / e, y: a[a.length - 1].y - d / f});
        b.push({
            x: a[a.length - 1].x,
            y: a[a.length - 1].y
        });
        return b
    }, drawBeziers: function (a) {
        var b = "", c;
        for (c = 0; c < (a.length - 1) / 3; c++)b += this.drawBezierMidpoint(a[3 * c], a[3 * c + 1], a[3 * c + 2], a[3 * c + 3]);
        return b
    }, drawBezierMidpoint: function (a, b, c, d) {
        var e = Math.round, f = this.getPointOnSegment(a, b, 0.75), g = this.getPointOnSegment(d, c, 0.75), h = (d.x - a.x) / 16, k = (d.y - a.y) / 16, l = this.getPointOnSegment(a, b, 0.375);
        a = this.getPointOnSegment(f, g, 0.375);
        a.x -= h;
        a.y -= k;
        b = this.getPointOnSegment(g, f, 0.375);
        b.x += h;
        b.y += k;
        c = this.getPointOnSegment(d, c, 0.375);
        h = this.getMiddle(l,
            a);
        f = this.getMiddle(f, g);
        g = this.getMiddle(b, c);
        l = " Q" + e(l.x) + "," + e(l.y) + "," + e(h.x) + "," + e(h.y);
        l += " Q" + e(a.x) + "," + e(a.y) + "," + e(f.x) + "," + e(f.y);
        l += " Q" + e(b.x) + "," + e(b.y) + "," + e(g.x) + "," + e(g.y);
        return l += " Q" + e(c.x) + "," + e(c.y) + "," + e(d.x) + "," + e(d.y)
    }, getMiddle: function (a, b) {
        return {x: (a.x + b.x) / 2, y: (a.y + b.y) / 2}
    }, getPointOnSegment: function (a, b, c) {
        return {x: a.x + (b.x - a.x) * c, y: a.y + (b.y - a.y) * c}
    }
});
AmCharts.Cuboid = AmCharts.Class({
    construct: function (a, b, c, d, e, f, g, h, k, l, m, n, s) {
        this.set = a.set();
        this.container = a;
        this.h = Math.round(c);
        this.w = Math.round(b);
        this.dx = d;
        this.dy = e;
        this.colors = f;
        this.alpha = g;
        this.bwidth = h;
        this.bcolor = k;
        this.balpha = l;
        this.colors = f;
        s ? 0 > b && 0 === m && (m = 180) : 0 > c && 270 == m && (m = 90);
        this.gradientRotation = m;
        0 === d && 0 === e && (this.cornerRadius = n);
        this.draw()
    }, draw: function () {
        var a = this.set;
        a.clear();
        var b = this.container, c = this.w, d = this.h, e = this.dx, f = this.dy, g = this.colors, h = this.alpha, k =
            this.bwidth, l = this.bcolor, m = this.balpha, n = this.gradientRotation, s = this.cornerRadius, q = g, t = g;
        "object" == typeof g && (q = g[0], t = g[g.length - 1]);
        var p, r, u, v, w, A, x, B, y;
        if (0 < e || 0 < f)x = t, t = AmCharts.adjustLuminosity(q, -0.2), t = AmCharts.adjustLuminosity(q, -0.2), p = AmCharts.polygon(b, [0, e, c + e, c, 0], [0, f, f, 0, 0], t, h, 0, 0, 0, n), 0 < m && (y = AmCharts.line(b, [0, e, c + e], [0, f, f], l, m, k)), r = AmCharts.polygon(b, [0, 0, c, c, 0], [0, d, d, 0, 0], t, h, 0, 0, 0, 0, n), r.translate(e, f), 0 < m && (u = AmCharts.line(b, [e, e], [f, f + d], l, 1, k)), v = AmCharts.polygon(b,
            [0, 0, e, e, 0], [0, d, d + f, f, 0], t, h, 0, 0, 0, n), w = AmCharts.polygon(b, [c, c, c + e, c + e, c], [0, d, d + f, f, 0], t, h, 0, 0, 0, n), 0 < m && (A = AmCharts.line(b, [c, c + e, c + e, c], [0, f, d + f, d], l, m, k)), t = AmCharts.adjustLuminosity(x, 0.2), x = AmCharts.polygon(b, [0, e, c + e, c, 0], [d, d + f, d + f, d, d], t, h, 0, 0, 0, n), 0 < m && (B = AmCharts.line(b, [0, e, c + e], [d, d + f, d + f], l, m, k));
        1 > Math.abs(d) && (d = 0);
        1 > Math.abs(c) && (c = 0);
        b = 0 === d ? AmCharts.line(b, [0, c], [0, 0], l, m, k) : 0 === c ? AmCharts.line(b, [0, 0], [0, d], l, m, k) : 0 < s ? AmCharts.rect(b, c, d, g, h, k, l, m, s, n) : AmCharts.polygon(b, [0,
            0, c, c, 0], [0, d, d, 0, 0], g, h, k, l, m, n);
        d = 0 > d ? [p, y, r, u, v, w, A, x, B, b] : [x, B, r, u, v, w, p, y, A, b];
        for (p = 0; p < d.length; p++)(r = d[p]) && a.push(r)
    }, width: function (a) {
        this.w = a;
        this.draw()
    }, height: function (a) {
        this.h = a;
        this.draw()
    }, animateHeight: function (a, b) {
        var c = this;
        c.easing = b;
        c.totalFrames = 1E3 * a / AmCharts.updateRate;
        c.rh = c.h;
        c.frame = 0;
        c.height(1);
        setTimeout(function () {
            c.updateHeight.call(c)
        }, AmCharts.updateRate)
    }, updateHeight: function () {
        var a = this;
        a.frame++;
        var b = a.totalFrames;
        a.frame <= b && (b = a.easing(0, a.frame, 1, a.rh -
            1, b), a.height(b), setTimeout(function () {
            a.updateHeight.call(a)
        }, AmCharts.updateRate))
    }, animateWidth: function (a, b) {
        var c = this;
        c.easing = b;
        c.totalFrames = 1E3 * a / AmCharts.updateRate;
        c.rw = c.w;
        c.frame = 0;
        c.width(1);
        setTimeout(function () {
            c.updateWidth.call(c)
        }, AmCharts.updateRate)
    }, updateWidth: function () {
        var a = this;
        a.frame++;
        var b = a.totalFrames;
        a.frame <= b && (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), setTimeout(function () {
            a.updateWidth.call(a)
        }, AmCharts.updateRate))
    }
});
AmCharts.AmLegend = AmCharts.Class({
    construct: function () {
        this.createEvents("rollOverMarker", "rollOverItem", "rollOutMarker", "rollOutItem", "showItem", "hideItem", "clickMarker", "rollOverItem", "rollOutItem", "clickLabel");
        this.position = "bottom";
        this.borderColor = this.color = "#000000";
        this.borderAlpha = 0;
        this.markerLabelGap = 5;
        this.verticalGap = 10;
        this.align = "left";
        this.horizontalGap = 0;
        this.spacing = 10;
        this.markerDisabledColor = "#AAB3B3";
        this.markerType = "square";
        this.markerSize = 16;
        this.markerBorderThickness = 1;
        this.marginBottom =
            this.marginTop = 0;
        this.marginLeft = this.marginRight = 20;
        this.autoMargins = !0;
        this.valueWidth = 50;
        this.switchable = !0;
        this.switchType = "x";
        this.switchColor = "#FFFFFF";
        this.rollOverColor = "#CC0000";
        this.reversedOrder = !1;
        this.labelText = "[[title]]";
        this.valueText = "[[value]]";
        this.useMarkerColorForLabels = !1;
        this.rollOverGraphAlpha = 1;
        this.textClickEnabled = !1;
        this.equalWidths = !0;
        this.dateFormat = "DD-MM-YYYY";
        this.backgroundColor = "#FFFFFF";
        this.backgroundAlpha = 0;
        this.showEntries = !0
    }, setData: function (a) {
        this.data = a;
        this.invalidateSize()
    }, invalidateSize: function () {
        this.destroy();
        this.entries = [];
        this.valueLabels = [];
        AmCharts.ifArray(this.data) && this.drawLegend()
    }, drawLegend: function () {
        var a = this.chart, b = this.position, c = this.width, d = a.divRealWidth, e = a.divRealHeight, f = this.div, g = this.data;
        isNaN(this.fontSize) && (this.fontSize = a.fontSize);
        if ("right" == b || "left" == b)this.maxColumns = 1, this.marginLeft = this.marginRight = 10; else if (this.autoMargins) {
            this.marginRight = a.marginRight;
            this.marginLeft = a.marginLeft;
            var h = a.autoMarginOffset;
            "bottom" == b ? (this.marginBottom = h, this.marginTop = 0) : (this.marginTop = h, this.marginBottom = 0)
        }
        c = void 0 !== c ? AmCharts.toCoordinate(c, d) : a.realWidth;
        "outside" == b ? (c = f.offsetWidth, e = f.offsetHeight, f.clientHeight && (c = f.clientWidth, e = f.clientHeight)) : (f.style.width = c + "px", f.className = "amChartsLegend");
        this.divWidth = c;
        this.container = new AmCharts.AmDraw(f, c, e);
        this.lx = 0;
        this.ly = 8;
        b = this.markerSize;
        b > this.fontSize && (this.ly = b / 2 - 1);
        0 < b && (this.lx += b + this.markerLabelGap);
        this.titleWidth = 0;
        if (b = this.title)a = AmCharts.text(this.container,
            b, this.color, a.fontFamily, this.fontSize, "start", !0), a.translate(this.marginLeft, this.marginTop + this.verticalGap + this.ly + 1), a = a.getBBox(), this.titleWidth = a.width + 15, this.titleHeight = a.height + 6;
        this.index = this.maxLabelWidth = 0;
        if (this.showEntries) {
            for (a = 0; a < g.length; a++)this.createEntry(g[a]);
            for (a = this.index = 0; a < g.length; a++)this.createValue(g[a])
        }
        this.arrangeEntries();
        this.updateValues()
    }, arrangeEntries: function () {
        var a = this.position, b = this.marginLeft + this.titleWidth, c = this.marginRight, d = this.marginTop,
            e = this.marginBottom, f = this.horizontalGap, g = this.div, h = this.divWidth, k = this.maxColumns, l = this.verticalGap, m = this.spacing, n = h - c - b, s = 0, q = 0, t = this.container, p = t.set();
        this.set = p;
        t = t.set();
        p.push(t);
        var r = this.entries, u, v;
        for (v = 0; v < r.length; v++) {
            u = r[v].getBBox();
            var w = u.width;
            w > s && (s = w);
            u = u.height;
            u > q && (q = u)
        }
        var A = w = 0, x = f;
        for (v = 0; v < r.length; v++) {
            var B = r[v];
            this.reversedOrder && (B = r[r.length - v - 1]);
            u = B.getBBox();
            var y;
            this.equalWidths ? y = f + A * (s + m + this.markerLabelGap) : (y = x, x = x + u.width + f + m);
            y + u.width > n && (0 <
            v && 0 != A) && (w++, A = 0, y = f, x = y + u.width + f + m, skipNewRow = !0);
            B.translate(y, (q + l) * w);
            A++;
            !isNaN(k) && A >= k && (A = 0, w++);
            t.push(B)
        }
        u = t.getBBox();
        k = u.height + 2 * l - 1;
        "left" == a || "right" == a ? (h = u.width + 2 * f, g.style.width = h + b + c + "px") : h = h - b - c - 1;
        c = AmCharts.polygon(this.container, [0, h, h, 0], [0, 0, k, k], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
        p.push(c);
        p.translate(b, d);
        c.toBack();
        b = f;
        if ("top" == a || "bottom" == a || "absolute" == a || "outside" == a)"center" == this.align ? b = f + (h - u.width) / 2 : "right" == this.align &&
        (b = f + h - u.width);
        t.translate(b, l + 1);
        this.titleHeight > k && (k = this.titleHeight);
        a = k + d + e + 1;
        0 > a && (a = 0);
        g.style.height = Math.round(a) + "px"
    }, createEntry: function (a) {
        if (!1 !== a.visibleInLegend) {
            var b = this.chart, c = a.markerType;
            c || (c = this.markerType);
            var d = a.color, e = a.alpha;
            a.legendKeyColor && (d = a.legendKeyColor());
            a.legendKeyAlpha && (e = a.legendKeyAlpha());
            !0 === a.hidden && (d = this.markerDisabledColor);
            var f = this.createMarker(c, d, e);
            this.addListeners(f, a);
            e = this.container.set([f]);
            this.switchable && e.setAttr("cursor",
                "pointer");
            var g = this.switchType;
            if (g) {
                var h;
                h = "x" == g ? this.createX() : this.createV();
                h.dItem = a;
                !0 !== a.hidden ? "x" == g ? h.hide() : h.show() : "x" != g && h.hide();
                this.switchable || h.hide();
                this.addListeners(h, a);
                a.legendSwitch = h;
                e.push(h)
            }
            g = this.color;
            a.showBalloon && (this.textClickEnabled && void 0 !== this.selectedColor) && (g = this.selectedColor);
            this.useMarkerColorForLabels && (g = d);
            !0 === a.hidden && (g = this.markerDisabledColor);
            var d = AmCharts.massReplace(this.labelText, {"[[title]]": a.title}), k = this.fontSize, l = this.markerSize;
            if (f && l <= k) {
                var m = 0;
                if ("bubble" == c || "circle" == c)m = l / 2;
                c = m + this.ly - k / 2 + (k + 2 - l) / 2;
                f.translate(m, c);
                h && h.translate(m, c)
            }
            var n;
            d && (d = AmCharts.fixNewLines(d), n = AmCharts.text(this.container, d, g, b.fontFamily, k, "start"), n.translate(this.lx, this.ly), e.push(n), b = n.getBBox().width, this.maxLabelWidth < b && (this.maxLabelWidth = b));
            this.entries[this.index] = e;
            a.legendEntry = this.entries[this.index];
            a.legendLabel = n;
            this.index++
        }
    }, addListeners: function (a, b) {
        var c = this;
        a && a.mouseover(function () {
            c.rollOverMarker(b)
        }).mouseout(function () {
            c.rollOutMarker(b)
        }).click(function () {
            c.clickMarker(b)
        })
    },
    rollOverMarker: function (a) {
        this.switchable && this.dispatch("rollOverMarker", a);
        this.dispatch("rollOverItem", a)
    }, rollOutMarker: function (a) {
        this.switchable && this.dispatch("rollOutMarker", a);
        this.dispatch("rollOutItem", a)
    }, clickMarker: function (a) {
        this.switchable ? !0 === a.hidden ? this.dispatch("showItem", a) : this.dispatch("hideItem", a) : this.textClickEnabled && this.dispatch("clickMarker", a)
    }, rollOverLabel: function (a) {
        a.hidden || (this.textClickEnabled && a.legendLabel && a.legendLabel.attr({fill: this.rollOverColor}),
            this.dispatch("rollOverItem", a))
    }, rollOutLabel: function (a) {
        if (!a.hidden) {
            if (this.textClickEnabled && a.legendLabel) {
                var b = this.color;
                void 0 !== this.selectedColor && a.showBalloon && (b = this.selectedColor);
                this.useMarkerColorForLabels && (b = a.lineColor, void 0 === b && (b = a.color));
                a.legendLabel.attr({fill: b})
            }
            this.dispatch("rollOutItem", a)
        }
    }, clickLabel: function (a) {
        this.textClickEnabled ? a.hidden || this.dispatch("clickLabel", a) : this.switchable && (!0 === a.hidden ? this.dispatch("showItem", a) : this.dispatch("hideItem", a))
    },
    dispatch: function (a, b) {
        this.fire(a, {type: a, dataItem: b, target: this, chart: this.chart})
    }, createValue: function (a) {
        var b = this, c = b.fontSize;
        if (!1 !== a.visibleInLegend) {
            var d = b.maxLabelWidth;
            b.equalWidths || (b.valueAlign = "left");
            "left" == b.valueAlign && (d = a.legendEntry.getBBox().width);
            var e = d;
            if (b.valueText) {
                var f = b.color;
                b.useMarkerColorForValues && (f = a.color, a.legendKeyColor && (f = a.legendKeyColor()));
                !0 === a.hidden && (f = b.markerDisabledColor);
                var g = b.valueText, d = d + b.lx + b.markerLabelGap + b.valueWidth, h = "end";
                "left" ==
                b.valueAlign && (d -= b.valueWidth, h = "start");
                f = AmCharts.text(b.container, g, f, b.chart.fontFamily, c, h);
                f.translate(d, b.ly);
                b.entries[b.index].push(f);
                e += b.valueWidth + 2 * b.markerLabelGap;
                f.dItem = a;
                b.valueLabels.push(f)
            }
            b.index++;
            f = b.markerSize;
            f < c + 7 && (f = c + 7, AmCharts.VML && (f += 3));
            c = b.container.rect(b.markerSize, 0, e, f, 0, 0).attr({
                stroke: "none",
                fill: "#ffffff",
                "fill-opacity": 0.005
            });
            c.dItem = a;
            b.entries[b.index - 1].push(c);
            c.mouseover(function () {
                b.rollOverLabel(a)
            }).mouseout(function () {
                b.rollOutLabel(a)
            }).click(function () {
                b.clickLabel(a)
            })
        }
    },
    createV: function () {
        var a = this.markerSize;
        return AmCharts.polygon(this.container, [a / 5, a / 2, a - a / 5, a / 2], [a / 3, a - a / 5, a / 5, a / 1.7], this.switchColor)
    }, createX: function () {
        var a = this.markerSize - 3, b = {
            stroke: this.switchColor,
            "stroke-width": 3
        }, c = this.container, d = AmCharts.line(c, [3, a], [3, a]).attr(b), a = AmCharts.line(c, [3, a], [a, 3]).attr(b);
        return this.container.set([d, a])
    }, createMarker: function (a, b, c) {
        var d = this.markerSize, e = this.container, f, g = this.markerBorderColor;
        g || (g = b);
        var h = this.markerBorderThickness, k = this.markerBorderAlpha;
        switch (a) {
            case "square":
                f = AmCharts.polygon(e, [0, d, d, 0], [0, 0, d, d], b, c, h, g, k);
                break;
            case "circle":
                f = AmCharts.circle(e, d / 2, b, c, h, g, k);
                f.translate(d / 2, d / 2);
                break;
            case "line":
                f = AmCharts.line(e, [0, d], [d / 2, d / 2], b, c, h);
                break;
            case "dashedLine":
                f = AmCharts.line(e, [0, d], [d / 2, d / 2], b, c, h, 3);
                break;
            case "triangleUp":
                f = AmCharts.polygon(e, [0, d / 2, d, d], [d, 0, d, d], b, c, h, g, k);
                break;
            case "triangleDown":
                f = AmCharts.polygon(e, [0, d / 2, d, d], [0, d, 0, 0], b, c, h, g, k);
                break;
            case "bubble":
                f = AmCharts.circle(e, d / 2, b, c, h, g, k, !0), f.translate(d /
                    2, d / 2)
        }
        return f
    }, validateNow: function () {
        this.invalidateSize()
    }, updateValues: function () {
        var a = this.valueLabels, b = this.chart, c;
        for (c = 0; c < a.length; c++) {
            var d = a[c], e = d.dItem;
            if (void 0 !== e.type) {
                var f = e.currentDataItem;
                if (f) {
                    var g = this.valueText;
                    e.legendValueText && (g = e.legendValueText);
                    e = g;
                    e = b.formatString(e, f);
                    d.text(e)
                } else d.text(" ")
            } else f = b.formatString(this.valueText, e), d.text(f)
        }
    }, renderFix: function () {
        if (!AmCharts.VML) {
            var a = this.container;
            a && a.renderFix()
        }
    }, destroy: function () {
        this.div.innerHTML =
            "";
        AmCharts.remove(this.set)
    }
});
AmCharts.AmBalloon = AmCharts.Class({
    construct: function () {
        this.enabled = !0;
        this.fillColor = "#CC0000";
        this.fillAlpha = 1;
        this.borderThickness = 2;
        this.borderColor = "#FFFFFF";
        this.borderAlpha = 1;
        this.cornerRadius = 6;
        this.maximumWidth = 220;
        this.horizontalPadding = 8;
        this.verticalPadding = 5;
        this.pointerWidth = 10;
        this.pointerOrientation = "V";
        this.color = "#FFFFFF";
        this.textShadowColor = "#000000";
        this.adjustBorderColor = !1;
        this.showBullet = !0;
        this.show = this.follow = !1;
        this.bulletSize = 3;
        this.textAlign = "middle"
    }, draw: function () {
        var a =
            this.pointToX, b = this.pointToY, c = this.textAlign;
        if (!isNaN(a)) {
            var d = this.chart, e = d.container, f = this.set;
            AmCharts.remove(f);
            AmCharts.remove(this.pointer);
            this.set = f = e.set();
            d.balloonsSet.push(f);
            if (this.show) {
                var g = this.l, h = this.t, k = this.r, l = this.b, m = this.textShadowColor;
                this.color == m && (m = void 0);
                var n = this.balloonColor, s = this.fillColor, q = this.borderColor;
                void 0 != n && (this.adjustBorderColor ? q = n : s = n);
                var t = this.horizontalPadding, n = this.verticalPadding, p = this.pointerWidth, r = this.pointerOrientation, u = this.cornerRadius,
                    v = d.fontFamily, w = this.fontSize;
                void 0 == w && (w = d.fontSize);
                d = AmCharts.text(e, this.text, this.color, v, w, c);
                f.push(d);
                var A;
                void 0 != m && (A = AmCharts.text(e, this.text, m, v, w, c, !1, 0.4), f.push(A));
                v = d.getBBox();
                m = v.height + 2 * n;
                v = v.width + 2 * t;
                window.opera && (m += 2);
                var x, w = w / 2 + n;
                switch (c) {
                    case "middle":
                        x = v / 2;
                        break;
                    case "left":
                        x = t;
                        break;
                    case "right":
                        x = v - t
                }
                d.translate(x, w);
                A && A.translate(x + 1, w + 1);
                "H" != r ? (x = a - v / 2, c = b < h + m + 10 && "down" != r ? b + p : b - m - p) : (2 * p > m && (p = m / 2), c = b - m / 2, x = a < g + (k - g) / 2 ? a + p : a - v - p);
                c + m >= l && (c = l - m);
                c < h &&
                (c = h);
                x < g && (x = g);
                x + v > k && (x = k - v);
                0 < u || 0 === p ? (q = AmCharts.rect(e, v, m, s, this.fillAlpha, this.borderThickness, q, this.borderAlpha, this.cornerRadius), this.showBullet && (e = AmCharts.circle(e, this.bulletSize, s, this.fillAlpha), e.translate(a, b), this.pointer = e)) : (l = [], u = [], "H" != r ? (g = a - x, g > v - p && (g = v - p), g < p && (g = p), l = [0, g - p, a - x, g + p, v, v, 0, 0], u = b < h + m + 10 && "down" != r ? [0, 0, b - c, 0, 0, m, m, 0] : [m, m, b - c, m, m, 0, 0, m]) : (h = b - c, h > m - p && (h = m - p), h < p && (h = p), u = [0, h - p, b - c, h + p, m, m, 0, 0], l = a < g + (k - g) / 2 ? [0, 0, x < a ? 0 : a - x, 0, 0, v, v, 0] : [v, v, x + v > a ? v : a -
                x, v, v, 0, 0, v]), q = AmCharts.polygon(e, l, u, s, this.fillAlpha, this.borderThickness, q, this.borderAlpha));
                f.push(q);
                q.toFront();
                A && A.toFront();
                d.toFront();
                a = 1;
                9 > AmCharts.IEversion && this.follow && (a = 6);
                f.translate(x - a, c);
                f = d.getBBox();
                this.bottom = c + f.y + f.height + 2 * n + 2;
                this.yPos = f.y + c
            }
        }
    }, followMouse: function () {
        if (this.follow && this.show) {
            var a = this.chart.mouseX, b = this.chart.mouseY - 3;
            this.pointToX = a;
            this.pointToY = b;
            if (a != this.previousX || b != this.previousY)if (this.previousX = a, this.previousY = b, 0 === this.cornerRadius)this.draw();
            else {
                var c = this.set;
                if (c) {
                    var d = c.getBBox(), a = a - d.width / 2, e = b - d.height - 10;
                    a < this.l && (a = this.l);
                    a > this.r - d.width && (a = this.r - d.width);
                    e < this.t && (e = b + 10);
                    c.translate(a, e)
                }
            }
        }
    }, changeColor: function (a) {
        this.balloonColor = a
    }, setBounds: function (a, b, c, d) {
        this.l = a;
        this.t = b;
        this.r = c;
        this.b = d
    }, showBalloon: function (a) {
        this.text = a;
        this.show = !0;
        this.draw()
    }, hide: function () {
        this.follow = this.show = !1;
        this.destroy()
    }, setPosition: function (a, b, c) {
        this.pointToX = a;
        this.pointToY = b;
        c && (a == this.previousX && b == this.previousY ||
        this.draw());
        this.previousX = a;
        this.previousY = b
    }, followCursor: function (a) {
        var b = this;
        (b.follow = a) ? (b.pShowBullet = b.showBullet, b.showBullet = !1) : void 0 !== b.pShowBullet && (b.showBullet = b.pShowBullet);
        clearInterval(b.interval);
        var c = b.chart.mouseX, d = b.chart.mouseY;
        !isNaN(c) && a && (b.pointToX = c, b.pointToY = d - 3, b.interval = setInterval(function () {
            b.followMouse.call(b)
        }, 40))
    }, destroy: function () {
        clearInterval(this.interval);
        AmCharts.remove(this.set);
        this.set = null;
        AmCharts.remove(this.pointer);
        this.pointer = null
    }
});
AmCharts.AmCoordinateChart = AmCharts.Class({
    inherits: AmCharts.AmChart, construct: function () {
        AmCharts.AmCoordinateChart.base.construct.call(this);
        this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph");
        this.plotAreaFillColors = "#FFFFFF";
        this.plotAreaFillAlphas = 0;
        this.plotAreaBorderColor = "#000000";
        this.plotAreaBorderAlpha = 0;
        this.startAlpha = 1;
        this.startDuration = 0;
        this.startEffect = "elastic";
        this.sequencedAnimation = !0;
        this.colors =
            "#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000".split(" ");
        this.balloonDateFormat = "MMM DD, YYYY";
        this.valueAxes = [];
        this.graphs = []
    }, initChart: function () {
        AmCharts.AmCoordinateChart.base.initChart.call(this);
        this.createValueAxes();
        AmCharts.VML && (this.startAlpha = 1);
        var a = this.legend;
        a && a.setData(this.graphs)
    }, createValueAxes: function () {
        if (0 === this.valueAxes.length) {
            var a = new AmCharts.ValueAxis;
            this.addValueAxis(a)
        }
    }, parseData: function () {
        this.processValueAxes();
        this.processGraphs()
    }, parseSerialData: function () {
        AmCharts.AmSerialChart.base.parseData.call(this);
        var a = this.graphs, b, c = {}, d = this.seriesIdField;
        d || (d = this.categoryField);
        this.chartData = [];
        var e = this.dataProvider;
        if (e) {
            var f = !1, g, h = this.categoryAxis;
            if (h) {
                var f = h.parseDates, k = h.forceShowField;
                g = h.categoryFunction
            }
            var l, m;
            f && (b = AmCharts.extractPeriod(h.minPeriod), l = b.period, m = b.count);
            var n = {};
            this.lookupTable = n;
            var s;
            for (s = 0; s < e.length; s++) {
                var q = {}, t = e[s];
                b = t[this.categoryField];
                q.category = g ? g(b,
                    t, h) : String(b);
                k && (q.forceShow = t[k]);
                n[t[d]] = q;
                f && (b = h.categoryFunction ? h.categoryFunction(b, t, h) : b instanceof Date ? "fff" == h.minPeriod ? AmCharts.useUTC ? new Date(b.getUTCFullYear(), b.getUTCMonth(), b.getUTCDate(), b.getUTCHours(), b.getUTCMinutes(), b.getUTCSeconds(), b.getUTCMilliseconds()) : new Date(b.getFullYear(), b.getMonth(), b.getDate(), b.getHours(), b.getMinutes(), b.getSeconds(), b.getMilliseconds()) : new Date(b) : new Date(b), b = AmCharts.resetDateToMin(b, l, m), q.category = b, q.time = b.getTime());
                var p = this.valueAxes;
                q.axes = {};
                q.x = {};
                var r;
                for (r = 0; r < p.length; r++) {
                    var u = p[r].id;
                    q.axes[u] = {};
                    q.axes[u].graphs = {};
                    var v;
                    for (v = 0; v < a.length; v++) {
                        b = a[v];
                        var w = b.id, A = b.periodValue;
                        if (b.valueAxis.id == u) {
                            q.axes[u].graphs[w] = {};
                            var x = {};
                            x.index = s;
                            b.dataProvider && (t = c);
                            x.values = this.processValues(t, b, A);
                            this.processFields(b, x, t);
                            x.category = q.category;
                            x.serialDataItem = q;
                            x.graph = b;
                            q.axes[u].graphs[w] = x
                        }
                    }
                }
                this.chartData[s] = q
            }
        }
        for (c = 0; c < a.length; c++)b = a[c], b.dataProvider && this.parseGraphData(b)
    }, processValues: function (a, b, c) {
        var d =
        {}, e, f = !1;
        "candlestick" != b.type && "ohlc" != b.type || "" === c || (f = !0);
        e = Number(a[b.valueField + c]);
        isNaN(e) || (d.value = e);
        f && (c = "Open");
        e = Number(a[b.openField + c]);
        isNaN(e) || (d.open = e);
        f && (c = "Close");
        e = Number(a[b.closeField + c]);
        isNaN(e) || (d.close = e);
        f && (c = "Low");
        e = Number(a[b.lowField + c]);
        isNaN(e) || (d.low = e);
        f && (c = "High");
        e = Number(a[b.highField + c]);
        isNaN(e) || (d.high = e);
        return d
    }, parseGraphData: function (a) {
        var b = a.dataProvider, c = a.seriesIdField;
        c || (c = this.seriesIdField);
        c || (c = this.categoryField);
        var d;
        for (d =
                 0; d < b.length; d++) {
            var e = b[d], f = this.lookupTable[String(e[c])], g = a.valueAxis.id;
            f && (g = f.axes[g].graphs[a.id], g.serialDataItem = f, g.values = this.processValues(e, a, a.periodValue), this.processFields(a, g, e))
        }
    }, addValueAxis: function (a) {
        a.chart = this;
        this.valueAxes.push(a);
        this.validateData()
    }, removeValueAxesAndGraphs: function () {
        var a = this.valueAxes, b;
        for (b = a.length - 1; -1 < b; b--)this.removeValueAxis(a[b])
    }, removeValueAxis: function (a) {
        var b = this.graphs, c;
        for (c = b.length - 1; 0 <= c; c--) {
            var d = b[c];
            d && d.valueAxis == a &&
            this.removeGraph(d)
        }
        b = this.valueAxes;
        for (c = b.length - 1; 0 <= c; c--)b[c] == a && b.splice(c, 1);
        this.validateData()
    }, addGraph: function (a) {
        this.graphs.push(a);
        this.chooseGraphColor(a, this.graphs.length - 1);
        this.validateData()
    }, removeGraph: function (a) {
        var b = this.graphs, c;
        for (c = b.length - 1; 0 <= c; c--)b[c] == a && (b.splice(c, 1), a.destroy());
        this.validateData()
    }, processValueAxes: function () {
        var a = this.valueAxes, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.chart = this;
            c.id || (c.id = "valueAxis" + b + "_" + (new Date).getTime());
            if (!0 ===
                this.usePrefixes || !1 === this.usePrefixes)c.usePrefixes = this.usePrefixes
        }
    }, processGraphs: function () {
        var a = this.graphs, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.chart = this;
            c.valueAxis || (c.valueAxis = this.valueAxes[0]);
            c.id || (c.id = "graph" + b + "_" + (new Date).getTime())
        }
    }, formatString: function (a, b) {
        var c = b.graph, d = c.valueAxis;
        d.duration && b.values.value && (d = AmCharts.formatDuration(b.values.value, d.duration, "", d.durationUnits, d.maxInterval, d.numberFormatter), a = a.split("[[value]]").join(d));
        a = AmCharts.massReplace(a,
            {"[[title]]": c.title, "[[description]]": b.description, "<br>": "\n"});
        a = AmCharts.fixNewLines(a);
        return a = AmCharts.cleanFromEmpty(a)
    }, getBalloonColor: function (a, b) {
        var c = a.lineColor, d = a.balloonColor, e = a.fillColors;
        "object" == typeof e ? c = e[0] : void 0 !== e && (c = e);
        if (b.isNegative) {
            var e = a.negativeLineColor, f = a.negativeFillColors;
            "object" == typeof f ? e = f[0] : void 0 !== f && (e = f);
            void 0 !== e && (c = e)
        }
        void 0 !== b.color && (c = b.color);
        void 0 === d && (d = c);
        return d
    }, getGraphById: function (a) {
        return this.getObjById(this.graphs, a)
    },
    getValueAxisById: function (a) {
        return this.getObjById(this.valueAxes, a)
    }, getObjById: function (a, b) {
        var c, d;
        for (d = 0; d < a.length; d++) {
            var e = a[d];
            e.id == b && (c = e)
        }
        return c
    }, processFields: function (a, b, c) {
        if (a.itemColors) {
            var d = a.itemColors, e = b.index;
            b.color = e < d.length ? d[e] : AmCharts.randomColor()
        }
        d = "lineColor color alpha fillColors description bullet customBullet bulletSize bulletConfig url labelColor".split(" ");
        for (e = 0; e < d.length; e++) {
            var f = d[e], g = a[f + "Field"];
            g && (g = c[g], AmCharts.isDefined(g) && (b[f] = g))
        }
        b.dataContext =
            c
    }, chooseGraphColor: function (a, b) {
        if (void 0 == a.lineColor) {
            var c;
            c = this.colors.length > b ? this.colors[b] : AmCharts.randomColor();
            a.lineColor = c
        }
    }, handleLegendEvent: function (a) {
        var b = a.type;
        if (a = a.dataItem) {
            var c = a.hidden, d = a.showBalloon;
            switch (b) {
                case "clickMarker":
                    d ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a);
                    break;
                case "clickLabel":
                    d ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a);
                    break;
                case "rollOverItem":
                    c || this.highlightGraph(a);
                    break;
                case "rollOutItem":
                    c || this.unhighlightGraph();
                    break;
                case "hideItem":
                    this.hideGraph(a);
                    break;
                case "showItem":
                    this.showGraph(a)
            }
        }
    }, highlightGraph: function (a) {
        var b = this.graphs, c, d = 0.2;
        this.legend && (d = this.legend.rollOverGraphAlpha);
        if (1 != d)for (c = 0; c < b.length; c++) {
            var e = b[c];
            e != a && e.changeOpacity(d)
        }
    }, unhighlightGraph: function () {
        var a;
        this.legend && (a = this.legend.rollOverGraphAlpha);
        if (1 != a) {
            a = this.graphs;
            var b;
            for (b = 0; b < a.length; b++)a[b].changeOpacity(1)
        }
    }, showGraph: function (a) {
        a.hidden = !1;
        this.dataChanged = !0;
        this.marginsUpdated = !1;
        this.chartCreated &&
        this.initChart()
    }, hideGraph: function (a) {
        this.dataChanged = !0;
        this.marginsUpdated = !1;
        a.hidden = !0;
        this.chartCreated && this.initChart()
    }, hideGraphsBalloon: function (a) {
        a.showBalloon = !1;
        this.updateLegend()
    }, showGraphsBalloon: function (a) {
        a.showBalloon = !0;
        this.updateLegend()
    }, updateLegend: function () {
        this.legend && this.legend.invalidateSize()
    }, resetAnimation: function () {
        var a = this.graphs;
        if (a) {
            var b;
            for (b = 0; b < a.length; b++)a[b].animationPlayed = !1
        }
    }, animateAgain: function () {
        this.resetAnimation();
        this.validateNow()
    }
});
AmCharts.AmRectangularChart = AmCharts.Class({
    inherits: AmCharts.AmCoordinateChart, construct: function () {
        AmCharts.AmRectangularChart.base.construct.call(this);
        this.createEvents("zoomed");
        this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 20;
        this.verticalPosition = this.horizontalPosition = this.depth3D = this.angle = 0;
        this.heightMultiplier = this.widthMultiplier = 1;
        this.zoomOutText = "Show all";
        this.zoomOutButton = {backgroundColor: "#b2e1ff", backgroundAlpha: 1};
        this.trendLines = [];
        this.autoMargins = !0;
        this.marginsUpdated = !1;
        this.autoMarginOffset = 10
    }, initChart: function () {
        AmCharts.AmRectangularChart.base.initChart.call(this);
        this.updateDxy();
        var a = !0;
        !this.marginsUpdated && this.autoMargins && (this.resetMargins(), a = !1);
        this.updateMargins();
        this.updatePlotArea();
        this.updateScrollbars();
        this.updateTrendLines();
        this.updateChartCursor();
        this.updateValueAxes();
        a && (this.scrollbarOnly || this.updateGraphs())
    }, drawChart: function () {
        AmCharts.AmRectangularChart.base.drawChart.call(this);
        this.drawPlotArea();
        if (AmCharts.ifArray(this.chartData)) {
            var a =
                this.chartCursor;
            a && a.draw();
            a = this.zoomOutText;
            "" !== a && a && this.drawZoomOutButton()
        }
    }, resetMargins: function () {
        var a = {}, b;
        if ("serial" == this.chartType) {
            var c = this.valueAxes;
            for (b = 0; b < c.length; b++) {
                var d = c[b];
                d.ignoreAxisWidth || (d.setOrientation(this.rotate), d.fixAxisPosition(), a[d.position] = !0)
            }
            (b = this.categoryAxis) && !b.ignoreAxisWidth && (b.setOrientation(!this.rotate), b.fixAxisPosition(), b.fixAxisPosition(), a[b.position] = !0)
        } else {
            d = this.xAxes;
            c = this.yAxes;
            for (b = 0; b < d.length; b++) {
                var e = d[b];
                e.ignoreAxisWidth ||
                (e.setOrientation(!0), e.fixAxisPosition(), a[e.position] = !0)
            }
            for (b = 0; b < c.length; b++)d = c[b], d.ignoreAxisWidth || (d.setOrientation(!1), d.fixAxisPosition(), a[d.position] = !0)
        }
        a.left && (this.marginLeft = 0);
        a.right && (this.marginRight = 0);
        a.top && (this.marginTop = 0);
        a.bottom && (this.marginBottom = 0);
        this.fixMargins = a
    }, measureMargins: function () {
        var a = this.valueAxes, b, c = this.autoMarginOffset, d = this.fixMargins, e = this.realWidth, f = this.realHeight, g = c, h = c, k = e - c;
        b = f - c;
        var l;
        for (l = 0; l < a.length; l++)b = this.getAxisBounds(a[l],
            g, k, h, b), g = b.l, k = b.r, h = b.t, b = b.b;
        if (a = this.categoryAxis)b = this.getAxisBounds(a, g, k, h, b), g = b.l, k = b.r, h = b.t, b = b.b;
        d.left && g < c && (this.marginLeft = Math.round(-g + c));
        d.right && k > e - c && (this.marginRight = Math.round(k - e + c));
        d.top && h < c + this.titleHeight && (this.marginTop = Math.round(this.marginTop - h + c + this.titleHeight));
        d.bottom && b > f - c && (this.marginBottom = Math.round(b - f + c));
        this.initChart()
    }, getAxisBounds: function (a, b, c, d, e) {
        if (!a.ignoreAxisWidth) {
            var f = a.labelsSet, g = a.tickLength;
            a.inside && (g = 0);
            if (f)switch (f = a.getBBox(),
                a.position) {
                case "top":
                    a = f.y;
                    d > a && (d = a);
                    break;
                case "bottom":
                    a = f.y + f.height;
                    e < a && (e = a);
                    break;
                case "right":
                    a = f.x + f.width + g + 3;
                    c < a && (c = a);
                    break;
                case "left":
                    a = f.x - g, b > a && (b = a)
            }
        }
        return {l: b, t: d, r: c, b: e}
    }, drawZoomOutButton: function () {
        var a = this, b = a.container.set();
        a.zoomButtonSet.push(b);
        var c = a.color, d = a.fontSize, e = a.zoomOutButton;
        e && (e.fontSize && (d = e.fontSize), e.color && (c = e.color));
        c = AmCharts.text(a.container, a.zoomOutText, c, a.fontFamily, d, "start");
        d = c.getBBox();
        c.translate(29, 6 + d.height / 2);
        e = AmCharts.rect(a.container,
            d.width + 40, d.height + 15, e.backgroundColor, e.backgroundAlpha);
        b.push(e);
        a.zbBG = e;
        void 0 !== a.pathToImages && (e = a.container.image(a.pathToImages + "lens.png", 0, 0, 16, 16), e.translate(7, d.height / 2 - 1), e.toFront(), b.push(e));
        c.toFront();
        b.push(c);
        e = b.getBBox();
        b.translate(a.marginLeftReal + a.plotAreaWidth - e.width, a.marginTopReal);
        b.hide();
        b.mouseover(function () {
            a.rollOverZB()
        }).mouseout(function () {
            a.rollOutZB()
        }).click(function () {
            a.clickZB()
        }).touchstart(function () {
            a.rollOverZB()
        }).touchend(function () {
            a.rollOutZB();
            a.clickZB()
        });
        for (e = 0; e < b.length; e++)b[e].attr({cursor: "pointer"});
        a.zbSet = b
    }, rollOverZB: function () {
        this.zbBG.show()
    }, rollOutZB: function () {
        this.zbBG.hide()
    }, clickZB: function () {
        this.zoomOut()
    }, zoomOut: function () {
        this.updateScrollbar = !0;
        this.zoom()
    }, drawPlotArea: function () {
        var a = this.dx, b = this.dy, c = this.marginLeftReal, d = this.marginTopReal, e = this.plotAreaWidth - 1, f = this.plotAreaHeight - 1, g = this.plotAreaFillColors, h = this.plotAreaFillAlphas, k = this.plotAreaBorderColor, l = this.plotAreaBorderAlpha;
        this.trendLinesSet.clipRect(c,
            d, e, f);
        "object" == typeof h && (h = h[0]);
        g = AmCharts.polygon(this.container, [0, e, e, 0], [0, 0, f, f], g, h, 1, k, l, this.plotAreaGradientAngle);
        g.translate(c + a, d + b);
        g.node.setAttribute("class", "amChartsPlotArea");
        this.set.push(g);
        0 !== a && 0 !== b && (g = this.plotAreaFillColors, "object" == typeof g && (g = g[0]), g = AmCharts.adjustLuminosity(g, -0.15), e = AmCharts.polygon(this.container, [0, a, e + a, e, 0], [0, b, b, 0, 0], g, h, 1, k, l), e.translate(c, d + f), this.set.push(e), a = AmCharts.polygon(this.container, [0, 0, a, a, 0], [0, f, f + b, b, 0], g, h, 1, k, l), a.translate(c,
            d), this.set.push(a))
    }, updatePlotArea: function () {
        var a = this.updateWidth(), b = this.updateHeight(), c = this.container;
        this.realWidth = a;
        this.realWidth = b;
        c && this.container.setSize(a, b);
        a = a - this.marginLeftReal - this.marginRightReal - this.dx;
        b = b - this.marginTopReal - this.marginBottomReal;
        1 > a && (a = 1);
        1 > b && (b = 1);
        this.plotAreaWidth = Math.round(a);
        this.plotAreaHeight = Math.round(b)
    }, updateDxy: function () {
        this.dx = Math.round(this.depth3D * Math.cos(this.angle * Math.PI / 180));
        this.dy = Math.round(-this.depth3D * Math.sin(this.angle *
                Math.PI / 180));
        this.d3x = Math.round(this.columnSpacing3D * Math.cos(this.angle * Math.PI / 180));
        this.d3y = Math.round(-this.columnSpacing3D * Math.sin(this.angle * Math.PI / 180))
    }, updateMargins: function () {
        var a = this.getTitleHeight();
        this.titleHeight = a;
        this.marginTopReal = this.marginTop - this.dy + a;
        this.marginBottomReal = this.marginBottom;
        this.marginLeftReal = this.marginLeft;
        this.marginRightReal = this.marginRight
    }, updateValueAxes: function () {
        var a = this.valueAxes, b = this.marginLeftReal, c = this.marginTopReal, d = this.plotAreaHeight,
            e = this.plotAreaWidth, f;
        for (f = 0; f < a.length; f++) {
            var g = a[f];
            g.axisRenderer = AmCharts.RecAxis;
            g.guideFillRenderer = AmCharts.RecFill;
            g.axisItemRenderer = AmCharts.RecItem;
            g.dx = this.dx;
            g.dy = this.dy;
            g.viW = e - 1;
            g.viH = d - 1;
            g.marginsChanged = !0;
            g.viX = b;
            g.viY = c;
            this.updateObjectSize(g)
        }
    }, updateObjectSize: function (a) {
        a.width = (this.plotAreaWidth - 1) * this.widthMultiplier;
        a.height = (this.plotAreaHeight - 1) * this.heightMultiplier;
        a.x = this.marginLeftReal + this.horizontalPosition;
        a.y = this.marginTopReal + this.verticalPosition
    },
    updateGraphs: function () {
        var a = this.graphs, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.x = this.marginLeftReal + this.horizontalPosition;
            c.y = this.marginTopReal + this.verticalPosition;
            c.width = this.plotAreaWidth * this.widthMultiplier;
            c.height = this.plotAreaHeight * this.heightMultiplier;
            c.index = b;
            c.dx = this.dx;
            c.dy = this.dy;
            c.rotate = this.rotate;
            c.chartType = this.chartType
        }
    }, updateChartCursor: function () {
        var a = this.chartCursor;
        a && (a.x = this.marginLeftReal, a.y = this.marginTopReal, a.width = this.plotAreaWidth - 1, a.height = this.plotAreaHeight -
            1, a.chart = this)
    }, updateScrollbars: function () {
    }, addChartCursor: function (a) {
        AmCharts.callMethod("destroy", [this.chartCursor]);
        a && (this.listenTo(a, "changed", this.handleCursorChange), this.listenTo(a, "zoomed", this.handleCursorZoom));
        this.chartCursor = a
    }, removeChartCursor: function () {
        AmCharts.callMethod("destroy", [this.chartCursor]);
        this.chartCursor = null
    }, zoomTrendLines: function () {
        var a = this.trendLines, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.valueAxis.recalculateToPercents ? c.set && c.set.hide() : (c.x = this.marginLeftReal +
                this.horizontalPosition, c.y = this.marginTopReal + this.verticalPosition, c.draw())
        }
    }, addTrendLine: function (a) {
        this.trendLines.push(a)
    }, removeTrendLine: function (a) {
        var b = this.trendLines, c;
        for (c = b.length - 1; 0 <= c; c--)b[c] == a && b.splice(c, 1)
    }, adjustMargins: function (a, b) {
        var c = a.scrollbarHeight;
        "top" == a.position ? b ? this.marginLeftReal += c : this.marginTopReal += c : b ? this.marginRightReal += c : this.marginBottomReal += c
    }, getScrollbarPosition: function (a, b, c) {
        a.position = b ? "bottom" == c || "left" == c ? "bottom" : "top" : "top" == c || "right" ==
        c ? "bottom" : "top"
    }, updateChartScrollbar: function (a, b) {
        if (a) {
            a.rotate = b;
            var c = this.marginTopReal, d = this.marginLeftReal, e = a.scrollbarHeight, f = this.dx, g = this.dy;
            "top" == a.position ? b ? (a.y = c, a.x = d - e) : (a.y = c - e + g, a.x = d + f) : b ? (a.y = c + g, a.x = d + this.plotAreaWidth + f) : (a.y = c + this.plotAreaHeight + 1, a.x = this.marginLeftReal)
        }
    }, showZB: function (a) {
        var b = this.zbSet;
        b && (a ? b.show() : b.hide(), this.zbBG.hide())
    }, handleReleaseOutside: function (a) {
        AmCharts.AmRectangularChart.base.handleReleaseOutside.call(this, a);
        (a = this.chartCursor) &&
        a.handleReleaseOutside()
    }, handleMouseDown: function (a) {
        AmCharts.AmRectangularChart.base.handleMouseDown.call(this, a);
        var b = this.chartCursor;
        b && b.handleMouseDown(a)
    }, handleCursorChange: function (a) {
    }
});
AmCharts.TrendLine = AmCharts.Class({
    construct: function () {
        this.createEvents("click");
        this.isProtected = !1;
        this.dashLength = 0;
        this.lineColor = "#00CC00";
        this.lineThickness = this.lineAlpha = 1
    }, draw: function () {
        var a = this;
        a.destroy();
        var b = a.chart, c = b.container, d, e, f, g, h = a.categoryAxis, k = a.initialDate, l = a.initialCategory, m = a.finalDate, n = a.finalCategory, s = a.valueAxis, q = a.valueAxisX, t = a.initialXValue, p = a.finalXValue, r = a.initialValue, u = a.finalValue, v = s.recalculateToPercents;
        h && (k && (d = h.dateToCoordinate(k)), l && (d =
            h.categoryToCoordinate(l)), m && (e = h.dateToCoordinate(m)), n && (e = h.categoryToCoordinate(n)));
        q && !v && (isNaN(t) || (d = q.getCoordinate(t)), isNaN(p) || (e = q.getCoordinate(p)));
        s && !v && (isNaN(r) || (f = s.getCoordinate(r)), isNaN(u) || (g = s.getCoordinate(u)));
        isNaN(d) || (isNaN(e) || isNaN(f) || isNaN(f)) || (b.rotate ? (h = [f, g], e = [d, e]) : (h = [d, e], e = [f, g]), f = a.lineColor, d = AmCharts.line(c, h, e, f, a.lineAlpha, a.lineThickness, a.dashLength), e = AmCharts.line(c, h, e, f, 0.005, 5), c = c.set([d, e]), c.translate(b.marginLeftReal, b.marginTopReal),
            b.trendLinesSet.push(c), a.line = d, a.set = c, e.mouseup(function () {
            a.handleLineClick()
        }).mouseover(function () {
            a.handleLineOver()
        }).mouseout(function () {
            a.handleLineOut()
        }), e.touchend && e.touchend(function () {
            a.handleLineClick()
        }))
    }, handleLineClick: function () {
        var a = {type: "click", trendLine: this, chart: this.chart};
        this.fire(a.type, a)
    }, handleLineOver: function () {
        var a = this.rollOverColor;
        void 0 !== a && this.line.attr({stroke: a})
    }, handleLineOut: function () {
        this.line.attr({stroke: this.lineColor})
    }, destroy: function () {
        AmCharts.remove(this.set)
    }
});
AmCharts.AmSerialChart = AmCharts.Class({
    inherits: AmCharts.AmRectangularChart, construct: function () {
        AmCharts.AmSerialChart.base.construct.call(this);
        this.createEvents("changed");
        this.columnSpacing = 5;
        this.columnSpacing3D = 0;
        this.columnWidth = 0.8;
        this.updateScrollbar = !0;
        var a = new AmCharts.CategoryAxis;
        a.chart = this;
        this.categoryAxis = a;
        this.chartType = "serial";
        this.zoomOutOnDataUpdate = !0;
        this.skipZoom = !1;
        this.minSelectedTime = 0
    }, initChart: function () {
        AmCharts.AmSerialChart.base.initChart.call(this);
        this.updateCategoryAxis();
        this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
        var a = this.chartCursor;
        a && a.updateData();
        var a = this.countColumns(), b = this.graphs, c;
        for (c = 0; c < b.length; c++)b[c].columnCount = a;
        this.updateScrollbar = !0;
        this.drawChart();
        this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins())
    }, validateData: function (a) {
        this.marginsUpdated = !1;
        this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN);
        AmCharts.AmSerialChart.base.validateData.call(this)
    },
    drawChart: function () {
        AmCharts.AmSerialChart.base.drawChart.call(this);
        var a = this.chartData;
        if (AmCharts.ifArray(a)) {
            var b = this.chartScrollbar;
            b && b.draw();
            if (0 < this.realWidth && 0 < this.realHeight) {
                var a = a.length - 1, c, b = this.categoryAxis;
                if (b.parseDates && !b.equalSpacing) {
                    if (b = this.startTime, c = this.endTime, isNaN(b) || isNaN(c))b = this.firstTime, c = this.lastTime
                } else if (b = this.start, c = this.end, isNaN(b) || isNaN(c))b = 0, c = a;
                this.endTime = this.startTime = this.end = this.start = void 0;
                this.zoom(b, c)
            }
        } else this.cleanChart();
        this.dispDUpd();
        this.chartCreated = !0
    }, cleanChart: function () {
        AmCharts.callMethod("destroy", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor])
    }, updateCategoryAxis: function () {
        var a = this.categoryAxis;
        a.id = "categoryAxis";
        a.rotate = this.rotate;
        a.axisRenderer = AmCharts.RecAxis;
        a.guideFillRenderer = AmCharts.RecFill;
        a.axisItemRenderer = AmCharts.RecItem;
        a.setOrientation(!this.rotate);
        a.x = this.marginLeftReal;
        a.y = this.marginTopReal;
        a.dx = this.dx;
        a.dy = this.dy;
        a.width = this.plotAreaWidth -
            1;
        a.height = this.plotAreaHeight - 1;
        a.viW = this.plotAreaWidth - 1;
        a.viH = this.plotAreaHeight - 1;
        a.viX = this.marginLeftReal;
        a.viY = this.marginTopReal;
        a.marginsChanged = !0
    }, updateValueAxes: function () {
        AmCharts.AmSerialChart.base.updateValueAxes.call(this);
        var a = this.valueAxes, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b], d = this.rotate;
            c.rotate = d;
            c.setOrientation(d);
            d = this.categoryAxis;
            if (!d.startOnAxis || d.parseDates)c.expandMinMax = !0
        }
    }, updateData: function () {
        this.parseData();
        var a = this.graphs, b, c = this.chartData;
        for (b = 0; b <
        a.length; b++)a[b].data = c;
        0 < c.length && (this.firstTime = this.getStartTime(c[0].time), this.lastTime = this.getEndTime(c[c.length - 1].time))
    }, getStartTime: function (a) {
        var b = this.categoryAxis;
        return AmCharts.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime()
    }, getEndTime: function (a) {
        var b = AmCharts.extractPeriod(this.categoryAxis.minPeriod);
        return AmCharts.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1
    }, updateMargins: function () {
        AmCharts.AmSerialChart.base.updateMargins.call(this);
        var a = this.chartScrollbar;
        a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate))
    }, updateScrollbars: function () {
        this.updateChartScrollbar(this.chartScrollbar, this.rotate)
    }, zoom: function (a, b) {
        var c = this.categoryAxis;
        c.parseDates && !c.equalSpacing ? this.timeZoom(a, b) : this.indexZoom(a, b)
    }, timeZoom: function (a, b) {
        var c = this.maxSelectedTime;
        isNaN(c) || (b != this.endTime && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.startTime && b - a > c && (b = a + c, this.updateScrollbar = !0));
        var d = this.minSelectedTime;
        if (0 < d && b - a < d) {
            var e = Math.round(a + (b - a) / 2), d = Math.round(d / 2);
            a = e - d;
            b = e + d
        }
        var f = this.chartData, e = this.categoryAxis;
        if (AmCharts.ifArray(f) && (a != this.startTime || b != this.endTime)) {
            var g = e.minDuration(), d = this.firstTime, h = this.lastTime;
            a || (a = d, isNaN(c) || (a = h - c));
            b || (b = h);
            a > h && (a = h);
            b < d && (b = d);
            a < d && (a = d);
            b > h && (b = h);
            b < a && (b = a + g);
            b - a < g / 5 && (b < h ? b = a + g / 5 : a = b - g / 5);
            this.startTime = a;
            this.endTime = b;
            c = f.length - 1;
            g = this.getClosestIndex(f, "time", a, !0, 0, c);
            f = this.getClosestIndex(f, "time",
                b, !1, g, c);
            e.timeZoom(a, b);
            e.zoom(g, f);
            this.start = AmCharts.fitToBounds(g, 0, c);
            this.end = AmCharts.fitToBounds(f, 0, c);
            this.zoomAxesAndGraphs();
            this.zoomScrollbar();
            a != d || b != h ? this.showZB(!0) : this.showZB(!1);
            this.updateColumnsDepth();
            this.dispatchTimeZoomEvent()
        }
    }, indexZoom: function (a, b) {
        var c = this.maxSelectedSeries;
        isNaN(c) || (b != this.end && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.start && b - a > c && (b = a + c, this.updateScrollbar = !0));
        if (a != this.start || b != this.end) {
            var d = this.chartData.length - 1;
            isNaN(a) &&
            (a = 0, isNaN(c) || (a = d - c));
            isNaN(b) && (b = d);
            b < a && (b = a);
            b > d && (b = d);
            a > d && (a = d - 1);
            0 > a && (a = 0);
            this.start = a;
            this.end = b;
            this.categoryAxis.zoom(a, b);
            this.zoomAxesAndGraphs();
            this.zoomScrollbar();
            0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1);
            this.updateColumnsDepth();
            this.dispatchIndexZoomEvent()
        }
    }, updateGraphs: function () {
        AmCharts.AmSerialChart.base.updateGraphs.call(this);
        var a = this.graphs, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.columnWidth = this.columnWidth;
            c.categoryAxis = this.categoryAxis
        }
    },
    updateColumnsDepth: function () {
        var a, b = this.graphs, c;
        AmCharts.remove(this.columnsSet);
        this.columnsArray = [];
        for (a = 0; a < b.length; a++) {
            c = b[a];
            var d = c.columnsArray;
            if (d) {
                var e;
                for (e = 0; e < d.length; e++)this.columnsArray.push(d[e])
            }
        }
        this.columnsArray.sort(this.compareDepth);
        if (0 < this.columnsArray.length) {
            b = this.container.set();
            this.columnSet.push(b);
            for (a = 0; a < this.columnsArray.length; a++)b.push(this.columnsArray[a].column.set);
            c && b.translate(c.x, c.y);
            this.columnsSet = b
        }
    }, compareDepth: function (a, b) {
        return a.depth >
        b.depth ? 1 : -1
    }, zoomScrollbar: function () {
        var a = this.chartScrollbar, b = this.categoryAxis;
        a && this.updateScrollbar && (b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end), this.updateScrollbar = !0)
    }, updateTrendLines: function () {
        var a = this.trendLines, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.chart = this;
            c.valueAxis || (c.valueAxis = this.valueAxes[0]);
            c.categoryAxis = this.categoryAxis
        }
    }, zoomAxesAndGraphs: function () {
        if (!this.scrollbarOnly) {
            var a = this.valueAxes, b;
            for (b = 0; b <
            a.length; b++)a[b].zoom(this.start, this.end);
            a = this.graphs;
            for (b = 0; b < a.length; b++)a[b].zoom(this.start, this.end);
            this.zoomTrendLines();
            (b = this.chartCursor) && b.zoom(this.start, this.end, this.startTime, this.endTime)
        }
    }, countColumns: function () {
        var a = 0, b = this.valueAxes.length, c = this.graphs.length, d, e, f = !1, g, h;
        for (h = 0; h < b; h++) {
            e = this.valueAxes[h];
            var k = e.stackType;
            if ("100%" == k || "regular" == k)for (f = !1, g = 0; g < c; g++)d = this.graphs[g], d.hidden || (d.valueAxis != e || "column" != d.type) || (!f && d.stackable && (a++, f = !0), d.stackable ||
            a++, d.columnIndex = a - 1);
            if ("none" == k || "3d" == k)for (g = 0; g < c; g++)d = this.graphs[g], d.hidden || (d.valueAxis != e || "column" != d.type) || (d.columnIndex = a, a++);
            if ("3d" == k) {
                for (h = 0; h < c; h++)d = this.graphs[h], d.depthCount = a;
                a = 1
            }
        }
        return a
    }, parseData: function () {
        AmCharts.AmSerialChart.base.parseData.call(this);
        this.parseSerialData()
    }, getCategoryIndexByValue: function (a) {
        var b = this.chartData, c, d;
        for (d = 0; d < b.length; d++)b[d].category == a && (c = d);
        return c
    }, handleCursorChange: function (a) {
        this.updateLegendValues(a.index)
    }, handleCursorZoom: function (a) {
        this.updateScrollbar = !0;
        this.zoom(a.start, a.end)
    }, handleScrollbarZoom: function (a) {
        this.updateScrollbar = !1;
        this.zoom(a.start, a.end)
    }, dispatchTimeZoomEvent: function () {
        if (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime) {
            var a = {type: "zoomed"};
            a.startDate = new Date(this.startTime);
            a.endDate = new Date(this.endTime);
            a.startIndex = this.start;
            a.endIndex = this.end;
            this.startIndex = this.start;
            this.endIndex = this.end;
            this.startDate = a.startDate;
            this.endDate = a.endDate;
            this.prevStartTime = this.startTime;
            this.prevEndTime =
                this.endTime;
            var b = this.categoryAxis, c = AmCharts.extractPeriod(b.minPeriod).period, b = b.dateFormatsObject[c];
            a.startValue = AmCharts.formatDate(a.startDate, b);
            a.endValue = AmCharts.formatDate(a.endDate, b);
            a.chart = this;
            a.target = this;
            this.fire(a.type, a)
        }
    }, dispatchIndexZoomEvent: function () {
        if (this.prevStartIndex != this.start || this.prevEndIndex != this.end) {
            this.startIndex = this.start;
            this.endIndex = this.end;
            var a = this.chartData;
            if (AmCharts.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {
                var b = {
                    chart: this, target: this,
                    type: "zoomed"
                };
                b.startIndex = this.start;
                b.endIndex = this.end;
                b.startValue = a[this.start].category;
                b.endValue = a[this.end].category;
                this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));
                this.prevStartIndex = this.start;
                this.prevEndIndex = this.end;
                this.fire(b.type, b)
            }
        }
    }, updateLegendValues: function (a) {
        var b = this.graphs, c;
        for (c = 0; c < b.length; c++) {
            var d = b[c];
            isNaN(a) ? d.currentDataItem = void 0 : d.currentDataItem =
                this.chartData[a].axes[d.valueAxis.id].graphs[d.id]
        }
        this.legend && this.legend.updateValues()
    }, getClosestIndex: function (a, b, c, d, e, f) {
        0 > e && (e = 0);
        f > a.length - 1 && (f = a.length - 1);
        var g = e + Math.round((f - e) / 2), h = a[g][b];
        if (1 >= f - e) {
            if (d)return e;
            d = a[f][b];
            return Math.abs(a[e][b] - c) < Math.abs(d - c) ? e : f
        }
        return c == h ? g : c < h ? this.getClosestIndex(a, b, c, d, e, g) : this.getClosestIndex(a, b, c, d, g, f)
    }, zoomToIndexes: function (a, b) {
        this.updateScrollbar = !0;
        var c = this.chartData;
        if (c) {
            var d = c.length;
            0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1),
                d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b))
        }
    }, zoomToDates: function (a, b) {
        this.updateScrollbar = !0;
        var c = this.chartData;
        if (this.categoryAxis.equalSpacing) {
            var d = this.getClosestIndex(c, "time", a.getTime(), !0, 0, c.length), c = this.getClosestIndex(c, "time", b.getTime(), !1, 0, c.length);
            this.zoom(d, c)
        } else this.zoom(a.getTime(), b.getTime())
    }, zoomToCategoryValues: function (a, b) {
        this.updateScrollbar = !0;
        this.zoom(this.getCategoryIndexByValue(a),
            this.getCategoryIndexByValue(b))
    }, formatString: function (a, b) {
        var c = b.graph;
        if (-1 != a.indexOf("[[category]]")) {
            var d = b.serialDataItem.category;
            if (this.categoryAxis.parseDates) {
                var e = this.balloonDateFormat, f = this.chartCursor;
                f && (e = f.categoryBalloonDateFormat);
                -1 != a.indexOf("[[category]]") && (e = AmCharts.formatDate(d, e), -1 != e.indexOf("fff") && (e = AmCharts.formatMilliseconds(e, d)), d = e)
            }
            a = a.replace(/\[\[category\]\]/g, String(d))
        }
        c = c.numberFormatter;
        c || (c = this.numberFormatter);
        d = b.graph.valueAxis;
        (e = d.duration) && !isNaN(b.values.value) && (d = AmCharts.formatDuration(b.values.value, e, "", d.durationUnits, d.maxInterval, c), a = a.replace(RegExp("\\[\\[value\\]\\]", "g"), d));
        d = "value open low high close total".split(" ");
        e = this.percentFormatter;
        a = AmCharts.formatValue(a, b.percents, d, e, "percents\\.");
        a = AmCharts.formatValue(a, b.values, d, c, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
        a = AmCharts.formatValue(a, b.values, ["percents"], e);
        -1 != a.indexOf("[[") && (a = AmCharts.formatDataContextValue(a, b.dataContext));
        return a = AmCharts.AmSerialChart.base.formatString.call(this, a, b)
    }, addChartScrollbar: function (a) {
        AmCharts.callMethod("destroy", [this.chartScrollbar]);
        a && (a.chart = this, this.listenTo(a, "zoomed", this.handleScrollbarZoom));
        this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight);
        this.chartScrollbar = a
    }, removeChartScrollbar: function () {
        AmCharts.callMethod("destroy", [this.chartScrollbar]);
        this.chartScrollbar = null
    }, handleReleaseOutside: function (a) {
        AmCharts.AmSerialChart.base.handleReleaseOutside.call(this,
            a);
        AmCharts.callMethod("handleReleaseOutside", [this.chartScrollbar])
    }
});
AmCharts.AmRadarChart = AmCharts.Class({
    inherits: AmCharts.AmCoordinateChart, construct: function () {
        AmCharts.AmRadarChart.base.construct.call(this);
        this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 0;
        this.chartType = "radar";
        this.radius = "35%"
    }, initChart: function () {
        AmCharts.AmRadarChart.base.initChart.call(this);
        this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
        this.drawChart()
    }, updateData: function () {
        this.parseData();
        var a = this.graphs, b;
        for (b = 0; b < a.length; b++)a[b].data =
            this.chartData
    }, updateGraphs: function () {
        var a = this.graphs, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.index = b;
            c.width = this.realRadius;
            c.height = this.realRadius;
            c.x = this.marginLeftReal;
            c.y = this.marginTopReal;
            c.chartType = this.chartType
        }
    }, parseData: function () {
        AmCharts.AmRadarChart.base.parseData.call(this);
        this.parseSerialData()
    }, updateValueAxes: function () {
        var a = this.valueAxes, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.axisRenderer = AmCharts.RadAxis;
            c.guideFillRenderer = AmCharts.RadarFill;
            c.axisItemRenderer = AmCharts.RadItem;
            c.autoGridCount = !1;
            c.x = this.marginLeftReal;
            c.y = this.marginTopReal;
            c.width = this.realRadius;
            c.height = this.realRadius
        }
    }, drawChart: function () {
        AmCharts.AmRadarChart.base.drawChart.call(this);
        var a = this.updateWidth(), b = this.updateHeight(), c = this.marginTop + this.getTitleHeight(), d = this.marginLeft, b = b - c - this.marginBottom;
        this.marginLeftReal = d + (a - d - this.marginRight) / 2;
        this.marginTopReal = c + b / 2;
        this.realRadius = AmCharts.toCoordinate(this.radius, a, b);
        this.updateValueAxes();
        this.updateGraphs();
        a = this.chartData;
        if (AmCharts.ifArray(a)) {
            if (0 < this.realWidth && 0 < this.realHeight) {
                a = a.length - 1;
                d = this.valueAxes;
                for (c = 0; c < d.length; c++)d[c].zoom(0, a);
                d = this.graphs;
                for (c = 0; c < d.length; c++)d[c].zoom(0, a);
                (a = this.legend) && a.invalidateSize()
            }
        } else this.cleanChart();
        this.dispDUpd();
        this.chartCreated = !0
    }, formatString: function (a, b) {
        var c = b.graph;
        -1 != a.indexOf("[[category]]") && (a = a.replace(/\[\[category\]\]/g, String(b.serialDataItem.category)));
        c = c.numberFormatter;
        c || (c = this.numberFormatter);
        a = AmCharts.formatValue(a, b.values,
            ["value"], c, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
        return a = AmCharts.AmRadarChart.base.formatString.call(this, a, b)
    }, cleanChart: function () {
        AmCharts.callMethod("destroy", [this.valueAxes, this.graphs])
    }
});
AmCharts.AxisBase = AmCharts.Class({
    construct: function () {
        this.viY = this.viX = this.y = this.x = this.dy = this.dx = 0;
        this.axisThickness = 1;
        this.axisColor = "#000000";
        this.axisAlpha = 1;
        this.gridCount = this.tickLength = 5;
        this.gridAlpha = 0.15;
        this.gridThickness = 1;
        this.gridColor = "#000000";
        this.dashLength = 0;
        this.labelFrequency = 1;
        this.showLastLabel = this.showFirstLabel = !0;
        this.fillColor = "#FFFFFF";
        this.fillAlpha = 0;
        this.labelsEnabled = !0;
        this.labelRotation = 0;
        this.autoGridCount = !0;
        this.valueRollOverColor = "#CC0000";
        this.offset =
            0;
        this.guides = [];
        this.visible = !0;
        this.counter = 0;
        this.guides = [];
        this.ignoreAxisWidth = this.inside = !1;
        this.minGap = 75;
        this.titleBold = !0
    }, zoom: function (a, b) {
        this.start = a;
        this.end = b;
        this.dataChanged = !0;
        this.draw()
    }, fixAxisPosition: function () {
        var a = this.position;
        "H" == this.orientation ? ("left" == a && (a = "bottom"), "right" == a && (a = "top")) : ("bottom" == a && (a = "left"), "top" == a && (a = "right"));
        this.position = a
    }, draw: function () {
        var a = this.chart;
        void 0 === this.titleColor && (this.titleColor = a.color);
        isNaN(this.titleFontSize) &&
        (this.titleFontSize = a.fontSize + 1);
        this.allLabels = [];
        this.counter = 0;
        this.destroy();
        this.fixAxisPosition();
        this.labels = [];
        var b = a.container, c = b.set();
        a.gridSet.push(c);
        this.set = c;
        b = b.set();
        a.axesLabelsSet.push(b);
        this.labelsSet = b;
        this.axisLine = new this.axisRenderer(this);
        this.autoGridCount && ("V" == this.orientation ? (a = this.height / 35, 3 > a && (a = 3)) : a = this.width / this.minGap, this.gridCount = Math.max(a, 1));
        this.axisWidth = this.axisLine.axisWidth;
        this.addTitle()
    }, setOrientation: function (a) {
        this.orientation = a ? "H" :
            "V"
    }, addTitle: function () {
        var a = this.title;
        if (a) {
            var b = this.chart;
            this.titleLabel = AmCharts.text(b.container, a, this.titleColor, b.fontFamily, this.titleFontSize, "middle", this.titleBold)
        }
    }, positionTitle: function () {
        var a = this.titleLabel;
        if (a) {
            var b, c, d = this.labelsSet, e = {};
            0 < d.length() ? e = d.getBBox() : (e.x = 0, e.y = 0, e.width = this.viW, e.height = this.viH);
            d.push(a);
            var d = e.x, f = e.y;
            AmCharts.VML && (this.rotate ? d -= this.x : f -= this.y);
            var g = e.width, e = e.height, h = this.viW, k = this.viH;
            a.getBBox();
            var l = 0, m = this.titleFontSize /
                2, n = this.inside;
            switch (this.position) {
                case "top":
                    b = h / 2;
                    c = f - 10 - m;
                    break;
                case "bottom":
                    b = h / 2;
                    c = f + e + 10 + m;
                    break;
                case "left":
                    b = d - 10 - m;
                    n && (b -= 5);
                    c = k / 2;
                    l = -90;
                    break;
                case "right":
                    b = d + g + 10 + m - 3, n && (b += 7), c = k / 2, l = -90
            }
            this.marginsChanged ? (a.translate(b, c), this.tx = b, this.ty = c) : a.translate(this.tx, this.ty);
            this.marginsChanged = !1;
            0 !== l && a.rotate(l)
        }
    }, pushAxisItem: function (a, b) {
        var c = a.graphics();
        0 < c.length() && (b ? this.labelsSet.push(c) : this.set.push(c));
        (c = a.getLabel()) && this.labelsSet.push(c)
    }, addGuide: function (a) {
        this.guides.push(a)
    },
    removeGuide: function (a) {
        var b = this.guides, c;
        for (c = 0; c < b.length; c++)b[c] == a && b.splice(c, 1)
    }, handleGuideOver: function (a) {
        clearTimeout(this.chart.hoverInt);
        var b = a.graphics.getBBox(), c = b.x + b.width / 2, b = b.y + b.height / 2, d = a.fillColor;
        void 0 === d && (d = a.lineColor);
        this.chart.showBalloon(a.balloonText, d, !0, c, b)
    }, handleGuideOut: function (a) {
        this.chart.hideBalloon()
    }, addEventListeners: function (a, b) {
        var c = this;
        a.mouseover(function () {
            c.handleGuideOver(b)
        });
        a.mouseout(function () {
            c.handleGuideOut(b)
        })
    }, getBBox: function () {
        var a =
            this.labelsSet.getBBox();
        AmCharts.VML || (a = {x: a.x + this.x, y: a.y + this.y, width: a.width, height: a.height});
        return a
    }, destroy: function () {
        AmCharts.remove(this.set);
        AmCharts.remove(this.labelsSet);
        var a = this.axisLine;
        a && AmCharts.remove(a.set);
        AmCharts.remove(this.grid0)
    }
});
AmCharts.ValueAxis = AmCharts.Class({
    inherits: AmCharts.AxisBase, construct: function () {
        this.createEvents("axisChanged", "logarithmicAxisFailed", "axisSelfZoomed", "axisZoomed");
        AmCharts.ValueAxis.base.construct.call(this);
        this.dataChanged = !0;
        this.gridCount = 8;
        this.stackType = "none";
        this.position = "left";
        this.unitPosition = "right";
        this.recalculateToPercents = this.includeHidden = this.includeGuidesInMinMax = this.integersOnly = !1;
        this.durationUnits = {DD: "d. ", hh: ":", mm: ":", ss: ""};
        this.scrollbar = !1;
        this.baseValue = 0;
        this.radarCategoriesEnabled = !0;
        this.gridType = "polygons";
        this.useScientificNotation = !1;
        this.axisTitleOffset = 10;
        this.minMaxMultiplier = 1
    }, updateData: function () {
        0 >= this.gridCount && (this.gridCount = 1);
        this.totals = [];
        this.data = this.chart.chartData;
        "xy" != this.chart.chartType && (this.stackGraphs("smoothedLine"), this.stackGraphs("line"), this.stackGraphs("column"), this.stackGraphs("step"));
        this.recalculateToPercents && this.recalculate();
        this.synchronizationMultiplier && this.synchronizeWithAxis ? this.foundGraphs = !0 : (this.foundGraphs = !1, this.getMinMax())
    },
    draw: function () {
        AmCharts.ValueAxis.base.draw.call(this);
        var a = this.chart, b = this.set;
        "duration" == this.type && (this.duration = "ss");
        !0 === this.dataChanged && (this.updateData(), this.dataChanged = !1);
        if (this.logarithmic && (0 >= this.getMin(0, this.data.length - 1) || 0 >= this.minimum))this.fire("logarithmicAxisFailed", {
            type: "logarithmicAxisFailed",
            chart: a
        }); else {
            this.grid0 = null;
            var c, d, e = a.dx, f = a.dy, g = !1, h = this.logarithmic, k = a.chartType;
            if (isNaN(this.min) || isNaN(this.max) || !this.foundGraphs || Infinity == this.min || -Infinity ==
                this.max)g = !0; else {
                var l = this.labelFrequency, m = this.showFirstLabel, n = this.showLastLabel, s = 1, q = 0, t = Math.round((this.max - this.min) / this.step) + 1, p;
                !0 === h ? (p = Math.log(this.max) * Math.LOG10E - Math.log(this.minReal) * Math.LOG10E, this.stepWidth = this.axisWidth / p, 2 < p && (t = Math.ceil(Math.log(this.max) * Math.LOG10E) + 1, q = Math.round(Math.log(this.minReal) * Math.LOG10E), t > this.gridCount && (s = Math.ceil(t / this.gridCount)))) : this.stepWidth = this.axisWidth / (this.max - this.min);
                c = 0;
                1 > this.step && -1 < this.step && (c = this.getDecimals(this.step));
                this.integersOnly && (c = 0);
                c > this.maxDecCount && (c = this.maxDecCount);
                var r = this.precision;
                isNaN(r) || (c = r);
                this.max = AmCharts.roundTo(this.max, this.maxDecCount);
                this.min = AmCharts.roundTo(this.min, this.maxDecCount);
                var u = {};
                u.precision = c;
                u.decimalSeparator = a.numberFormatter.decimalSeparator;
                u.thousandsSeparator = a.numberFormatter.thousandsSeparator;
                this.numberFormatter = u;
                var v, w = this.guides, A = w.length;
                if (0 < A) {
                    var x = this.fillAlpha;
                    for (d = this.fillAlpha = 0; d < A; d++) {
                        var B = w[d], y = NaN, z = B.above;
                        isNaN(B.toValue) ||
                        (y = this.getCoordinate(B.toValue), v = new this.axisItemRenderer(this, y, "", !0, NaN, NaN, B), this.pushAxisItem(v, z));
                        var C = NaN;
                        isNaN(B.value) || (C = this.getCoordinate(B.value), v = new this.axisItemRenderer(this, C, B.label, !0, NaN, (y - C) / 2, B), this.pushAxisItem(v, z));
                        isNaN(y - C) || (v = new this.guideFillRenderer(this, C, y, B), this.pushAxisItem(v, z), v = v.graphics(), B.graphics = v, B.balloonText && this.addEventListeners(v, B))
                    }
                    this.fillAlpha = x
                }
                w = !1;
                for (d = q; d < t; d += s)v = AmCharts.roundTo(this.step * d + this.min, c), -1 != String(v).indexOf("e") &&
                (w = !0, String(v).split("e"));
                this.duration && (this.maxInterval = AmCharts.getMaxInterval(this.max, this.duration));
                for (d = q; d < t; d += s)if (q = this.step * d + this.min, q = AmCharts.roundTo(q, this.maxDecCount + 1), !this.integersOnly || Math.round(q) == q)if (isNaN(r) || Number(AmCharts.toFixed(q, r)) == q) {
                    !0 === h && (0 === q && (q = this.minReal), 2 < p && (q = Math.pow(10, d)), w = -1 != String(q).indexOf("e") ? !0 : !1);
                    this.useScientificNotation && (w = !0);
                    this.usePrefixes && (w = !1);
                    w ? (v = -1 == String(q).indexOf("e") ? q.toExponential(15) : String(q), v = v.split("e"),
                        c = Number(v[0]), v = Number(v[1]), c = AmCharts.roundTo(c, 14), 10 == c && (c = 1, v += 1), v = c + "e" + v, 0 === q && (v = "0"), 1 == q && (v = "1")) : (h && (c = String(q).split("."), u.precision = c[1] ? c[1].length : -1), v = this.usePrefixes ? AmCharts.addPrefix(q, a.prefixesOfBigNumbers, a.prefixesOfSmallNumbers, u, !0) : AmCharts.formatNumber(q, u, u.precision));
                    this.duration && (v = AmCharts.formatDuration(q, this.duration, "", this.durationUnits, this.maxInterval, u));
                    this.recalculateToPercents ? v += "%" : (c = this.unit) && (v = "left" == this.unitPosition ? c + v : v + c);
                    Math.round(d /
                        l) != d / l && (v = void 0);
                    if (0 === d && !m || d == t - 1 && !n)v = " ";
                    c = this.getCoordinate(q);
                    this.labelFunction && (v = this.labelFunction(q, v, this));
                    v = new this.axisItemRenderer(this, c, v);
                    this.pushAxisItem(v);
                    if (q == this.baseValue && "radar" != k) {
                        var H, J, A = this.viW, x = this.viH, q = this.viX;
                        v = this.viY;
                        "H" == this.orientation ? 0 <= c && c <= A + 1 && (H = [c, c, c + e], J = [x, 0, f]) : 0 <= c && c <= x + 1 && (H = [0, A, A + e], J = [c, c, c + f]);
                        H && (c = AmCharts.fitToBounds(2 * this.gridAlpha, 0, 1), c = AmCharts.line(a.container, H, J, this.gridColor, c, 1, this.dashLength), c.translate(q,
                            v), this.grid0 = c, a.axesSet.push(c), c.toBack())
                    }
                }
                d = this.baseValue;
                this.min > this.baseValue && this.max > this.baseValue && (d = this.min);
                this.min < this.baseValue && this.max < this.baseValue && (d = this.max);
                h && d < this.minReal && (d = this.minReal);
                this.baseCoord = this.getCoordinate(d);
                a = {type: "axisChanged", target: this, chart: a};
                a.min = h ? this.minReal : this.min;
                a.max = this.max;
                this.fire("axisChanged", a);
                this.axisCreated = !0
            }
            h = this.axisLine.set;
            a = this.labelsSet;
            this.positionTitle();
            "radar" != k ? (k = this.viX, d = this.viY, b.translate(k,
                d), a.translate(k, d)) : h.toFront();
            !this.visible || g ? (b.hide(), h.hide(), a.hide()) : (b.show(), h.show(), a.show())
        }
    }, getDecimals: function (a) {
        var b = 0;
        isNaN(a) || (a = String(a), -1 != a.indexOf("e-") ? b = Number(a.split("-")[1]) : -1 != a.indexOf(".") && (b = a.split(".")[1].length));
        return b
    }, stackGraphs: function (a) {
        var b = this.stackType;
        "stacked" == b && (b = "regular");
        "line" == b && (b = "none");
        "100% stacked" == b && (b = "100%");
        this.stackType = b;
        var c = [], d = [], e = [], f = [], g, h = this.chart.graphs, k, l, m, n, s = this.baseValue, q = !1;
        if ("line" == a ||
            "step" == a || "smoothedLine" == a)q = !0;
        if (q && ("regular" == b || "100%" == b))for (n = 0; n < h.length; n++)m = h[n], m.hidden || (l = m.type, m.chart == this.chart && (m.valueAxis == this && a == l && m.stackable) && (k && (m.stackGraph = k), k = m));
        for (k = this.start; k <= this.end; k++) {
            var t = 0;
            for (n = 0; n < h.length; n++)if (m = h[n], !m.hidden && (l = m.type, m.chart == this.chart && (m.valueAxis == this && a == l && m.stackable) && (l = this.data[k].axes[this.id].graphs[m.id], g = l.values.value, !isNaN(g)))) {
                var p = this.getDecimals(g);
                t < p && (t = p);
                isNaN(f[k]) ? f[k] = Math.abs(g) : f[k] +=
                    Math.abs(g);
                f[k] = AmCharts.roundTo(f[k], t);
                m = m.fillToGraph;
                q && m && (m = this.data[k].axes[this.id].graphs[m.id]) && (l.values.open = m.values.value);
                "regular" == b && (q && (isNaN(c[k]) ? (c[k] = g, l.values.close = g, l.values.open = this.baseValue) : (isNaN(g) ? l.values.close = c[k] : l.values.close = g + c[k], l.values.open = c[k], c[k] = l.values.close)), "column" != a || isNaN(g) || (l.values.close = g, 0 > g ? (l.values.close = g, isNaN(d[k]) ? l.values.open = s : (l.values.close += d[k], l.values.open = d[k]), d[k] = l.values.close) : (l.values.close = g, isNaN(e[k]) ?
                    l.values.open = s : (l.values.close += e[k], l.values.open = e[k]), e[k] = l.values.close)))
            }
        }
        for (k = this.start; k <= this.end; k++)for (n = 0; n < h.length; n++)m = h[n], m.hidden || (l = m.type, m.chart == this.chart && (m.valueAxis == this && a == l && m.stackable) && (l = this.data[k].axes[this.id].graphs[m.id], g = l.values.value, isNaN(g) || (c = 100 * (g / f[k]), l.values.percents = c, l.values.total = f[k], "100%" == b && (isNaN(d[k]) && (d[k] = 0), isNaN(e[k]) && (e[k] = 0), 0 > c ? (l.values.close = AmCharts.fitToBounds(c + d[k], -100, 100), l.values.open = d[k], d[k] = l.values.close) :
            (l.values.close = AmCharts.fitToBounds(c + e[k], -100, 100), l.values.open = e[k], e[k] = l.values.close)))))
    }, recalculate: function () {
        var a = this.chart.graphs, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            if (c.valueAxis == this) {
                var d = "value";
                if ("candlestick" == c.type || "ohlc" == c.type)d = "open";
                var e, f, g = this.end + 2, g = AmCharts.fitToBounds(this.end + 1, 0, this.data.length - 1), h = this.start;
                0 < h && h--;
                var k;
                for (k = this.start; k <= g && (f = this.data[k].axes[this.id].graphs[c.id], e = f.values[d], isNaN(e)); k++);
                for (d = h; d <= g; d++) {
                    f = this.data[d].axes[this.id].graphs[c.id];
                    f.percents = {};
                    var h = f.values, l;
                    for (l in h)f.percents[l] = "percents" != l ? 100 * (h[l] / e) - 100 : h[l]
                }
            }
        }
    }, getMinMax: function () {
        var a = !1, b = this.chart, c = b.graphs, d;
        for (d = 0; d < c.length; d++) {
            var e = c[d].type;
            ("line" == e || "step" == e || "smoothedLine" == e) && this.expandMinMax && (a = !0)
        }
        a && (0 < this.start && this.start--, this.end < this.data.length - 1 && this.end++);
        "serial" == b.chartType && (!0 !== b.categoryAxis.parseDates || a || this.end < this.data.length - 1 && this.end++);
        a = this.minMaxMultiplier;
        this.min = this.getMin(this.start, this.end);
        this.max =
            this.getMax();
        a = (this.max - this.min) * (a - 1);
        this.min -= a;
        this.max += a;
        a = this.guides.length;
        if (this.includeGuidesInMinMax && 0 < a)for (b = 0; b < a; b++)c = this.guides[b], c.toValue < this.min && (this.min = c.toValue), c.value < this.min && (this.min = c.value), c.toValue > this.max && (this.max = c.toValue), c.value > this.max && (this.max = c.value);
        isNaN(this.minimum) || (this.min = this.minimum);
        isNaN(this.maximum) || (this.max = this.maximum);
        this.min > this.max && (a = this.max, this.max = this.min, this.min = a);
        isNaN(this.minTemp) || (this.min = this.minTemp);
        isNaN(this.maxTemp) || (this.max = this.maxTemp);
        this.minReal = this.min;
        this.maxReal = this.max;
        0 === this.min && 0 === this.max && (this.max = 9);
        this.min > this.max && (this.min = this.max - 1);
        a = this.min;
        b = this.max;
        c = this.max - this.min;
        d = 0 === c ? Math.pow(10, Math.floor(Math.log(Math.abs(this.max)) * Math.LOG10E)) / 10 : Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
        isNaN(this.maximum) && isNaN(this.maxTemp) && (this.max = Math.ceil(this.max / d) * d + d);
        isNaN(this.minimum) && isNaN(this.minTemp) && (this.min = Math.floor(this.min /
                d) * d - d);
        0 > this.min && 0 <= a && (this.min = 0);
        0 < this.max && 0 >= b && (this.max = 0);
        "100%" == this.stackType && (this.min = 0 > this.min ? -100 : 0, this.max = 0 > this.max ? 0 : 100);
        c = this.max - this.min;
        d = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
        this.step = Math.ceil(c / this.gridCount / d) * d;
        c = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E));
        c = c.toExponential(0).split("e");
        d = Number(c[1]);
        9 == Number(c[0]) && d++;
        c = this.generateNumber(1, d);
        d = Math.ceil(this.step / c);
        5 < d && (d = 10);
        5 >= d && 2 < d && (d = 5);
        this.step =
            Math.ceil(this.step / (c * d)) * c * d;
        1 > c ? (this.maxDecCount = Math.abs(Math.log(Math.abs(c)) * Math.LOG10E), this.maxDecCount = Math.round(this.maxDecCount), this.step = AmCharts.roundTo(this.step, this.maxDecCount + 1)) : this.maxDecCount = 0;
        this.min = this.step * Math.floor(this.min / this.step);
        this.max = this.step * Math.ceil(this.max / this.step);
        0 > this.min && 0 <= a && (this.min = 0);
        0 < this.max && 0 >= b && (this.max = 0);
        1 < this.minReal && 1 < this.max - this.minReal && (this.minReal = Math.floor(this.minReal));
        c = Math.pow(10, Math.floor(Math.log(Math.abs(this.minReal)) *
            Math.LOG10E));
        0 === this.min && (this.minReal = c);
        0 === this.min && 1 < this.minReal && (this.minReal = 1);
        0 < this.min && 0 < this.minReal - this.step && (this.minReal = this.min + this.step < this.minReal ? this.min + this.step : this.min);
        c = Math.log(b) * Math.LOG10E - Math.log(a) * Math.LOG10E;
        this.logarithmic && (2 < c ? (this.minReal = this.min = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)), this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(b)) * Math.LOG10E))) : (b = Math.pow(10, Math.floor(Math.log(Math.abs(this.min)) * Math.LOG10E)) / 10, a =
            Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)) / 10, b < a && (this.minReal = this.min = 10 * a)))
    }, generateNumber: function (a, b) {
        var c = "", d;
        d = 0 > b ? Math.abs(b) - 1 : Math.abs(b);
        var e;
        for (e = 0; e < d; e++)c += "0";
        return 0 > b ? Number("0." + c + String(a)) : Number(String(a) + c)
    }, getMin: function (a, b) {
        var c, d;
        for (d = a; d <= b; d++) {
            var e = this.data[d].axes[this.id].graphs, f;
            for (f in e)if (e.hasOwnProperty(f)) {
                var g = this.chart.getGraphById(f);
                if (g.includeInMinMax && (!g.hidden || this.includeHidden)) {
                    isNaN(c) && (c = Infinity);
                    this.foundGraphs = !0;
                    g = e[f].values;
                    this.recalculateToPercents && (g = e[f].percents);
                    var h;
                    if (this.minMaxField)h = g[this.minMaxField], h < c && (c = h); else for (var k in g)g.hasOwnProperty(k) && ("percents" != k && "total" != k) && (h = g[k], h < c && (c = h))
                }
            }
        }
        return c
    }, getMax: function () {
        var a, b;
        for (b = this.start; b <= this.end; b++) {
            var c = this.data[b].axes[this.id].graphs, d;
            for (d in c)if (c.hasOwnProperty(d)) {
                var e = this.chart.getGraphById(d);
                if (e.includeInMinMax && (!e.hidden || this.includeHidden)) {
                    isNaN(a) && (a = -Infinity);
                    this.foundGraphs = !0;
                    e = c[d].values;
                    this.recalculateToPercents && (e = c[d].percents);
                    var f;
                    if (this.minMaxField)f = e[this.minMaxField], f > a && (a = f); else for (var g in e)e.hasOwnProperty(g) && ("percents" != g && "total" != g) && (f = e[g], f > a && (a = f))
                }
            }
        }
        return a
    }, dispatchZoomEvent: function (a, b) {
        var c = {type: "axisZoomed", startValue: a, endValue: b, target: this, chart: this.chart};
        this.fire(c.type, c)
    }, zoomToValues: function (a, b) {
        if (b < a) {
            var c = b;
            b = a;
            a = c
        }
        a < this.min && (a = this.min);
        b > this.max && (b = this.max);
        c = {type: "axisSelfZoomed"};
        c.chart = this.chart;
        c.valueAxis = this;
        c.multiplier = this.axisWidth / Math.abs(this.getCoordinate(b) - this.getCoordinate(a));
        c.position = "V" == this.orientation ? this.reversed ? this.getCoordinate(a) : this.getCoordinate(b) : this.reversed ? this.getCoordinate(b) : this.getCoordinate(a);
        this.fire(c.type, c)
    }, coordinateToValue: function (a) {
        if (isNaN(a))return NaN;
        var b = this.axisWidth, c = this.stepWidth, d = this.reversed, e = this.rotate, f = this.min, g = this.minReal;
        return !0 === this.logarithmic ? Math.pow(10, (e ? !0 === d ? (b - a) / c : a / c : !0 === d ? a / c : (b - a) / c) + Math.log(g) * Math.LOG10E) :
            !0 === d ? e ? f - (a - b) / c : a / c + f : e ? a / c + f : f - (a - b) / c
    }, getCoordinate: function (a) {
        if (isNaN(a))return NaN;
        var b = this.rotate, c = this.reversed, d = this.axisWidth, e = this.stepWidth, f = this.min, g = this.minReal;
        !0 === this.logarithmic ? (a = Math.log(a) * Math.LOG10E - Math.log(g) * Math.LOG10E, b = b ? !0 === c ? d - e * a : e * a : !0 === c ? e * a : d - e * a) : b = !0 === c ? b ? d - e * (a - f) : e * (a - f) : b ? e * (a - f) : d - e * (a - f);
        b = this.rotate ? b + (this.x - this.viX) : b + (this.y - this.viY);
        return Math.round(b)
    }, synchronizeWithAxis: function (a) {
        this.synchronizeWithAxis = a;
        this.removeListener(this.synchronizeWithAxis,
            "axisChanged", this.handleSynchronization);
        this.listenTo(this.synchronizeWithAxis, "axisChanged", this.handleSynchronization)
    }, handleSynchronization: function (a) {
        var b = this.synchronizeWithAxis;
        a = b.min;
        var c = b.max, b = b.step, d = this.synchronizationMultiplier;
        d && (this.min = a * d, this.max = c * d, this.step = b * d, a = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E)), a = Math.abs(Math.log(Math.abs(a)) * Math.LOG10E), this.maxDecCount = a = Math.round(a), this.draw())
    }
});
AmCharts.CategoryAxis = AmCharts.Class({
    inherits: AmCharts.AxisBase, construct: function () {
        AmCharts.CategoryAxis.base.construct.call(this);
        this.minPeriod = "DD";
        this.equalSpacing = this.parseDates = !1;
        this.position = "bottom";
        this.startOnAxis = !1;
        this.firstDayOfWeek = 1;
        this.gridPosition = "middle";
        this.markPeriodChange = this.boldPeriodBeginning = !0;
        this.safeDistance = 30;
        this.centerLabelOnFullPeriod = !0;
        this.periods = [{period: "ss", count: 1}, {period: "ss", count: 5}, {period: "ss", count: 10}, {
            period: "ss",
            count: 30
        }, {
            period: "mm",
            count: 1
        }, {period: "mm", count: 5}, {period: "mm", count: 10}, {period: "mm", count: 30}, {
            period: "hh",
            count: 1
        }, {period: "hh", count: 3}, {period: "hh", count: 6}, {period: "hh", count: 12}, {
            period: "DD",
            count: 1
        }, {period: "DD", count: 2}, {period: "DD", count: 3}, {period: "DD", count: 4}, {
            period: "DD",
            count: 5
        }, {period: "WW", count: 1}, {period: "MM", count: 1}, {period: "MM", count: 2}, {
            period: "MM",
            count: 3
        }, {period: "MM", count: 6}, {period: "YYYY", count: 1}, {period: "YYYY", count: 2}, {
            period: "YYYY",
            count: 5
        }, {period: "YYYY", count: 10}, {period: "YYYY", count: 50},
            {period: "YYYY", count: 100}];
        this.dateFormats = [{period: "fff", format: "JJ:NN:SS"}, {period: "ss", format: "JJ:NN:SS"}, {
            period: "mm",
            format: "JJ:NN"
        }, {period: "hh", format: "JJ:NN"}, {period: "DD", format: "MMM DD"}, {
            period: "WW",
            format: "MMM DD"
        }, {period: "MM", format: "MMM"}, {period: "YYYY", format: "YYYY"}];
        this.nextPeriod = {};
        this.nextPeriod.fff = "ss";
        this.nextPeriod.ss = "mm";
        this.nextPeriod.mm = "hh";
        this.nextPeriod.hh = "DD";
        this.nextPeriod.DD = "MM";
        this.nextPeriod.MM = "YYYY"
    }, draw: function () {
        AmCharts.CategoryAxis.base.draw.call(this);
        this.generateDFObject();
        var a = this.chart.chartData;
        this.data = a;
        if (AmCharts.ifArray(a)) {
            var b, c = this.chart, d = this.start, e = this.labelFrequency, f = 0;
            b = this.end - d + 1;
            var g = this.gridCount, h = this.showFirstLabel, k = this.showLastLabel, l, m = "", m = AmCharts.extractPeriod(this.minPeriod);
            l = AmCharts.getPeriodDuration(m.period, m.count);
            var n, s, q, t, p;
            n = this.rotate;
            var r = this.firstDayOfWeek, u = this.boldPeriodBeginning, a = AmCharts.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * l), this.minPeriod, 1, r).getTime(), v;
            this.endTime >
            a && (this.endTime = a);
            if (this.parseDates && !this.equalSpacing) {
                this.timeDifference = this.endTime - this.startTime;
                d = this.choosePeriod(0);
                e = d.period;
                n = d.count;
                s = AmCharts.getPeriodDuration(e, n);
                s < l && (e = m.period, n = m.count, s = l);
                q = e;
                "WW" == q && (q = "DD");
                this.stepWidth = this.getStepWidth(this.timeDifference);
                var g = Math.ceil(this.timeDifference / s) + 1, w = m = AmCharts.resetDateToMin(new Date(this.startTime - s), e, n, r).getTime();
                q == e && (1 == n && this.centerLabelOnFullPeriod) && (t = s * this.stepWidth);
                this.cellWidth = l * this.stepWidth;
                b = Math.round(m / s);
                d = -1;
                b / 2 == Math.round(b / 2) && (d = -2, m -= s);
                var A = c.firstTime;
                if (0 < this.gridCount)for (b = d; b <= g; b++) {
                    a = A + s * (b + 0.1 + Math.floor((w - A) / s));
                    a = AmCharts.resetDateToMin(new Date(a), e, n, r).getTime();
                    l = (a - this.startTime) * this.stepWidth;
                    p = !1;
                    this.nextPeriod[q] && (p = this.checkPeriodChange(this.nextPeriod[q], 1, a, m));
                    v = !1;
                    p && this.markPeriodChange ? (m = this.dateFormatsObject[this.nextPeriod[q]], v = !0) : m = this.dateFormatsObject[q];
                    u || (v = !1);
                    m = AmCharts.formatDate(new Date(a), m);
                    if (b == d && !h || b == g && !k)m = " ";
                    this.labelFunction && (m = this.labelFunction(m, new Date(a), this));
                    m = new this.axisItemRenderer(this, l, m, !1, t, 0, !1, v);
                    this.pushAxisItem(m);
                    m = a
                }
            } else if (!this.parseDates) {
                if (this.cellWidth = this.getStepWidth(b), b < g && (g = b), f += this.start, this.stepWidth = this.getStepWidth(b), 0 < g)for (u = Math.floor(b / g), l = f, l / 2 == Math.round(l / 2) && l--, 0 > l && (l = 0), g = 0, b = l; b <= this.end + 2; b++)if (0 <= b && b < this.data.length ? (q = this.data[b], m = q.category) : m = "", b / u == Math.round(b / u) || q.forceShow) {
                    l = this.getCoordinate(b - f);
                    r = 0;
                    "start" == this.gridPosition &&
                    (l -= this.cellWidth / 2, r = this.cellWidth / 2);
                    if (b == d && !h || b == this.end && !k)m = void 0;
                    Math.round(g / e) != g / e && (m = void 0);
                    g++;
                    t = this.cellWidth;
                    n && (t = NaN);
                    this.labelFunction && (m = this.labelFunction(m, q, this));
                    m = AmCharts.fixNewLines(m);
                    m = new this.axisItemRenderer(this, l, m, !0, t, r, void 0, !1, r);
                    this.pushAxisItem(m)
                }
            } else if (this.parseDates && this.equalSpacing) {
                f = this.start;
                this.startTime = this.data[this.start].time;
                this.endTime = this.data[this.end].time;
                this.timeDifference = this.endTime - this.startTime;
                d = this.choosePeriod(0);
                e = d.period;
                n = d.count;
                s = AmCharts.getPeriodDuration(e, n);
                s < l && (e = m.period, n = m.count, s = l);
                q = e;
                "WW" == q && (q = "DD");
                this.stepWidth = this.getStepWidth(b);
                g = Math.ceil(this.timeDifference / s) + 1;
                m = AmCharts.resetDateToMin(new Date(this.startTime - s), e, n, r).getTime();
                this.cellWidth = this.getStepWidth(b);
                b = Math.round(m / s);
                d = -1;
                b / 2 == Math.round(b / 2) && (d = -2, m -= s);
                l = this.start;
                l / 2 == Math.round(l / 2) && l--;
                0 > l && (l = 0);
                t = this.end + 2;
                t >= this.data.length && (t = this.data.length);
                s = !1;
                s = !h;
                this.previousPos = -1E3;
                20 < this.labelRotation &&
                (this.safeDistance = 5);
                if (this.data[l].time != AmCharts.resetDateToMin(new Date(this.data[l].time), e, n, r).getTime())for (r = 0, w = m, b = l; b < t; b++)a = this.data[b].time, this.checkPeriodChange(e, n, a, w) && (r++, 2 <= r && (l = b, b = t), w = a);
                for (b = l; b < t; b++)if (a = this.data[b].time, this.checkPeriodChange(e, n, a, m)) {
                    l = this.getCoordinate(b - this.start);
                    p = !1;
                    this.nextPeriod[q] && (p = this.checkPeriodChange(this.nextPeriod[q], 1, a, m));
                    v = !1;
                    p && this.markPeriodChange ? (m = this.dateFormatsObject[this.nextPeriod[q]], v = !0) : m = this.dateFormatsObject[q];
                    m = AmCharts.formatDate(new Date(a), m);
                    if (b == d && !h || b == g && !k)m = " ";
                    s ? s = !1 : (u || (v = !1), l - this.previousPos > this.safeDistance * Math.cos(this.labelRotation * Math.PI / 180) && (this.labelFunction && (m = this.labelFunction(m, new Date(a), this)), m = new this.axisItemRenderer(this, l, m, void 0, void 0, void 0, void 0, v), r = m.graphics(), this.pushAxisItem(m), this.previousPos = l + r.getBBox().width));
                    m = a
                }
            }
            for (b = 0; b < this.data.length; b++)if (h = this.data[b])k = this.parseDates && !this.equalSpacing ? Math.round((h.time - this.startTime) * this.stepWidth +
                this.cellWidth / 2) : this.getCoordinate(b - f), h.x[this.id] = k;
            h = this.guides.length;
            for (b = 0; b < h; b++)k = this.guides[b], r = r = r = g = u = NaN, d = k.above, k.toCategory && (r = c.getCategoryIndexByValue(k.toCategory), isNaN(r) || (u = this.getCoordinate(r - f), m = new this.axisItemRenderer(this, u, "", !0, NaN, NaN, k), this.pushAxisItem(m, d))), k.category && (r = c.getCategoryIndexByValue(k.category), isNaN(r) || (g = this.getCoordinate(r - f), r = (u - g) / 2, m = new this.axisItemRenderer(this, g, k.label, !0, NaN, r, k), this.pushAxisItem(m, d))), k.toDate && (this.equalSpacing ?
                (r = c.getClosestIndex(this.data, "time", k.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(r) || (u = this.getCoordinate(r - f))) : u = (k.toDate.getTime() - this.startTime) * this.stepWidth, m = new this.axisItemRenderer(this, u, "", !0, NaN, NaN, k), this.pushAxisItem(m, d)), k.date && (this.equalSpacing ? (r = c.getClosestIndex(this.data, "time", k.date.getTime(), !1, 0, this.data.length - 1), isNaN(r) || (g = this.getCoordinate(r - f))) : g = (k.date.getTime() - this.startTime) * this.stepWidth, r = (u - g) / 2, m = "H" == this.orientation ? new this.axisItemRenderer(this,
                g, k.label, !1, 2 * r, NaN, k) : new this.axisItemRenderer(this, g, k.label, !1, NaN, r, k), this.pushAxisItem(m, d)), u = new this.guideFillRenderer(this, g, u, k), g = u.graphics(), this.pushAxisItem(u, d), k.graphics = g, g.index = b, k.balloonText && this.addEventListeners(g, k)
        }
        this.axisCreated = !0;
        c = this.x;
        f = this.y;
        this.set.translate(c, f);
        this.labelsSet.translate(c, f);
        this.positionTitle();
        (c = this.axisLine.set) && c.toFront()
    }, choosePeriod: function (a) {
        var b = AmCharts.getPeriodDuration(this.periods[a].period, this.periods[a].count), c =
            Math.ceil(this.timeDifference / b), d = this.periods;
        return this.timeDifference < b && 0 < a ? d[a - 1] : c <= this.gridCount ? d[a] : a + 1 < d.length ? this.choosePeriod(a + 1) : d[a]
    }, getStepWidth: function (a) {
        var b;
        this.startOnAxis ? (b = this.axisWidth / (a - 1), 1 == a && (b = this.axisWidth)) : b = this.axisWidth / a;
        return b
    }, getCoordinate: function (a) {
        a *= this.stepWidth;
        this.startOnAxis || (a += this.stepWidth / 2);
        return Math.round(a)
    }, timeZoom: function (a, b) {
        this.startTime = a;
        this.endTime = b
    }, minDuration: function () {
        var a = AmCharts.extractPeriod(this.minPeriod);
        return AmCharts.getPeriodDuration(a.period, a.count)
    }, checkPeriodChange: function (a, b, c, d) {
        c = new Date(c);
        var e = new Date(d), f = this.firstDayOfWeek;
        d = b;
        "DD" == a && (b = 1);
        c = AmCharts.resetDateToMin(c, a, b, f).getTime();
        b = AmCharts.resetDateToMin(e, a, b, f).getTime();
        return "DD" == a && c - b <= AmCharts.getPeriodDuration(a, d) ? !1 : c != b ? !0 : !1
    }, generateDFObject: function () {
        this.dateFormatsObject = {};
        var a;
        for (a = 0; a < this.dateFormats.length; a++) {
            var b = this.dateFormats[a];
            this.dateFormatsObject[b.period] = b.format
        }
    }, xToIndex: function (a) {
        var b =
            this.data, c = this.chart, d = c.rotate, e = this.stepWidth;
        this.parseDates && !this.equalSpacing ? (a = this.startTime + Math.round(a / e) - this.minDuration() / 2, c = c.getClosestIndex(b, "time", a, !1, this.start, this.end + 1)) : (this.startOnAxis || (a -= e / 2), c = this.start + Math.round(a / e));
        var c = AmCharts.fitToBounds(c, 0, b.length - 1), f;
        b[c] && (f = b[c].x[this.id]);
        d ? f > this.height + 1 && c-- : f > this.width + 1 && c--;
        0 > f && c++;
        return c = AmCharts.fitToBounds(c, 0, b.length - 1)
    }, dateToCoordinate: function (a) {
        return this.parseDates && !this.equalSpacing ? (a.getTime() -
        this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, "time", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN
    }, categoryToCoordinate: function (a) {
        return this.chart ? (a = this.chart.getCategoryIndexByValue(a), this.getCoordinate(a - this.start)) : NaN
    }, coordinateToDate: function (a) {
        return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth)
    }
});
AmCharts.RecAxis = AmCharts.Class({
    construct: function (a) {
        var b = a.chart, c = a.axisThickness, d = a.axisColor, e = a.axisAlpha, f = a.offset, g = a.dx, h = a.dy, k = a.viX, l = a.viY, m = a.viH, n = a.viW, s = b.container;
        "H" == a.orientation ? (d = AmCharts.line(s, [0, n], [0, 0], d, e, c), this.axisWidth = a.width, "bottom" == a.position ? (a = c / 2 + f + m + l - 1, c = k) : (a = -c / 2 - f + l + h, c = g + k)) : (this.axisWidth = a.height, "right" == a.position ? (d = AmCharts.line(s, [0, 0, -g], [0, m, m - h], d, e, c), a = l + h, c = c / 2 + f + g + n + k - 1) : (d = AmCharts.line(s, [0, 0], [0, m], d, e, c), a = l, c = -c / 2 - f + k));
        d.translate(c,
            a);
        b.axesSet.push(d);
        this.set = d
    }
});
AmCharts.RecItem = AmCharts.Class({
    construct: function (a, b, c, d, e, f, g, h, k) {
        b = Math.round(b);
        void 0 == c && (c = "");
        k || (k = 0);
        void 0 == d && (d = !0);
        var l = a.chart.fontFamily, m = a.fontSize;
        void 0 == m && (m = a.chart.fontSize);
        var n = a.color;
        void 0 == n && (n = a.chart.color);
        var s = a.chart.container, q = s.set();
        this.set = q;
        var t = a.axisThickness, p = a.axisColor, r = a.axisAlpha, u = a.tickLength, v = a.gridAlpha, w = a.gridThickness, A = a.gridColor, x = a.dashLength, B = a.fillColor, y = a.fillAlpha, z = a.labelsEnabled, C = a.labelRotation, H = a.counter, J = a.inside,
            W = a.dx, U = a.dy, sa = a.orientation, R = a.position, T = a.previousCoord, P = a.viH, la = a.viW, da = a.offset, ea, fa;
        g ? (z = !0, isNaN(g.tickLength) || (u = g.tickLength), void 0 != g.lineColor && (A = g.lineColor), void 0 != g.color && (n = g.color), isNaN(g.lineAlpha) || (v = g.lineAlpha), isNaN(g.dashLength) || (x = g.dashLength), isNaN(g.lineThickness) || (w = g.lineThickness), !0 === g.inside && (J = !0), isNaN(g.labelRotation) || (C = g.labelRotation), isNaN(g.fontSize) || (m = g.fontSize), g.position && (R = g.position)) : "" === c && (u = 0);
        fa = "start";
        e && (fa = "middle");
        var X =
            C * Math.PI / 180, V, I = 0, G = 0, $ = 0, D = V = 0;
        "V" == sa && (C = 0);
        var Y;
        z && (Y = AmCharts.text(s, c, n, l, m, fa, h), D = Y.getBBox().width);
        if ("H" == sa) {
            if (0 <= b && b <= la + 1 && (0 < u && (0 < r && b + k <= la + 1) && (ea = AmCharts.line(s, [b + k, b + k], [0, u], p, r, w), q.push(ea)), 0 < v && (fa = AmCharts.line(s, [b, b + W, b + W], [P, P + U, U], A, v, w, x), q.push(fa))), G = 0, I = b, g && 90 == C && (I -= m), !1 === d ? (fa = "start", G = "bottom" == R ? J ? G + u : G - u : J ? G - u : G + u, I += 3, e && (I += e / 2, fa = "middle"), 0 < C && (fa = "middle")) : fa = "middle", 1 == H && (0 < y && !g && T < la) && (d = AmCharts.fitToBounds(b, 0, la), T = AmCharts.fitToBounds(T,
                    0, la), V = d - T, 0 < V && (fill = AmCharts.rect(s, V, a.height, B, y), fill.translate(d - V + W, U), q.push(fill))), "bottom" == R ? (G += P + m / 2 + da, J ? 0 < C ? (G = P - D / 2 * Math.sin(X) - u - 3, I += D / 2 * Math.cos(X)) : G -= u + m + 3 + 3 : 0 < C ? (G = P + D / 2 * Math.sin(X) + u + 3, I -= D / 2 * Math.cos(X)) : G += u + t + 3 + 3) : (G += U + m / 2 - da, I += W, J ? 0 < C ? (G = D / 2 * Math.sin(X) + u + 3, I -= D / 2 * Math.cos(X)) : G += u + 3 : 0 < C ? (G = -(D / 2) * Math.sin(X) - u - 6, I += D / 2 * Math.cos(X)) : G -= u + m + 3 + t + 3), "bottom" == R ? V = (J ? P - u - 1 : P + t - 1) + da : ($ = W, V = (J ? U : U - u - t + 1) - da), f && (I += f), U = I, 0 < C && (U += D / 2 * Math.cos(X)), Y && (R = 0, J && (R = D / 2 * Math.cos(X)),
                U + R > la + 2 || 0 > U))Y.remove(), Y = null
        } else {
            0 <= b && b <= P + 1 && (0 < u && (0 < r && b + k <= P + 1) && (ea = AmCharts.line(s, [0, u], [b + k, b + k], p, r, w), q.push(ea)), 0 < v && (fa = AmCharts.line(s, [0, W, la + W], [b, b + U, b + U], A, v, w, x), q.push(fa)));
            fa = "end";
            if (!0 === J && "left" == R || !1 === J && "right" == R)fa = "start";
            G = b - m / 2;
            1 == H && (0 < y && !g) && (d = AmCharts.fitToBounds(b, 0, P), T = AmCharts.fitToBounds(T, 0, P), X = d - T, fill = AmCharts.polygon(s, [0, a.width, a.width, 0], [0, 0, X, X], B, y), fill.translate(W, d - X + U), q.push(fill));
            G += m / 2;
            "right" == R ? (I += W + la + da, G += U, J ? (I -= u + 4, f || (G -=
                m / 2 + 3)) : (I += u + 4 + t, G -= 2)) : J ? (I += u + 4 - da, f || (G -= m / 2 + 3), g && (I += W, G += U)) : (I += -u - t - 4 - 2 - da, G -= 2);
            ea && ("right" == R ? ($ += W + da + la, V += U, $ = J ? $ - t : $ + t) : ($ -= da, J || ($ -= u + t)));
            f && (G += f);
            J = -3;
            "right" == R && (J += U);
            Y && (G > P + 1 || G < J) && (Y.remove(), Y = null)
        }
        ea && ea.translate($, V);
        !1 === a.visible && (ea && ea.remove(), Y && (Y.remove(), Y = null));
        Y && (Y.attr({"text-anchor": fa}), Y.translate(I, G), 0 !== C && Y.rotate(-C), a.allLabels.push(Y), " " != c && (this.label = Y));
        a.counter = 0 === H ? 1 : 0;
        a.previousCoord = b;
        0 === this.set.node.childNodes.length && this.set.remove()
    },
    graphics: function () {
        return this.set
    }, getLabel: function () {
        return this.label
    }
});
AmCharts.RecFill = AmCharts.Class({
    construct: function (a, b, c, d) {
        var e = a.dx, f = a.dy, g = a.orientation, h = 0;
        if (c < b) {
            var k = b;
            b = c;
            c = k
        }
        var l = d.fillAlpha;
        isNaN(l) && (l = 0);
        k = a.chart.container;
        d = d.fillColor;
        "V" == g ? (b = AmCharts.fitToBounds(b, 0, a.viH), c = AmCharts.fitToBounds(c, 0, a.viH)) : (b = AmCharts.fitToBounds(b, 0, a.viW), c = AmCharts.fitToBounds(c, 0, a.viW));
        c -= b;
        isNaN(c) && (c = 4, h = 2, l = 0);
        0 > c && "object" == typeof d && (d = d.join(",").split(",").reverse());
        "V" == g ? (a = AmCharts.rect(k, a.width, c, d, l), a.translate(e, b - h + f)) : (a = AmCharts.rect(k,
            c, a.height, d, l), a.translate(b - h + e, f));
        this.set = k.set([a])
    }, graphics: function () {
        return this.set
    }, getLabel: function () {
    }
});
AmCharts.RadAxis = AmCharts.Class({
    construct: function (a) {
        var b = a.chart, c = a.axisThickness, d = a.axisColor, e = a.axisAlpha, f = a.x, g = a.y;
        this.set = b.container.set();
        b.axesSet.push(this.set);
        var h = a.axisTitleOffset, k = a.radarCategoriesEnabled, l = a.chart.fontFamily, m = a.fontSize;
        void 0 === m && (m = a.chart.fontSize);
        var n = a.color;
        void 0 === n && (n = a.chart.color);
        if (b) {
            this.axisWidth = a.height;
            a = b.chartData;
            var s = a.length, q;
            for (q = 0; q < s; q++) {
                var t = 180 - 360 / s * q, p = f + this.axisWidth * Math.sin(t / 180 * Math.PI), r = g + this.axisWidth * Math.cos(t /
                        180 * Math.PI);
                0 < e && (p = AmCharts.line(b.container, [f, p], [g, r], d, e, c), this.set.push(p));
                if (k) {
                    var u = "start", p = f + (this.axisWidth + h) * Math.sin(t / 180 * Math.PI), r = g + (this.axisWidth + h) * Math.cos(t / 180 * Math.PI);
                    if (180 == t || 0 === t)u = "middle", p -= 5;
                    0 > t && (u = "end", p -= 10);
                    180 == t && (r -= 5);
                    0 === t && (r += 5);
                    t = AmCharts.text(b.container, a[q].category, n, l, m, u);
                    t.translate(p + 5, r);
                    this.set.push(t);
                    t.getBBox()
                }
            }
        }
    }
});
AmCharts.RadItem = AmCharts.Class({
    construct: function (a, b, c, d, e, f, g) {
        void 0 === c && (c = "");
        var h = a.chart.fontFamily, k = a.fontSize;
        void 0 === k && (k = a.chart.fontSize);
        var l = a.color;
        void 0 === l && (l = a.chart.color);
        var m = a.chart.container;
        this.set = d = m.set();
        var n = a.axisColor, s = a.axisAlpha, q = a.tickLength, t = a.gridAlpha, p = a.gridThickness, r = a.gridColor, u = a.dashLength, v = a.fillColor, w = a.fillAlpha, A = a.labelsEnabled;
        e = a.counter;
        var x = a.inside, B = a.gridType, y;
        b -= a.height;
        var z;
        f = a.x;
        var C = a.y;
        g ? (A = !0, isNaN(g.tickLength) ||
        (q = g.tickLength), void 0 != g.lineColor && (r = g.lineColor), isNaN(g.lineAlpha) || (t = g.lineAlpha), isNaN(g.dashLength) || (u = g.dashLength), isNaN(g.lineThickness) || (p = g.lineThickness), !0 === g.inside && (x = !0)) : c || (t /= 3, q /= 2);
        var H = "end", J = -1;
        x && (H = "start", J = 1);
        var W;
        A && (W = AmCharts.text(m, c, l, h, k, H), W.translate(f + (q + 3) * J, b), d.push(W), this.label = W, z = AmCharts.line(m, [f, f + q * J], [b, b], n, s, p), d.push(z));
        b = a.y - b;
        c = [];
        h = [];
        if (0 < t) {
            if ("polygons" == B) {
                y = a.data.length;
                for (k = 0; k < y; k++)l = 180 - 360 / y * k, c.push(b * Math.sin(l / 180 * Math.PI)),
                    h.push(b * Math.cos(l / 180 * Math.PI));
                c.push(c[0]);
                h.push(h[0]);
                t = AmCharts.line(m, c, h, r, t, p, u)
            } else t = AmCharts.circle(m, b, "#FFFFFF", 0, p, r, t);
            t.translate(f, C);
            d.push(t)
        }
        if (1 == e && 0 < w && !g) {
            g = a.previousCoord;
            if ("polygons" == B) {
                for (k = y; 0 <= k; k--)l = 180 - 360 / y * k, c.push(g * Math.sin(l / 180 * Math.PI)), h.push(g * Math.cos(l / 180 * Math.PI));
                y = AmCharts.polygon(m, c, h, v, w)
            } else y = AmCharts.wedge(m, 0, 0, 0, -360, b, b, g, 0, {
                fill: v,
                "fill-opacity": w,
                stroke: 0,
                "stroke-opacity": 0,
                "stroke-width": 0
            });
            d.push(y);
            y.translate(f, C)
        }
        !1 === a.visible &&
        (z && z.hide(), W && W.hide());
        a.counter = 0 === e ? 1 : 0;
        a.previousCoord = b
    }, graphics: function () {
        return this.set
    }, getLabel: function () {
        return this.label
    }
});
AmCharts.RadarFill = AmCharts.Class({
    construct: function (a, b, c, d) {
        b -= a.axisWidth;
        c -= a.axisWidth;
        var e = Math.max(b, c);
        b = c = Math.min(b, c);
        c = a.chart.container;
        var f = d.fillAlpha, g = d.fillColor, e = Math.abs(e - a.y);
        b = Math.abs(b - a.y);
        var h = Math.max(e, b);
        b = Math.min(e, b);
        e = h;
        h = -d.angle;
        d = -d.toAngle;
        isNaN(h) && (h = 0);
        isNaN(d) && (d = -360);
        this.set = c.set();
        void 0 === g && (g = "#000000");
        isNaN(f) && (f = 0);
        if ("polygons" == a.gridType) {
            d = [];
            var k = [], l = a.data.length, m;
            for (m = 0; m < l; m++)h = 180 - 360 / l * m, d.push(e * Math.sin(h / 180 * Math.PI)), k.push(e *
                Math.cos(h / 180 * Math.PI));
            d.push(d[0]);
            k.push(k[0]);
            for (m = l; 0 <= m; m--)h = 180 - 360 / l * m, d.push(b * Math.sin(h / 180 * Math.PI)), k.push(b * Math.cos(h / 180 * Math.PI));
            this.fill = AmCharts.polygon(c, d, k, g, f)
        } else this.fill = AmCharts.wedge(c, 0, 0, h, d - h, e, e, b, 0, {
            fill: g,
            "fill-opacity": f,
            stroke: 0,
            "stroke-opacity": 0,
            "stroke-width": 0
        });
        this.set.push(this.fill);
        this.fill.translate(a.x, a.y)
    }, graphics: function () {
        return this.set
    }, getLabel: function () {
    }
});
AmCharts.AmGraph = AmCharts.Class({
    construct: function () {
        this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph");
        this.type = "line";
        this.stackable = !0;
        this.columnCount = 1;
        this.columnIndex = 0;
        this.centerCustomBullets = this.showBalloon = !0;
        this.maxBulletSize = 50;
        this.minBulletSize = 0;
        this.balloonText = "[[value]]";
        this.hidden = this.scrollbar = this.animationPlayed = !1;
        this.columnWidth = 0.8;
        this.pointPosition = "middle";
        this.depthCount = 1;
        this.includeInMinMax = !0;
        this.negativeBase = 0;
        this.visibleInLegend = !0;
        this.showAllValueLabels = !1;
        this.showBalloonAt = "close";
        this.lineThickness = 1;
        this.dashLength = 0;
        this.connect = !0;
        this.lineAlpha = 1;
        this.bullet = "none";
        this.bulletBorderThickness = 2;
        this.bulletAlpha = this.bulletBorderAlpha = 1;
        this.bulletSize = 8;
        this.hideBulletsCount = this.bulletOffset = 0;
        this.labelPosition = "top";
        this.cornerRadiusTop = 0;
        this.cursorBulletAlpha = 1;
        this.gradientOrientation = "vertical";
        this.dy = this.dx = 0;
        this.periodValue = "";
        this.y = this.x = 0
    }, draw: function () {
        var a =
            this.chart, b = a.container;
        this.container = b;
        this.destroy();
        var c = b.set(), d = b.set();
        this.behindColumns ? (a.graphsBehindSet.push(c), a.bulletBehindSet.push(d)) : (a.graphsSet.push(c), a.bulletSet.push(d));
        this.bulletSet = d;
        if (!this.scrollbar) {
            var e = a.marginLeftReal, a = a.marginTopReal;
            c.translate(e, a);
            d.translate(e, a)
        }
        b = b.set();
        AmCharts.remove(this.columnsSet);
        c.push(b);
        this.set = c;
        this.columnsSet = b;
        this.columnsArray = [];
        this.ownColumns = [];
        this.allBullets = [];
        this.animationArray = [];
        AmCharts.ifArray(this.data) &&
        (c = !1, "xy" == this.chartType ? this.xAxis.axisCreated && this.yAxis.axisCreated && (c = !0) : this.valueAxis.axisCreated && (c = !0), !this.hidden && c && this.createGraph())
    }, createGraph: function () {
        var a = this, b = a.chart;
        "inside" == a.labelPosition && (a.labelPosition = "bottom");
        a.startAlpha = b.startAlpha;
        a.seqAn = b.sequencedAnimation;
        a.baseCoord = a.valueAxis.baseCoord;
        a.fillColors || (a.fillColors = a.lineColor);
        void 0 === a.fillAlphas && (a.fillAlphas = 0);
        void 0 === a.bulletColor && (a.bulletColor = a.lineColor, a.bulletColorNegative = a.negativeLineColor);
        void 0 === a.bulletAlpha && (a.bulletAlpha = a.lineAlpha);
        a.bulletBorderColor || (a.bulletBorderAlpha = 0);
        clearTimeout(a.playedTO);
        if (!isNaN(a.valueAxis.min) && !isNaN(a.valueAxis.max)) {
            switch (a.chartType) {
                case "serial":
                    a.createSerialGraph();
                    "candlestick" == a.type && 1 > a.valueAxis.minMaxMultiplier && a.positiveClip(a.set);
                    break;
                case "radar":
                    a.createRadarGraph();
                    break;
                case "xy":
                    a.createXYGraph(), a.positiveClip(a.set)
            }
            a.playedTO = setTimeout(function () {
                a.setAnimationPlayed.call(a)
            }, 500 * a.chart.startDuration)
        }
    }, setAnimationPlayed: function () {
        this.animationPlayed = !0
    }, createXYGraph: function () {
        var a = [], b = [], c = this.xAxis, d = this.yAxis;
        this.pmh = d.viH + 1;
        this.pmw = c.viW + 1;
        this.pmy = this.pmx = 0;
        var e;
        for (e = this.start; e <= this.end; e++) {
            var f = this.data[e].axes[c.id].graphs[this.id], g = f.values, h = g.x, k = g.y, g = c.getCoordinate(h), l = d.getCoordinate(k);
            !isNaN(h) && !isNaN(k) && (a.push(g), b.push(l), (h = this.createBullet(f, g, l, e)) || (h = 0), k = this.labelText) && (f = this.createLabel(f, g, l, k), this.allBullets.push(f), this.positionLabel(g, l, f, this.labelPosition, h))
        }
        this.drawLineGraph(a, b);
        this.launchAnimation()
    },
    createRadarGraph: function () {
        var a = this.valueAxis.stackType, b = [], c = [], d, e, f;
        for (f = this.start; f <= this.end; f++) {
            var g = this.data[f].axes[this.valueAxis.id].graphs[this.id], h;
            h = "none" == a || "3d" == a ? g.values.value : g.values.close;
            if (isNaN(h))this.drawLineGraph(b, c), b = [], c = []; else {
                var k = this.y - (this.valueAxis.getCoordinate(h) - this.height), l = 180 - 360 / (this.end - this.start + 1) * f;
                h = k * Math.sin(l / 180 * Math.PI);
                k *= Math.cos(l / 180 * Math.PI);
                b.push(h);
                c.push(k);
                (l = this.createBullet(g, h, k, f)) || (l = 0);
                var m = this.labelText;
                m && (g = this.createLabel(g, h, k, m), this.allBullets.push(g), this.positionLabel(h, k, g, this.labelPosition, l));
                isNaN(d) && (d = h);
                isNaN(e) && (e = k)
            }
        }
        b.push(d);
        c.push(e);
        this.drawLineGraph(b, c);
        this.launchAnimation()
    }, positionLabel: function (a, b, c, d, e) {
        var f = c.getBBox();
        switch (d) {
            case "left":
                a -= (f.width + e) / 2 + 2;
                break;
            case "top":
                b -= (e + f.height) / 2 + 1;
                break;
            case "right":
                a += (f.width + e) / 2 + 2;
                break;
            case "bottom":
                b += (e + f.height) / 2 + 1
        }
        c.translate(a, b)
    }, createSerialGraph: function () {
        var a = this.chart, b = this.id, c = this.index, d =
                this.data, e = this.chart.container, f = this.valueAxis, g = this.type, h = this.columnWidth, k = this.width, l = this.height, m = this.y, n = this.rotate, s = this.columnCount, q = AmCharts.toCoordinate(this.cornerRadiusTop, h / 2), t = this.connect, p = [], r = [], u, v, w = this.chart.graphs.length, A, x = this.dx / this.depthCount, B = this.dy / this.depthCount, y = f.stackType, z = this.labelPosition, C = this.start, H = this.end, J = this.scrollbar, W = this.categoryAxis, U = this.baseCoord, sa = this.negativeBase, R = this.columnIndex, T = this.lineThickness, P = this.lineAlpha,
            la = this.lineColor, da = this.dashLength, ea = this.set;
        "above" == z && (z = "top");
        "below" == z && (z = "bottom");
        var fa = z, X = 270;
        "horizontal" == this.gradientOrientation && (X = 0);
        this.gradientRotation = X;
        var V = this.chart.columnSpacing, I = W.cellWidth, G = (I * h - s) / s;
        V > G && (V = G);
        var $, D, Y, Wa = l + 1, Xa = k + 1, Pa = 0, Ya = 0, Za, $a, Qa, Ra, Cb = this.fillColors, Fa = this.negativeFillColors, ya = this.negativeLineColor, Ga = this.fillAlphas, Ha = this.negativeFillAlphas;
        "object" == typeof Ga && (Ga = Ga[0]);
        "object" == typeof Ha && (Ha = Ha[0]);
        var Sa = f.getCoordinate(f.min);
        f.logarithmic && (Sa = f.getCoordinate(f.minReal));
        this.minCoord = Sa;
        this.resetBullet && (this.bullet = "none");
        if (!J && ("line" == g || "smoothedLine" == g || "step" == g) && (1 == d.length && ("step" != g && "none" == this.bullet) && (this.bullet = "round", this.resetBullet = !0), Fa || void 0 != ya)) {
            var Ca = sa;
            Ca > f.max && (Ca = f.max);
            Ca < f.min && (Ca = f.min);
            f.logarithmic && (Ca = f.minReal);
            var ta = f.getCoordinate(Ca), ob = f.getCoordinate(f.max);
            n ? (Wa = l, Xa = Math.abs(ob - ta), Za = l, $a = Math.abs(Sa - ta), Ra = Ya = 0, f.reversed ? (Pa = 0, Qa = ta) : (Pa = ta, Qa = 0)) : (Xa = k, Wa =
                Math.abs(ob - ta), $a = k, Za = Math.abs(Sa - ta), Qa = Pa = 0, f.reversed ? (Ra = m, Ya = ta) : Ra = ta + 1)
        }
        var ua = Math.round;
        this.pmx = ua(Pa);
        this.pmy = ua(Ya);
        this.pmh = ua(Wa);
        this.pmw = ua(Xa);
        this.nmx = ua(Qa);
        this.nmy = ua(Ra);
        this.nmh = ua(Za);
        this.nmw = ua($a);
        9 > AmCharts.IEversion && 0 < AmCharts.IEversion && (this.nmy = this.nmx = 0, this.nmh = this.height);
        h = "column" == g ? (I * h - V * (s - 1)) / s : I * h;
        1 > h && (h = 1);
        var N;
        if ("line" == g || "step" == g || "smoothedLine" == g) {
            if (0 < C)for (N = C - 1; -1 < N; N--)if ($ = d[N], D = $.axes[f.id].graphs[b], Y = D.values.value) {
                C = N;
                break
            }
            if (H <
                d.length - 1)for (N = H + 1; N < d.length; N++)if ($ = d[N], D = $.axes[f.id].graphs[b], Y = D.values.value) {
                H = N;
                break
            }
        }
        H < d.length - 1 && H++;
        var ga = [], ha = [], Ia = !1;
        if ("line" == g || "step" == g || "smoothedLine" == g)if (this.stackable && "regular" == y || "100%" == y || this.fillToGraph)Ia = !0;
        for (N = C; N <= H; N++) {
            $ = d[N];
            D = $.axes[f.id].graphs[b];
            D.index = N;
            var L, M, K, aa, na = NaN, F = NaN, E = NaN, Q = NaN, O = NaN, Ja = NaN, za = NaN, Ka = NaN, Aa = NaN, Z = NaN, ca = NaN, oa = NaN, pa = NaN, S = NaN, ab = NaN, bb = NaN, ia = NaN, ja = void 0, va = Cb, La = Ga, ma = la, ka, qa;
            void 0 != D.color && (va = D.color);
            D.fillColors &&
            (va = D.fillColors);
            isNaN(D.alpha) || (La = D.alpha);
            var ra = D.values;
            f.recalculateToPercents && (ra = D.percents);
            if (ra) {
                S = this.stackable && "none" != y && "3d" != y ? ra.close : ra.value;
                if ("candlestick" == g || "ohlc" == g)S = ra.close, bb = ra.low, za = f.getCoordinate(bb), ab = ra.high, Aa = f.getCoordinate(ab);
                ia = ra.open;
                E = f.getCoordinate(S);
                isNaN(ia) || (O = f.getCoordinate(ia));
                if (!J)switch (this.showBalloonAt) {
                    case "close":
                        D.y = E;
                        break;
                    case "open":
                        D.y = O;
                        break;
                    case "high":
                        D.y = Aa;
                        break;
                    case "low":
                        D.y = za
                }
                var na = $.x[W.id], wa = Math.floor(I / 2),
                    Ma = wa;
                "start" == this.pointPosition && (na -= I / 2, wa = 0, Ma = I);
                J || (D.x = na);
                -1E5 > na && (na = -1E5);
                na > k + 1E5 && (na = k + 1E5);
                n ? (F = E, Q = O, O = E = na, isNaN(ia) && !this.fillToGraph && (Q = U), Ja = za, Ka = Aa) : (Q = F = na, isNaN(ia) && !this.fillToGraph && (O = U));
                S < ia && (D.isNegative = !0, Fa && (va = Fa), Ha && (La = Ha), void 0 != ya && (ma = ya));
                switch (g) {
                    case "line":
                        isNaN(S) ? t || (this.drawLineGraph(p, r, ga, ha), p = [], r = [], ga = [], ha = []) : (D.isNegative = S < sa ? !0 : !1, p.push(F), r.push(E), Z = F, ca = E, oa = F, pa = E, !Ia || (isNaN(O) || isNaN(Q)) || (ga.push(Q), ha.push(O)));
                        break;
                    case "smoothedLine":
                        isNaN(S) ?
                        t || (this.drawSmoothedGraph(p, r, ga, ha), p = [], r = [], ga = [], ha = []) : (D.isNegative = S < sa ? !0 : !1, p.push(F), r.push(E), Z = F, ca = E, oa = F, pa = E, !Ia || (isNaN(O) || isNaN(Q)) || (ga.push(Q), ha.push(O)));
                        break;
                    case "step":
                        isNaN(S) ? t || (v = NaN, this.drawLineGraph(p, r, ga, ha), p = [], r = [], ga = [], ha = []) : (D.isNegative = S < sa ? !0 : !1, n ? (isNaN(u) || (p.push(u), r.push(E - wa)), r.push(E - wa), p.push(F), r.push(E + Ma), p.push(F), !Ia || (isNaN(O) || isNaN(Q)) || (ga.push(Q), ha.push(O - wa), ga.push(Q), ha.push(O + Ma))) : (isNaN(v) || (r.push(v), p.push(F - wa)), p.push(F -
                            wa), r.push(E), p.push(F + Ma), r.push(E), !Ia || (isNaN(O) || isNaN(Q)) || (ga.push(Q - wa), ha.push(O), ga.push(Q + Ma), ha.push(O))), u = F, v = E, Z = F, ca = E, oa = F, pa = E);
                        break;
                    case "column":
                        ka = ma;
                        void 0 != D.lineColor && (ka = D.lineColor);
                        if (!isNaN(S)) {
                            S < sa ? (D.isNegative = !0, Fa && (va = Fa), void 0 != ya && (ma = ya)) : D.isNegative = !1;
                            var pb = f.min, qb = f.max;
                            if (!(S < pb && ia < pb || S > qb && ia > qb))if (n) {
                                "3d" == y ? (M = E - 0.5 * (h + V) + V / 2 + B * R, L = Q + x * R) : (M = E - (s / 2 - R) * (h + V) + V / 2, L = Q);
                                K = h;
                                Z = F;
                                ca = M + h / 2;
                                oa = F;
                                pa = M + h / 2;
                                M + K > l && (K = l - M);
                                0 > M && (K += M, M = 0);
                                aa = F - Q;
                                var Db = L;
                                L =
                                    AmCharts.fitToBounds(L, 0, k);
                                aa += Db - L;
                                aa = AmCharts.fitToBounds(aa, -L, k - L + x * R);
                                if (M < l && 0 < K && (ja = new AmCharts.Cuboid(e, aa, K, x - a.d3x, B - a.d3y, va, La, T, ka, P, X, q, n), "bottom" != z))if (z = f.reversed ? "left" : "right", 0 > S)z = f.reversed ? "right" : "left"; else if ("regular" == y || "100%" == y)Z += this.dx
                            } else {
                                "3d" == y ? (L = F - 0.5 * (h + V) + V / 2 + x * R, M = O + B * R) : (L = F - (s / 2 - R) * (h + V) + V / 2, M = O);
                                K = h;
                                Z = L + h / 2;
                                ca = E;
                                oa = L + h / 2;
                                pa = E;
                                L + K > k + R * x && (K = k - L + R * x);
                                0 > L && (K += L, L = 0);
                                aa = E - O;
                                var Eb = M;
                                M = AmCharts.fitToBounds(M, this.dy, l);
                                aa += Eb - M;
                                aa = AmCharts.fitToBounds(aa,
                                    -M + B * R, l - M);
                                if (L < k + R * x && 0 < K)if (ja = new AmCharts.Cuboid(e, K, aa, x - a.d3x, B - a.d3y, va, La, T, ka, this.lineAlpha, X, q, n), 0 > S && "middle" != z)z = "bottom"; else if (z = fa, "regular" == y || "100%" == y)ca += this.dy
                            }
                            if (ja && (qa = ja.set, qa.translate(L, M), this.columnsSet.push(qa), (D.url || this.showHandOnHover) && qa.setAttr("cursor", "pointer"), !J)) {
                                "none" == y && (A = n ? (this.end + 1 - N) * w - c : w * N + c);
                                "3d" == y && (n ? (A = (w - c) * (this.end + 1 - N), Z += x * this.columnIndex, oa += x * this.columnIndex, D.y += x * this.columnIndex) : (A = (w - c) * (N + 1), Z += 3, ca += B * this.columnIndex +
                                    7, pa += B * this.columnIndex, D.y += B * this.columnIndex));
                                if ("regular" == y || "100%" == y)z = "middle", A = n ? 0 < ra.value ? (this.end + 1 - N) * w + c : (this.end + 1 - N) * w - c : 0 < ra.value ? w * N + c : w * N - c;
                                this.columnsArray.push({column: ja, depth: A});
                                D.x = n ? M + K / 2 : L + K / 2;
                                this.ownColumns.push(ja);
                                this.animateColumns(ja, N, F, Q, E, O);
                                this.addListeners(qa, D)
                            }
                        }
                        break;
                    case "candlestick":
                        if (!isNaN(ia) && !isNaN(S)) {
                            var Ta, cb;
                            ka = ma;
                            void 0 != D.lineColor && (ka = D.lineColor);
                            if (n) {
                                if (M = E - h / 2, L = Q, K = h, M + K > l && (K = l - M), 0 > M && (K += M, M = 0), M < l && 0 < K) {
                                    var db, eb;
                                    S > ia ? (db =
                                        [F, Ka], eb = [Q, Ja]) : (db = [Q, Ka], eb = [F, Ja]);
                                    !isNaN(Ka) && !isNaN(Ja) && (E < l && 0 < E) && (Ta = AmCharts.line(e, db, [E, E], ka, P, T), cb = AmCharts.line(e, eb, [E, E], ka, P, T));
                                    aa = F - Q;
                                    ja = new AmCharts.Cuboid(e, aa, K, x, B, va, Ga, T, ka, P, X, q, n)
                                }
                            } else if (L = F - h / 2, M = O + T / 2, K = h, L + K > k && (K = k - L), 0 > L && (K += L, L = 0), aa = E - O, L < k && 0 < K) {
                                var ja = new AmCharts.Cuboid(e, K, aa, x, B, va, La, T, ka, P, X, q, n), fb, gb;
                                S > ia ? (fb = [E, Aa], gb = [O, za]) : (fb = [O, Aa], gb = [E, za]);
                                !isNaN(Aa) && !isNaN(za) && (F < k && 0 < F) && (Ta = AmCharts.line(e, [F, F], fb, ka, P, T), cb = AmCharts.line(e, [F, F], gb,
                                    ka, P, T))
                            }
                            ja && (qa = ja.set, ea.push(qa), qa.translate(L, M - T / 2), (D.url || this.showHandOnHover) && qa.setAttr("cursor", "pointer"), Ta && (ea.push(Ta), ea.push(cb)), Z = F, ca = E, oa = F, pa = E, J || (D.x = n ? M + K / 2 : L + K / 2, this.animateColumns(ja, N, F, Q, E, O), this.addListeners(qa, D)))
                        }
                        break;
                    case "ohlc":
                        if (!(isNaN(ia) || isNaN(ab) || isNaN(bb) || isNaN(S))) {
                            S < ia && (D.isNegative = !0, void 0 != ya && (ma = ya));
                            var hb, ib, jb;
                            if (n) {
                                var kb = E - h / 2, kb = AmCharts.fitToBounds(kb, 0, l), rb = AmCharts.fitToBounds(E, 0, l), lb = E + h / 2, lb = AmCharts.fitToBounds(lb, 0, l);
                                ib =
                                    AmCharts.line(e, [Q, Q], [kb, rb], ma, P, T, da);
                                0 < E && E < l && (hb = AmCharts.line(e, [Ja, Ka], [E, E], ma, P, T, da));
                                jb = AmCharts.line(e, [F, F], [rb, lb], ma, P, T, da)
                            } else {
                                var mb = F - h / 2, mb = AmCharts.fitToBounds(mb, 0, k), sb = AmCharts.fitToBounds(F, 0, k), nb = F + h / 2, nb = AmCharts.fitToBounds(nb, 0, k);
                                ib = AmCharts.line(e, [mb, sb], [O, O], ma, P, T, da);
                                0 < F && F < k && (hb = AmCharts.line(e, [F, F], [za, Aa], ma, P, T, da));
                                jb = AmCharts.line(e, [sb, nb], [E, E], ma, P, T, da)
                            }
                            ea.push(ib);
                            ea.push(hb);
                            ea.push(jb);
                            Z = F;
                            ca = E;
                            oa = F;
                            pa = E
                        }
                }
                if (!J && !isNaN(S)) {
                    var tb = this.hideBulletsCount;
                    if (this.end - this.start <= tb || 0 === tb) {
                        var Da = this.createBullet(D, oa, pa, N);
                        Da || (Da = 0);
                        var ub = this.labelText;
                        if (ub) {
                            var ba = this.createLabel(D, 0, 0, ub), xa = 0, Ba = 0, vb = ba.getBBox(), Ua = vb.width, Va = vb.height;
                            switch (z) {
                                case "left":
                                    xa = -(Ua / 2 + Da / 2 + 3);
                                    break;
                                case "top":
                                    Ba = -(Va / 2 + Da / 2 + 3);
                                    break;
                                case "right":
                                    xa = Da / 2 + 2 + Ua / 2;
                                    break;
                                case "bottom":
                                    n && "column" == g ? (Z = U, 0 > S ? (xa = -6, ba.attr({"text-anchor": "end"})) : (xa = 6, ba.attr({"text-anchor": "start"}))) : (Ba = Da / 2 + Va / 2, ba.x = -(Ua / 2 + 2));
                                    break;
                                case "middle":
                                    "column" == g && (n ? (Ba = -(Va /
                                        2) + this.fontSize / 2, xa = -(F - Q) / 2 - x, 0 > aa && (xa += x), Math.abs(F - Q) < Ua && !this.showAllValueLabels && (ba.remove(), ba = null)) : (Ba = -(E - O) / 2, 0 > aa && (Ba -= B), Math.abs(E - O) < Va && !this.showAllValueLabels && (ba.remove(), ba = null)))
                            }
                            if (ba) {
                                if (isNaN(ca) || isNaN(Z))ba.remove(), ba = null; else if (Z += xa, ca += Ba, ba.translate(Z, ca), n) {
                                    if (0 > ca || ca > l)ba.remove(), ba = null
                                } else {
                                    var wb = 0;
                                    "3d" == y && (wb = x * R);
                                    if (0 > Z || Z > k + wb)ba.remove(), ba = null
                                }
                                ba && this.allBullets.push(ba)
                            }
                        }
                        if ("column" == g && "regular" == y || "100%" == y) {
                            var xb = f.totalText;
                            if (xb) {
                                var Ea =
                                    this.createLabel(D, 0, 0, xb, f.totalTextColor);
                                this.allBullets.push(Ea);
                                var yb = Ea.getBBox(), zb = yb.width, Ab = yb.height, Na, Oa, Bb = f.totals[N];
                                Bb && Bb.remove();
                                n ? (Oa = E, Na = 0 > S ? F - zb / 2 - 2 : F + zb / 2 + 3) : (Na = F, Oa = 0 > S ? E + Ab / 2 : E - Ab / 2 - 3);
                                Ea.translate(Na, Oa);
                                f.totals[N] = Ea;
                                n ? (0 > Oa || Oa > l) && Ea.remove() : (0 > Na || Na > k) && Ea.remove()
                            }
                        }
                    }
                }
            }
        }
        if ("line" == g || "step" == g || "smoothedLine" == g)"smoothedLine" == g ? this.drawSmoothedGraph(p, r, ga, ha) : this.drawLineGraph(p, r, ga, ha), J || this.launchAnimation();
        this.bulletsHidden && this.hideBullets()
    }, animateColumns: function (a,
                                 b, c, d, e, f) {
        var g = this;
        c = g.chart.startDuration;
        0 < c && !g.animationPlayed && (g.seqAn ? (a.set.hide(), g.animationArray.push(a), a = setTimeout(function () {
            g.animate.call(g)
        }, 1E3 * c / (g.end - g.start + 1) * (b - g.start)), g.timeOuts.push(a)) : g.animate(a))
    }, createLabel: function (a, b, c, d, e) {
        var f = this.chart, g = a.labelColor;
        void 0 == g && (g = this.color);
        void 0 == g && (g = f.color);
        void 0 != e && (g = e);
        e = this.fontSize;
        void 0 === e && (this.fontSize = e = f.fontSize);
        a = f.formatString(d, a, this);
        a = AmCharts.cleanFromEmpty(a);
        f = AmCharts.text(this.container,
            a, g, f.fontFamily, e);
        f.translate(b, c);
        this.bulletSet.push(f);
        return f
    }, positiveClip: function (a) {
        a.clipRect(this.pmx, this.pmy, this.pmw, this.pmh)
    }, negativeClip: function (a) {
        a.clipRect(this.nmx, this.nmy, this.nmw, this.nmh)
    }, drawLineGraph: function (a, b, c, d) {
        var e = this;
        if (1 < a.length) {
            var f = e.set, g = e.container, h = g.set(), k = g.set();
            f.push(k);
            f.push(h);
            var l = e.lineAlpha, m = e.lineThickness, n = e.dashLength, f = e.fillAlphas, s = e.lineColor, q = e.fillColors, t = e.negativeLineColor, p = e.negativeFillColors, r = e.negativeFillAlphas,
                u = e.baseCoord;
            0 != e.negativeBase && (u = e.valueAxis.getCoordinate(e.negativeBase));
            s = AmCharts.line(g, a, b, s, l, m, n, !1, !0);
            h.push(s);
            h.click(function () {
                e.handleGraphClick()
            });
            void 0 !== t && (l = AmCharts.line(g, a, b, t, l, m, n, !1, !0), k.push(l));
            if (0 < f || 0 < r)if (l = a.join(";").split(";"), m = b.join(";").split(";"), "serial" == e.chartType && (0 < c.length ? (c.reverse(), d.reverse(), l = a.concat(c), m = b.concat(d)) : e.rotate ? (m.push(m[m.length - 1]), l.push(u), m.push(m[0]), l.push(u), m.push(m[0]), l.push(l[0])) : (l.push(l[l.length - 1]), m.push(u),
                    l.push(l[0]), m.push(u), l.push(a[0]), m.push(m[0]))), 0 < f && (a = AmCharts.polygon(g, l, m, q, f, 0, 0, 0, this.gradientRotation), h.push(a)), p || void 0 !== t)isNaN(r) && (r = f), p || (p = t), g = AmCharts.polygon(g, l, m, p, r, 0, 0, 0, this.gradientRotation), k.push(g), k.click(function () {
                e.handleGraphClick()
            });
            e.applyMask(k, h)
        }
    }, applyMask: function (a, b) {
        var c = a.length();
        "serial" != this.chartType || this.scrollbar || (this.positiveClip(b), 0 < c && this.negativeClip(a))
    }, drawSmoothedGraph: function (a, b, c, d) {
        if (1 < a.length) {
            var e = this.set, f = this.container,
                g = f.set(), h = f.set();
            e.push(h);
            e.push(g);
            var k = this.lineAlpha, l = this.lineThickness, e = this.dashLength, m = this.fillAlphas, n = this.fillColors, s = this.negativeLineColor, q = this.negativeFillColors, t = this.negativeFillAlphas, p = this.baseCoord, r = new AmCharts.Bezier(f, a, b, this.lineColor, k, l, n, 0, e);
            g.push(r.path);
            void 0 !== s && (k = new AmCharts.Bezier(f, a, b, s, k, l, n, 0, e), h.push(k.path));
            0 < m && (l = a.join(";").split(";"), r = b.join(";").split(";"), k = "", 0 < c.length ? (c.reverse(), d.reverse(), l = a.concat(c), r = b.concat(d)) : (this.rotate ?
                (k += " L" + p + "," + b[b.length - 1], k += " L" + p + "," + b[0]) : (k += " L" + a[a.length - 1] + "," + p, k += " L" + a[0] + "," + p), k += " L" + a[0] + "," + b[0]), c = new AmCharts.Bezier(f, l, r, NaN, 0, 0, n, m, e, k), g.push(c.path), q || void 0 !== s) && (t || (t = m), q || (q = s), a = new AmCharts.Bezier(f, a, b, NaN, 0, 0, q, t, e, k), h.push(a.path));
            this.applyMask(h, g)
        }
    }, launchAnimation: function () {
        var a = this, b = a.chart.startDuration;
        if (0 < b && !a.animationPlayed) {
            var c = a.set, d = a.bulletSet;
            AmCharts.VML || (c.attr({opacity: a.startAlpha}), d.attr({opacity: a.startAlpha}));
            c.hide();
            d.hide();
            a.seqAn ? (b = setTimeout(function () {
                a.animateGraphs.call(a)
            }, 1E3 * a.index * b), a.timeOuts.push(b)) : a.animateGraphs()
        }
    }, animateGraphs: function () {
        var a = this.chart, b = this.set, c = this.bulletSet, d = this.x, e = this.y;
        b.show();
        c.show();
        var f = a.startDuration, a = a.startEffect;
        b && (this.rotate ? (b.translate(-1E3, e), c.translate(-1E3, e)) : (b.translate(d, -1E3), c.translate(d, -1E3)), b.animate({
            opacity: 1,
            translate: d + "," + e
        }, f, a), c.animate({opacity: 1, translate: d + "," + e}, f, a))
    }, animate: function (a) {
        var b = this.chart, c = this.container,
            d = this.animationArray;
        !a && 0 < d.length && (a = d[0], d.shift());
        c = c[AmCharts.getEffect(b.startEffect)];
        b = b.startDuration;
        a && (this.rotate ? a.animateWidth(b, c) : a.animateHeight(b, c), a.set.show())
    }, legendKeyColor: function () {
        var a = this.legendColor, b = this.lineAlpha;
        void 0 === a && (a = this.lineColor, 0 === b && (b = this.fillColors) && (a = "object" == typeof b ? b[0] : b));
        return a
    }, legendKeyAlpha: function () {
        var a = this.legendAlpha;
        void 0 === a && (a = this.lineAlpha, 0 === a && this.fillAlphas && (a = this.fillAlphas), 0 === a && (a = this.bulletAlpha),
        0 === a && (a = 1));
        return a
    }, createBullet: function (a, b, c, d) {
        d = this.container;
        var e = this.bulletOffset, f = this.bulletSize;
        isNaN(a.bulletSize) || (f = a.bulletSize);
        if (!isNaN(this.maxValue)) {
            var g = a.values.value;
            isNaN(g) || (f = g / this.maxValue * this.maxBulletSize)
        }
        f < this.minBulletSize && (f = this.minBulletSize);
        this.rotate ? b += e : c -= e;
        var h;
        if ("none" != this.bullet || a.bullet) {
            var k = this.bulletColor;
            a.isNegative && void 0 !== this.bulletColorNegative && (k = this.bulletColorNegative);
            void 0 !== a.color && (k = a.color);
            e = this.bullet;
            a.bullet &&
            (e = a.bullet);
            var g = this.bulletBorderThickness, l = this.bulletBorderColor, m = this.bulletBorderAlpha, n = k, s = this.bulletAlpha, k = a.alpha;
            isNaN(k) || (s = k);
            k = 0;
            switch (e) {
                case "round":
                    h = AmCharts.circle(d, f / 2, n, s, g, l, m);
                    break;
                case "square":
                    h = AmCharts.polygon(d, [0, f, f, 0], [0, 0, f, f], n, s, g, l, m);
                    b -= f / 2;
                    c -= f / 2;
                    k = -f / 2;
                    break;
                case "triangleUp":
                    h = AmCharts.triangle(d, f, 0, n, s, g, l, m);
                    break;
                case "triangleDown":
                    h = AmCharts.triangle(d, f, 180, n, s, g, l, m);
                    break;
                case "triangleLeft":
                    h = AmCharts.triangle(d, f, 270, n, s, g, l, m);
                    break;
                case "triangleRight":
                    h =
                        AmCharts.triangle(d, f, 90, n, s, g, l, m);
                    break;
                case "bubble":
                    h = AmCharts.circle(d, f / 2, n, s, g, l, m, !0)
            }
        }
        g = e = 0;
        if (this.customBullet || a.customBullet)l = this.customBullet, a.customBullet && (l = a.customBullet), l && (h && h.remove(), "function" == typeof l ? (h = new l, h.chart = this.chart, a.bulletConfig && (h.availableSpace = c, h.graph = this, a.bulletConfig.minCoord = this.minCoord - c, h.bulletConfig = a.bulletConfig), h.write(d), h = h.set) : (this.chart.path && (l = this.chart.path + l), h = d.image(l, 0, 0, f, f), this.centerCustomBullets && (b -= f / 2, c -= f / 2,
            e -= f / 2, g -= f / 2)));
        h && ((a.url || this.showHandOnHover) && h.setAttr("cursor", "pointer"), "serial" == this.chartType && (b - e < k || b - e > this.width || c < -f / 2 || c - g > this.height) && (h.remove(), h = null), h && (this.bulletSet.push(h), h.translate(b, c), this.addListeners(h, a), this.allBullets.push(h)));
        return f
    }, showBullets: function () {
        var a = this.allBullets, b;
        this.bulletsHidden = !1;
        for (b = 0; b < a.length; b++)a[b].show()
    }, hideBullets: function () {
        var a = this.allBullets, b;
        this.bulletsHidden = !0;
        for (b = 0; b < a.length; b++)a[b].hide()
    }, addListeners: function (a,
                               b) {
        var c = this;
        a.mouseover(function () {
            c.handleRollOver(b)
        }).mouseout(function () {
            c.handleRollOut(b)
        }).touchend(function () {
            c.handleRollOver(b)
        }).touchstart(function () {
            c.handleRollOver(b)
        }).click(function () {
            c.handleClick(b)
        }).dblclick(function () {
            c.handleDoubleClick(b)
        }).contextmenu(function () {
            c.handleRightClick(b)
        })
    }, handleRollOver: function (a) {
        if (a) {
            var b = this.chart, c = {
                type: "rollOverGraphItem",
                item: a,
                index: a.index,
                graph: this,
                target: this,
                chart: this.chart
            };
            this.fire("rollOverGraphItem", c);
            b.fire("rollOverGraphItem",
                c);
            clearTimeout(b.hoverInt);
            c = this.showBalloon;
            b.chartCursor && "serial" == this.chartType && (c = !1, !b.chartCursor.valueBalloonsEnabled && this.showBalloon && (c = !0));
            c && (c = b.formatString(this.balloonText, a, a.graph), c = AmCharts.cleanFromEmpty(c), a = b.getBalloonColor(this, a), b.balloon.showBullet = !1, b.balloon.pointerOrientation = "V", b.showBalloon(c, a, !0))
        }
    }, handleRollOut: function (a) {
        this.chart.hideBalloon();
        a && (a = {
            type: "rollOutGraphItem",
            item: a,
            index: a.index,
            graph: this,
            target: this,
            chart: this.chart
        }, this.fire("rollOutGraphItem",
            a), this.chart.fire("rollOutGraphItem", a))
    }, handleClick: function (a) {
        if (a) {
            var b = {type: "clickGraphItem", item: a, index: a.index, graph: this, target: this, chart: this.chart};
            this.fire("clickGraphItem", b);
            this.chart.fire("clickGraphItem", b);
            AmCharts.getURL(a.url, this.urlTarget)
        }
        this.handleGraphClick()
    }, handleGraphClick: function () {
        var a = {type: "clickGraph", graph: this, target: this, chart: this.chart};
        this.fire("clickGraph", a);
        this.chart.fire("clickGraph", a)
    }, handleRightClick: function (a) {
        a && (a = {
            type: "rightClickGraphItem",
            item: a, index: a.index, graph: this, target: this, chart: this.chart
        }, this.fire("rightClickGraphItem", a), this.chart.fire("rightClickGraphItem", a))
    }, handleDoubleClick: function (a) {
        a && (a = {
            type: "doubleClickGraphItem",
            item: a,
            index: a.index,
            graph: this,
            target: this,
            chart: this.chart
        }, this.fire("doubleClickGraphItem", a), this.chart.fire("doubleClickGraphItem", a))
    }, zoom: function (a, b) {
        this.start = a;
        this.end = b;
        this.draw()
    }, changeOpacity: function (a) {
        var b = this.set;
        b && b.setAttr("opacity", a);
        if (b = this.ownColumns) {
            var c;
            for (c =
                     0; c < b.length; c++) {
                var d = b[c].set;
                d && d.setAttr("opacity", a)
            }
        }
        (b = this.bulletSet) && b.setAttr("opacity", a)
    }, destroy: function () {
        AmCharts.remove(this.set);
        AmCharts.remove(this.bulletSet);
        var a = this.timeOuts;
        if (a) {
            var b;
            for (b = 0; b < a.length; b++)clearTimeout(a[b])
        }
        this.timeOuts = []
    }
});
AmCharts.ChartCursor = AmCharts.Class({
    construct: function () {
        this.createEvents("changed", "zoomed", "onHideCursor", "draw", "selected");
        this.enabled = !0;
        this.cursorAlpha = 1;
        this.selectionAlpha = 0.2;
        this.cursorColor = "#CC0000";
        this.categoryBalloonAlpha = 1;
        this.color = "#FFFFFF";
        this.type = "cursor";
        this.zoomed = !1;
        this.zoomable = !0;
        this.pan = !1;
        this.animate = !0;
        this.categoryBalloonDateFormat = "MMM DD, YYYY";
        this.categoryBalloonEnabled = this.valueBalloonsEnabled = !0;
        this.rolledOver = !1;
        this.cursorPosition = "middle";
        this.bulletsEnabled =
            this.skipZoomDispatch = !1;
        this.bulletSize = 8;
        this.selectWithoutZooming = this.oneBalloonOnly = !1
    }, draw: function () {
        var a = this;
        a.destroy();
        var b = a.chart, c = b.container;
        a.rotate = b.rotate;
        a.container = c;
        c = c.set();
        c.translate(a.x, a.y);
        a.set = c;
        b.cursorSet.push(c);
        c = new AmCharts.AmBalloon;
        c.chart = b;
        a.categoryBalloon = c;
        c.cornerRadius = 0;
        c.borderThickness = 0;
        c.borderAlpha = 0;
        c.showBullet = !1;
        var d = a.categoryBalloonColor;
        void 0 === d && (d = a.cursorColor);
        c.fillColor = d;
        c.fillAlpha = a.categoryBalloonAlpha;
        c.borderColor = d;
        c.color =
            a.color;
        a.rotate && (c.pointerOrientation = "H");
        if (a.valueBalloonsEnabled)for (c = 0; c < b.graphs.length; c++)d = new AmCharts.AmBalloon, d.chart = b, AmCharts.copyProperties(b.balloon, d), b.graphs[c].valueBalloon = d;
        "cursor" == a.type ? a.createCursor() : a.createCrosshair();
        a.interval = setInterval(function () {
            a.detectMovement.call(a)
        }, 40)
    }, updateData: function () {
        var a = this.chart;
        this.data = a.chartData;
        this.firstTime = a.firstTime;
        this.lastTime = a.lastTime
    }, createCursor: function () {
        var a = this.chart, b = this.cursorAlpha, c = a.categoryAxis,
            d = c.position, e = c.inside, f = c.axisThickness, g = this.categoryBalloon, h, k, l = a.dx, m = a.dy, n = this.x, s = this.y, q = this.width, t = this.height, a = a.rotate, p = c.tickLength;
        g.pointerWidth = p;
        a ? (h = [0, q, q + l], k = [0, 0, m]) : (h = [l, 0, 0], k = [m, 0, t]);
        this.line = b = AmCharts.line(this.container, h, k, this.cursorColor, b, 1);
        this.set.push(b);
        a ? (e && (g.pointerWidth = 0), "right" == d ? e ? g.setBounds(n, s + m, n + q + l, s + t + m) : g.setBounds(n + q + l + f, s + m, n + q + 1E3, s + t + m) : e ? g.setBounds(n, s, q + n, t + s) : g.setBounds(-1E3, -1E3, n - p - f, s + t + 15)) : (g.maxWidth = q, c.parseDates &&
        (p = 0, g.pointerWidth = 0), "top" == d ? e ? g.setBounds(n + l, s + m, q + l + n, t + s) : g.setBounds(n + l, -1E3, q + l + n, s + m - p - f) : e ? g.setBounds(n, s, q + n, t + s - p) : g.setBounds(n, s + t + p + f - 1, n + q, s + t + p + f));
        this.hideCursor()
    }, createCrosshair: function () {
        var a = this.cursorAlpha, b = this.container, c = AmCharts.line(b, [0, 0], [0, this.height], this.cursorColor, a, 1), a = AmCharts.line(b, [0, this.width], [0, 0], this.cursorColor, a, 1);
        this.set.push(c);
        this.set.push(a);
        this.vLine = c;
        this.hLine = a;
        this.hideCursor()
    }, detectMovement: function () {
        var a = this.chart;
        if (a.mouseIsOver) {
            var b =
                a.mouseX - this.x, c = a.mouseY - this.y;
            0 < b && b < this.width && 0 < c && c < this.height ? (this.drawing ? this.rolledOver || a.setMouseCursor("crosshair") : this.pan && (this.rolledOver || a.setMouseCursor("move")), this.rolledOver = !0, this.setPosition()) : this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
        } else this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
    }, getMousePosition: function () {
        var a, b = this.width, c = this.height;
        a = this.chart;
        this.rotate ? (a = a.mouseY - this.y, 0 > a && (a = 0), a > c && (a = c)) : (a = a.mouseX - this.x, 0 >
        a && (a = 0), a > b && (a = b));
        return a
    }, updateCrosshair: function () {
        var a = this.chart, b = a.mouseX - this.x, c = a.mouseY - this.y, d = this.vLine, e = this.hLine, b = AmCharts.fitToBounds(b, 0, this.width), c = AmCharts.fitToBounds(c, 0, this.height);
        0 < this.cursorAlpha && (d.show(), e.show(), d.translate(b, 0), e.translate(0, c));
        this.zooming && (a.hideXScrollbar && (b = NaN), a.hideYScrollbar && (c = NaN), this.updateSelectionSize(b, c));
        a.mouseIsOver || this.zooming || this.hideCursor()
    }, updateSelectionSize: function (a, b) {
        AmCharts.remove(this.selection);
        var c = this.selectionPosX, d = this.selectionPosY, e = 0, f = 0, g = this.width, h = this.height;
        isNaN(a) || (c > a && (e = a, g = c - a), c < a && (e = c, g = a - c), c == a && (e = a, g = 0));
        isNaN(b) || (d > b && (f = b, h = d - b), d < b && (f = d, h = b - d), d == b && (f = b, h = 0));
        0 < g && 0 < h && (c = AmCharts.rect(this.container, g, h, this.cursorColor, this.selectionAlpha), c.translate(e + this.x, f + this.y), this.selection = c)
    }, arrangeBalloons: function () {
        var a = this.valueBalloons, b = this.x, c = this.y, d = this.height + c;
        a.sort(this.compareY);
        var e;
        for (e = 0; e < a.length; e++) {
            var f = a[e].balloon;
            f.setBounds(b,
                c, b + this.width, d);
            f.draw();
            d = f.yPos - 3
        }
        this.arrangeBalloons2()
    }, compareY: function (a, b) {
        return a.yy < b.yy ? 1 : -1
    }, arrangeBalloons2: function () {
        var a = this.valueBalloons;
        a.reverse();
        var b, c = this.x, d, e;
        for (e = 0; e < a.length; e++) {
            var f = a[e].balloon;
            b = f.bottom;
            var g = f.bottom - f.yPos;
            0 < e && b - g < d + 3 && (f.setBounds(c, d + 3, c + this.width, d + g + 3), f.draw());
            f.set && f.set.show();
            d = f.bottom
        }
    }, showBullets: function () {
        AmCharts.remove(this.allBullets);
        var a = this.container, b = a.set();
        this.set.push(b);
        this.set.show();
        this.allBullets =
            b;
        var b = this.chart.graphs, c;
        for (c = 0; c < b.length; c++) {
            var d = b[c];
            if (!d.hidden && d.balloonText) {
                var e = this.data[this.index].axes[d.valueAxis.id].graphs[d.id], f = e.y;
                if (!isNaN(f)) {
                    var g, h;
                    g = e.x;
                    this.rotate ? (h = f, f = g) : h = g;
                    d = AmCharts.circle(a, this.bulletSize / 2, this.chart.getBalloonColor(d, e), d.cursorBulletAlpha);
                    d.translate(h, f);
                    this.allBullets.push(d)
                }
            }
        }
    }, destroy: function () {
        this.clear();
        AmCharts.remove(this.selection);
        this.selection = null;
        var a = this.categoryBalloon;
        a && a.destroy();
        this.destroyValueBalloons();
        AmCharts.remove(this.set)
    }, clear: function () {
        clearInterval(this.interval)
    }, destroyValueBalloons: function () {
        var a = this.valueBalloons;
        if (a) {
            var b;
            for (b = 0; b < a.length; b++)a[b].balloon.hide()
        }
    }, zoom: function (a, b, c, d) {
        var e = this.chart;
        this.destroyValueBalloons();
        this.zooming = !1;
        var f;
        this.rotate ? this.selectionPosY = f = e.mouseY : this.selectionPosX = f = e.mouseX;
        this.start = a;
        this.end = b;
        this.startTime = c;
        this.endTime = d;
        this.zoomed = !0;
        var g = e.categoryAxis, e = this.rotate;
        f = this.width;
        var h = this.height;
        g.parseDates && !g.equalSpacing ? (a = d - c + g.minDuration(), a = e ? h / a : f / a) : a = e ? h / (b - a) : f / (b - a);
        this.stepWidth = a;
        this.setPosition();
        this.hideCursor()
    }, hideObj: function (a) {
        a && a.hide()
    }, hideCursor: function (a) {
        void 0 === a && (a = !0);
        this.hideObj(this.set);
        this.hideObj(this.categoryBalloon);
        this.hideObj(this.line);
        this.hideObj(this.vLine);
        this.hideObj(this.hLine);
        this.hideObj(this.allBullets);
        this.destroyValueBalloons();
        this.selectWithoutZooming || AmCharts.remove(this.selection);
        this.previousIndex = NaN;
        a && this.fire("onHideCursor",
            {type: "onHideCursor", chart: this.chart, target: this});
        this.drawing || this.chart.setMouseCursor("auto")
    }, setPosition: function (a, b) {
        void 0 === b && (b = !0);
        if ("cursor" == this.type) {
            if (AmCharts.ifArray(this.data)) {
                isNaN(a) && (a = this.getMousePosition());
                if ((a != this.previousMousePosition || !0 === this.zoomed || this.oneBalloonOnly) && !isNaN(a)) {
                    var c = this.chart.categoryAxis.xToIndex(a);
                    if (c != this.previousIndex || this.zoomed || "mouse" == this.cursorPosition || this.oneBalloonOnly)this.updateCursor(c, b), this.zoomed = !1
                }
                this.previousMousePosition =
                    a
            }
        } else this.updateCrosshair()
    }, updateCursor: function (a, b) {
        var c = this.chart, d = c.mouseX - this.x, e = c.mouseY - this.y;
        this.drawingNow && (AmCharts.remove(this.drawingLine), this.drawingLine = AmCharts.line(this.container, [this.x + this.drawStartX, this.x + d], [this.y + this.drawStartY, this.y + e], this.cursorColor, 1, 1));
        if (this.enabled) {
            void 0 === b && (b = !0);
            this.index = a;
            var f = c.categoryAxis, g = c.dx, h = c.dy, k = this.x, l = this.y, m = this.width, n = this.height, s = this.data[a];
            if (s) {
                var q = s.x[f.id], t = c.rotate, p = f.inside, r = this.stepWidth,
                    u = this.categoryBalloon, v = this.firstTime, w = this.lastTime, A = this.cursorPosition, x = f.position, B = this.zooming, y = this.panning, z = c.graphs, C = f.axisThickness;
                if (c.mouseIsOver || B || y || this.forceShow)if (this.forceShow = !1, y) {
                    var g = this.panClickPos, c = this.panClickEndTime, B = this.panClickStartTime, H = this.panClickEnd, k = this.panClickStart, d = (t ? g - e : g - d) / r;
                    if (!f.parseDates || f.equalSpacing)d = Math.round(d);
                    0 !== d && (g = {
                        type: "zoomed",
                        target: this
                    }, g.chart = this.chart, f.parseDates && !f.equalSpacing ? (c + d > w && (d = w - c), B + d < v && (d =
                        v - B), g.start = B + d, g.end = c + d, this.fire(g.type, g)) : H + d >= this.data.length || 0 > k + d || (g.start = k + d, g.end = H + d, this.fire(g.type, g)))
                } else {
                    "start" == A && (q -= f.cellWidth / 2);
                    "mouse" == A && c.mouseIsOver && (q = t ? e - 2 : d - 2);
                    if (t) {
                        if (0 > q)if (B)q = 0; else {
                            this.hideCursor();
                            return
                        }
                        if (q > n + 1)if (B)q = n + 1; else {
                            this.hideCursor();
                            return
                        }
                    } else {
                        if (0 > q)if (B)q = 0; else {
                            this.hideCursor();
                            return
                        }
                        if (q > m)if (B)q = m; else {
                            this.hideCursor();
                            return
                        }
                    }
                    0 < this.cursorAlpha && (v = this.line, t ? v.translate(0, q + h) : v.translate(q, 0), v.show());
                    this.linePos = t ? q + h :
                        q;
                    B && (t ? this.updateSelectionSize(NaN, q) : this.updateSelectionSize(q, NaN));
                    v = !0;
                    B && (v = !1);
                    this.categoryBalloonEnabled && v ? (t ? (p && ("right" == x ? u.setBounds(k, l + h, k + m + g, l + q + h) : u.setBounds(k, l + h, k + m + g, l + q)), "right" == x ? p ? u.setPosition(k + m + g, l + q + h) : u.setPosition(k + m + g + C, l + q + h) : p ? u.setPosition(k, l + q) : u.setPosition(k - C, l + q)) : "top" == x ? p ? u.setPosition(k + q + g, l + h) : u.setPosition(k + q + g, l + h - C + 1) : p ? u.setPosition(k + q, l + n) : u.setPosition(k + q, l + n + C - 1), f.parseDates ? (f = AmCharts.formatDate(s.category, this.categoryBalloonDateFormat),
                    -1 != f.indexOf("fff") && (f = AmCharts.formatMilliseconds(f, s.category)), u.showBalloon(f)) : u.showBalloon(s.category)) : u.hide();
                    z && this.bulletsEnabled && this.showBullets();
                    this.destroyValueBalloons();
                    if (z && this.valueBalloonsEnabled && v && c.balloon.enabled) {
                        this.valueBalloons = v = [];
                        if (this.oneBalloonOnly) {
                            h = Infinity;
                            for (f = 0; f < z.length; f++)r = z[f], r.showBalloon && (!r.hidden && r.balloonText) && (u = s.axes[r.valueAxis.id].graphs[r.id], w = u.y, isNaN(w) || (t ? Math.abs(d - w) < h && (h = Math.abs(d - w), H = r) : Math.abs(e - w) < h && (h = Math.abs(e -
                                w), H = r)));
                            this.mostCloseGraph && (H = this.mostCloseGraph)
                        }
                        for (f = 0; f < z.length; f++)if (r = z[f], (!this.oneBalloonOnly || r == H) && (r.showBalloon && !r.hidden && r.balloonText) && (u = s.axes[r.valueAxis.id].graphs[r.id], w = u.y, !isNaN(w))) {
                            q = u.x;
                            p = !0;
                            if (t) {
                                if (h = w, 0 > q || q > n)p = !1
                            } else if (h = q, q = w, 0 > h || h > m + g)p = !1;
                            p && (p = r.valueBalloon, x = c.getBalloonColor(r, u), p.setBounds(k, l, k + m, l + n), p.pointerOrientation = "H", p.changeColor(x), void 0 !== r.balloonAlpha && (p.fillAlpha = r.balloonAlpha), void 0 !== r.balloonTextColor && (p.color = r.balloonTextColor),
                                p.setPosition(h + k, q + l), r = c.formatString(r.balloonText, u, r), "" !== r && p.showBalloon(r), !t && p.set && p.set.hide(), v.push({
                                yy: w,
                                balloon: p
                            }))
                        }
                        t || this.arrangeBalloons()
                    }
                    b ? (g = {type: "changed"}, g.index = a, g.target = this, g.chart = this.chart, g.zooming = B, g.mostCloseGraph = H, g.position = t ? e : d, g.target = this, c.fire("changed", g), this.fire("changed", g), this.skipZoomDispatch = !1) : (this.skipZoomDispatch = !0, c.updateLegendValues(a));
                    this.previousIndex = a
                }
            }
        } else this.hideCursor()
    }, enableDrawing: function (a) {
        this.enabled = !a;
        this.hideCursor();
        this.rolledOver = !1;
        this.drawing = a
    }, isZooming: function (a) {
        a && a != this.zooming && this.handleMouseDown("fake");
        a || a == this.zooming || this.handleMouseUp()
    }, handleMouseOut: function () {
        if (this.enabled)if (this.zooming)this.setPosition(); else {
            this.index = void 0;
            var a = {type: "changed", index: void 0, target: this};
            a.chart = this.chart;
            this.fire("changed", a);
            this.hideCursor()
        }
    }, handleReleaseOutside: function () {
        this.handleMouseUp()
    }, handleMouseUp: function () {
        var a = this.chart, b = this.data, c;
        if (a) {
            var d = a.mouseX - this.x, e = a.mouseY -
                this.y;
            if (this.drawingNow) {
                this.drawingNow = !1;
                AmCharts.remove(this.drawingLine);
                c = this.drawStartX;
                var f = this.drawStartY;
                if (2 < Math.abs(c - d) || 2 < Math.abs(f - e))c = {
                    type: "draw",
                    target: this,
                    chart: a,
                    initialX: c,
                    initialY: f,
                    finalX: d,
                    finalY: e
                }, this.fire(c.type, c)
            }
            if (this.enabled && 0 < b.length) {
                if (this.pan)this.rolledOver = !1; else if (this.zoomable && this.zooming) {
                    c = this.selectWithoutZooming ? {type: "selected"} : {type: "zoomed"};
                    c.target = this;
                    c.chart = a;
                    if ("cursor" == this.type)this.rotate ? this.selectionPosY = e : this.selectionPosX =
                        e = d, 2 > Math.abs(e - this.initialMouse) && this.fromIndex == this.index || (this.index < this.fromIndex ? (c.end = this.fromIndex, c.start = this.index) : (c.end = this.index, c.start = this.fromIndex), e = a.categoryAxis, e.parseDates && !e.equalSpacing && (c.start = b[c.start].time, c.end = a.getEndTime(b[c.end].time)), this.skipZoomDispatch || this.fire(c.type, c)); else {
                        var g = this.initialMouseX, h = this.initialMouseY;
                        3 > Math.abs(d - g) && 3 > Math.abs(e - h) || (b = Math.min(g, d), f = Math.min(h, e), d = Math.abs(g - d), e = Math.abs(h - e), a.hideXScrollbar && (b = 0,
                            d = this.width), a.hideYScrollbar && (f = 0, e = this.height), c.selectionHeight = e, c.selectionWidth = d, c.selectionY = f, c.selectionX = b, this.skipZoomDispatch || this.fire(c.type, c))
                    }
                    this.selectWithoutZooming || AmCharts.remove(this.selection)
                }
                this.panning = this.zooming = this.skipZoomDispatch = !1
            }
        }
    }, showCursorAt: function (a) {
        var b = this.chart.categoryAxis;
        a = b.parseDates ? b.dateToCoordinate(a) : b.categoryToCoordinate(a);
        this.previousMousePosition = NaN;
        this.forceShow = !0;
        this.setPosition(a, !1)
    }, handleMouseDown: function (a) {
        if (this.zoomable ||
            this.pan || this.drawing) {
            var b = this.rotate, c = this.chart, d = c.mouseX - this.x, e = c.mouseY - this.y;
            if (0 < d && d < this.width && 0 < e && e < this.height || "fake" == a)this.setPosition(), this.selectWithoutZooming && AmCharts.remove(this.selection), this.drawing ? (this.drawStartY = e, this.drawStartX = d, this.drawingNow = !0) : this.pan ? (this.zoomable = !1, c.setMouseCursor("move"), this.panning = !0, this.panClickPos = b ? e : d, this.panClickStart = this.start, this.panClickEnd = this.end, this.panClickStartTime = this.startTime, this.panClickEndTime = this.endTime) :
            this.zoomable && ("cursor" == this.type ? (this.fromIndex = this.index, b ? (this.initialMouse = e, this.selectionPosY = this.linePos) : (this.initialMouse = d, this.selectionPosX = this.linePos)) : (this.initialMouseX = d, this.initialMouseY = e, this.selectionPosX = d, this.selectionPosY = e), this.zooming = !0)
        }
    }
});
AmCharts.SimpleChartScrollbar = AmCharts.Class({
    construct: function () {
        this.createEvents("zoomed");
        this.backgroundColor = "#D4D4D4";
        this.backgroundAlpha = 1;
        this.selectedBackgroundColor = "#EFEFEF";
        this.scrollDuration = this.selectedBackgroundAlpha = 1;
        this.resizeEnabled = !0;
        this.hideResizeGrips = !1;
        this.scrollbarHeight = 20;
        this.updateOnReleaseOnly = !1;
        9 > document.documentMode && (this.updateOnReleaseOnly = !0);
        this.dragIconWidth = 11;
        this.dragIconHeight = 18
    }, draw: function () {
        var a = this;
        a.destroy();
        a.interval = setInterval(function () {
                a.updateScrollbar.call(a)
            },
            40);
        var b = a.chart.container, c = a.rotate, d = a.chart, e = b.set();
        a.set = e;
        d.scrollbarsSet.push(e);
        var f, g;
        c ? (f = a.scrollbarHeight, g = d.plotAreaHeight) : (g = a.scrollbarHeight, f = d.plotAreaWidth);
        a.width = f;
        if ((a.height = g) && f) {
            var h = AmCharts.rect(b, f, g, a.backgroundColor, a.backgroundAlpha);
            a.bg = h;
            e.push(h);
            h = AmCharts.rect(b, f, g, "#000", 0.005);
            e.push(h);
            a.invisibleBg = h;
            h.click(function () {
                a.handleBgClick()
            }).mouseover(function () {
                a.handleMouseOver()
            }).mouseout(function () {
                a.handleMouseOut()
            }).touchend(function () {
                a.handleBgClick()
            });
            h = AmCharts.rect(b, f, g, a.selectedBackgroundColor, a.selectedBackgroundAlpha);
            a.selectedBG = h;
            e.push(h);
            f = AmCharts.rect(b, f, g, "#000", 0.005);
            a.dragger = f;
            e.push(f);
            f.mousedown(function (b) {
                a.handleDragStart(b)
            }).mouseup(function () {
                a.handleDragStop()
            }).mouseover(function () {
                a.handleDraggerOver()
            }).mouseout(function () {
                a.handleMouseOut()
            }).touchstart(function (b) {
                a.handleDragStart(b)
            }).touchend(function () {
                a.handleDragStop()
            });
            f = d.pathToImages;
            c ? (h = f + "dragIconH.gif", f = a.dragIconWidth, c = a.dragIconHeight) : (h = f +
                "dragIcon.gif", c = a.dragIconWidth, f = a.dragIconHeight);
            g = b.image(h, 0, 0, c, f);
            var h = b.image(h, 0, 0, c, f), k = 10, l = 20;
            d.panEventsEnabled && (k = 25, l = a.scrollbarHeight);
            var m = AmCharts.rect(b, k, l, "#000", 0.005), n = AmCharts.rect(b, k, l, "#000", 0.005);
            n.translate(-(k - c) / 2, -(l - f) / 2);
            m.translate(-(k - c) / 2, -(l - f) / 2);
            c = b.set([g, n]);
            b = b.set([h, m]);
            a.iconLeft = c;
            e.push(a.iconLeft);
            a.iconRight = b;
            e.push(b);
            c.mousedown(function () {
                a.leftDragStart()
            }).mouseup(function () {
                a.leftDragStop()
            }).mouseover(function () {
                a.iconRollOver()
            }).mouseout(function () {
                a.iconRollOut()
            }).touchstart(function (b) {
                a.leftDragStart()
            }).touchend(function () {
                a.leftDragStop()
            });
            b.mousedown(function () {
                a.rightDragStart()
            }).mouseup(function () {
                a.rightDragStop()
            }).mouseover(function () {
                a.iconRollOver()
            }).mouseout(function () {
                a.iconRollOut()
            }).touchstart(function (b) {
                a.rightDragStart()
            }).touchend(function () {
                a.rightDragStop()
            });
            AmCharts.ifArray(d.chartData) ? e.show() : e.hide();
            a.hideDragIcons()
        }
        e.translate(a.x, a.y);
        a.clipDragger(!1)
    }, updateScrollbarSize: function (a, b) {
        var c = this.dragger, d, e, f, g;
        this.rotate ? (d = 0, e = a, f = this.width + 1, g = b - a, c.setAttr("height", b - a), c.setAttr("y", e)) : (d = a,
            e = 0, f = b - a, g = this.height + 1, c.setAttr("width", b - a), c.setAttr("x", d));
        this.clipAndUpdate(d, e, f, g)
    }, updateScrollbar: function () {
        var a, b = !1, c, d, e = this.x, f = this.y, g = this.dragger, h = this.getDBox();
        c = h.x + e;
        d = h.y + f;
        var k = h.width, h = h.height, l = this.rotate, m = this.chart, n = this.width, s = this.height, q = m.mouseX, t = m.mouseY;
        a = this.initialMouse;
        m.mouseIsOver && (this.dragging && (m = this.initialCoord, l ? (a = m + (t - a), 0 > a && (a = 0), m = s - h, a > m && (a = m), g.setAttr("y", a)) : (a = m + (q - a), 0 > a && (a = 0), m = n - k, a > m && (a = m), g.setAttr("x", a))), this.resizingRight &&
        (l ? (a = t - d, a + d > s + f && (a = s - d + f), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = 0.1), g.setAttr("height", a))) : (a = q - c, a + c > n + e && (a = n - c + e), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = 0.1), g.setAttr("width", a)))), this.resizingLeft && (l ? (c = d, d = t, d < f && (d = f), d > s + f && (d = s + f), a = !0 === b ? c - d : h + c - d, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("y", c + h - f)) : (0 === a && (a = 0.1), g.setAttr("y", d - f), g.setAttr("height", a))) : (d = q, d < e && (d = e), d > n + e && (d = n + e), a = !0 === b ? c - d : k + c - d, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("x", c + k - e)) : (0 === a && (a = 0.1), g.setAttr("x", d - e), g.setAttr("width", a)))), this.clipDragger(!0))
    }, clipDragger: function (a) {
        var b = this.getDBox(), c = b.x, d = b.y, e = b.width, b = b.height, f = !1;
        if (this.rotate) {
            if (c = 0, e = this.width + 1, this.clipY != d || this.clipH != b)f = !0
        } else if (d = 0, b = this.height + 1, this.clipX != c || this.clipW != e)f = !0;
        f && (this.clipAndUpdate(c, d, e, b), a && (this.updateOnReleaseOnly || this.dispatchScrollbarEvent()))
    }, maskGraphs: function () {
    }, clipAndUpdate: function (a, b, c, d) {
        this.clipX =
            a;
        this.clipY = b;
        this.clipW = c;
        this.clipH = d;
        this.selectedBG.clipRect(a, b, c, d);
        this.updateDragIconPositions();
        this.maskGraphs(a, b, c, d)
    }, dispatchScrollbarEvent: function () {
        if (this.skipEvent)this.skipEvent = !1; else {
            var a = this.chart;
            a.hideBalloon();
            var b = this.getDBox(), c = b.x, d = b.y, e = b.width, b = b.height;
            this.rotate ? (c = d, e = this.height / b) : e = this.width / e;
            a = {type: "zoomed", position: c, chart: a, target: this, multiplier: e};
            this.fire(a.type, a)
        }
    }, updateDragIconPositions: function () {
        var a = this.getDBox(), b = a.x, c = a.y, d = this.iconLeft,
            e = this.iconRight, f, g, h = this.scrollbarHeight;
        this.rotate ? (f = this.dragIconWidth, g = this.dragIconHeight, d.translate((h - g) / 2, c - f / 2), e.translate((h - g) / 2, c + a.height - f / 2)) : (f = this.dragIconHeight, g = this.dragIconWidth, d.translate(b - g / 2, (h - f) / 2), e.translate(b + -g / 2 + a.width, (h - f) / 2))
    }, showDragIcons: function () {
        this.resizeEnabled && (this.iconLeft.show(), this.iconRight.show())
    }, hideDragIcons: function () {
        this.resizingLeft || (this.resizingRight || this.dragging) || (this.hideResizeGrips && (this.iconLeft.hide(), this.iconRight.hide()),
            this.removeCursors())
    }, removeCursors: function () {
        this.chart.setMouseCursor("auto")
    }, relativeZoom: function (a, b) {
        this.dragger.stop();
        this.multiplier = a;
        this.position = b;
        this.updateScrollbarSize(b, this.rotate ? b + this.height / a : b + this.width / a)
    }, destroy: function () {
        this.clear();
        AmCharts.remove(this.set)
    }, clear: function () {
        clearInterval(this.interval)
    }, handleDragStart: function () {
        var a = this.chart;
        this.dragger.stop();
        this.removeCursors();
        this.dragging = !0;
        var b = this.getDBox();
        this.rotate ? (this.initialCoord = b.y, this.initialMouse =
            a.mouseY) : (this.initialCoord = b.x, this.initialMouse = a.mouseX)
    }, handleDragStop: function () {
        this.updateOnReleaseOnly && (this.updateScrollbar(), this.skipEvent = !1, this.dispatchScrollbarEvent());
        this.dragging = !1;
        this.mouseIsOver && this.removeCursors();
        this.updateScrollbar()
    }, handleDraggerOver: function () {
        this.handleMouseOver()
    }, leftDragStart: function () {
        this.dragger.stop();
        this.resizingLeft = !0
    }, leftDragStop: function () {
        this.resizingLeft = !1;
        this.mouseIsOver || this.removeCursors();
        this.updateOnRelease()
    }, rightDragStart: function () {
        this.dragger.stop();
        this.resizingRight = !0
    }, rightDragStop: function () {
        this.resizingRight = !1;
        this.mouseIsOver || this.removeCursors();
        this.updateOnRelease()
    }, iconRollOut: function () {
        this.removeCursors()
    }, iconRollOver: function () {
        this.rotate ? this.chart.setMouseCursor("n-resize") : this.chart.setMouseCursor("e-resize");
        this.handleMouseOver()
    }, getDBox: function () {
        return this.dragger.getBBox()
    }, handleBgClick: function () {
        if (!this.resizingRight && !this.resizingLeft) {
            this.zooming = !0;
            var a, b, c = this.scrollDuration, d = this.dragger;
            a = this.getDBox();
            var e = a.height, f = a.width;
            b = this.chart;
            var g = this.y, h = this.x, k = this.rotate;
            k ? (a = "y", b = b.mouseY - e / 2 - g, b = AmCharts.fitToBounds(b, 0, this.height - e)) : (a = "x", b = b.mouseX - f / 2 - h, b = AmCharts.fitToBounds(b, 0, this.width - f));
            this.updateOnReleaseOnly ? (this.skipEvent = !1, d.setAttr(a, b), this.dispatchScrollbarEvent(), this.clipDragger()) : (b = Math.round(b), k ? d.animate({y: b}, c, ">") : d.animate({x: b}, c, ">"))
        }
    }, updateOnRelease: function () {
        this.updateOnReleaseOnly && (this.updateScrollbar(), this.skipEvent = !1, this.dispatchScrollbarEvent())
    },
    handleReleaseOutside: function () {
        if (this.set) {
            if (this.resizingLeft || this.resizingRight || this.dragging)this.updateOnRelease(), this.removeCursors();
            this.mouseIsOver = this.dragging = this.resizingRight = this.resizingLeft = !1;
            this.hideDragIcons();
            this.updateScrollbar()
        }
    }, handleMouseOver: function () {
        this.mouseIsOver = !0;
        this.showDragIcons()
    }, handleMouseOut: function () {
        this.mouseIsOver = !1;
        this.hideDragIcons()
    }
});
AmCharts.ChartScrollbar = AmCharts.Class({
    inherits: AmCharts.SimpleChartScrollbar, construct: function () {
        AmCharts.ChartScrollbar.base.construct.call(this);
        this.graphLineColor = "#BBBBBB";
        this.graphLineAlpha = 0;
        this.graphFillColor = "#BBBBBB";
        this.graphFillAlpha = 1;
        this.selectedGraphLineColor = "#888888";
        this.selectedGraphLineAlpha = 0;
        this.selectedGraphFillColor = "#888888";
        this.selectedGraphFillAlpha = 1;
        this.gridCount = 0;
        this.gridColor = "#FFFFFF";
        this.gridAlpha = 0.7;
        this.skipEvent = this.autoGridCount = !1;
        this.color = "#FFFFFF";
        this.scrollbarCreated = !1
    }, init: function () {
        var a = this.categoryAxis, b = this.chart;
        a || (this.categoryAxis = a = new AmCharts.CategoryAxis);
        a.chart = b;
        a.id = "scrollbar";
        a.dateFormats = b.categoryAxis.dateFormats;
        a.boldPeriodBeginning = b.categoryAxis.boldPeriodBeginning;
        a.axisItemRenderer = AmCharts.RecItem;
        a.axisRenderer = AmCharts.RecAxis;
        a.guideFillRenderer = AmCharts.RecFill;
        a.inside = !0;
        a.fontSize = this.fontSize;
        a.tickLength = 0;
        a.axisAlpha = 0;
        this.graph && (a = this.valueAxis, a || (this.valueAxis = a = new AmCharts.ValueAxis, a.visible = !1, a.scrollbar = !0, a.axisItemRenderer = AmCharts.RecItem, a.axisRenderer = AmCharts.RecAxis, a.guideFillRenderer = AmCharts.RecFill, a.labelsEnabled = !1, a.chart = b), b = this.unselectedGraph, b || (b = new AmCharts.AmGraph, b.scrollbar = !0, this.unselectedGraph = b, b.negativeBase = this.graph.negativeBase), b = this.selectedGraph, b || (b = new AmCharts.AmGraph, b.scrollbar = !0, this.selectedGraph = b, b.negativeBase = this.graph.negativeBase));
        this.scrollbarCreated = !0
    }, draw: function () {
        var a = this;
        AmCharts.ChartScrollbar.base.draw.call(a);
        a.scrollbarCreated || a.init();
        var b = a.chart, c = b.chartData, d = a.categoryAxis, e = a.rotate, f = a.x, g = a.y, h = a.width, k = a.height, l = b.categoryAxis, m = a.set;
        d.setOrientation(!e);
        d.parseDates = l.parseDates;
        d.rotate = e;
        d.equalSpacing = l.equalSpacing;
        d.minPeriod = l.minPeriod;
        d.startOnAxis = l.startOnAxis;
        d.viW = h;
        d.viH = k;
        d.width = h;
        d.height = k;
        d.gridCount = a.gridCount;
        d.gridColor = a.gridColor;
        d.gridAlpha = a.gridAlpha;
        d.color = a.color;
        d.autoGridCount = a.autoGridCount;
        d.parseDates && !d.equalSpacing && d.timeZoom(b.firstTime, b.lastTime);
        d.zoom(0, c.length - 1);
        if (l = a.graph) {
            var n = a.valueAxis, s = l.valueAxis;
            n.id = s.id;
            n.rotate = e;
            n.setOrientation(e);
            n.width = h;
            n.height = k;
            n.viW = h;
            n.viH = k;
            n.dataProvider = c;
            n.reversed = s.reversed;
            n.logarithmic = s.logarithmic;
            n.gridAlpha = 0;
            n.axisAlpha = 0;
            m.push(n.set);
            e ? n.y = g : n.x = f;
            var f = Infinity, g = -Infinity, q;
            for (q = 0; q < c.length; q++) {
                var t = c[q].axes[s.id].graphs[l.id].values, p;
                for (p in t)if (t.hasOwnProperty(p) && "percents" != p && "total" != p) {
                    var r = t[p];
                    r < f && (f = r);
                    r > g && (g = r)
                }
            }
            Infinity != f && (n.minimum = f);
            -Infinity != g &&
            (n.maximum = g + 0.1 * (g - f));
            f == g && (n.minimum -= 1, n.maximum += 1);
            void 0 != a.minimum && (n.minimum = a.minimum);
            void 0 != a.maximum && (n.maximum = a.maximum);
            n.zoom(0, c.length - 1);
            p = a.unselectedGraph;
            p.id = l.id;
            p.rotate = e;
            p.chart = b;
            p.chartType = b.chartType;
            p.data = c;
            p.valueAxis = n;
            p.chart = l.chart;
            p.categoryAxis = a.categoryAxis;
            p.valueField = l.valueField;
            p.openField = l.openField;
            p.closeField = l.closeField;
            p.highField = l.highField;
            p.lowField = l.lowField;
            p.lineAlpha = a.graphLineAlpha;
            p.lineColor = a.graphLineColor;
            p.fillAlphas = a.graphFillAlpha;
            p.fillColors = a.graphFillColor;
            p.connect = l.connect;
            p.hidden = l.hidden;
            p.width = h;
            p.height = k;
            s = a.selectedGraph;
            s.id = l.id;
            s.rotate = e;
            s.chart = b;
            s.chartType = b.chartType;
            s.data = c;
            s.valueAxis = n;
            s.chart = l.chart;
            s.categoryAxis = d;
            s.valueField = l.valueField;
            s.openField = l.openField;
            s.closeField = l.closeField;
            s.highField = l.highField;
            s.lowField = l.lowField;
            s.lineAlpha = a.selectedGraphLineAlpha;
            s.lineColor = a.selectedGraphLineColor;
            s.fillAlphas = a.selectedGraphFillAlpha;
            s.fillColors = a.selectedGraphFillColor;
            s.connect = l.connect;
            s.hidden = l.hidden;
            s.width = h;
            s.height = k;
            b = a.graphType;
            b || (b = l.type);
            p.type = b;
            s.type = b;
            c = c.length - 1;
            p.zoom(0, c);
            s.zoom(0, c);
            s.set.click(function () {
                a.handleBackgroundClick()
            }).mouseover(function () {
                a.handleMouseOver()
            }).mouseout(function () {
                a.handleMouseOut()
            });
            p.set.click(function () {
                a.handleBackgroundClick()
            }).mouseover(function () {
                a.handleMouseOver()
            }).mouseout(function () {
                a.handleMouseOut()
            });
            m.push(p.set);
            m.push(s.set)
        }
        m.push(d.set);
        m.push(d.labelsSet);
        a.bg.toBack();
        a.invisibleBg.toFront();
        a.dragger.toFront();
        a.iconLeft.toFront();
        a.iconRight.toFront()
    }, timeZoom: function (a, b) {
        this.startTime = a;
        this.endTime = b;
        this.timeDifference = b - a;
        this.skipEvent = !0;
        this.zoomScrollbar()
    }, zoom: function (a, b) {
        this.start = a;
        this.end = b;
        this.skipEvent = !0;
        this.zoomScrollbar()
    }, dispatchScrollbarEvent: function () {
        if (this.skipEvent)this.skipEvent = !1; else {
            var a = this.chart.chartData, b, c, d = this.dragger.getBBox();
            b = d.x;
            c = d.y;
            var e = d.width, f = d.height, d = this.chart;
            this.rotate ? (b = c, c = f) : c = e;
            e = {type: "zoomed", target: this};
            e.chart = d;
            var f = this.categoryAxis,
                g = this.stepWidth;
            if (f.parseDates && !f.equalSpacing) {
                if (a = d.firstTime, f.minDuration(), d = Math.round(b / g) + a, a = this.dragging ? d + this.timeDifference : Math.round((b + c) / g) + a, d > a && (d = a), d != this.startTime || a != this.endTime)this.startTime = d, this.endTime = a, e.start = d, e.end = a, e.startDate = new Date(d), e.endDate = new Date(a), this.fire(e.type, e)
            } else if (f.startOnAxis || (b += g / 2), c -= this.stepWidth / 2, d = f.xToIndex(b), b = f.xToIndex(b + c), d != this.start || this.end != b)f.startOnAxis && (this.resizingRight && d == b && b++, this.resizingLeft &&
            d == b && (0 < d ? d-- : b = 1)), this.start = d, this.end = this.dragging ? this.start + this.difference : b, e.start = this.start, e.end = this.end, f.parseDates && (a[this.start] && (e.startDate = new Date(a[this.start].time)), a[this.end] && (e.endDate = new Date(a[this.end].time))), this.fire(e.type, e)
        }
    }, zoomScrollbar: function () {
        var a, b;
        a = this.chart;
        var c = a.chartData, d = this.categoryAxis;
        d.parseDates && !d.equalSpacing ? (c = d.stepWidth, d = a.firstTime, a = c * (this.startTime - d), b = c * (this.endTime - d)) : (a = c[this.start].x[d.id], b = c[this.end].x[d.id],
            c = d.stepWidth, d.startOnAxis || (d = c / 2, a -= d, b += d));
        this.stepWidth = c;
        this.updateScrollbarSize(a, b)
    }, maskGraphs: function (a, b, c, d) {
        var e = this.selectedGraph;
        e && e.set.clipRect(a, b, c, d)
    }, handleDragStart: function () {
        AmCharts.ChartScrollbar.base.handleDragStart.call(this);
        this.difference = this.end - this.start;
        this.timeDifference = this.endTime - this.startTime;
        0 > this.timeDifference && (this.timeDifference = 0)
    }, handleBackgroundClick: function () {
        AmCharts.ChartScrollbar.base.handleBackgroundClick.call(this);
        this.dragging ||
        (this.difference = this.end - this.start, this.timeDifference = this.endTime - this.startTime, 0 > this.timeDifference && (this.timeDifference = 0))
    }
});
AmCharts.circle = function (a, b, c, d, e, f, g, h) {
    if (void 0 == e || 0 === e)e = 1;
    void 0 === f && (f = "#000000");
    void 0 === g && (g = 0);
    d = {fill: c, stroke: f, "fill-opacity": d, "stroke-width": e, "stroke-opacity": g};
    a = a.circle(0, 0, b).attr(d);
    h && a.gradient("radialGradient", [c, AmCharts.adjustLuminosity(c, -0.6)]);
    return a
};
AmCharts.text = function (a, b, c, d, e, f, g, h) {
    f || (f = "middle");
    "right" == f && (f = "end");
    AmCharts.isIE && 9 > AmCharts.IEversion && (b = b.replace("&amp;", "&"), b = b.replace("&", "&amp;"));
    c = {fill: c, "font-family": d, "font-size": e, opacity: h};
    !0 === g && (c["font-weight"] = "bold");
    c["text-anchor"] = f;
    return a.text(b, c)
};
AmCharts.polygon = function (a, b, c, d, e, f, g, h, k) {
    isNaN(f) && (f = 0);
    isNaN(h) && (h = e);
    var l = d, m = !1;
    "object" == typeof l && 1 < l.length && (m = !0, l = l[0]);
    void 0 === g && (g = l);
    e = {fill: l, stroke: g, "fill-opacity": e, "stroke-width": f, "stroke-opacity": h};
    f = AmCharts.dx;
    g = AmCharts.dy;
    h = Math.round;
    var l = "M" + (h(b[0]) + f) + "," + (h(c[0]) + g), n;
    for (n = 1; n < b.length; n++)l += " L" + (h(b[n]) + f) + "," + (h(c[n]) + g);
    a = a.path(l + " Z").attr(e);
    m && a.gradient("linearGradient", d, k);
    return a
};
AmCharts.rect = function (a, b, c, d, e, f, g, h, k, l) {
    isNaN(f) && (f = 0);
    void 0 === k && (k = 0);
    void 0 === l && (l = 270);
    isNaN(e) && (e = 0);
    var m = d, n = !1;
    "object" == typeof m && (m = m[0], n = !0);
    void 0 === g && (g = m);
    void 0 === h && (h = e);
    b = Math.round(b);
    c = Math.round(c);
    var s = 0, q = 0;
    0 > b && (b = Math.abs(b), s = -b);
    0 > c && (c = Math.abs(c), q = -c);
    s += AmCharts.dx;
    q += AmCharts.dy;
    e = {fill: m, stroke: g, "fill-opacity": e, "stroke-opacity": h};
    a = a.rect(s, q, b, c, k, f).attr(e);
    n && a.gradient("linearGradient", d, l);
    return a
};
AmCharts.triangle = function (a, b, c, d, e, f, g, h) {
    if (void 0 === f || 0 === f)f = 1;
    void 0 === g && (g = "#000");
    void 0 === h && (h = 0);
    d = {fill: d, stroke: g, "fill-opacity": e, "stroke-width": f, "stroke-opacity": h};
    b /= 2;
    var k;
    0 === c && (k = " M" + -b + "," + b + " L0," + -b + " L" + b + "," + b + " Z");
    180 == c && (k = " M" + -b + "," + -b + " L0," + b + " L" + b + "," + -b + " Z");
    90 == c && (k = " M" + -b + "," + -b + " L" + b + ",0 L" + -b + "," + b + " Z");
    270 == c && (k = " M" + -b + ",0 L" + b + "," + b + " L" + b + "," + -b + " Z");
    return a.path(k).attr(d)
};
AmCharts.line = function (a, b, c, d, e, f, g, h, k, l) {
    f = {fill: "none", "stroke-width": f};
    void 0 !== g && 0 < g && (f["stroke-dasharray"] = g);
    isNaN(e) || (f["stroke-opacity"] = e);
    d && (f.stroke = d);
    d = Math.round;
    l && (d = AmCharts.doNothing);
    l = AmCharts.dx;
    e = AmCharts.dy;
    g = "M" + (d(b[0]) + l) + "," + (d(c[0]) + e);
    for (h = 1; h < b.length; h++)g += " L" + (d(b[h]) + l) + "," + (d(c[h]) + e);
    if (AmCharts.VML)return a.path(g, void 0, !0).attr(f);
    k && (g += " M0,0 L0,0");
    return a.path(g).attr(f)
};
AmCharts.doNothing = function (a) {
    return a
};
AmCharts.wedge = function (a, b, c, d, e, f, g, h, k, l, m) {
    var n = Math.round;
    f = n(f);
    g = n(g);
    h = n(h);
    var s = n(g / f * h), q = AmCharts.VML, t = -359.5 - f / 100;
    -359.94 > t && (t = -359.94);
    e <= t && (e = t);
    var p = 1 / 180 * Math.PI, t = b + Math.cos(d * p) * h, r = c + Math.sin(-d * p) * s, u = b + Math.cos(d * p) * f, v = c + Math.sin(-d * p) * g, w = b + Math.cos((d + e) * p) * f, A = c + Math.sin((-d - e) * p) * g, x = b + Math.cos((d + e) * p) * h, p = c + Math.sin((-d - e) * p) * s, B = {
        fill: AmCharts.adjustLuminosity(l.fill, -0.2),
        "stroke-opacity": 0
    }, y = 0;
    180 < Math.abs(e) && (y = 1);
    d = a.set();
    var z;
    q && (t = n(10 * t), u = n(10 * u), w =
        n(10 * w), x = n(10 * x), r = n(10 * r), v = n(10 * v), A = n(10 * A), p = n(10 * p), b = n(10 * b), k = n(10 * k), c = n(10 * c), f *= 10, g *= 10, h *= 10, s *= 10, 1 > Math.abs(e) && (1 >= Math.abs(w - u) && 1 >= Math.abs(A - v)) && (z = !0));
    e = "";
    if (0 < k) {
        q ? (path = " M" + t + "," + (r + k) + " L" + u + "," + (v + k), z || (path += " A" + (b - f) + "," + (k + c - g) + "," + (b + f) + "," + (k + c + g) + "," + u + "," + (v + k) + "," + w + "," + (A + k)), path += " L" + x + "," + (p + k), 0 < h && (z || (path += " B" + (b - h) + "," + (k + c - s) + "," + (b + h) + "," + (k + c + s) + "," + x + "," + (k + p) + "," + t + "," + (k + r)))) : (path = " M" + t + "," + (r + k) + " L" + u + "," + (v + k), path += " A" + f + "," + g + ",0," + y +
            ",1," + w + "," + (A + k) + " L" + x + "," + (p + k), 0 < h && (path += " A" + h + "," + s + ",0," + y + ",0," + t + "," + (r + k)));
        path += " Z";
        var C = a.path(path, void 0, void 0, "1000,1000").attr(B);
        d.push(C);
        C = a.path(" M" + t + "," + r + " L" + t + "," + (r + k) + " L" + u + "," + (v + k) + " L" + u + "," + v + " L" + t + "," + r + " Z", void 0, void 0, "1000,1000").attr(B);
        k = a.path(" M" + w + "," + A + " L" + w + "," + (A + k) + " L" + x + "," + (p + k) + " L" + x + "," + p + " L" + w + "," + A + " Z", void 0, void 0, "1000,1000").attr(B);
        d.push(C);
        d.push(k)
    }
    q ? (z || (e = " A" + n(b - f) + "," + n(c - g) + "," + n(b + f) + "," + n(c + g) + "," + n(u) + "," + n(v) + "," +
        n(w) + "," + n(A)), f = " M" + n(t) + "," + n(r) + " L" + n(u) + "," + n(v) + e + " L" + n(x) + "," + n(p)) : f = " M" + t + "," + r + " L" + u + "," + v + (" A" + f + "," + g + ",0," + y + ",1," + w + "," + A) + " L" + x + "," + p;
    0 < h && (q ? z || (f += " B" + (b - h) + "," + (c - s) + "," + (b + h) + "," + (c + s) + "," + x + "," + p + "," + t + "," + r) : f += " A" + h + "," + s + ",0," + y + ",0," + t + "," + r);
    a = a.path(f + " Z", void 0, void 0, "1000,1000").attr(l);
    if (m) {
        b = [];
        for (c = 0; c < m.length; c++)b.push(AmCharts.adjustLuminosity(l.fill, m[c]));
        0 < b.length && a.gradient("linearGradient", b)
    }
    d.push(a);
    return d
};
AmCharts.adjustLuminosity = function (a, b) {
    a = String(a).replace(/[^0-9a-f]/gi, "");
    6 > a.length && (a = String(a[0]) + String(a[0]) + String(a[1]) + String(a[1]) + String(a[2]) + String(a[2]));
    b = b || 0;
    var c = "#", d, e;
    for (e = 0; 3 > e; e++)d = parseInt(a.substr(2 * e, 2), 16), d = Math.round(Math.min(Math.max(0, d + d * b), 255)).toString(16), c += ("00" + d).substr(d.length);
    return c
};
AmCharts.AmPieChart = AmCharts.Class({
    inherits: AmCharts.AmChart, construct: function () {
        this.createEvents("rollOverSlice", "rollOutSlice", "clickSlice", "pullOutSlice", "pullInSlice", "rightClickSlice");
        AmCharts.AmPieChart.base.construct.call(this);
        this.colors = "#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25".split(" ");
        this.pieAlpha = 1;
        this.pieBrightnessStep = 30;
        this.groupPercent = 0;
        this.groupedTitle =
            "Other";
        this.groupedPulled = !1;
        this.groupedAlpha = 1;
        this.marginLeft = 0;
        this.marginBottom = this.marginTop = 10;
        this.marginRight = 0;
        this.minRadius = 10;
        this.hoverAlpha = 1;
        this.depth3D = 0;
        this.startAngle = 90;
        this.angle = this.innerRadius = 0;
        this.outlineColor = "#FFFFFF";
        this.outlineAlpha = 0;
        this.outlineThickness = 1;
        this.startRadius = "500%";
        this.startDuration = this.startAlpha = 1;
        this.startEffect = "bounce";
        this.sequencedAnimation = !1;
        this.pullOutRadius = "20%";
        this.pullOutDuration = 1;
        this.pullOutEffect = "bounce";
        this.pullOnHover =
            this.pullOutOnlyOne = !1;
        this.labelsEnabled = !0;
        this.labelRadius = 30;
        this.labelTickColor = "#000000";
        this.labelTickAlpha = 0.2;
        this.labelText = "[[title]]: [[percents]]%";
        this.hideLabelsPercent = 0;
        this.balloonText = "[[title]]: [[percents]]% ([[value]])\n[[description]]";
        this.urlTarget = "_self";
        this.previousScale = 1;
        this.autoMarginOffset = 10;
        this.gradientRatio = []
    }, initChart: function () {
        AmCharts.AmPieChart.base.initChart.call(this);
        this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1,
        this.legend && this.legend.setData(this.chartData));
        this.drawChart()
    }, handleLegendEvent: function (a) {
        var b = a.type;
        if (a = a.dataItem) {
            var c = a.hidden;
            switch (b) {
                case "clickMarker":
                    c || this.clickSlice(a);
                    break;
                case "clickLabel":
                    c || this.clickSlice(a);
                    break;
                case "rollOverItem":
                    c || this.rollOverSlice(a, !1);
                    break;
                case "rollOutItem":
                    c || this.rollOutSlice(a);
                    break;
                case "hideItem":
                    this.hideSlice(a);
                    break;
                case "showItem":
                    this.showSlice(a)
            }
        }
    }, invalidateVisibility: function () {
        this.recalculatePercents();
        this.initChart();
        var a = this.legend;
        a && a.invalidateSize()
    }, drawChart: function () {
        var a = this;
        AmCharts.AmPieChart.base.drawChart.call(a);
        var b = a.chartData;
        if (AmCharts.ifArray(b)) {
            if (0 < a.realWidth && 0 < a.realHeight) {
                AmCharts.VML && (a.startAlpha = 1);
                var c = a.startDuration, d = a.container, e = a.updateWidth();
                a.realWidth = e;
                var f = a.updateHeight();
                a.realHeight = f;
                var g = AmCharts.toCoordinate, h = g(a.marginLeft, e), k = g(a.marginRight, e), l = g(a.marginTop, f) + a.getTitleHeight(), m = g(a.marginBottom, f);
                a.chartDataLabels = [];
                a.ticks = [];
                var n, s, q, t =
                    AmCharts.toNumber(a.labelRadius), p = a.measureMaxLabel();
                a.labelText && a.labelsEnabled || (t = p = 0);
                n = void 0 === a.pieX ? (e - h - k) / 2 + h : g(a.pieX, a.realWidth);
                s = void 0 === a.pieY ? (f - l - m) / 2 + l : g(a.pieY, f);
                q = g(a.radius, e, f);
                a.pullOutRadiusReal = AmCharts.toCoordinate(a.pullOutRadius, q);
                q || (e = 0 <= t ? e - h - k - 2 * p : e - h - k, f = f - l - m, q = Math.min(e, f), f < e && (q /= 1 - a.angle / 90, q > e && (q = e)), a.pullOutRadiusReal = AmCharts.toCoordinate(a.pullOutRadius, q), q = 0 <= t ? q - 1.8 * (t + a.pullOutRadiusReal) : q - 1.8 * a.pullOutRadiusReal, q /= 2);
                q < a.minRadius && (q = a.minRadius);
                a.pullOutRadiusReal = g(a.pullOutRadius, q);
                g = g(a.innerRadius, q);
                g >= q && (g = q - 1);
                f = AmCharts.fitToBounds(a.startAngle, 0, 360);
                0 < a.depth3D && (f = 270 <= f ? 270 : 90);
                l = q - q * a.angle / 90;
                for (m = 0; m < b.length; m++)if (e = b[m], !0 !== e.hidden && 0 < e.percents) {
                    var k = 360 * -e.percents / 100, p = Math.cos((f + k / 2) / 180 * Math.PI), r = Math.sin((-f - k / 2) / 180 * Math.PI) * (l / q), h = {
                        fill: e.color,
                        stroke: a.outlineColor,
                        "stroke-width": a.outlineThickness,
                        "stroke-opacity": a.outlineAlpha
                    };
                    e.url && (h.cursor = "pointer");
                    h = AmCharts.wedge(d, n, s, f, k, q, l, g, a.depth3D,
                        h, a.gradientRatio);
                    a.addEventListeners(h, e);
                    e.startAngle = f;
                    b[m].wedge = h;
                    if (0 < c) {
                        var u = a.startAlpha;
                        a.chartCreated && (u = e.alpha);
                        h.setAttr("opacity", u)
                    }
                    e.ix = p;
                    e.iy = r;
                    e.wedge = h;
                    e.index = m;
                    if (a.labelsEnabled && a.labelText && e.percents >= a.hideLabelsPercent) {
                        var v = f + k / 2;
                        0 >= v && (v += 360);
                        k = t;
                        isNaN(e.labelRadius) || (k = e.labelRadius);
                        var p = n + p * (q + k), r = s + r * (q + k), w, u = 0;
                        if (0 <= k) {
                            var A;
                            90 >= v && 0 <= v ? (A = 0, w = "start", u = 8) : 360 >= v && 270 < v ? (A = 1, w = "start", u = 8) : 270 >= v && 180 < v ? (A = 2, w = "end", u = -8) : 180 >= v && 90 < v && (A = 3, w = "end", u = -8);
                            e.labelQuarter = A
                        } else w = "middle";
                        var v = a.formatString(a.labelText, e), x = e.labelColor;
                        void 0 == x && (x = a.color);
                        v = AmCharts.text(d, v, x, a.fontFamily, a.fontSize, w);
                        v.translate(p + 1.5 * u, r);
                        e.tx = p + 1.5 * u;
                        e.ty = r;
                        0 <= k ? h.push(v) : a.freeLabelsSet.push(v);
                        e.label = v;
                        a.chartDataLabels[m] = v;
                        e.tx = p;
                        e.tx2 = p + u
                    }
                    a.graphsSet.push(h);
                    (0 === e.alpha || 0 < c && !a.chartCreated) && h.hide();
                    f -= 360 * e.percents / 100;
                    0 >= f && (f += 360)
                }
                b = setTimeout(function () {
                    a.showLabels.call(a)
                }, 1E3 * c);
                a.timeOuts.push(b);
                0 < t && !a.labelRadiusField && a.arrangeLabels();
                a.pieXReal = n;
                a.pieYReal = s;
                a.radiusReal = q;
                a.innerRadiusReal = g;
                0 < t && a.drawTicks();
                a.chartCreated ? a.pullSlices(!0) : (c = setTimeout(function () {
                    a.pullSlices.call(a)
                }, 1200 * c), a.timeOuts.push(c));
                a.chartCreated || a.startSlices();
                a.setDepths()
            }
            (c = a.legend) && c.invalidateSize()
        } else a.cleanChart();
        a.dispDUpd();
        a.chartCreated = !0
    }, setDepths: function () {
        var a = this.chartData, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b], d = c.wedge, c = c.startAngle;
            90 >= c && 0 <= c || 360 >= c && 270 < c ? d.toFront() : (270 >= c && 180 < c || 180 >= c && 90 < c) && d.toBack()
        }
    },
    addEventListeners: function (a, b) {
        var c = this;
        a.mouseover(function () {
            c.rollOverSlice(b, !0)
        }).mouseout(function () {
            c.rollOutSlice(b)
        }).click(function () {
            c.clickSlice(b)
        }).contextmenu(function () {
            c.handleRightClick(b)
        })
    }, formatString: function (a, b) {
        a = AmCharts.formatValue(a, b, ["value"], this.numberFormatter, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
        a = AmCharts.formatValue(a, b, ["percents"], this.percentFormatter);
        a = AmCharts.massReplace(a, {
            "[[title]]": b.title, "[[description]]": b.description,
            "<br>": "\n"
        });
        a = AmCharts.fixNewLines(a);
        return a = AmCharts.cleanFromEmpty(a)
    }, drawTicks: function () {
        var a = this.chartData, b;
        for (b = 0; b < a.length; b++)if (this.chartDataLabels[b]) {
            var c = a[b], d = c.ty, e = this.radiusReal, d = AmCharts.line(this.container, [this.pieXReal + c.ix * e, c.tx, c.tx2], [this.pieYReal + c.iy * e, d, d], this.labelTickColor, this.labelTickAlpha);
            c.wedge.push(d);
            this.ticks[b] = d
        }
    }, arrangeLabels: function () {
        var a = this.chartData, b = a.length, c, d;
        for (d = b - 1; 0 <= d; d--)c = a[d], 0 !== c.labelQuarter || c.hidden || this.checkOverlapping(d,
            c, 0, !0, 0);
        for (d = 0; d < b; d++)c = a[d], 1 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 1, !1, 0);
        for (d = b - 1; 0 <= d; d--)c = a[d], 2 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 2, !0, 0);
        for (d = 0; d < b; d++)c = a[d], 3 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 3, !1, 0)
    }, checkOverlapping: function (a, b, c, d, e) {
        var f, g, h = this.chartData, k = h.length, l = b.label;
        if (l) {
            if (!0 === d)for (g = a + 1; g < k; g++)(f = this.checkOverlappingReal(b, h[g], c)) && (g = k); else for (g = a - 1; 0 <= g; g--)(f = this.checkOverlappingReal(b, h[g], c)) &&
            (g = 0);
            !0 === f && 100 > e && (f = b.ty + 3 * b.iy, b.ty = f, l.translate(b.tx2, f), this.checkOverlapping(a, b, c, d, e + 1))
        }
    }, checkOverlappingReal: function (a, b, c) {
        var d = !1, e = a.label, f = b.label;
        a.labelQuarter != c || (a.hidden || b.hidden || !f) || (e = e.getBBox(), c = {}, c.width = e.width, c.height = e.height, c.y = a.ty, c.x = a.tx, a = f.getBBox(), f = {}, f.width = a.width, f.height = a.height, f.y = b.ty, f.x = b.tx, AmCharts.hitTest(c, f) && (d = !0));
        return d
    }, startSlices: function () {
        var a;
        for (a = 0; a < this.chartData.length; a++)0 < this.startDuration && this.sequencedAnimation ?
            this.setStartTO(a) : this.startSlice(this.chartData[a])
    }, setStartTO: function (a) {
        var b = this;
        a = setTimeout(function () {
            b.startSequenced.call(b)
        }, 500 * (b.startDuration / b.chartData.length) * a);
        b.timeOuts.push(a)
    }, pullSlices: function (a) {
        var b = this.chartData, c;
        for (c = 0; c < b.length; c++) {
            var d = b[c];
            d.pulled && this.pullSlice(d, 1, a)
        }
    }, startSequenced: function () {
        var a = this.chartData, b;
        for (b = 0; b < a.length; b++)if (!a[b].started) {
            this.startSlice(this.chartData[b]);
            break
        }
    }, startSlice: function (a) {
        a.started = !0;
        var b = a.wedge,
            c = this.startDuration;
        if (b && 0 < c) {
            0 < a.alpha && b.show();
            var d = AmCharts.toCoordinate(this.startRadius, this.radiusReal);
            b.translate(Math.round(a.ix * d), Math.round(a.iy * d));
            b.animate({opacity: a.alpha, translate: "0,0"}, c, this.startEffect)
        }
    }, showLabels: function () {
        var a = this.chartData, b;
        for (b = 0; b < a.length; b++)if (0 < a[b].alpha) {
            var c = this.chartDataLabels[b];
            c && c.show();
            (c = this.ticks[b]) && c.show()
        }
    }, showSlice: function (a) {
        isNaN(a) ? a.hidden = !1 : this.chartData[a].hidden = !1;
        this.hideBalloon();
        this.invalidateVisibility()
    },
    hideSlice: function (a) {
        isNaN(a) ? a.hidden = !0 : this.chartData[a].hidden = !0;
        this.hideBalloon();
        this.invalidateVisibility()
    }, rollOverSlice: function (a, b) {
        isNaN(a) || (a = this.chartData[a]);
        clearTimeout(this.hoverInt);
        this.pullOnHover && this.pullSlice(a, 1);
        var c = this.innerRadiusReal + (this.radiusReal - this.innerRadiusReal) / 2;
        a.pulled && (c += this.pullOutRadiusReal);
        1 > this.hoverAlpha && a.wedge && a.wedge.attr({opacity: this.hoverAlpha});
        var d = a.ix * c + this.pieXReal, c = a.iy * c + this.pieYReal, e = this.formatString(this.balloonText,
            a), f = AmCharts.adjustLuminosity(a.color, -0.15);
        this.showBalloon(e, f, b, d, c);
        d = {type: "rollOverSlice", dataItem: a, chart: this};
        this.fire(d.type, d)
    }, rollOutSlice: function (a) {
        isNaN(a) || (a = this.chartData[a]);
        a.wedge && a.wedge.attr({opacity: a.alpha});
        this.hideBalloon();
        a = {type: "rollOutSlice", dataItem: a, chart: this};
        this.fire(a.type, a)
    }, clickSlice: function (a) {
        isNaN(a) || (a = this.chartData[a]);
        this.hideBalloon();
        a.pulled ? this.pullSlice(a, 0) : this.pullSlice(a, 1);
        AmCharts.getURL(a.url, this.urlTarget);
        a = {
            type: "clickSlice",
            dataItem: a, chart: this
        };
        this.fire(a.type, a)
    }, handleRightClick: function (a) {
        isNaN(a) || (a = this.chartData[a]);
        a = {type: "rightClickSlice", dataItem: a, chart: this};
        this.fire(a.type, a)
    }, pullSlice: function (a, b, c) {
        var d = a.ix, e = a.iy, f = this.pullOutDuration;
        !0 === c && (f = 0);
        c = a.wedge;
        var g = this.pullOutRadiusReal;
        c && c.animate({translate: b * d * g + "," + b * e * g}, f, this.pullOutEffect);
        1 == b ? (a.pulled = !0, this.pullOutOnlyOne && this.pullInAll(a.index), a = {
            type: "pullOutSlice",
            dataItem: a,
            chart: this
        }) : (a.pulled = !1, a = {
            type: "pullInSlice",
            dataItem: a, chart: this
        });
        this.fire(a.type, a)
    }, pullInAll: function (a) {
        var b = this.chartData, c;
        for (c = 0; c < this.chartData.length; c++)c != a && b[c].pulled && this.pullSlice(b[c], 0)
    }, pullOutAll: function (a) {
        a = this.chartData;
        var b;
        for (b = 0; b < a.length; b++)a[b].pulled || this.pullSlice(a[b], 1)
    }, parseData: function () {
        var a = [];
        this.chartData = a;
        var b = this.dataProvider;
        if (void 0 !== b) {
            var c = b.length, d = 0, e, f, g;
            for (e = 0; e < c; e++) {
                f = {};
                var h = b[e];
                f.dataContext = h;
                f.value = Number(h[this.valueField]);
                (g = h[this.titleField]) || (g = "");
                f.title = g;
                f.pulled = AmCharts.toBoolean(h[this.pulledField], !1);
                (g = h[this.descriptionField]) || (g = "");
                f.description = g;
                f.labelRadius = Number(h[this.labelRadiusField]);
                f.url = h[this.urlField];
                f.visibleInLegend = AmCharts.toBoolean(h[this.visibleInLegendField], !0);
                g = h[this.alphaField];
                f.alpha = void 0 !== g ? Number(g) : this.pieAlpha;
                g = h[this.colorField];
                void 0 !== g && (f.color = AmCharts.toColor(g));
                f.labelColor = AmCharts.toColor(h[this.labelColorField]);
                d += f.value;
                f.hidden = !1;
                a[e] = f
            }
            for (e = b = 0; e < c; e++)f = a[e], f.percents =
                100 * (f.value / d), f.percents < this.groupPercent && b++;
            1 < b && (this.groupValue = 0, this.removeSmallSlices(), a.push({
                title: this.groupedTitle,
                value: this.groupValue,
                percents: 100 * (this.groupValue / d),
                pulled: this.groupedPulled,
                color: this.groupedColor,
                url: this.groupedUrl,
                description: this.groupedDescription,
                alpha: this.groupedAlpha
            }));
            for (e = 0; e < a.length; e++)this.pieBaseColor ? g = AmCharts.adjustLuminosity(this.pieBaseColor, e * this.pieBrightnessStep / 100) : (g = this.colors[e], void 0 === g && (g = AmCharts.randomColor())), void 0 ===
            a[e].color && (a[e].color = g);
            this.recalculatePercents()
        }
    }, recalculatePercents: function () {
        var a = this.chartData, b = 0, c, d;
        for (c = 0; c < a.length; c++)d = a[c], !d.hidden && 0 < d.value && (b += d.value);
        for (c = 0; c < a.length; c++)d = this.chartData[c], d.percents = !d.hidden && 0 < d.value ? 100 * d.value / b : 0
    }, removeSmallSlices: function () {
        var a = this.chartData, b;
        for (b = a.length - 1; 0 <= b; b--)a[b].percents < this.groupPercent && (this.groupValue += a[b].value, a.splice(b, 1))
    }, animateAgain: function () {
        var a = this;
        a.startSlices();
        var b = setTimeout(function () {
                a.pullSlices.call(a)
            },
            1200 * a.startDuration);
        a.timeOuts.push(b)
    }, measureMaxLabel: function () {
        var a = this.chartData, b = 0, c;
        for (c = 0; c < a.length; c++) {
            var d = this.formatString(this.labelText, a[c]), d = AmCharts.text(this.container, d, this.color, this.fontFamily, this.fontSize), e = d.getBBox().width;
            e > b && (b = e);
            d.remove()
        }
        return b
    }
});
AmCharts.AmXYChart = AmCharts.Class({
    inherits: AmCharts.AmRectangularChart, construct: function () {
        AmCharts.AmXYChart.base.construct.call(this);
        this.createEvents("zoomed");
        this.maxZoomFactor = 20;
        this.chartType = "xy"
    }, initChart: function () {
        AmCharts.AmXYChart.base.initChart.call(this);
        this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
        this.updateScrollbar = !0;
        this.drawChart();
        this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins());
        var a = this.marginLeftReal,
            b = this.marginTopReal, c = this.plotAreaWidth, d = this.plotAreaHeight;
        this.graphsSet.clipRect(a, b, c, d);
        this.bulletSet.clipRect(a, b, c, d);
        this.trendLinesSet.clipRect(a, b, c, d)
    }, createValueAxes: function () {
        var a = [], b = [];
        this.xAxes = a;
        this.yAxes = b;
        var c = this.valueAxes, d, e;
        for (e = 0; e < c.length; e++) {
            d = c[e];
            var f = d.position;
            if ("top" == f || "bottom" == f)d.rotate = !0;
            d.setOrientation(d.rotate);
            f = d.orientation;
            "V" == f && b.push(d);
            "H" == f && a.push(d)
        }
        0 === b.length && (d = new AmCharts.ValueAxis, d.rotate = !1, d.setOrientation(!1), c.push(d),
            b.push(d));
        0 === a.length && (d = new AmCharts.ValueAxis, d.rotate = !0, d.setOrientation(!0), c.push(d), a.push(d));
        for (e = 0; e < c.length; e++)this.processValueAxis(c[e], e);
        a = this.graphs;
        for (e = 0; e < a.length; e++)this.processGraph(a[e], e)
    }, drawChart: function () {
        AmCharts.AmXYChart.base.drawChart.call(this);
        AmCharts.ifArray(this.chartData) ? (this.chartScrollbar && this.updateScrollbars(), this.zoomChart()) : this.cleanChart();
        if (this.hideXScrollbar) {
            var a = this.scrollbarH;
            a && (this.removeListener(a, "zoomed", this.handleHSBZoom),
                a.destroy());
            this.scrollbarH = null
        }
        if (this.hideYScrollbar) {
            if (a = this.scrollbarV)this.removeListener(a, "zoomed", this.handleVSBZoom), a.destroy();
            this.scrollbarV = null
        }
        if (!this.autoMargins || this.marginsUpdated)this.dispDUpd(), this.chartCreated = !0, this.zoomScrollbars()
    }, cleanChart: function () {
        AmCharts.callMethod("destroy", [this.valueAxes, this.graphs, this.scrollbarV, this.scrollbarH, this.chartCursor])
    }, zoomChart: function () {
        this.toggleZoomOutButton();
        this.zoomObjects(this.valueAxes);
        this.zoomObjects(this.graphs);
        this.zoomTrendLines();
        this.dispatchAxisZoom()
    }, toggleZoomOutButton: function () {
        1 == this.heightMultiplier && 1 == this.widthMultiplier ? this.showZB(!1) : this.showZB(!0)
    }, dispatchAxisZoom: function () {
        var a = this.valueAxes, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            if (!isNaN(c.min) && !isNaN(c.max)) {
                var d, e;
                "V" == c.orientation ? (d = c.coordinateToValue(-this.verticalPosition), e = c.coordinateToValue(-this.verticalPosition + this.plotAreaHeight)) : (d = c.coordinateToValue(-this.horizontalPosition), e = c.coordinateToValue(-this.horizontalPosition +
                    this.plotAreaWidth));
                if (!isNaN(d) && !isNaN(e)) {
                    if (d > e) {
                        var f = e;
                        e = d;
                        d = f
                    }
                    c.dispatchZoomEvent(d, e)
                }
            }
        }
    }, zoomObjects: function (a) {
        var b = a.length, c;
        for (c = 0; c < b; c++) {
            var d = a[c];
            this.updateObjectSize(d);
            d.zoom(0, this.chartData.length - 1)
        }
    }, updateData: function () {
        this.parseData();
        var a = this.chartData, b = a.length - 1, c = this.graphs, d = this.dataProvider, e = 0, f, g;
        for (f = 0; f < c.length; f++)if (g = c[f], g.data = a, g.zoom(0, b), g = g.valueField) {
            var h;
            for (h = 0; h < d.length; h++) {
                var k = d[h][g];
                k > e && (e = k)
            }
        }
        for (f = 0; f < c.length; f++)g = c[f], g.maxValue =
            e;
        if (a = this.chartCursor)a.updateData(), a.type = "crosshair", a.valueBalloonsEnabled = !1
    }, zoomOut: function () {
        this.verticalPosition = this.horizontalPosition = 0;
        this.heightMultiplier = this.widthMultiplier = 1;
        this.zoomChart();
        this.zoomScrollbars()
    }, processValueAxis: function (a) {
        a.chart = this;
        a.minMaxField = "H" == a.orientation ? "x" : "y";
        a.minTemp = NaN;
        a.maxTemp = NaN;
        this.listenTo(a, "axisSelfZoomed", this.handleAxisSelfZoom)
    }, processGraph: function (a) {
        a.xAxis || (a.xAxis = this.xAxes[0]);
        a.yAxis || (a.yAxis = this.yAxes[0])
    }, parseData: function () {
        AmCharts.AmXYChart.base.parseData.call(this);
        this.chartData = [];
        var a = this.dataProvider, b = this.valueAxes, c = this.graphs, d;
        for (d = 0; d < a.length; d++) {
            var e = {axes: {}, x: {}, y: {}}, f = a[d], g;
            for (g = 0; g < b.length; g++) {
                var h = b[g].id;
                e.axes[h] = {};
                e.axes[h].graphs = {};
                var k;
                for (k = 0; k < c.length; k++) {
                    var l = c[k], m = l.id;
                    if (l.xAxis.id == h || l.yAxis.id == h) {
                        var n = {};
                        n.serialDataItem = e;
                        n.index = d;
                        var s = {}, q = Number(f[l.valueField]);
                        isNaN(q) || (s.value = q);
                        q = Number(f[l.xField]);
                        isNaN(q) || (s.x = q);
                        q = Number(f[l.yField]);
                        isNaN(q) || (s.y = q);
                        n.values = s;
                        this.processFields(l, n, f);
                        n.serialDataItem =
                            e;
                        n.graph = l;
                        e.axes[h].graphs[m] = n
                    }
                }
            }
            this.chartData[d] = e
        }
    }, formatString: function (a, b) {
        var c = b.graph.numberFormatter;
        c || (c = this.numberFormatter);
        a = AmCharts.formatValue(a, b.values, ["value", "x", "y"], c);
        -1 != a.indexOf("[[") && (a = AmCharts.formatDataContextValue(a, b.dataContext));
        return a = AmCharts.AmSerialChart.base.formatString.call(this, a, b)
    }, addChartScrollbar: function (a) {
        AmCharts.callMethod("destroy", [this.chartScrollbar, this.scrollbarH, this.scrollbarV]);
        if (a) {
            this.chartScrollbar = a;
            this.scrollbarHeight =
                a.scrollbarHeight;
            var b = "backgroundColor backgroundAlpha selectedBackgroundColor selectedBackgroundAlpha scrollDuration resizeEnabled hideResizeGrips scrollbarHeight updateOnReleaseOnly".split(" ");
            if (!this.hideYScrollbar) {
                var c = new AmCharts.SimpleChartScrollbar;
                c.skipEvent = !0;
                c.chart = this;
                this.listenTo(c, "zoomed", this.handleVSBZoom);
                AmCharts.copyProperties(a, c, b);
                c.rotate = !0;
                this.scrollbarV = c
            }
            this.hideXScrollbar || (c = new AmCharts.SimpleChartScrollbar, c.skipEvent = !0, c.chart = this, this.listenTo(c, "zoomed",
                this.handleHSBZoom), AmCharts.copyProperties(a, c, b), c.rotate = !1, this.scrollbarH = c)
        }
    }, updateTrendLines: function () {
        var a = this.trendLines, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.chart = this;
            c.valueAxis || (c.valueAxis = this.yAxes[0]);
            c.valueAxisX || (c.valueAxisX = this.xAxes[0])
        }
    }, updateMargins: function () {
        AmCharts.AmXYChart.base.updateMargins.call(this);
        var a = this.scrollbarV;
        a && (this.getScrollbarPosition(a, !0, this.yAxes[0].position), this.adjustMargins(a, !0));
        if (a = this.scrollbarH)this.getScrollbarPosition(a, !1,
            this.xAxes[0].position), this.adjustMargins(a, !1)
    }, updateScrollbars: function () {
        var a = this.scrollbarV;
        a && (this.updateChartScrollbar(a, !0), a.draw());
        if (a = this.scrollbarH)this.updateChartScrollbar(a, !1), a.draw()
    }, zoomScrollbars: function () {
        var a = this.scrollbarH;
        a && a.relativeZoom(this.widthMultiplier, -this.horizontalPosition / this.widthMultiplier);
        (a = this.scrollbarV) && a.relativeZoom(this.heightMultiplier, -this.verticalPosition / this.heightMultiplier)
    }, fitMultiplier: function (a) {
        a > this.maxZoomFactor && (a = this.maxZoomFactor);
        return a
    }, handleHSBZoom: function (a) {
        var b = this.fitMultiplier(a.multiplier);
        a = -a.position * b;
        var c = -(this.plotAreaWidth * b - this.plotAreaWidth);
        a < c && (a = c);
        this.widthMultiplier = b;
        this.horizontalPosition = a;
        this.zoomChart()
    }, handleVSBZoom: function (a) {
        var b = this.fitMultiplier(a.multiplier);
        a = -a.position * b;
        var c = -(this.plotAreaHeight * b - this.plotAreaHeight);
        a < c && (a = c);
        this.heightMultiplier = b;
        this.verticalPosition = a;
        this.zoomChart()
    }, handleAxisSelfZoom: function (a) {
        if ("H" == a.valueAxis.orientation) {
            var b = this.fitMultiplier(a.multiplier);
            a = -a.position * b;
            var c = -(this.plotAreaWidth * b - this.plotAreaWidth);
            a < c && (a = c);
            this.horizontalPosition = a;
            this.widthMultiplier = b
        } else b = this.fitMultiplier(a.multiplier), a = -a.position * b, c = -(this.plotAreaHeight * b - this.plotAreaHeight), a < c && (a = c), this.verticalPosition = a, this.heightMultiplier = b;
        this.zoomChart();
        this.zoomScrollbars()
    }, handleCursorZoom: function (a) {
        var b = this.widthMultiplier * this.plotAreaWidth / a.selectionWidth, c = this.heightMultiplier * this.plotAreaHeight / a.selectionHeight, b = this.fitMultiplier(b),
            c = this.fitMultiplier(c);
        this.horizontalPosition = (this.horizontalPosition - a.selectionX) * b / this.widthMultiplier;
        this.verticalPosition = (this.verticalPosition - a.selectionY) * c / this.heightMultiplier;
        this.widthMultiplier = b;
        this.heightMultiplier = c;
        this.zoomChart();
        this.zoomScrollbars()
    }, removeChartScrollbar: function () {
        AmCharts.callMethod("destroy", [this.scrollbarH, this.scrollbarV]);
        this.scrollbarV = this.scrollbarH = null
    }, handleReleaseOutside: function (a) {
        AmCharts.AmXYChart.base.handleReleaseOutside.call(this,
            a);
        AmCharts.callMethod("handleReleaseOutside", [this.scrollbarH, this.scrollbarV])
    }
});
AmCharts.AmStockChart = AmCharts.Class({
    construct: function () {
        this.version = "2.10.7";
        this.createEvents("zoomed", "rollOverStockEvent", "rollOutStockEvent", "clickStockEvent", "panelRemoved", "dataUpdated", "init", "rendered");
        this.colors = "#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000".split(" ");
        this.firstDayOfWeek = 1;
        this.glueToTheEnd = !1;
        this.dataSetCounter = -1;
        this.zoomOutOnDataSetChange = !1;
        this.panels = [];
        this.dataSets = [];
        this.chartCursors = [];
        this.comparedDataSets =
            [];
        this.categoryAxesSettings = new AmCharts.CategoryAxesSettings;
        this.valueAxesSettings = new AmCharts.ValueAxesSettings;
        this.panelsSettings = new AmCharts.PanelsSettings;
        this.chartScrollbarSettings = new AmCharts.ChartScrollbarSettings;
        this.chartCursorSettings = new AmCharts.ChartCursorSettings;
        this.stockEventsSettings = new AmCharts.StockEventsSettings;
        this.legendSettings = new AmCharts.LegendSettings;
        this.balloon = new AmCharts.AmBalloon;
        this.previousEndDate = new Date(0);
        this.previousStartDate = new Date(0);
        this.dataSetCount =
            this.graphCount = 0;
        this.chartCreated = !1
    }, write: function (a) {
        this.chartRendered = !1;
        a = "object" != typeof a ? document.getElementById(a) : a;
        this.zoomOutOnDataSetChange && (this.endDate = this.startDate = void 0);
        a.innerHTML = "";
        this.div = a;
        this.measure();
        this.createLayout();
        this.updateDataSets();
        this.addDataSetSelector();
        this.addPeriodSelector();
        this.addPanels();
        this.addChartScrollbar();
        this.updatePanels();
        this.updateData();
        this.skipDefault || this.setDefaultPeriod()
    }, setDefaultPeriod: function (a) {
        var b = this.periodSelector;
        b && (this.animationPlayed = !1, b.setDefaultPeriod(a))
    }, validateSize: function () {
        var a, b = this.panels;
        this.measurePanels();
        for (a = 0; a < b.length; a++)panel = b[a], panel.invalidateSize()
    }, updateDataSets: function () {
        var a = this.dataSets;
        !this.mainDataSet && AmCharts.ifArray(a) && (this.mainDataSet = this.dataSets[0]);
        var b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.id || (this.dataSetCount++, c.id = "ds" + this.dataSetCount);
            void 0 === c.color && (c.color = this.colors.length - 1 > b ? this.colors[b] : AmCharts.randomColor())
        }
    }, updateEvents: function () {
        var a =
            this.mainDataSet;
        AmCharts.ifArray(a.stockEvents) && AmCharts.parseEvents(a, this.panels, this.stockEventsSettings, this.firstDayOfWeek, this)
    }, getLastDate: function (a) {
        return new Date(AmCharts.changeDate(new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds()), this.categoryAxesSettings.minPeriod, 1, !0).getTime() - 1)
    }, getFirstDate: function (a) {
        return new Date(AmCharts.resetDateToMin(new Date(a), this.categoryAxesSettings.minPeriod, 1, this.firstDayOfWeek))
    },
    updateData: function () {
        var a = this.mainDataSet;
        if (a) {
            var b = this.categoryAxesSettings;
            -1 == AmCharts.getItemIndex(b.minPeriod, b.groupToPeriods) && b.groupToPeriods.unshift(b.minPeriod);
            var c = a.dataProvider;
            if (AmCharts.ifArray(c)) {
                var d = a.categoryField;
                this.firstDate = this.getFirstDate(c[0][d]);
                this.lastDate = this.getLastDate(c[c.length - 1][d]);
                this.periodSelector && this.periodSelector.setRanges(this.firstDate, this.lastDate);
                a.dataParsed || (AmCharts.parseStockData(a, b.minPeriod, b.groupToPeriods, this.firstDayOfWeek),
                    a.dataParsed = !0);
                this.updateComparingData();
                this.updateEvents()
            } else this.lastDate = this.firstDate = void 0;
            this.glueToTheEnd && (this.startDate && this.endDate && this.lastDate) && (AmCharts.getPeriodDuration(b.minPeriod), this.startDate = new Date(this.startDate.getTime() + (this.lastDate.getTime() - this.endDate.getTime())), this.endDate = this.lastDate, this.updateScrollbar = !0);
            this.updatePanelsWithNewData()
        }
        a = {type: "dataUpdated", chart: this};
        this.fire(a.type, a)
    }, updateComparingData: function () {
        var a = this.comparedDataSets,
            b = this.categoryAxesSettings, c;
        for (c = 0; c < a.length; c++) {
            var d = a[c];
            d.dataParsed || (AmCharts.parseStockData(d, b.minPeriod, b.groupToPeriods, this.firstDayOfWeek), d.dataParsed = !0)
        }
    }, createLayout: function () {
        var a = this.div, b, c, d = this.periodSelector;
        d && (b = d.position);
        if (d = this.dataSetSelector)c = d.position;
        if ("left" == b || "left" == c)d = document.createElement("div"), d.style.cssFloat = "left", d.style.styleFloat = "left", d.style.width = "0px", d.style.position = "absolute", a.appendChild(d), this.leftContainer = d;
        if ("right" ==
            b || "right" == c)b = document.createElement("div"), b.style.cssFloat = "right", b.style.styleFloat = "right", b.style.width = "0px", a.appendChild(b), this.rightContainer = b;
        b = document.createElement("div");
        a.appendChild(b);
        this.centerContainer = b;
        a = document.createElement("div");
        b.appendChild(a);
        this.panelsContainer = a
    }, addPanels: function () {
        this.measurePanels();
        for (var a = this.panels, b = 0; b < a.length; b++)this.addStockPanel(a[b], b);
        this.panelsAdded = !0
    }, measurePanels: function () {
        this.measure();
        var a = this.chartScrollbarSettings,
            b = this.divRealHeight, c = this.panelsSettings.panelSpacing;
        a.enabled && (b -= a.height);
        (a = this.periodSelector) && !a.vertical && (a = a.offsetHeight, b -= a + c);
        (a = this.dataSetSelector) && !a.vertical && (a = a.offsetHeight, b -= a + c);
        a = this.panels;
        this.panelsContainer.style.height = b + "px";
        this.chartCursors = [];
        var d = 0, e, f;
        for (e = 0; e < a.length; e++) {
            f = a[e];
            var g = f.percentHeight;
            isNaN(g) && (g = 100 / a.length, f.percentHeight = g);
            d += g
        }
        this.panelsHeight = Math.max(b - c * (a.length - 1), 0);
        for (e = 0; e < a.length; e++)f = a[e], f.percentHeight = 100 * (f.percentHeight /
            d), f.panelBox && (f.panelBox.style.height = Math.round(f.percentHeight * this.panelsHeight / 100) + "px")
    }, addStockPanel: function (a, b) {
        var c = this.panelsSettings, d = document.createElement("div");
        d.className = "amChartsPanel";
        0 < b && !this.panels[b - 1].showCategoryAxis && (d.style.marginTop = c.panelSpacing + "px");
        a.panelBox = d;
        a.stockChart = this;
        a.id || (a.id = "stockPanel" + b);
        a.pathToImages = this.pathToImages;
        d.style.height = Math.round(a.percentHeight * this.panelsHeight / 100) + "px";
        d.style.width = "100%";
        this.panelsContainer.appendChild(d);
        0 < c.backgroundAlpha && (d.style.backgroundColor = c.backgroundColor);
        if (d = a.stockLegend)d.container = void 0, d.title = a.title, d.marginLeft = c.marginLeft, d.marginRight = c.marginRight, d.verticalGap = 3, d.position = "top", AmCharts.copyProperties(this.legendSettings, d), a.addLegend(d);
        a.zoomOutText = "";
        a.removeChartCursor();
        this.addCursor(a)
    }, enableCursors: function (a) {
        var b = this.chartCursors, c;
        for (c = 0; c < b.length; c++)b[c].enabled = a
    }, updatePanels: function () {
        var a = this.panels, b;
        for (b = 0; b < a.length; b++)this.updatePanel(a[b]);
        this.mainDataSet && this.updateGraphs();
        this.currentPeriod = void 0
    }, updatePanel: function (a) {
        a.seriesIdField = "amCategoryIdField";
        a.dataProvider = [];
        a.chartData = [];
        a.graphs = [];
        var b = a.categoryAxis, c = this.categoryAxesSettings;
        AmCharts.copyProperties(this.panelsSettings, a);
        AmCharts.copyProperties(c, b);
        b.parseDates = !0;
        a.zoomOutOnDataUpdate = !1;
        a.showCategoryAxis ? "top" == b.position ? a.marginTop = c.axisHeight : a.marginBottom = c.axisHeight : (a.categoryAxis.labelsEnabled = !1, a.chartCursor && (a.chartCursor.categoryBalloonEnabled = !1));
        var c = a.valueAxes, d = c.length, e;
        0 === d && (e = new AmCharts.ValueAxis, a.addValueAxis(e));
        b = new AmCharts.AmBalloon;
        AmCharts.copyProperties(this.balloon, b);
        a.balloon = b;
        c = a.valueAxes;
        d = c.length;
        for (b = 0; b < d; b++)e = c[b], AmCharts.copyProperties(this.valueAxesSettings, e);
        a.listenersAdded = !1;
        a.write(a.panelBox)
    }, zoom: function (a, b) {
        this.zoomChart(a, b)
    }, zoomOut: function () {
        this.zoomChart(this.firstDate, this.lastDate)
    }, updatePanelsWithNewData: function () {
        var a = this.mainDataSet;
        if (a) {
            var b = this.panels;
            this.currentPeriod = void 0;
            var c;
            for (c = 0; c < b.length; c++) {
                var d = b[c];
                d.categoryField = a.categoryField;
                0 === a.dataProvider.length && (d.dataProvider = [])
            }
            if (b = this.scrollbarChart) {
                c = this.categoryAxesSettings;
                d = c.minPeriod;
                b.categoryField = a.categoryField;
                if (0 < a.dataProvider.length) {
                    var e = this.chartScrollbarSettings.usePeriod;
                    b.dataProvider = e ? a.agregatedDataProviders[e] : a.agregatedDataProviders[d]
                } else b.dataProvider = [];
                e = b.categoryAxis;
                e.minPeriod = d;
                e.firstDayOfWeek = this.firstDayOfWeek;
                e.equalSpacing = c.equalSpacing;
                b.validateData()
            }
            0 <
            a.dataProvider.length && this.zoomChart(this.startDate, this.endDate)
        }
        this.panelDataInvalidated = !1
    }, addChartScrollbar: function () {
        var a = this.chartScrollbarSettings, b = this.scrollbarChart;
        b && (b.clear(), b.destroy());
        if (a.enabled) {
            var c = this.panelsSettings, d = this.categoryAxesSettings, b = new AmCharts.AmSerialChart;
            b.pathToImages = this.pathToImages;
            b.autoMargins = !1;
            this.scrollbarChart = b;
            b.id = "scrollbarChart";
            b.scrollbarOnly = !0;
            b.zoomOutText = "";
            b.panEventsEnabled = this.panelsSettings.panEventsEnabled;
            b.marginLeft =
                c.marginLeft;
            b.marginRight = c.marginRight;
            b.marginTop = 0;
            b.marginBottom = 0;
            var c = d.dateFormats, e = b.categoryAxis;
            e.boldPeriodBeginning = d.boldPeriodBeginning;
            c && (e.dateFormats = d.dateFormats);
            e.labelsEnabled = !1;
            e.parseDates = !0;
            var d = a.graph, f;
            d && (f = new AmCharts.AmGraph, f.valueField = d.valueField, f.periodValue = d.periodValue, f.type = d.type, f.connect = d.connect, b.addGraph(f));
            d = new AmCharts.ChartScrollbar;
            b.addChartScrollbar(d);
            AmCharts.copyProperties(a, d);
            d.scrollbarHeight = a.height;
            d.graph = f;
            this.removeListener(d,
                "zoomed", this.handleScrollbarZoom);
            this.listenTo(d, "zoomed", this.handleScrollbarZoom);
            f = document.createElement("div");
            f.style.height = a.height + "px";
            a = this.periodSelectorContainer;
            (d = this.periodSelector) ? "bottom" == d.position ? this.centerContainer.insertBefore(f, a) : this.centerContainer.appendChild(f) : this.centerContainer.appendChild(f);
            b.write(f)
        }
    }, handleScrollbarZoom: function (a) {
        if (this.skipScrollbarEvent)this.skipScrollbarEvent = !1; else {
            var b = a.endDate, c = {};
            c.startDate = a.startDate;
            c.endDate = b;
            this.updateScrollbar = !1;
            this.handleZoom(c)
        }
    }, addPeriodSelector: function () {
        var a = this.periodSelector;
        if (a) {
            var b = this.categoryAxesSettings.minPeriod;
            a.minDuration = AmCharts.getPeriodDuration(b);
            a.minPeriod = b;
            a.chart = this;
            var c = this.dataSetSelector, d, b = this.dssContainer;
            c && (d = c.position);
            var c = this.panelsSettings.panelSpacing, e = document.createElement("div");
            this.periodSelectorContainer = e;
            var f = this.leftContainer, g = this.rightContainer, h = this.centerContainer, k = this.panelsContainer, l = a.width + 2 * c + "px";
            switch (a.position) {
                case "left":
                    f.style.width =
                        a.width + "px";
                    f.appendChild(e);
                    h.style.paddingLeft = l;
                    break;
                case "right":
                    h.style.marginRight = l;
                    g.appendChild(e);
                    g.style.width = a.width + "px";
                    break;
                case "top":
                    k.style.clear = "both";
                    "top" == d ? h.insertAfter(e, b) : h.insertBefore(e, k);
                    e.style.paddingBottom = c + "px";
                    break;
                case "bottom":
                    e.style.marginTop = c + "px", "bottom" == d ? h.insertBefore(e, b) : h.appendChild(e)
            }
            this.removeListener(a, "changed", this.handlePeriodSelectorZoom);
            this.listenTo(a, "changed", this.handlePeriodSelectorZoom);
            a.write(e)
        }
    }, addDataSetSelector: function () {
        var a =
            this.dataSetSelector;
        if (a) {
            a.chart = this;
            a.dataProvider = this.dataSets;
            var b = a.position, c = this.panelsSettings.panelSpacing, d = document.createElement("div");
            this.dssContainer = d;
            var e = this.leftContainer, f = this.rightContainer, g = this.centerContainer, h = this.panelsContainer, c = a.width + 2 * c + "px";
            switch (b) {
                case "left":
                    e.style.width = a.width + "px";
                    e.appendChild(d);
                    g.style.paddingLeft = c;
                    break;
                case "right":
                    g.style.marginRight = c;
                    f.appendChild(d);
                    f.style.width = a.width + "px";
                    break;
                case "top":
                    h.style.clear = "both";
                    g.insertBefore(d,
                        h);
                    break;
                case "bottom":
                    g.appendChild(d)
            }
            a.write(d)
        }
    }, handlePeriodSelectorZoom: function (a) {
        var b = this.scrollbarChart;
        b && (b.updateScrollbar = !0);
        a.predefinedPeriod ? (this.predefinedStart = a.startDate, this.predefinedEnd = a.endDate) : this.predefinedEnd = this.predefinedStart = null;
        this.zoomChart(a.startDate, a.endDate)
    }, addCursor: function (a) {
        var b = this.chartCursorSettings;
        if (b.enabled) {
            var c = new AmCharts.ChartCursor;
            AmCharts.copyProperties(b, c);
            a.removeChartCursor();
            a.addChartCursor(c);
            this.removeListener(c, "changed",
                this.handleCursorChange);
            this.removeListener(c, "onHideCursor", this.hideChartCursor);
            this.removeListener(c, "zoomed", this.handleCursorZoom);
            this.listenTo(c, "changed", this.handleCursorChange);
            this.listenTo(c, "onHideCursor", this.hideChartCursor);
            this.listenTo(c, "zoomed", this.handleCursorZoom);
            this.chartCursors.push(c)
        }
    }, hideChartCursor: function () {
        var a = this.chartCursors, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.hideCursor(!1);
            (c = c.chart) && c.updateLegendValues()
        }
    }, handleCursorZoom: function (a) {
        var b = this.scrollbarChart;
        b && (b.updateScrollbar = !0);
        var b = {}, c;
        if (this.categoryAxesSettings.equalSpacing) {
            var d = this.mainDataSet.categoryField, e = this.mainDataSet.agregatedDataProviders[this.currentPeriod];
            c = new Date(e[a.start][d]);
            a = new Date(e[a.end][d])
        } else c = new Date(a.start), a = new Date(a.end);
        b.startDate = c;
        b.endDate = a;
        this.handleZoom(b)
    }, handleZoom: function (a) {
        this.zoomChart(a.startDate, a.endDate)
    }, zoomChart: function (a, b) {
        var c = this, d = c.firstDate, e = c.lastDate, f = c.currentPeriod, g = c.categoryAxesSettings, h = g.minPeriod, k =
            c.panelsSettings, l = c.periodSelector, m = c.panels, n = c.comparedGraphs, s = c.scrollbarChart, q = c.firstDayOfWeek;
        if (d && e) {
            a || (a = d);
            b || (b = e);
            if (f) {
                var t = AmCharts.extractPeriod(f);
                a.getTime() == b.getTime() && t != h && (b = AmCharts.changeDate(b, t.period, t.count), b.setTime(b.getTime() - 1))
            }
            a.getTime() < d.getTime() && (a = d);
            a.getTime() > e.getTime() && (a = e);
            b.getTime() < d.getTime() && (b = d);
            b.getTime() > e.getTime() && (b = e);
            g = AmCharts.getItemIndex(h, g.groupToPeriods);
            e = f;
            f = c.choosePeriod(g, a, b);
            c.currentPeriod = f;
            g = AmCharts.extractPeriod(f);
            AmCharts.getPeriodDuration(g.period, g.count);
            AmCharts.getPeriodDuration(h);
            1 > b.getTime() - a.getTime() && (a = new Date(b.getTime() - 1));
            h = new Date(a);
            h.getTime() == d.getTime() && (h = AmCharts.resetDateToMin(a, g.period, g.count, q));
            for (d = 0; d < m.length; d++) {
                t = m[d];
                if (f != e) {
                    var p;
                    for (p = 0; p < n.length; p++) {
                        var r = n[p].graph;
                        r.dataProvider = r.dataSet.agregatedDataProviders[f]
                    }
                    p = t.categoryAxis;
                    p.firstDayOfWeek = q;
                    p.minPeriod = f;
                    t.dataProvider = c.mainDataSet.agregatedDataProviders[f];
                    if (p = t.chartCursor)p.categoryBalloonDateFormat =
                        c.chartCursorSettings.categoryBalloonDateFormat(g.period), t.showCategoryAxis || (p.categoryBalloonEnabled = !1);
                    t.startTime = h.getTime();
                    t.endTime = b.getTime();
                    t.validateData(!0)
                }
                p = !1;
                t.chartCursor && t.chartCursor.panning && (p = !0);
                p || (t.startTime = void 0, t.endTime = void 0, t.zoomToDates(h, b));
                0 < k.startDuration && c.animationPlayed ? (t.startDuration = 0, t.animateAgain()) : 0 < k.startDuration && t.animateAgain()
            }
            c.animationPlayed = !0;
            AmCharts.extractPeriod(f);
            k = new Date(b);
            s && c.updateScrollbar && (s.zoomToDates(a, k), c.skipScrollbarEvent = !0, setTimeout(function () {
                c.resetSkip.call(c)
            }, 100));
            c.updateScrollbar = !0;
            c.startDate = a;
            c.endDate = b;
            l && l.zoom(a, b);
            if (a.getTime() != c.previousStartDate.getTime() || b.getTime() != c.previousEndDate.getTime())l = {type: "zoomed"}, l.startDate = a, l.endDate = b, l.chart = c, l.period = f, c.fire(l.type, l), c.previousStartDate = new Date(a), c.previousEndDate = new Date(b)
        }
        c.eventsHidden && c.showHideEvents(!1);
        c.chartCreated || (f = "init", c.fire(f, {type: f, chart: c}));
        c.chartRendered || (f = "rendered", c.fire(f, {type: f, chart: c}), c.chartRendered = !0);
        c.chartCreated = !0;
        c.animationPlayed = !0
    }, resetSkip: function () {
        this.skipScrollbarEvent = !1
    }, updateGraphs: function () {
        this.getSelections();
        if (0 < this.dataSets.length) {
            var a = this.panels;
            this.comparedGraphs = [];
            var b;
            for (b = 0; b < a.length; b++) {
                var c = a[b], d = c.valueAxes, e;
                for (e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.prevLog && (f.logarithmic = f.prevLog);
                    f.recalculateToPercents = "always" == c.recalculateToPercents ? !0 : !1
                }
                d = this.mainDataSet;
                e = this.comparedDataSets;
                f = c.stockGraphs;
                c.graphs = [];
                var g;
                for (g = 0; g < f.length; g++) {
                    var h =
                        f[g];
                    if (!h.title || h.resetTitleOnDataSetChange)h.title = d.title, h.resetTitleOnDataSetChange = !0;
                    h.useDataSetColors && (h.lineColor = d.color, h.fillColors = void 0, h.bulletColor = void 0);
                    c.addGraph(h);
                    var k = !1;
                    "always" == c.recalculateToPercents && (k = !0);
                    var l = c.stockLegend, m, n;
                    l && (m = l.valueTextComparing, n = l.valueTextRegular);
                    if (h.comparable) {
                        var s = e.length;
                        0 < s && (h.valueAxis.logarithmic && "never" != c.recalculateToPercents) && (h.valueAxis.logarithmic = !1, h.valueAxis.prevLog = !0);
                        0 < s && "whenComparing" == c.recalculateToPercents &&
                        (h.valueAxis.recalculateToPercents = !0);
                        l && h.valueAxis && !0 === h.valueAxis.recalculateToPercents && (k = !0);
                        var q;
                        for (q = 0; q < s; q++) {
                            var t = e[q], p = h.comparedGraphs[t.id];
                            p || (p = new AmCharts.AmGraph, p.id = "comparedGraph" + q + "_" + t.id);
                            p.periodValue = h.periodValue;
                            p.dataSet = t;
                            h.comparedGraphs[t.id] = p;
                            p.seriesIdField = "amCategoryIdField";
                            p.connect = h.connect;
                            var r = h.compareField;
                            r || (r = h.valueField);
                            var u = !1, v = t.fieldMappings, w;
                            for (w = 0; w < v.length; w++)v[w].toField == r && (u = !0);
                            if (u) {
                                p.valueField = r;
                                p.title = t.title;
                                p.lineColor =
                                    t.color;
                                h.compareGraphType && (p.type = h.compareGraphType);
                                r = h.compareGraphLineThickness;
                                isNaN(r) || (p.lineThickness = r);
                                r = h.compareGraphDashLength;
                                isNaN(r) || (p.dashLength = r);
                                r = h.compareGraphLineAlpha;
                                isNaN(r) || (p.lineAlpha = r);
                                r = h.compareGraphCornerRadiusTop;
                                isNaN(r) || (p.cornerRadiusTop = r);
                                r = h.compareGraphCornerRadiusBottom;
                                isNaN(r) || (p.cornerRadiusBottom = r);
                                r = h.compareGraphBalloonColor;
                                isNaN(r) || (p.balloonColor = r);
                                if (r = h.compareGraphFillColors)p.fillColors = r;
                                if (r = h.compareGraphNegativeFillColors)p.negativeFillColors =
                                    r;
                                if (r = h.compareGraphFillAlphas)p.fillAlphas = r;
                                if (r = h.compareGraphNegativeFillAlphas)p.negativeFillAlphas = r;
                                if (r = h.compareGraphBullet)p.bullet = r;
                                if (r = h.compareGraphNumberFormatter)p.numberFormatter = r;
                                if (r = h.compareGraphBalloonText)p.balloonText = r;
                                r = h.compareGraphBulletSize;
                                isNaN(r) || (p.bulletSize = r);
                                r = h.compareGraphBulletAlpha;
                                isNaN(r) || (p.bulletAlpha = r);
                                p.visibleInLegend = h.compareGraphVisibleInLegend;
                                p.valueAxis = h.valueAxis;
                                l && (k && m ? p.legendValueText = m : n && (p.legendValueText = n));
                                c.addGraph(p);
                                this.comparedGraphs.push({
                                    graph: p,
                                    dataSet: t
                                })
                            }
                        }
                    }
                    l && (k && m ? h.legendValueText = m : n && (h.legendValueText = n))
                }
            }
        }
    }, choosePeriod: function (a, b, c) {
        var d = this.categoryAxesSettings, e = d.groupToPeriods, f = e[a], e = e[a + 1], g = AmCharts.extractPeriod(f), g = AmCharts.getPeriodDuration(g.period, g.count), h = b.getTime(), k = c.getTime(), d = d.maxSeries;
        return (k - h) / g > d && 0 < d && e ? this.choosePeriod(a + 1, b, c) : f
    }, handleCursorChange: function (a) {
        var b = a.target, c = a.position;
        a = a.zooming;
        var d = this.chartCursors, e;
        for (e = 0; e < d.length; e++) {
            var f = d[e];
            f != b && c && (f.isZooming(a), f.previousMousePosition =
                NaN, f.forceShow = !0, f.setPosition(c, !1))
        }
    }, getSelections: function () {
        var a = [], b = this.dataSets, c;
        for (c = 0; c < b.length; c++) {
            var d = b[c];
            d.compared && a.push(d)
        }
        this.comparedDataSets = a;
        b = this.panels;
        for (c = 0; c < b.length; c++)d = b[c], "never" != d.recalculateToPercents && 0 < a.length ? d.hideDrawingIcons(!0) : d.drawingIconsEnabled && d.hideDrawingIcons(!1)
    }, addPanel: function (a) {
        this.panels.push(a);
        AmCharts.removeChart(a);
        AmCharts.addChart(a)
    }, addPanelAt: function (a, b) {
        this.panels.splice(b, 0, a);
        AmCharts.removeChart(a);
        AmCharts.addChart(a)
    },
    removePanel: function (a) {
        var b = this.panels, c;
        for (c = b.length - 1; 0 <= c; c--)if (b[c] == a) {
            var d = {type: "panelRemoved", panel: a, chart: this};
            this.fire(d.type, d);
            b.splice(c, 1);
            a.destroy();
            a.clear()
        }
    }, validateData: function () {
        this.resetDataParsed();
        this.updateDataSets();
        this.mainDataSet.compared = !1;
        this.updateGraphs();
        this.updateData();
        var a = this.dataSetSelector;
        a && a.write(a.div)
    }, resetDataParsed: function () {
        var a = this.dataSets, b;
        for (b = 0; b < a.length; b++)a[b].dataParsed = !1
    }, validateNow: function () {
        this.skipDefault = !0;
        this.clear(!0);
        this.write(this.div)
    }, hideStockEvents: function () {
        this.showHideEvents(!1);
        this.eventsHidden = !0
    }, showStockEvents: function () {
        this.showHideEvents(!0);
        this.eventsHidden = !1
    }, showHideEvents: function (a) {
        var b = this.panels, c;
        for (c = 0; c < b.length; c++) {
            var d = b[c].graphs, e;
            for (e = 0; e < d.length; e++) {
                var f = d[e];
                !0 === a ? f.showBullets() : f.hideBullets()
            }
        }
    }, measure: function () {
        var a = this.div, b = a.offsetWidth, c = a.offsetHeight;
        a.clientHeight && (b = a.clientWidth, c = a.clientHeight);
        this.divRealWidth = b;
        this.divRealHeight =
            c
    }, clear: function (a) {
        var b = this.panels, c;
        if (b)for (c = 0; c < b.length; c++) {
            var d = b[c];
            a || (d.cleanChart(), d.destroy());
            d.clear(a)
        }
        (b = this.scrollbarChart) && b.clear();
        if (b = this.div)b.innerHTML = "";
        a || (this.div = null, AmCharts.deleteObject(this))
    }
});
AmCharts.StockEvent = AmCharts.Class({
    construct: function () {
    }
});
AmCharts.DataSet = AmCharts.Class({
    construct: function () {
        this.fieldMappings = [];
        this.dataProvider = [];
        this.agregatedDataProviders = [];
        this.stockEvents = [];
        this.compared = !1;
        this.showInCompare = this.showInSelect = !0
    }
});
AmCharts.PeriodSelector = AmCharts.Class({
    construct: function () {
        this.createEvents("changed");
        this.inputFieldsEnabled = !0;
        this.position = "bottom";
        this.width = 180;
        this.fromText = "From: ";
        this.toText = "to: ";
        this.periodsText = "Zoom: ";
        this.periods = [];
        this.inputFieldWidth = 100;
        this.dateFormat = "DD-MM-YYYY";
        this.hideOutOfScopePeriods = !0
    }, zoom: function (a, b) {
        this.inputFieldsEnabled && (this.startDateField.value = AmCharts.formatDate(a, this.dateFormat), this.endDateField.value = AmCharts.formatDate(b, this.dateFormat));
        this.markButtonAsSelected()
    },
    write: function (a) {
        var b = this;
        a.className = "amChartsPeriodSelector";
        b.div = a;
        a.innerHTML = "";
        var c = b.position, c = "top" == c || "bottom" == c ? !1 : !0;
        b.vertical = c;
        var d = 0, e = 0;
        if (b.inputFieldsEnabled) {
            var f = document.createElement("div");
            a.appendChild(f);
            var g = document.createTextNode(b.fromText);
            f.appendChild(g);
            c ? AmCharts.addBr(f) : (f.style.styleFloat = "left", f.style.display = "inline");
            var h = document.createElement("input");
            h.className = "amChartsInputField";
            h.style.textAlign = "center";
            h.onblur = function () {
                b.handleCalChange()
            };
            AmCharts.isNN && h.addEventListener("keypress", function (a) {
                b.handleCalendarChange.call(b, a)
            }, !0);
            AmCharts.isIE && h.attachEvent("onkeypress", function (a) {
                b.handleCalendarChange.call(b, a)
            });
            f.appendChild(h);
            b.startDateField = h;
            if (c)g = b.width - 6 + "px", AmCharts.addBr(f); else {
                var g = b.inputFieldWidth + "px", k = document.createTextNode(" ");
                f.appendChild(k)
            }
            h.style.width = g;
            h = document.createTextNode(b.toText);
            f.appendChild(h);
            c && AmCharts.addBr(f);
            h = document.createElement("input");
            h.className = "amChartsInputField";
            h.style.textAlign =
                "center";
            h.onblur = function () {
                b.handleCalChange()
            };
            AmCharts.isNN && h.addEventListener("keypress", function (a) {
                b.handleCalendarChange.call(b, a)
            }, !0);
            AmCharts.isIE && h.attachEvent("onkeypress", function (a) {
                b.handleCalendarChange.call(b, a)
            });
            f.appendChild(h);
            b.endDateField = h;
            c ? AmCharts.addBr(f) : d = h.offsetHeight + 2;
            g && (h.style.width = g)
        }
        f = b.periods;
        if (AmCharts.ifArray(f)) {
            g = document.createElement("div");
            c || (g.style.cssFloat = "right", g.style.styleFloat = "right", g.style.display = "inline");
            a.appendChild(g);
            c && AmCharts.addBr(g);
            a = document.createTextNode(b.periodsText);
            g.appendChild(a);
            b.periodContainer = g;
            var l;
            for (a = 0; a < f.length; a++)h = f[a], l = document.createElement("input"), l.type = "button", l.value = h.label, l.period = h.period, l.count = h.count, l.periodObj = h, l.className = "amChartsButton", c && (l.style.width = b.width - 1 + "px"), g.appendChild(l), b.addEventListeners(l), h.button = l;
            !c && l && (e = l.offsetHeight);
            b.offsetHeight = Math.max(d, e)
        }
    }, addEventListeners: function (a) {
        var b = this;
        AmCharts.isNN && a.addEventListener("click", function (a) {
            b.handlePeriodChange.call(b,
                a)
        }, !0);
        AmCharts.isIE && a.attachEvent("onclick", function (a) {
            b.handlePeriodChange.call(b, a)
        })
    }, getPeriodDates: function () {
        var a = this.periods, b;
        for (b = 0; b < a.length; b++)this.selectPeriodButton(a[b], !0)
    }, handleCalendarChange: function (a) {
        13 == a.keyCode && this.handleCalChange()
    }, handleCalChange: function () {
        var a = this.dateFormat, b = AmCharts.stringToDate(this.startDateField.value, a), a = this.chart.getLastDate(AmCharts.stringToDate(this.endDateField.value, a));
        try {
            this.startDateField.blur(), this.endDateField.blur()
        } catch (c) {
        }
        if (b &&
            a) {
            var d = {type: "changed"};
            d.startDate = b;
            d.endDate = a;
            d.chart = this.chart;
            this.fire(d.type, d)
        }
    }, handlePeriodChange: function (a) {
        this.selectPeriodButton((a.srcElement ? a.srcElement : a.target).periodObj)
    }, setRanges: function (a, b) {
        this.firstDate = a;
        this.lastDate = b;
        this.getPeriodDates()
    }, selectPeriodButton: function (a, b) {
        var c = a.button, d = c.count, e = c.period, f, g, h = this.firstDate, k = this.lastDate, l;
        h && k && ("MAX" == e ? (f = h, g = k) : "YTD" == e ? (f = new Date, f.setMonth(0, 1), f.setHours(0, 0, 0, 0), 0 === d && f.setDate(f.getDate() - 1), g =
            this.lastDate) : (l = AmCharts.getPeriodDuration(e, d), this.selectFromStart ? (f = h, g = new Date(h.getTime() + l)) : (f = new Date(k.getTime() - l), g = k)), a.startTime = f.getTime(), this.hideOutOfScopePeriods && (b && a.startTime < h.getTime() ? c.style.display = "none" : c.style.display = "inline"), f.getTime() > k.getTime() && (l = AmCharts.getPeriodDuration("DD", 1), f = new Date(k.getTime() - l)), f.getTime() < h.getTime() && (f = h), "YTD" == e && (a.startTime = f.getTime()), a.endTime = g.getTime(), b || (this.skipMark = !0, this.unselectButtons(), c.className = "amChartsButtonSelected",
            c = {type: "changed"}, c.startDate = f, c.endDate = g, c.predefinedPeriod = e, c.chart = this.chart, c.count = d, this.fire(c.type, c)))
    }, markButtonAsSelected: function () {
        if (!this.skipMark) {
            var a = this.chart, b = this.periods, c = a.startDate.getTime(), a = a.endDate.getTime();
            this.unselectButtons();
            var d;
            for (d = b.length - 1; 0 <= d; d--) {
                var e = b[d], f = e.button;
                e.startTime && e.endTime && (c == e.startTime && a == e.endTime) && (this.unselectButtons(), f.className = "amChartsButtonSelected")
            }
        }
        this.skipMark = !1
    }, unselectButtons: function () {
        var a = this.periods,
            b;
        for (b = a.length - 1; 0 <= b; b--)a[b].button.className = "amChartsButton"
    }, setDefaultPeriod: function () {
        var a = this.periods, b;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.selected && this.selectPeriodButton(c)
        }
    }
});
AmCharts.StockGraph = AmCharts.Class({
    inherits: AmCharts.AmGraph, construct: function () {
        AmCharts.StockGraph.base.construct.call(this);
        this.useDataSetColors = !0;
        this.periodValue = "Close";
        this.compareGraphType = "line";
        this.compareGraphVisibleInLegend = !0;
        this.comparedGraphs = {};
        this.comparable = this.resetTitleOnDataSetChange = !1;
        this.comparedGraphs = {}
    }
});
AmCharts.StockPanel = AmCharts.Class({
    inherits: AmCharts.AmSerialChart, construct: function () {
        AmCharts.StockPanel.base.construct.call(this);
        this.showCategoryAxis = !0;
        this.recalculateToPercents = "whenComparing";
        this.panelHeaderPaddingBottom = this.panelHeaderPaddingLeft = this.panelHeaderPaddingRight = this.panelHeaderPaddingTop = 0;
        this.trendLineAlpha = 1;
        this.trendLineColor = "#00CC00";
        this.trendLineColorHover = "#CC0000";
        this.trendLineThickness = 2;
        this.trendLineDashLength = 0;
        this.stockGraphs = [];
        this.drawingIconsEnabled = !1;
        this.iconSize = 18;
        this.autoMargins = this.allowTurningOff = this.eraseAll = this.erasingEnabled = this.drawingEnabled = !1
    }, initChart: function (a) {
        AmCharts.StockPanel.base.initChart.call(this, a);
        this.drawingIconsEnabled && this.createDrawIcons();
        if (a = this.chartCursor)this.removeListener(a, "draw", this.handleDraw), this.listenTo(a, "draw", this.handleDraw)
    }, addStockGraph: function (a) {
        this.stockGraphs.push(a);
        return a
    }, removeStockGraph: function (a) {
        var b = this.stockGraphs, c;
        for (c = b.length - 1; 0 <= c; c--)b[c] == a && b.splice(c,
            1)
    }, createDrawIcons: function () {
        var a = this, b = a.iconSize, c = a.container, d = a.pathToImages, e = a.realWidth - 2 * b - 1 - a.marginRight, f = AmCharts.rect(c, b, b, "#000", 0.005), g = AmCharts.rect(c, b, b, "#000", 0.005);
        g.translate(b + 1, 0);
        var h = c.image(d + "pencilIcon.gif", 0, 0, b, b);
        a.pencilButton = h;
        g.setAttr("cursor", "pointer");
        f.setAttr("cursor", "pointer");
        f.mouseup(function () {
            a.handlePencilClick()
        });
        var k = c.image(d + "pencilIconH.gif", 0, 0, b, b);
        a.pencilButtonPushed = k;
        a.drawingEnabled || k.hide();
        var l = c.image(d + "eraserIcon.gif",
            b + 1, 0, b, b);
        a.eraserButton = l;
        g.mouseup(function () {
            a.handleEraserClick()
        });
        f.touchend && (f.touchend(function () {
            a.handlePencilClick()
        }), g.touchend(function () {
            a.handleEraserClick()
        }));
        b = c.image(d + "eraserIconH.gif", b + 1, 0, b, b);
        a.eraserButtonPushed = b;
        a.erasingEnabled || b.hide();
        c = c.set([h, k, l, b, f, g]);
        c.translate(e, 1);
        this.hideIcons && c.hide()
    }, handlePencilClick: function () {
        var a = !this.drawingEnabled;
        this.disableDrawing(!a);
        this.erasingEnabled = !1;
        this.eraserButtonPushed.hide();
        a ? this.pencilButtonPushed.show() :
            (this.pencilButtonPushed.hide(), this.setMouseCursor("auto"))
    }, disableDrawing: function (a) {
        this.drawingEnabled = !a;
        var b = this.chartCursor;
        this.stockChart.enableCursors(a);
        b && b.enableDrawing(!a)
    }, handleEraserClick: function () {
        this.disableDrawing(!0);
        this.pencilButtonPushed.hide();
        if (this.eraseAll) {
            var a = this.trendLines, b;
            for (b = a.length - 1; 0 <= b; b--) {
                var c = a[b];
                c.isProtected || this.removeTrendLine(c)
            }
            this.validateNow()
        } else(this.erasingEnabled = a = !this.erasingEnabled) ? (this.eraserButtonPushed.show(), this.setTrendColorHover(this.trendLineColorHover),
            this.setMouseCursor("auto")) : (this.eraserButtonPushed.hide(), this.setTrendColorHover())
    }, setTrendColorHover: function (a) {
        var b = this.trendLines, c;
        for (c = b.length - 1; 0 <= c; c--) {
            var d = b[c];
            d.isProtected || (d.rollOverColor = a)
        }
    }, handleDraw: function (a) {
        var b = this.drawOnAxis;
        b || (b = this.valueAxes[0]);
        var c = this.categoryAxis, d = a.initialX, e = a.finalX, f = a.initialY;
        a = a.finalY;
        var g = new AmCharts.TrendLine;
        g.initialDate = c.coordinateToDate(d);
        g.finalDate = c.coordinateToDate(e);
        g.initialValue = b.coordinateToValue(f);
        g.finalValue =
            b.coordinateToValue(a);
        g.lineAlpha = this.trendLineAlpha;
        g.lineColor = this.trendLineColor;
        g.lineThickness = this.trendLineThickness;
        g.dashLength = this.trendLineDashLength;
        g.valueAxis = b;
        g.categoryAxis = c;
        this.addTrendLine(g);
        this.listenTo(g, "click", this.handleTrendClick);
        this.validateNow()
    }, hideDrawingIcons: function (a) {
        (this.hideIcons = a) && this.disableDrawing(a)
    }, handleTrendClick: function (a) {
        this.erasingEnabled && (a = a.trendLine, this.eraseAll || a.isProtected || this.removeTrendLine(a), this.validateNow())
    }
});
AmCharts.CategoryAxesSettings = AmCharts.Class({
    construct: function () {
        this.minPeriod = "DD";
        this.equalSpacing = !1;
        this.axisHeight = 28;
        this.tickLength = this.axisAlpha = 0;
        this.gridCount = 10;
        this.maxSeries = 150;
        this.groupToPeriods = "ss 10ss 30ss mm 10mm 30mm hh DD WW MM YYYY".split(" ");
        this.autoGridCount = !0
    }
});
AmCharts.ChartCursorSettings = AmCharts.Class({
    construct: function () {
        this.enabled = !0;
        this.bulletsEnabled = this.valueBalloonsEnabled = !1;
        this.categoryBalloonDateFormats = [{period: "YYYY", format: "YYYY"}, {
            period: "MM",
            format: "MMM, YYYY"
        }, {period: "WW", format: "MMM DD, YYYY"}, {period: "DD", format: "MMM DD, YYYY"}, {
            period: "hh",
            format: "JJ:NN"
        }, {period: "mm", format: "JJ:NN"}, {period: "ss", format: "JJ:NN:SS"}, {period: "fff", format: "JJ:NN:SS"}]
    }, categoryBalloonDateFormat: function (a) {
        var b = this.categoryBalloonDateFormats, c,
            d;
        for (d = 0; d < b.length; d++)b[d].period == a && (c = b[d].format);
        return c
    }
});
AmCharts.ChartScrollbarSettings = AmCharts.Class({
    construct: function () {
        this.height = 40;
        this.enabled = !0;
        this.color = "#FFFFFF";
        this.updateOnReleaseOnly = this.autoGridCount = !0;
        this.hideResizeGrips = !1
    }
});
AmCharts.LegendSettings = AmCharts.Class({
    construct: function () {
        this.marginBottom = this.marginTop = 0;
        this.usePositiveNegativeOnPercentsOnly = !0;
        this.positiveValueColor = "#00CC00";
        this.negativeValueColor = "#CC0000";
        this.autoMargins = this.equalWidths = this.textClickEnabled = !1
    }
});
AmCharts.PanelsSettings = AmCharts.Class({
    construct: function () {
        this.marginBottom = this.marginTop = this.marginRight = this.marginLeft = 0;
        this.backgroundColor = "#FFFFFF";
        this.backgroundAlpha = 0;
        this.panelSpacing = 8;
        this.panEventsEnabled = !1
    }
});
AmCharts.StockEventsSettings = AmCharts.Class({
    construct: function () {
        this.type = "sign";
        this.backgroundAlpha = 1;
        this.backgroundColor = "#DADADA";
        this.borderAlpha = 1;
        this.borderColor = "#888888";
        this.balloonColor = this.rollOverColor = "#CC0000"
    }
});
AmCharts.ValueAxesSettings = AmCharts.Class({
    construct: function () {
        this.tickLength = 0;
        this.showFirstLabel = this.autoGridCount = this.inside = !0;
        this.showLastLabel = !1;
        this.axisAlpha = 0
    }
});
AmCharts.getItemIndex = function (a, b) {
    var c = -1, d;
    for (d = 0; d < b.length; d++)a == b[d] && (c = d);
    return c
};
AmCharts.addBr = function (a) {
    a.appendChild(document.createElement("br"))
};
AmCharts.stringToDate = function (a, b) {
    var c = {}, d = [{pattern: "YYYY", period: "year"}, {pattern: "YY", period: "year"}, {
        pattern: "MM",
        period: "month"
    }, {pattern: "M", period: "month"}, {pattern: "DD", period: "date"}, {pattern: "D", period: "date"}, {
        pattern: "JJ",
        period: "hours"
    }, {pattern: "J", period: "hours"}, {pattern: "HH", period: "hours"}, {
        pattern: "H",
        period: "hours"
    }, {pattern: "KK", period: "hours"}, {pattern: "K", period: "hours"}, {
        pattern: "LL",
        period: "hours"
    }, {pattern: "L", period: "hours"}, {pattern: "NN", period: "minutes"}, {
        pattern: "N",
        period: "minutes"
    }, {pattern: "SS", period: "seconds"}, {pattern: "S", period: "seconds"}, {
        pattern: "QQQ",
        period: "milliseconds"
    }, {pattern: "QQ", period: "milliseconds"}, {pattern: "Q", period: "milliseconds"}], e = !0, f = b.indexOf("AA");
    -1 != f && (a.substr(f, 2), "pm" == a.toLowerCase && (e = !1));
    var f = b, g, h, k;
    for (k = 0; k < d.length; k++)h = d[k].period, c[h] = 0, "date" == h && (c[h] = 1);
    for (k = 0; k < d.length; k++)if (g = d[k].pattern, h = d[k].period, -1 != b.indexOf(g)) {
        var l = AmCharts.getFromDateString(g, a, f);
        b = b.replace(g, "");
        if ("KK" == g || "K" == g || "LL" ==
            g || "L" == g)e || (l += 12);
        c[h] = l
    }
    return new Date(c.year, c.month, c.date, c.hours, c.minutes, c.seconds, c.milliseconds)
};
AmCharts.getFromDateString = function (a, b, c) {
    c = c.indexOf(a);
    b = b.substr(c, a.length);
    "0" == b.charAt(0) && (b = b.substr(1, b.length - 1));
    b = Number(b);
    isNaN(b) && (b = 0);
    -1 != a.indexOf("M") && b--;
    return b
};
AmCharts.changeDate = function (a, b, c, d, e) {
    var f = -1;
    void 0 === d && (d = !0);
    void 0 === e && (e = !1);
    !0 === d && (f = 1);
    switch (b) {
        case "YYYY":
            a.setFullYear(a.getFullYear() + c * f);
            d || e || a.setDate(a.getDate() + 1);
            break;
        case "MM":
            a.setMonth(a.getMonth() + c * f);
            d || e || a.setDate(a.getDate() + 1);
            break;
        case "DD":
            a.setDate(a.getDate() + c * f);
            break;
        case "WW":
            a.setDate(a.getDate() + 7 * c * f + 1);
            break;
        case "hh":
            a.setHours(a.getHours() + c * f);
            break;
        case "mm":
            a.setMinutes(a.getMinutes() + c * f);
            break;
        case "ss":
            a.setSeconds(a.getSeconds() + c * f);
            break;
        case "fff":
            a.setMilliseconds(a.getMilliseconds() + c * f)
    }
    return a
};
AmCharts.parseStockData = function (a, b, c, d) {
    (new Date).getTime();
    var e = {}, f = a.dataProvider, g = a.categoryField;
    if (g) {
        var h = AmCharts.getItemIndex(b, c), k = c.length, l, m = f.length, n, s = {};
        for (l = h; l < k; l++)n = c[l], e[n] = [];
        var q = {}, t = a.fieldMappings, p = t.length;
        for (l = 0; l < m; l++) {
            var r = f[l], u = r[g], u = u instanceof Date ? "fff" == b ? AmCharts.useUTC ? new Date(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate(), u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), u.getUTCMilliseconds()) : new Date(u.getFullYear(), u.getMonth(), u.getDate(),
                u.getHours(), u.getMinutes(), u.getSeconds(), u.getMilliseconds()) : new Date(u) : new Date(u), v = u.getTime(), w = {};
            for (n = 0; n < p; n++)w[t[n].toField] = r[t[n].fromField];
            var A;
            for (A = h; A < k; A++) {
                n = c[A];
                var x = AmCharts.extractPeriod(n), B = x.period, x = x.count;
                if (A == h || v >= s[n] || !s[n]) {
                    q[n] = {};
                    q[n][g] = new Date(u);
                    q[n].amCategoryIdField = String(AmCharts.resetDateToMin(u, B, x, d).getTime());
                    var y;
                    for (y = 0; y < p; y++) {
                        var z = q[n], C = t[y].toField, H = Number(w[C]);
                        z[C + "Count"] = 0;
                        z[C + "Sum"] = 0;
                        isNaN(H) || (z[C + "Open"] = H, z[C + "Sum"] = H, z[C +
                        "High"] = H, z[C + "Low"] = H, z[C + "Close"] = H, z[C + "Count"] = 1, z[C + "Average"] = H)
                    }
                    e[n].push(q[n]);
                    A > h && (z = new Date(u), z = AmCharts.changeDate(z, B, x, !0), z = AmCharts.resetDateToMin(z, B, x, d), s[n] = z.getTime());
                    if (A == h)for (var J in r)r.hasOwnProperty(J) && (q[n][J] = r[J])
                } else for (B = 0; B < p; B++)C = t[B].toField, z = q[n], l == m - 1 && (z[g] = new Date(u)), H = Number(w[C]), isNaN(H) || (isNaN(z[C + "Low"]) && (z[C + "Low"] = H), H < z[C + "Low"] && (z[C + "Low"] = H), isNaN(z[C + "High"]) && (z[C + "High"] = H), H > z[C + "High"] && (z[C + "High"] = H), z[C + "Close"] = H, z[C + "Sum"] +=
                    H, z[C + "Count"]++, z[C + "Average"] = z[C + "Sum"] / z[C + "Count"])
            }
        }
    }
    a.agregatedDataProviders = e
};
AmCharts.parseEvents = function (a, b, c, d, e) {
    var f = a.stockEvents, g = a.agregatedDataProviders, h = b.length, k, l, m, n, s, q, t;
    for (k = 0; k < h; k++)for (q = b[k], s = q.graphs, m = s.length, l = 0; l < m; l++)n = s[l], n.customBulletField = "amCustomBullet" + n.id + "_" + q.id, n.bulletConfigField = "amCustomBulletConfig" + n.id + "_" + q.id;
    for (var p in g)if (g.hasOwnProperty(p)) {
        var r = g[p], u = AmCharts.extractPeriod(p), v = r.length, w;
        for (w = 0; w < v; w++) {
            var A = r[w];
            k = A[a.categoryField];
            var x = k.getTime();
            l = u.period;
            m = u.count;
            var B;
            B = "fff" == l ? k.getTime() + 1 : AmCharts.resetDateToMin(AmCharts.changeDate(new Date(k),
                u.period, u.count), l, m, d).getTime();
            for (k = 0; k < h; k++)for (q = b[k], s = q.graphs, m = s.length, l = 0; l < m; l++) {
                n = s[l];
                var y = {};
                y.eventDispatcher = e;
                y.eventObjects = [];
                y.letters = [];
                y.descriptions = [];
                y.shapes = [];
                y.backgroundColors = [];
                y.backgroundAlphas = [];
                y.borderColors = [];
                y.borderAlphas = [];
                y.colors = [];
                y.rollOverColors = [];
                y.showOnAxis = [];
                for (t = 0; t < f.length; t++) {
                    var z = f[t], C = z.date.getTime();
                    n == z.graph && (C >= x && C < B) && (y.eventObjects.push(z), y.letters.push(z.text), y.descriptions.push(z.description), z.type ? y.shapes.push(z.type) :
                        y.shapes.push(c.type), void 0 !== z.backgroundColor ? y.backgroundColors.push(z.backgroundColor) : y.backgroundColors.push(c.backgroundColor), isNaN(z.backgroundAlpha) ? y.backgroundAlphas.push(c.backgroundAlpha) : y.backgroundAlphas.push(z.backgroundAlpha), isNaN(z.borderAlpha) ? y.borderAlphas.push(c.borderAlpha) : y.borderAlphas.push(z.borderAlpha), void 0 !== z.borderColor ? y.borderColors.push(z.borderColor) : y.borderColors.push(c.borderColor), void 0 !== z.rollOverColor ? y.rollOverColors.push(z.rollOverColor) : y.rollOverColors.push(c.rollOverColor),
                        y.colors.push(z.color), !z.panel && z.graph && (z.panel = z.graph.chart), y.showOnAxis.push(z.showOnAxis), y.date = new Date(z.date))
                }
                0 < y.shapes.length && (t = "amCustomBullet" + n.id + "_" + q.id, n = "amCustomBulletConfig" + n.id + "_" + q.id, A[t] = AmCharts.StackedBullet, A[n] = y)
            }
        }
    }
};
AmCharts.StockLegend = AmCharts.Class({
    inherits: AmCharts.AmLegend, construct: function () {
        AmCharts.StockLegend.base.construct.call(this);
        this.valueTextComparing = "[[percents.value]]%";
        this.valueTextRegular = "[[value]]"
    }, drawLegend: function () {
        var a = this;
        AmCharts.StockLegend.base.drawLegend.call(a);
        var b = a.chart;
        if (b.allowTurningOff) {
            var c = a.container, d = c.image(b.pathToImages + "xIcon.gif", b.realWidth - 17, 3, 17, 17), b = c.image(b.pathToImages + "xIconH.gif", b.realWidth - 17, 3, 17, 17);
            b.hide();
            a.xButtonHover = b;
            d.mouseup(function () {
                a.handleXClick()
            }).mouseover(function () {
                a.handleXOver()
            });
            b.mouseup(function () {
                a.handleXClick()
            }).mouseout(function () {
                a.handleXOut()
            })
        }
    }, handleXOver: function () {
        this.xButtonHover.show()
    }, handleXOut: function () {
        this.xButtonHover.hide()
    }, handleXClick: function () {
        var a = this.chart, b = a.stockChart;
        b.removePanel(a);
        b.validateNow()
    }
});
AmCharts.DataSetSelector = AmCharts.Class({
    construct: function () {
        this.createEvents("dataSetSelected", "dataSetCompared", "dataSetUncompared");
        this.position = "left";
        this.selectText = "Select:";
        this.comboBoxSelectText = "Select...";
        this.compareText = "Compare to:";
        this.width = 180;
        this.dataProvider = [];
        this.listHeight = 150;
        this.listCheckBoxSize = 14;
        this.rollOverBackgroundColor = "#b2e1ff";
        this.selectedBackgroundColor = "#7fceff"
    }, write: function (a) {
        var b = this, c;
        a.className = "amChartsDataSetSelector";
        b.div = a;
        a.innerHTML = "";
        var d = b.position, e;
        e = "top" == d || "bottom" == d ? !1 : !0;
        b.vertical = e;
        var f;
        e && (f = b.width + "px");
        var d = b.dataProvider, g, h;
        if (1 < b.countDataSets("showInSelect")) {
            c = document.createTextNode(b.selectText);
            a.appendChild(c);
            e && AmCharts.addBr(a);
            var k = document.createElement("select");
            f && (k.style.width = f);
            b.selectCB = k;
            a.appendChild(k);
            AmCharts.isNN && k.addEventListener("change", function (a) {
                b.handleDataSetChange.call(b, a)
            }, !0);
            AmCharts.isIE && k.attachEvent("onchange", function (a) {
                b.handleDataSetChange.call(b, a)
            });
            for (c =
                     0; c < d.length; c++)if (g = d[c], !0 === g.showInSelect) {
                h = document.createElement("option");
                h.text = g.title;
                h.value = c;
                g == b.chart.mainDataSet && (h.selected = !0);
                try {
                    k.add(h, null)
                } catch (l) {
                    k.add(h)
                }
            }
            b.offsetHeight = k.offsetHeight
        }
        if (0 < b.countDataSets("showInCompare") && 1 < d.length)if (e ? (AmCharts.addBr(a), AmCharts.addBr(a)) : (c = document.createTextNode(" "), a.appendChild(c)), c = document.createTextNode(b.compareText), a.appendChild(c), h = b.listCheckBoxSize, e) {
            AmCharts.addBr(a);
            f = document.createElement("div");
            a.appendChild(f);
            f.className = "amChartsCompareList";
            f.style.overflow = "auto";
            f.style.overflowX = "hidden";
            f.style.width = b.width - 2 + "px";
            f.style.maxHeight = b.listHeight + "px";
            for (c = 0; c < d.length; c++)g = d[c], !0 === g.showInCompare && g != b.chart.mainDataSet && (e = document.createElement("div"), e.style.padding = "4px", e.style.position = "relative", e.name = "amCBContainer", e.dataSet = g, e.style.height = h + "px", g.compared && (e.style.backgroundColor = b.selectedBackgroundColor), f.appendChild(e), k = document.createElement("div"), k.style.width = h + "px", k.style.height =
                h + "px", k.style.position = "absolute", k.style.backgroundColor = g.color, e.appendChild(k), k = document.createElement("div"), k.style.width = "100%", k.style.position = "absolute", k.style.left = h + 10 + "px", e.appendChild(k), g = document.createTextNode(g.title), k.style.whiteSpace = "nowrap", k.style.cursor = "default", k.appendChild(g), b.addEventListeners(e));
            AmCharts.addBr(a);
            AmCharts.addBr(a)
        } else {
            e = document.createElement("select");
            b.compareCB = e;
            f && (e.style.width = f);
            a.appendChild(e);
            AmCharts.isNN && e.addEventListener("change",
                function (a) {
                    b.handleCBSelect.call(b, a)
                }, !0);
            AmCharts.isIE && e.attachEvent("onchange", function (a) {
                b.handleCBSelect.call(b, a)
            });
            h = document.createElement("option");
            h.text = b.comboBoxSelectText;
            try {
                e.add(h, null)
            } catch (m) {
                e.add(h)
            }
            for (c = 0; c < d.length; c++)if (g = d[c], !0 === g.showInCompare && g != b.chart.mainDataSet) {
                h = document.createElement("option");
                h.text = g.title;
                h.value = c;
                g.compared && (h.selected = !0);
                try {
                    e.add(h, null)
                } catch (n) {
                    e.add(h)
                }
            }
            b.offsetHeight = e.offsetHeight
        }
    }, addEventListeners: function (a) {
        var b = this;
        AmCharts.isNN && (a.addEventListener("mouseover", function (a) {
            b.handleRollOver.call(b, a)
        }, !0), a.addEventListener("mouseout", function (a) {
            b.handleRollOut.call(b, a)
        }, !0), a.addEventListener("click", function (a) {
            b.handleClick.call(b, a)
        }, !0));
        AmCharts.isIE && (a.attachEvent("onmouseout", function (a) {
            b.handleRollOut.call(b, a)
        }), a.attachEvent("onmouseover", function (a) {
            b.handleRollOver.call(b, a)
        }), a.attachEvent("onclick", function (a) {
            b.handleClick.call(b, a)
        }))
    }, handleDataSetChange: function () {
        var a = this.selectCB, a =
            this.dataProvider[a.options[a.selectedIndex].value], b = this.chart;
        b.mainDataSet = a;
        b.zoomOutOnDataSetChange && (b.startDate = void 0, b.endDate = void 0);
        b.validateData();
        a = {type: "dataSetSelected", dataSet: a, chart: this.chart};
        this.fire(a.type, a)
    }, handleRollOver: function (a) {
        a = this.getRealDiv(a);
        a.dataSet.compared || (a.style.backgroundColor = this.rollOverBackgroundColor)
    }, handleRollOut: function (a) {
        a = this.getRealDiv(a);
        a.dataSet.compared || (a.style.removeProperty && a.style.removeProperty("background-color"), a.style.removeAttribute &&
        a.style.removeAttribute("backgroundColor"))
    }, handleCBSelect: function (a) {
        var b = this.compareCB, c = this.dataProvider, d, e;
        for (d = 0; d < c.length; d++)e = c[d], e.compared && (a = {
            type: "dataSetUncompared",
            dataSet: e
        }), e.compared = !1;
        c = b.selectedIndex;
        0 < c && (e = this.dataProvider[b.options[c].value], e.compared || (a = {
            type: "dataSetCompared",
            dataSet: e
        }), e.compared = !0);
        b = this.chart;
        b.validateData();
        a.chart = b;
        this.fire(a.type, a)
    }, handleClick: function (a) {
        a = this.getRealDiv(a).dataSet;
        !0 === a.compared ? (a.compared = !1, a = {
            type: "dataSetUncompared",
            dataSet: a
        }) : (a.compared = !0, a = {type: "dataSetCompared", dataSet: a});
        var b = this.chart;
        b.validateData();
        a.chart = b;
        this.fire(a.type, a)
    }, getRealDiv: function (a) {
        a || (a = window.event);
        a = a.currentTarget ? a.currentTarget : a.srcElement;
        "amCBContainer" == a.parentNode.name && (a = a.parentNode);
        return a
    }, countDataSets: function (a) {
        var b = this.dataProvider, c = 0, d;
        for (d = 0; d < b.length; d++)!0 === b[d][a] && c++;
        return c
    }
});
AmCharts.StackedBullet = AmCharts.Class({
    construct: function () {
        this.fontSize = 11;
        this.stackDown = !1;
        this.mastHeight = 8;
        this.shapes = [];
        this.backgroundColors = [];
        this.backgroundAlphas = [];
        this.borderAlphas = [];
        this.borderColors = [];
        this.colors = [];
        this.rollOverColors = [];
        this.showOnAxiss = [];
        this.textColor = "#000000";
        this.nextY = 0;
        this.size = 16
    }, parseConfig: function () {
        var a = this.bulletConfig;
        this.eventObjects = a.eventObjects;
        this.letters = a.letters;
        this.shapes = a.shapes;
        this.backgroundColors = a.backgroundColors;
        this.backgroundAlphas =
            a.backgroundAlphas;
        this.borderColors = a.borderColors;
        this.borderAlphas = a.borderAlphas;
        this.colors = a.colors;
        this.rollOverColors = a.rollOverColors;
        this.date = a.date;
        this.showOnAxiss = a.showOnAxis;
        this.axisCoordinate = a.minCoord
    }, write: function (a) {
        this.parseConfig();
        this.container = a;
        this.bullets = [];
        if (this.graph) {
            var b = this.graph.fontSize;
            b && (this.fontSize = b)
        }
        b = this.letters.length;
        (this.mastHeight + 2 * (this.fontSize / 2 + 2)) * b > this.availableSpace && (this.stackDown = !0);
        this.set = a.set();
        a = 0;
        var c;
        for (c = 0; c < b; c++)this.shape =
            this.shapes[c], this.backgroundColor = this.backgroundColors[c], this.backgroundAlpha = this.backgroundAlphas[c], this.borderAlpha = this.borderAlphas[c], this.borderColor = this.borderColors[c], this.rollOverColor = this.rollOverColors[c], this.showOnAxis = this.showOnAxiss[c], this.color = this.colors[c], this.addLetter(this.letters[c], a, c), this.showOnAxis || a++
    }, addLetter: function (a, b, c) {
        var d = this.container;
        b = d.set();
        var e = -1, f = this.stackDown;
        this.showOnAxis && (this.stackDown = this.graph.valueAxis.reversed ? !0 : !1);
        this.stackDown &&
        (e = 1);
        var g = 0, h = 0, k = 0, l, k = this.fontSize, m = this.mastHeight, n = this.shape, s = this.textColor;
        void 0 !== this.color && (s = this.color);
        void 0 === a && (a = "");
        a = AmCharts.text(d, a, s, this.chart.fontFamily, this.fontSize);
        d = a.getBBox();
        this.labelWidth = s = d.width;
        this.labelHeight = d.height;
        d = 0;
        switch (n) {
            case "sign":
                l = this.drawSign(b);
                g = m + 4 + k / 2;
                d = m + k + 4;
                1 == e && (g -= 4);
                break;
            case "flag":
                l = this.drawFlag(b);
                h = s / 2 + 3;
                g = m + 4 + k / 2;
                d = m + k + 4;
                1 == e && (g -= 4);
                break;
            case "pin":
                l = this.drawPin(b);
                g = 6 + k / 2;
                d = k + 8;
                break;
            case "triangleUp":
                l = this.drawTriangleUp(b);
                g = -k - 1;
                d = k + 4;
                e = -1;
                break;
            case "triangleDown":
                l = this.drawTriangleDown(b);
                g = k + 1;
                d = k + 4;
                e = -1;
                break;
            case "triangleLeft":
                l = this.drawTriangleLeft(b);
                h = k;
                d = k + 4;
                e = -1;
                break;
            case "triangleRight":
                l = this.drawTriangleRight(b);
                h = -k;
                e = -1;
                d = k + 4;
                break;
            case "arrowUp":
                l = this.drawArrowUp(b);
                a.hide();
                break;
            case "arrowDown":
                l = this.drawArrowDown(b);
                a.hide();
                d = k + 4;
                break;
            case "text":
                e = -1;
                l = this.drawTextBackground(b, a);
                g = this.labelHeight + 3;
                d = k + 10;
                break;
            case "round":
                l = this.drawCircle(b)
        }
        this.bullets[c] = l;
        this.showOnAxis ? (l = isNaN(this.nextAxisY) ?
            this.axisCoordinate : this.nextY, k = g * e, this.nextAxisY = l + e * d) : (l = this.nextY, k = g * e);
        a.translate(h, k);
        b.push(a);
        b.translate(0, l);
        this.addEventListeners(b, c);
        this.nextY = l + e * d;
        this.stackDown = f
    }, addEventListeners: function (a, b) {
        var c = this;
        a.click(function () {
            c.handleClick(b)
        }).mouseover(function () {
            c.handleMouseOver(b)
        }).touchend(function () {
            c.handleMouseOver(b, !0)
        }).mouseout(function () {
            c.handleMouseOut(b)
        })
    }, drawPin: function (a) {
        var b = -1;
        this.stackDown && (b = 1);
        var c = this.fontSize + 4;
        return this.drawRealPolygon(a,
            [0, c / 2, c / 2, -c / 2, -c / 2, 0], [0, b * c / 4, b * (c + c / 4), b * (c + c / 4), b * c / 4, 0])
    }, drawSign: function (a) {
        var b = -1;
        this.stackDown && (b = 1);
        var c = this.mastHeight * b, d = this.fontSize / 2 + 2, e = AmCharts.line(this.container, [0, 0], [0, c], this.borderColor, this.borderAlpha, 1), f = AmCharts.circle(this.container, d, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
        f.translate(0, c + d * b);
        a.push(e);
        a.push(f);
        this.set.push(a);
        return f
    }, drawFlag: function (a) {
        var b = -1;
        this.stackDown && (b = 1);
        var c = this.fontSize + 4, d = this.labelWidth +
            6, e = this.mastHeight, b = 1 == b ? b * e : b * e - c, e = AmCharts.line(this.container, [0, 0], [0, b], this.borderColor, this.borderAlpha, 1), c = AmCharts.polygon(this.container, [0, d, d, 0], [0, 0, c, c], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
        c.translate(0, b);
        a.push(e);
        a.push(c);
        this.set.push(a);
        return c
    }, drawTriangleUp: function (a) {
        var b = this.fontSize + 7;
        return this.drawRealPolygon(a, [0, b / 2, -b / 2, 0], [0, b, b, 0])
    }, drawArrowUp: function (a) {
        var b = this.size, c = b / 2, d = b / 4;
        return this.drawRealPolygon(a,
            [0, c, d, d, -d, -d, -c, 0], [0, c, c, b, b, c, c, 0])
    }, drawArrowDown: function (a) {
        var b = this.size, c = b / 2, d = b / 4;
        return this.drawRealPolygon(a, [0, c, d, d, -d, -d, -c, 0], [0, -c, -c, -b, -b, -c, -c, 0])
    }, drawTriangleDown: function (a) {
        var b = this.fontSize + 7;
        return this.drawRealPolygon(a, [0, b / 2, -b / 2, 0], [0, -b, -b, 0])
    }, drawTriangleLeft: function (a) {
        var b = this.fontSize + 7;
        return this.drawRealPolygon(a, [0, b, b, 0], [0, -b / 2, b / 2])
    }, drawTriangleRight: function (a) {
        var b = this.fontSize + 7;
        return this.drawRealPolygon(a, [0, -b, -b, 0], [0, -b / 2, b / 2, 0])
    }, drawRealPolygon: function (a,
                                  b, c) {
        b = AmCharts.polygon(this.container, b, c, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
        a.push(b);
        this.set.push(a);
        return b
    }, drawCircle: function (a) {
        shape = AmCharts.circle(this.container, this.fontSize / 2, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
        a.push(shape);
        this.set.push(a);
        return shape
    }, drawTextBackground: function (a, b) {
        var c = b.getBBox(), d = -c.width / 2 - 5, e = c.width / 2 + 5, c = -c.height - 12;
        return this.drawRealPolygon(a, [d, -5, 0, 5, e, e, d, d],
            [-5, -5, 0, -5, -5, c, c, -5])
    }, handleMouseOver: function (a, b) {
        b || this.bullets[a].attr({fill: this.rollOverColors[a]});
        var c = this.eventObjects[a], d = {
            type: "rollOverStockEvent",
            eventObject: c,
            graph: this.graph,
            date: this.date
        }, e = this.bulletConfig.eventDispatcher;
        d.chart = e;
        e.fire(d.type, d);
        c.url && this.bullets[a].setAttr("cursor", "pointer");
        this.chart.showBalloon(c.description, e.stockEventsSettings.balloonColor, !0)
    }, handleClick: function (a) {
        a = this.eventObjects[a];
        var b = {
            type: "clickStockEvent", eventObject: a, graph: this.graph,
            date: this.date
        }, c = this.bulletConfig.eventDispatcher;
        b.chart = c;
        c.fire(b.type, b);
        b = a.urlTarget;
        b || (b = c.stockEventsSettings.urlTarget);
        AmCharts.getURL(a.url, b)
    }, handleMouseOut: function (a) {
        this.bullets[a].attr({fill: this.backgroundColors[a]});
        a = {type: "rollOutStockEvent", eventObject: this.eventObjects[a], graph: this.graph, date: this.date};
        var b = this.bulletConfig.eventDispatcher;
        a.chart = b;
        b.fire(a.type, a)
    }
});
AmCharts.AmDraw = AmCharts.Class({
    construct: function (a, b, c) {
        AmCharts.SVG_NS = "http://www.w3.org/2000/svg";
        AmCharts.SVG_XLINK = "http://www.w3.org/1999/xlink";
        AmCharts.hasSVG = !!document.createElementNS && !!document.createElementNS(AmCharts.SVG_NS, "svg").createSVGRect;
        1 > b && (b = 10);
        1 > c && (c = 10);
        this.div = a;
        this.width = b;
        this.height = c;
        this.rBin = document.createElement("div");
        if (AmCharts.hasSVG) {
            AmCharts.SVG = !0;
            var d = this.createSvgElement("svg");
            d.style.position = "absolute";
            d.style.width = b + "px";
            d.style.height = c + "px";
            AmCharts.rtl && (d.setAttribute("direction", "rtl"), d.style.left = "auto", d.style.right = "0px");
            d.setAttribute("version", "1.1");
            a.appendChild(d);
            this.container = d;
            this.R = new AmCharts.SVGRenderer(this)
        } else AmCharts.isIE && AmCharts.VMLRenderer && (AmCharts.VML = !0, AmCharts.vmlStyleSheet || (document.namespaces.add("amvml", "urn:schemas-microsoft-com:vml"), b = document.createStyleSheet(), b.addRule(".amvml", "behavior:url(#default#VML); display:inline-block; antialias:true"), AmCharts.vmlStyleSheet = b), this.container =
            a, this.R = new AmCharts.VMLRenderer(this), this.R.disableSelection(a))
    }, createSvgElement: function (a) {
        return document.createElementNS(AmCharts.SVG_NS, a)
    }, circle: function (a, b, c, d) {
        var e = new AmCharts.AmDObject("circle", this);
        e.attr({r: c, cx: a, cy: b});
        this.addToContainer(e.node, d);
        return e
    }, setSize: function (a, b) {
        0 < a && 0 < b && (this.container.style.width = a + "px", this.container.style.height = b + "px")
    }, rect: function (a, b, c, d, e, f, g) {
        var h = new AmCharts.AmDObject("rect", this);
        AmCharts.VML && (e = 100 * e / Math.min(c, d), c += 2 * f,
            d += 2 * f, h.bw = f, h.node.style.marginLeft = -f, h.node.style.marginTop = -f);
        1 > c && (c = 1);
        1 > d && (d = 1);
        h.attr({x: a, y: b, width: c, height: d, rx: e, ry: e, "stroke-width": f});
        this.addToContainer(h.node, g);
        return h
    }, image: function (a, b, c, d, e, f) {
        var g = new AmCharts.AmDObject("image", this);
        g.attr({x: b, y: c, width: d, height: e});
        this.R.path(g, a);
        this.addToContainer(g.node, f);
        return g
    }, addToContainer: function (a, b) {
        b || (b = this.container);
        b.appendChild(a)
    }, text: function (a, b, c) {
        return this.R.text(a, b, c)
    }, path: function (a, b, c, d) {
        var e =
            new AmCharts.AmDObject("path", this);
        d || (d = "100,100");
        e.attr({cs: d});
        c ? e.attr({dd: a}) : e.attr({d: a});
        this.addToContainer(e.node, b);
        return e
    }, set: function (a) {
        return this.R.set(a)
    }, remove: function (a) {
        if (a) {
            var b = this.rBin;
            b.appendChild(a);
            b.innerHTML = ""
        }
    }, bounce: function (a, b, c, d, e) {
        return (b /= e) < 1 / 2.75 ? d * 7.5625 * b * b + c : b < 2 / 2.75 ? d * (7.5625 * (b -= 1.5 / 2.75) * b + 0.75) + c : b < 2.5 / 2.75 ? d * (7.5625 * (b -= 2.25 / 2.75) * b + 0.9375) + c : d * (7.5625 * (b -= 2.625 / 2.75) * b + 0.984375) + c
    }, easeInSine: function (a, b, c, d, e) {
        return -d * Math.cos(b / e * (Math.PI /
                2)) + d + c
    }, easeOutSine: function (a, b, c, d, e) {
        return d * Math.sin(b / e * (Math.PI / 2)) + c
    }, easeOutElastic: function (a, b, c, d, e) {
        a = 1.70158;
        var f = 0, g = d;
        if (0 === b)return c;
        if (1 == (b /= e))return c + d;
        f || (f = 0.3 * e);
        g < Math.abs(d) ? (g = d, a = f / 4) : a = f / (2 * Math.PI) * Math.asin(d / g);
        return g * Math.pow(2, -10 * b) * Math.sin((b * e - a) * 2 * Math.PI / f) + d + c
    }, renderFix: function () {
        var a = this.container, b = a.style, c;
        try {
            c = a.getScreenCTM() || a.createSVGMatrix()
        } catch (d) {
            c = a.createSVGMatrix()
        }
        a = 1 - c.e % 1;
        c = 1 - c.f % 1;
        0.5 < a && (a -= 1);
        0.5 < c && (c -= 1);
        a && (b.left = a + "px");
        c && (b.top = c + "px")
    }
});
AmCharts.AmDObject = AmCharts.Class({
    construct: function (a, b) {
        this.D = b;
        this.R = b.R;
        this.node = this.R.create(this, a);
        this.y = this.x = 0;
        this.scale = 1
    }, attr: function (a) {
        this.R.attr(this, a);
        return this
    }, getAttr: function (a) {
        return this.node.getAttribute(a)
    }, setAttr: function (a, b) {
        this.R.setAttr(this, a, b);
        return this
    }, clipRect: function (a, b, c, d) {
        this.R.clipRect(this, a, b, c, d)
    }, translate: function (a, b, c, d) {
        d || (a = Math.round(a), b = Math.round(b));
        this.R.move(this, a, b, c);
        this.x = a;
        this.y = b;
        this.scale = c;
        this.angle && this.rotate(this.angle)
    },
    rotate: function (a) {
        this.R.rotate(this, a);
        this.angle = a
    }, animate: function (a, b, c) {
        for (var d in a)if (a.hasOwnProperty(d)) {
            var e = d, f = a[d];
            c = AmCharts.getEffect(c);
            this.R.animate(this, e, f, b, c)
        }
    }, push: function (a) {
        if (a) {
            var b = this.node;
            b.appendChild(a.node);
            var c = a.clipPath;
            c && b.appendChild(c);
            (a = a.grad) && b.appendChild(a)
        }
    }, text: function (a) {
        this.R.setText(this, a)
    }, remove: function () {
        this.R.remove(this)
    }, clear: function () {
        var a = this.node;
        if (a.hasChildNodes())for (; 1 <= a.childNodes.length;)a.removeChild(a.firstChild)
    },
    hide: function () {
        this.setAttr("visibility", "hidden")
    }, show: function () {
        this.setAttr("visibility", "visible")
    }, getBBox: function () {
        return this.R.getBBox(this)
    }, toFront: function () {
        var a = this.node;
        if (a) {
            this.prevNextNode = a.nextSibling;
            var b = a.parentNode;
            b && b.appendChild(a)
        }
    }, toPrevious: function () {
        var a = this.node;
        a && this.prevNextNode && (a = a.parentNode) && a.insertBefore(this.prevNextNode, null)
    }, toBack: function () {
        var a = this.node;
        if (a) {
            this.prevNextNode = a.nextSibling;
            var b = a.parentNode;
            if (b) {
                var c = b.firstChild;
                c && b.insertBefore(a, c)
            }
        }
    }, mouseover: function (a) {
        this.R.addListener(this, "mouseover", a);
        return this
    }, mouseout: function (a) {
        this.R.addListener(this, "mouseout", a);
        return this
    }, click: function (a) {
        this.R.addListener(this, "click", a);
        return this
    }, dblclick: function (a) {
        this.R.addListener(this, "dblclick", a);
        return this
    }, mousedown: function (a) {
        this.R.addListener(this, "mousedown", a);
        return this
    }, mouseup: function (a) {
        this.R.addListener(this, "mouseup", a);
        return this
    }, touchstart: function (a) {
        this.R.addListener(this,
            "touchstart", a);
        return this
    }, touchend: function (a) {
        this.R.addListener(this, "touchend", a);
        return this
    }, contextmenu: function (a) {
        this.node.addEventListener ? this.node.addEventListener("contextmenu", a) : this.R.addListener(this, "contextmenu", a);
        return this
    }, stop: function (a) {
        (a = this.animationX) && AmCharts.removeFromArray(this.R.animations, a);
        (a = this.animationY) && AmCharts.removeFromArray(this.R.animations, a)
    }, length: function () {
        return this.node.childNodes.length
    }, gradient: function (a, b, c) {
        this.R.gradient(this,
            a, b, c)
    }
});
AmCharts.VMLRenderer = AmCharts.Class({
    construct: function (a) {
        this.D = a;
        this.cNames = {circle: "oval", rect: "roundrect", path: "shape"};
        this.styleMap = {
            x: "left",
            y: "top",
            width: "width",
            height: "height",
            "font-family": "fontFamily",
            "font-size": "fontSize",
            visibility: "visibility"
        };
        this.animations = []
    }, create: function (a, b) {
        var c;
        if ("group" == b)c = document.createElement("div"), a.type = "div"; else if ("text" == b)c = document.createElement("div"), a.type = "text"; else if ("image" == b)c = document.createElement("img"), a.type = "image"; else {
            a.type =
                "shape";
            a.shapeType = this.cNames[b];
            c = document.createElement("amvml:" + this.cNames[b]);
            var d = document.createElement("amvml:stroke");
            c.appendChild(d);
            a.stroke = d;
            var e = document.createElement("amvml:fill");
            c.appendChild(e);
            a.fill = e;
            e.className = "amvml";
            d.className = "amvml";
            c.className = "amvml"
        }
        c.style.position = "absolute";
        c.style.top = 0;
        c.style.left = 0;
        return c
    }, path: function (a, b) {
        a.node.setAttribute("src", b)
    }, setAttr: function (a, b, c) {
        if (void 0 !== c) {
            var d;
            8 === document.documentMode && (d = !0);
            var e = a.node, f = a.type,
                g = e.style;
            "r" == b && (g.width = 2 * c, g.height = 2 * c);
            "roundrect" != a.shapeType || "width" != b && "height" != b || (c -= 1);
            "cursor" == b && (g.cursor = c);
            "cx" == b && (g.left = c - AmCharts.removePx(g.width) / 2);
            "cy" == b && (g.top = c - AmCharts.removePx(g.height) / 2);
            var h = this.styleMap[b];
            void 0 !== h && (g[h] = c);
            "text" == f && ("text-anchor" == b && (a.anchor = c, h = e.clientWidth, "end" == c && (g.marginLeft = -h + "px"), "middle" == c && (g.marginLeft = -(h / 2) + "px", g.textAlign = "center"), "start" == c && (g.marginLeft = "0px")), "fill" == b && (g.color = c), "font-weight" == b && (g.fontWeight =
                c));
            if (g = a.children)for (h = 0; h < g.length; h++)g[h].setAttr(b, c);
            if ("shape" == f) {
                "cs" == b && (e.style.width = "100px", e.style.height = "100px", e.setAttribute("coordsize", c));
                "d" == b && e.setAttribute("path", this.svgPathToVml(c));
                "dd" == b && e.setAttribute("path", c);
                f = a.stroke;
                a = a.fill;
                "stroke" == b && (d ? f.color = c : f.setAttribute("color", c));
                "stroke-width" == b && (d ? f.weight = c : f.setAttribute("weight", c));
                "stroke-opacity" == b && (d ? f.opacity = c : f.setAttribute("opacity", c));
                "stroke-dasharray" == b && (g = "solid", 0 < c && 3 > c && (g = "dot"),
                3 <= c && 6 >= c && (g = "dash"), 6 < c && (g = "longdash"), d ? f.dashstyle = g : f.setAttribute("dashstyle", g));
                if ("fill-opacity" == b || "opacity" == b)0 === c ? d ? a.on = !1 : a.setAttribute("on", !1) : d ? a.opacity = c : a.setAttribute("opacity", c);
                "fill" == b && (d ? a.color = c : a.setAttribute("color", c));
                "rx" == b && (d ? e.arcSize = c + "%" : e.setAttribute("arcsize", c + "%"))
            }
        }
    }, attr: function (a, b) {
        for (var c in b)b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
    }, text: function (a, b, c) {
        var d = new AmCharts.AmDObject("text", this.D), e = d.node;
        e.style.whiteSpace = "pre";
        e.innerHTML =
            a;
        this.D.addToContainer(e, c);
        this.attr(d, b);
        return d
    }, getBBox: function (a) {
        return this.getBox(a.node)
    }, getBox: function (a) {
        var b = a.offsetLeft, c = a.offsetTop, d = a.offsetWidth, e = a.offsetHeight, f;
        if (a.hasChildNodes()) {
            var g, h, k;
            for (k = 0; k < a.childNodes.length; k++) {
                f = this.getBox(a.childNodes[k]);
                var l = f.x;
                isNaN(l) || (isNaN(g) ? g = l : l < g && (g = l));
                var m = f.y;
                isNaN(m) || (isNaN(h) ? h = m : m < h && (h = m));
                l = f.width + l;
                isNaN(l) || (d = Math.max(d, l));
                f = f.height + m;
                isNaN(f) || (e = Math.max(e, f))
            }
            0 > g && (b += g);
            0 > h && (c += h)
        }
        return {
            x: b, y: c, width: d,
            height: e
        }
    }, setText: function (a, b) {
        var c = a.node;
        c && (c.innerHTML = b);
        this.setAttr(a, "text-anchor", a.anchor)
    }, addListener: function (a, b, c) {
        a.node["on" + b] = c
    }, move: function (a, b, c) {
        var d = a.node, e = d.style;
        "text" == a.type && (c -= AmCharts.removePx(e.fontSize) / 2 - 1);
        "oval" == a.shapeType && (b -= AmCharts.removePx(e.width) / 2, c -= AmCharts.removePx(e.height) / 2);
        a = a.bw;
        isNaN(a) || (b -= a, c -= a);
        isNaN(b) || isNaN(c) || (d.style.left = b + "px", d.style.top = c + "px")
    }, svgPathToVml: function (a) {
        var b = a.split(" ");
        a = "";
        var c, d = Math.round, e;
        for (e =
                 0; e < b.length; e++) {
            var f = b[e], g = f.substring(0, 1), f = f.substring(1), h = f.split(","), k = d(h[0]) + "," + d(h[1]);
            "M" == g && (a += " m " + k);
            "L" == g && (a += " l " + k);
            "Z" == g && (a += " x e");
            if ("Q" == g) {
                var l = c.length, m = c[l - 1], n = h[0], s = h[1], k = h[2], q = h[3];
                c = d(c[l - 2] / 3 + 2 / 3 * n);
                m = d(m / 3 + 2 / 3 * s);
                n = d(2 / 3 * n + k / 3);
                s = d(2 / 3 * s + q / 3);
                a += " c " + c + "," + m + "," + n + "," + s + "," + k + "," + q
            }
            "A" == g && (a += " wa " + f);
            "B" == g && (a += " at " + f);
            c = h
        }
        return a
    }, animate: function (a, b, c, d, e) {
        var f = this, g = a.node;
        if ("translate" == b) {
            var h = c.split(",");
            b = h[1];
            c = g.offsetTop;
            g = {
                obj: a,
                frame: 0, attribute: "left", from: g.offsetLeft, to: h[0], time: d, effect: e
            };
            f.animations.push(g);
            d = {obj: a, frame: 0, attribute: "top", from: c, to: b, time: d, effect: e};
            f.animations.push(d);
            a.animationX = g;
            a.animationY = d
        }
        f.interval || (f.interval = setInterval(function () {
            f.updateAnimations.call(f)
        }, AmCharts.updateRate))
    }, updateAnimations: function () {
        var a;
        for (a = this.animations.length - 1; 0 <= a; a--) {
            var b = this.animations[a], c = 1E3 * b.time / AmCharts.updateRate, d = b.frame + 1, e = b.obj, f = b.attribute;
            if (d <= c) {
                b.frame++;
                var g = Number(b.from),
                    h = Number(b.to) - g, b = this.D[b.effect](0, d, g, h, c);
                0 === h ? this.animations.splice(a, 1) : e.node.style[f] = b
            } else e.node.style[f] = Number(b.to), this.animations.splice(a, 1)
        }
    }, clipRect: function (a, b, c, d, e) {
        a = a.node;
        0 == b && 0 == c ? (a.style.width = d + "px", a.style.height = e + "px", a.style.overflow = "hidden") : a.style.clip = "rect(" + c + "px " + (b + d) + "px " + (c + e) + "px " + b + "px)"
    }, rotate: function (a, b) {
        if (0 != Number(b)) {
            var c = a.node, d = c.style, e = this.getBGColor(c.parentNode);
            d.backgroundColor = e;
            d.paddingLeft = 1;
            var e = b * Math.PI / 180, f = Math.cos(e),
                g = Math.sin(e), h = AmCharts.removePx(d.left), k = AmCharts.removePx(d.top), l = c.offsetWidth, c = c.offsetHeight, m = b / Math.abs(b);
            d.left = h + l / 2 - l / 2 * Math.cos(e) - m * c / 2 * Math.sin(e) + 3;
            d.top = k - m * l / 2 * Math.sin(e) + m * c / 2 * Math.sin(e);
            d.cssText = d.cssText + "; filter:progid:DXImageTransform.Microsoft.Matrix(M11='" + f + "', M12='" + -g + "', M21='" + g + "', M22='" + f + "', sizingmethod='auto expand');"
        }
    }, getBGColor: function (a) {
        var b = "#FFFFFF";
        if (a.style) {
            var c = a.style.backgroundColor;
            "" !== c ? b = c : a.parentNode && (b = this.getBGColor(a.parentNode))
        }
        return b
    },
    set: function (a) {
        var b = new AmCharts.AmDObject("group", this.D);
        this.D.container.appendChild(b.node);
        if (a) {
            var c;
            for (c = 0; c < a.length; c++)b.push(a[c])
        }
        return b
    }, gradient: function (a, b, c, d) {
        var e = "";
        "radialGradient" == b && (b = "gradientradial", c.reverse());
        "linearGradient" == b && (b = "gradient");
        var f;
        for (f = 0; f < c.length; f++) {
            var g = Math.round(100 * f / (c.length - 1)), e = e + (g + "% " + c[f]);
            f < c.length - 1 && (e += ",")
        }
        a = a.fill;
        90 == d ? d = 0 : 270 == d ? d = 180 : 180 == d ? d = 90 : 0 === d && (d = 270);
        8 === document.documentMode ? (a.type = b, a.angle = d) : (a.setAttribute("type",
            b), a.setAttribute("angle", d));
        e && (a.colors.value = e)
    }, remove: function (a) {
        a.clipPath && this.D.remove(a.clipPath);
        this.D.remove(a.node)
    }, disableSelection: function (a) {
        void 0 !== typeof a.onselectstart && (a.onselectstart = function () {
            return !1
        });
        a.style.cursor = "default"
    }
});
AmCharts.SVGRenderer = AmCharts.Class({
    construct: function (a) {
        this.D = a;
        this.animations = []
    }, create: function (a, b) {
        return document.createElementNS(AmCharts.SVG_NS, b)
    }, attr: function (a, b) {
        for (var c in b)b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
    }, setAttr: function (a, b, c) {
        void 0 !== c && a.node.setAttribute(b, c)
    }, animate: function (a, b, c, d, e) {
        var f = this, g = a.node;
        "translate" == b ? (g = (g = g.getAttribute("transform")) ? String(g).substring(10, g.length - 1) : "0,0", g = g.split(", ").join(" "), g = g.split(" ").join(","), 0 === g && (g =
            "0,0")) : g = g.getAttribute(b);
        b = {obj: a, frame: 0, attribute: b, from: g, to: c, time: d, effect: e};
        f.animations.push(b);
        a.animationX = b;
        f.interval || (f.interval = setInterval(function () {
            f.updateAnimations.call(f)
        }, AmCharts.updateRate))
    }, updateAnimations: function () {
        var a;
        for (a = this.animations.length - 1; 0 <= a; a--) {
            var b = this.animations[a], c = 1E3 * b.time / AmCharts.updateRate, d = b.frame + 1, e = b.obj, f = b.attribute, g, h, k;
            d <= c ? (b.frame++, "translate" == f ? (g = b.from.split(","), f = Number(g[0]), g = Number(g[1]), h = b.to.split(","), k = Number(h[0]),
                h = Number(h[1]), k = 0 === k - f ? k : Math.round(this.D[b.effect](0, d, f, k - f, c)), b = 0 === h - g ? h : Math.round(this.D[b.effect](0, d, g, h - g, c)), f = "transform", b = "translate(" + k + "," + b + ")") : (g = Number(b.from), k = Number(b.to), k -= g, b = this.D[b.effect](0, d, g, k, c), 0 === k && this.animations.splice(a, 1)), this.setAttr(e, f, b)) : ("translate" == f ? (h = b.to.split(","), k = Number(h[0]), h = Number(h[1]), e.translate(k, h)) : (k = Number(b.to), this.setAttr(e, f, k)), this.animations.splice(a, 1))
        }
    }, getBBox: function (a) {
        if (a = a.node)try {
            return a.getBBox()
        } catch (b) {
        }
        return {
            width: 0,
            height: 0, x: 0, y: 0
        }
    }, path: function (a, b) {
        a.node.setAttributeNS(AmCharts.SVG_XLINK, "xlink:href", b)
    }, clipRect: function (a, b, c, d, e) {
        var f = a.node, g = a.clipPath;
        g && this.D.remove(g);
        var h = f.parentNode;
        h && (f = document.createElementNS(AmCharts.SVG_NS, "clipPath"), g = AmCharts.getUniqueId(), f.setAttribute("id", g), this.D.rect(b, c, d, e, 0, 0, f), h.appendChild(f), b = "#", AmCharts.baseHref && !AmCharts.isIE && (b = window.location.href + b), this.setAttr(a, "clip-path", "url(" + b + g + ")"), this.clipPathC++, a.clipPath = f)
    }, text: function (a, b,
                       c) {
        var d = new AmCharts.AmDObject("text", this.D);
        a = String(a).split("\n");
        var e = b["font-size"], f;
        for (f = 0; f < a.length; f++) {
            var g = this.create(null, "tspan");
            g.appendChild(document.createTextNode(a[f]));
            g.setAttribute("y", (e + 2) * f + e / 2);
            g.setAttribute("x", 0);
            d.node.appendChild(g)
        }
        d.node.setAttribute("y", e / 2);
        this.attr(d, b);
        this.D.addToContainer(d.node, c);
        return d
    }, setText: function (a, b) {
        var c = a.node;
        c && (c.removeChild(c.firstChild), c.appendChild(document.createTextNode(b)))
    }, move: function (a, b, c, d) {
        b = "translate(" +
            b + "," + c + ")";
        d && (b = b + " scale(" + d + ")");
        this.setAttr(a, "transform", b)
    }, rotate: function (a, b) {
        var c = a.node.getAttribute("transform"), d = "rotate(" + b + ")";
        c && (d = c + " " + d);
        this.setAttr(a, "transform", d)
    }, set: function (a) {
        var b = new AmCharts.AmDObject("g", this.D);
        this.D.container.appendChild(b.node);
        if (a) {
            var c;
            for (c = 0; c < a.length; c++)b.push(a[c])
        }
        return b
    }, addListener: function (a, b, c) {
        a.node["on" + b] = c
    }, gradient: function (a, b, c, d) {
        var e = a.node, f = a.grad;
        f && this.D.remove(f);
        b = document.createElementNS(AmCharts.SVG_NS,
            b);
        f = AmCharts.getUniqueId();
        b.setAttribute("id", f);
        if (!isNaN(d)) {
            var g = 0, h = 0, k = 0, l = 0;
            90 == d ? k = 100 : 270 == d ? l = 100 : 180 == d ? g = 100 : 0 === d && (h = 100);
            b.setAttribute("x1", g + "%");
            b.setAttribute("x2", h + "%");
            b.setAttribute("y1", k + "%");
            b.setAttribute("y2", l + "%")
        }
        for (d = 0; d < c.length; d++)g = document.createElementNS(AmCharts.SVG_NS, "stop"), h = 100 * d / (c.length - 1), 0 === d && (h = 0), g.setAttribute("offset", h + "%"), g.setAttribute("stop-color", c[d]), b.appendChild(g);
        e.parentNode.appendChild(b);
        c = "#";
        AmCharts.baseHref && !AmCharts.isIE &&
        (c = window.location.href + c);
        e.setAttribute("fill", "url(" + c + f + ")");
        a.grad = b
    }, remove: function (a) {
        a.clipPath && this.D.remove(a.clipPath);
        a.grad && this.D.remove(a.grad);
        this.D.remove(a.node)
    }
});
AmCharts.AmDSet = AmCharts.Class({
    construct: function (a) {
        this.create("g")
    }, attr: function (a) {
        this.R.attr(this.node, a)
    }, move: function (a, b) {
        this.R.move(this.node, a, b)
    }
});

/*
 * jQuery Hotkeys Plugin
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Based upon the plugin by Tzury Bar Yochay:
 * http://github.com/tzuryby/hotkeys
 *
 * Original idea by:
 * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
 */

/*
 * One small change is: now keys are passed by object { keys: '...' }
 * Might be useful, when you want to pass some other data to your handler
 */

(function (jQuery) {

    jQuery.hotkeys = {
        version: "0.8",

        specialKeys: {
            8: "backspace", 9: "tab", 10: "return", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
            20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
            37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
            96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
            104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111: "/",
            112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8",
            120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 186: ";", 191: "/",
            220: "\\", 222: "'", 224: "meta"
        },

        shiftNums: {
            "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&",
            "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<",
            ".": ">", "/": "?", "\\": "|"
        }
    };

    function keyHandler(handleObj) {
        if (typeof handleObj.data === "string") {
            handleObj.data = {keys: handleObj.data};
        }

        // Only care when a possible input has been specified
        if (!handleObj.data || !handleObj.data.keys || typeof handleObj.data.keys !== "string") {
            return;
        }

        var origHandler = handleObj.handler,
            keys = handleObj.data.keys.toLowerCase().split(" "),
            textAcceptingInputTypes = ["text", "password", "number", "email", "url", "range", "date", "month", "week", "time", "datetime", "datetime-local", "search", "color", "tel"];

        handleObj.handler = function (event) {
            // Don't fire in text-accepting inputs that we didn't directly bind to
            if (this !== event.target && (/textarea|select/i.test(event.target.nodeName) ||
                jQuery.inArray(event.target.type, textAcceptingInputTypes) > -1 )) {
                return;
            }

            var special = jQuery.hotkeys.specialKeys[event.keyCode],
                character = String.fromCharCode(event.which).toLowerCase(),
                modif = "", possible = {};

            // check combinations (alt|ctrl|shift+anything)
            if (event.altKey && special !== "alt") {
                modif += "alt+";
            }

            if (event.ctrlKey && special !== "ctrl") {
                modif += "ctrl+";
            }

            // TODO: Need to make sure this works consistently across platforms
            if (event.metaKey && !event.ctrlKey && special !== "meta") {
                modif += "meta+";
            }

            if (event.shiftKey && special !== "shift") {
                modif += "shift+";
            }

            if (special) {
                possible[modif + special] = true;
            }

            if (character) {
                possible[modif + character] = true;
                possible[modif + jQuery.hotkeys.shiftNums[character]] = true;

                // "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
                if (modif === "shift+") {
                    possible[jQuery.hotkeys.shiftNums[character]] = true;
                }
            }

            for (var i = 0, l = keys.length; i < l; i++) {
                if (possible[keys[i]]) {
                    return origHandler.apply(this, arguments);
                }
            }
        };
    }

    jQuery.each(["keydown", "keyup", "keypress"], function () {
        jQuery.event.special[this] = {add: keyHandler};
    });

})(this.jQuery);
